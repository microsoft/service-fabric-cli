# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

from azure.core.exceptions import HttpResponseError
import msrest.serialization


class AadMetadata(msrest.serialization.Model):
    """Azure Active Directory metadata used for secured connection to cluster.

    :ivar authority: The AAD authority url.
    :vartype authority: str
    :ivar client: The AAD client application Id.
    :vartype client: str
    :ivar cluster: The AAD cluster application Id.
    :vartype cluster: str
    :ivar login: The AAD login url.
    :vartype login: str
    :ivar redirect: The client application redirect address.
    :vartype redirect: str
    :ivar tenant: The AAD tenant Id.
    :vartype tenant: str
    """

    _attribute_map = {
        'authority': {'key': 'authority', 'type': 'str'},
        'client': {'key': 'client', 'type': 'str'},
        'cluster': {'key': 'cluster', 'type': 'str'},
        'login': {'key': 'login', 'type': 'str'},
        'redirect': {'key': 'redirect', 'type': 'str'},
        'tenant': {'key': 'tenant', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword authority: The AAD authority url.
        :paramtype authority: str
        :keyword client: The AAD client application Id.
        :paramtype client: str
        :keyword cluster: The AAD cluster application Id.
        :paramtype cluster: str
        :keyword login: The AAD login url.
        :paramtype login: str
        :keyword redirect: The client application redirect address.
        :paramtype redirect: str
        :keyword tenant: The AAD tenant Id.
        :paramtype tenant: str
        """
        super(AadMetadata, self).__init__(**kwargs)
        self.authority = kwargs.get('authority', None)
        self.client = kwargs.get('client', None)
        self.cluster = kwargs.get('cluster', None)
        self.login = kwargs.get('login', None)
        self.redirect = kwargs.get('redirect', None)
        self.tenant = kwargs.get('tenant', None)


class AadMetadataObject(msrest.serialization.Model):
    """Azure Active Directory metadata object used for secured connection to cluster.

    :ivar type: The client authentication method.
    :vartype type: str
    :ivar metadata: Azure Active Directory metadata used for secured connection to cluster.
    :vartype metadata: ~azure.servicefabric.models.AadMetadata
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'metadata': {'key': 'metadata', 'type': 'AadMetadata'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword type: The client authentication method.
        :paramtype type: str
        :keyword metadata: Azure Active Directory metadata used for secured connection to cluster.
        :paramtype metadata: ~azure.servicefabric.models.AadMetadata
        """
        super(AadMetadataObject, self).__init__(**kwargs)
        self.type = kwargs.get('type', None)
        self.metadata = kwargs.get('metadata', None)


class ScalingMechanismDescription(msrest.serialization.Model):
    """Describes the mechanism for performing a scaling operation.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AddRemoveIncrementalNamedPartitionScalingMechanism, PartitionInstanceCountScaleMechanism.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. Specifies the kind of scaling mechanism.Constant filled by server.
     Possible values include: "Invalid", "PartitionInstanceCount",
     "AddRemoveIncrementalNamedPartition".
    :vartype kind: str or ~azure.servicefabric.models.ScalingMechanismKind
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'AddRemoveIncrementalNamedPartition': 'AddRemoveIncrementalNamedPartitionScalingMechanism', 'PartitionInstanceCount': 'PartitionInstanceCountScaleMechanism'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(ScalingMechanismDescription, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]


class AddRemoveIncrementalNamedPartitionScalingMechanism(ScalingMechanismDescription):
    """Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1''N-1'.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. Specifies the kind of scaling mechanism.Constant filled by server.
     Possible values include: "Invalid", "PartitionInstanceCount",
     "AddRemoveIncrementalNamedPartition".
    :vartype kind: str or ~azure.servicefabric.models.ScalingMechanismKind
    :ivar min_partition_count: Required. Minimum number of named partitions of the service.
    :vartype min_partition_count: int
    :ivar max_partition_count: Required. Maximum number of named partitions of the service.
    :vartype max_partition_count: int
    :ivar scale_increment: Required. The number of instances to add or remove during a scaling
     operation.
    :vartype scale_increment: int
    """

    _validation = {
        'kind': {'required': True},
        'min_partition_count': {'required': True},
        'max_partition_count': {'required': True},
        'scale_increment': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'min_partition_count': {'key': 'MinPartitionCount', 'type': 'int'},
        'max_partition_count': {'key': 'MaxPartitionCount', 'type': 'int'},
        'scale_increment': {'key': 'ScaleIncrement', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword min_partition_count: Required. Minimum number of named partitions of the service.
        :paramtype min_partition_count: int
        :keyword max_partition_count: Required. Maximum number of named partitions of the service.
        :paramtype max_partition_count: int
        :keyword scale_increment: Required. The number of instances to add or remove during a scaling
         operation.
        :paramtype scale_increment: int
        """
        super(AddRemoveIncrementalNamedPartitionScalingMechanism, self).__init__(**kwargs)
        self.kind = 'AddRemoveIncrementalNamedPartition'  # type: str
        self.min_partition_count = kwargs['min_partition_count']
        self.max_partition_count = kwargs['max_partition_count']
        self.scale_increment = kwargs['scale_increment']


class AutoScalingMechanism(msrest.serialization.Model):
    """Describes the mechanism for performing auto scaling operation. Derived classes will describe the actual mechanism.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AddRemoveReplicaScalingMechanism.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The type of auto scaling mechanism.Constant filled by server. Possible
     values include: "AddRemoveReplica".
    :vartype kind: str or ~azure.servicefabric.models.AutoScalingMechanismKind
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'AddRemoveReplica': 'AddRemoveReplicaScalingMechanism'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(AutoScalingMechanism, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]


class AddRemoveReplicaScalingMechanism(AutoScalingMechanism):
    """Describes the horizontal auto scaling mechanism that adds or removes replicas (containers or container groups).

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The type of auto scaling mechanism.Constant filled by server. Possible
     values include: "AddRemoveReplica".
    :vartype kind: str or ~azure.servicefabric.models.AutoScalingMechanismKind
    :ivar min_count: Required. Minimum number of containers (scale down won't be performed below
     this number).
    :vartype min_count: int
    :ivar max_count: Required. Maximum number of containers (scale up won't be performed above this
     number).
    :vartype max_count: int
    :ivar scale_increment: Required. Each time auto scaling is performed, this number of containers
     will be added or removed.
    :vartype scale_increment: int
    """

    _validation = {
        'kind': {'required': True},
        'min_count': {'required': True},
        'max_count': {'required': True},
        'scale_increment': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'min_count': {'key': 'minCount', 'type': 'int'},
        'max_count': {'key': 'maxCount', 'type': 'int'},
        'scale_increment': {'key': 'scaleIncrement', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword min_count: Required. Minimum number of containers (scale down won't be performed below
         this number).
        :paramtype min_count: int
        :keyword max_count: Required. Maximum number of containers (scale up won't be performed above
         this number).
        :paramtype max_count: int
        :keyword scale_increment: Required. Each time auto scaling is performed, this number of
         containers will be added or removed.
        :paramtype scale_increment: int
        """
        super(AddRemoveReplicaScalingMechanism, self).__init__(**kwargs)
        self.kind = 'AddRemoveReplica'  # type: str
        self.min_count = kwargs['min_count']
        self.max_count = kwargs['max_count']
        self.scale_increment = kwargs['scale_increment']


class AnalysisEventMetadata(msrest.serialization.Model):
    """Metadata about an Analysis Event.

    :ivar delay: The analysis delay.
    :vartype delay: ~datetime.timedelta
    :ivar duration: The duration of analysis.
    :vartype duration: ~datetime.timedelta
    """

    _attribute_map = {
        'delay': {'key': 'Delay', 'type': 'duration'},
        'duration': {'key': 'Duration', 'type': 'duration'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword delay: The analysis delay.
        :paramtype delay: ~datetime.timedelta
        :keyword duration: The duration of analysis.
        :paramtype duration: ~datetime.timedelta
        """
        super(AnalysisEventMetadata, self).__init__(**kwargs)
        self.delay = kwargs.get('delay', None)
        self.duration = kwargs.get('duration', None)


class BackupConfigurationInfo(msrest.serialization.Model):
    """Describes the backup configuration information.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ApplicationBackupConfigurationInfo, PartitionBackupConfigurationInfo, ServiceBackupConfigurationInfo.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The entity type of a Service Fabric entity such as Application, Service
     or a Partition where periodic backups can be enabled.Constant filled by server. Possible values
     include: "Invalid", "Partition", "Service", "Application".
    :vartype kind: str or ~azure.servicefabric.models.BackupEntityKind
    :ivar policy_name: The name of the backup policy which is applicable to this Service Fabric
     application or service or partition.
    :vartype policy_name: str
    :ivar policy_inherited_from: Specifies the scope at which the backup policy is applied.
     Possible values include: "Invalid", "Partition", "Service", "Application".
    :vartype policy_inherited_from: str or ~azure.servicefabric.models.BackupPolicyScope
    :ivar suspension_info: Describes the backup suspension details.
    :vartype suspension_info: ~azure.servicefabric.models.BackupSuspensionInfo
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'policy_name': {'key': 'PolicyName', 'type': 'str'},
        'policy_inherited_from': {'key': 'PolicyInheritedFrom', 'type': 'str'},
        'suspension_info': {'key': 'SuspensionInfo', 'type': 'BackupSuspensionInfo'},
    }

    _subtype_map = {
        'kind': {'Application': 'ApplicationBackupConfigurationInfo', 'Partition': 'PartitionBackupConfigurationInfo', 'Service': 'ServiceBackupConfigurationInfo'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword policy_name: The name of the backup policy which is applicable to this Service Fabric
         application or service or partition.
        :paramtype policy_name: str
        :keyword policy_inherited_from: Specifies the scope at which the backup policy is applied.
         Possible values include: "Invalid", "Partition", "Service", "Application".
        :paramtype policy_inherited_from: str or ~azure.servicefabric.models.BackupPolicyScope
        :keyword suspension_info: Describes the backup suspension details.
        :paramtype suspension_info: ~azure.servicefabric.models.BackupSuspensionInfo
        """
        super(BackupConfigurationInfo, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]
        self.policy_name = kwargs.get('policy_name', None)
        self.policy_inherited_from = kwargs.get('policy_inherited_from', None)
        self.suspension_info = kwargs.get('suspension_info', None)


class ApplicationBackupConfigurationInfo(BackupConfigurationInfo):
    """Backup configuration information for a specific Service Fabric application specifying what backup policy is being applied and suspend description, if any.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The entity type of a Service Fabric entity such as Application, Service
     or a Partition where periodic backups can be enabled.Constant filled by server. Possible values
     include: "Invalid", "Partition", "Service", "Application".
    :vartype kind: str or ~azure.servicefabric.models.BackupEntityKind
    :ivar policy_name: The name of the backup policy which is applicable to this Service Fabric
     application or service or partition.
    :vartype policy_name: str
    :ivar policy_inherited_from: Specifies the scope at which the backup policy is applied.
     Possible values include: "Invalid", "Partition", "Service", "Application".
    :vartype policy_inherited_from: str or ~azure.servicefabric.models.BackupPolicyScope
    :ivar suspension_info: Describes the backup suspension details.
    :vartype suspension_info: ~azure.servicefabric.models.BackupSuspensionInfo
    :ivar application_name: The name of the application, including the 'fabric:' URI scheme.
    :vartype application_name: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'policy_name': {'key': 'PolicyName', 'type': 'str'},
        'policy_inherited_from': {'key': 'PolicyInheritedFrom', 'type': 'str'},
        'suspension_info': {'key': 'SuspensionInfo', 'type': 'BackupSuspensionInfo'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword policy_name: The name of the backup policy which is applicable to this Service Fabric
         application or service or partition.
        :paramtype policy_name: str
        :keyword policy_inherited_from: Specifies the scope at which the backup policy is applied.
         Possible values include: "Invalid", "Partition", "Service", "Application".
        :paramtype policy_inherited_from: str or ~azure.servicefabric.models.BackupPolicyScope
        :keyword suspension_info: Describes the backup suspension details.
        :paramtype suspension_info: ~azure.servicefabric.models.BackupSuspensionInfo
        :keyword application_name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype application_name: str
        """
        super(ApplicationBackupConfigurationInfo, self).__init__(**kwargs)
        self.kind = 'Application'  # type: str
        self.application_name = kwargs.get('application_name', None)


class BackupEntity(msrest.serialization.Model):
    """Describes the Service Fabric entity that is configured for backup.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ApplicationBackupEntity, PartitionBackupEntity, ServiceBackupEntity.

    All required parameters must be populated in order to send to Azure.

    :ivar entity_kind: Required. The entity type of a Service Fabric entity such as Application,
     Service or a Partition where periodic backups can be enabled.Constant filled by server.
     Possible values include: "Invalid", "Partition", "Service", "Application".
    :vartype entity_kind: str or ~azure.servicefabric.models.BackupEntityKind
    """

    _validation = {
        'entity_kind': {'required': True},
    }

    _attribute_map = {
        'entity_kind': {'key': 'EntityKind', 'type': 'str'},
    }

    _subtype_map = {
        'entity_kind': {'Application': 'ApplicationBackupEntity', 'Partition': 'PartitionBackupEntity', 'Service': 'ServiceBackupEntity'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(BackupEntity, self).__init__(**kwargs)
        self.entity_kind = None  # type: Optional[str]


class ApplicationBackupEntity(BackupEntity):
    """Identifies the Service Fabric application which is being backed up.

    All required parameters must be populated in order to send to Azure.

    :ivar entity_kind: Required. The entity type of a Service Fabric entity such as Application,
     Service or a Partition where periodic backups can be enabled.Constant filled by server.
     Possible values include: "Invalid", "Partition", "Service", "Application".
    :vartype entity_kind: str or ~azure.servicefabric.models.BackupEntityKind
    :ivar application_name: The name of the application, including the 'fabric:' URI scheme.
    :vartype application_name: str
    """

    _validation = {
        'entity_kind': {'required': True},
    }

    _attribute_map = {
        'entity_kind': {'key': 'EntityKind', 'type': 'str'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword application_name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype application_name: str
        """
        super(ApplicationBackupEntity, self).__init__(**kwargs)
        self.entity_kind = 'Application'  # type: str
        self.application_name = kwargs.get('application_name', None)


class ApplicationCapacityDescription(msrest.serialization.Model):
    """Describes capacity information for services of this application. This description can be used for describing the following.


* Reserving the capacity for the services on the nodes
* Limiting the total number of nodes that services of this application can run on
* Limiting the custom capacity metrics to limit the total consumption of this metric by the services of this application.

    :ivar minimum_nodes: The minimum number of nodes where Service Fabric will reserve capacity for
     this application. Note that this does not mean that the services of this application will be
     placed on all of those nodes. If this property is set to zero, no capacity will be reserved.
     The value of this property cannot be more than the value of the MaximumNodes property.
    :vartype minimum_nodes: long
    :ivar maximum_nodes: The maximum number of nodes where Service Fabric will reserve capacity for
     this application. Note that this does not mean that the services of this application will be
     placed on all of those nodes. By default, the value of this property is zero and it means that
     the services can be placed on any node.
    :vartype maximum_nodes: long
    :ivar application_metrics: List of application capacity metric description.
    :vartype application_metrics: list[~azure.servicefabric.models.ApplicationMetricDescription]
    """

    _validation = {
        'minimum_nodes': {'minimum': 0},
        'maximum_nodes': {'minimum': 0},
    }

    _attribute_map = {
        'minimum_nodes': {'key': 'MinimumNodes', 'type': 'long'},
        'maximum_nodes': {'key': 'MaximumNodes', 'type': 'long'},
        'application_metrics': {'key': 'ApplicationMetrics', 'type': '[ApplicationMetricDescription]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword minimum_nodes: The minimum number of nodes where Service Fabric will reserve capacity
         for this application. Note that this does not mean that the services of this application will
         be placed on all of those nodes. If this property is set to zero, no capacity will be reserved.
         The value of this property cannot be more than the value of the MaximumNodes property.
        :paramtype minimum_nodes: long
        :keyword maximum_nodes: The maximum number of nodes where Service Fabric will reserve capacity
         for this application. Note that this does not mean that the services of this application will
         be placed on all of those nodes. By default, the value of this property is zero and it means
         that the services can be placed on any node.
        :paramtype maximum_nodes: long
        :keyword application_metrics: List of application capacity metric description.
        :paramtype application_metrics: list[~azure.servicefabric.models.ApplicationMetricDescription]
        """
        super(ApplicationCapacityDescription, self).__init__(**kwargs)
        self.minimum_nodes = kwargs.get('minimum_nodes', None)
        self.maximum_nodes = kwargs.get('maximum_nodes', 0)
        self.application_metrics = kwargs.get('application_metrics', None)


class FabricEvent(msrest.serialization.Model):
    """Represents the base for all Fabric Events.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ApplicationEvent, ClusterEvent, ContainerInstanceEvent, NodeEvent, PartitionEvent, ReplicaEvent, ServiceEvent.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
    }

    _subtype_map = {
        'kind': {'ApplicationEvent': 'ApplicationEvent', 'ClusterEvent': 'ClusterEvent', 'ContainerInstanceEvent': 'ContainerInstanceEvent', 'NodeEvent': 'NodeEvent', 'PartitionEvent': 'PartitionEvent', 'ReplicaEvent': 'ReplicaEvent', 'ServiceEvent': 'ServiceEvent'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        """
        super(FabricEvent, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]
        self.event_instance_id = kwargs['event_instance_id']
        self.category = kwargs.get('category', None)
        self.time_stamp = kwargs['time_stamp']
        self.has_correlated_events = kwargs.get('has_correlated_events', None)


class ApplicationEvent(FabricEvent):
    """Represents the base for all Application Events.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ApplicationContainerInstanceExitedEvent, ApplicationCreatedEvent, ApplicationDeletedEvent, ApplicationHealthReportExpiredEvent, ApplicationNewHealthReportEvent, ApplicationProcessExitedEvent, ApplicationUpgradeCompletedEvent, ApplicationUpgradeDomainCompletedEvent, ApplicationUpgradeRollbackCompletedEvent, ApplicationUpgradeRollbackStartedEvent, ApplicationUpgradeStartedEvent, ChaosCodePackageRestartScheduledEvent, DeployedApplicationHealthReportExpiredEvent, DeployedApplicationNewHealthReportEvent, DeployedServicePackageHealthReportExpiredEvent, DeployedServicePackageNewHealthReportEvent.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'ApplicationContainerInstanceExited': 'ApplicationContainerInstanceExitedEvent', 'ApplicationCreated': 'ApplicationCreatedEvent', 'ApplicationDeleted': 'ApplicationDeletedEvent', 'ApplicationHealthReportExpired': 'ApplicationHealthReportExpiredEvent', 'ApplicationNewHealthReport': 'ApplicationNewHealthReportEvent', 'ApplicationProcessExited': 'ApplicationProcessExitedEvent', 'ApplicationUpgradeCompleted': 'ApplicationUpgradeCompletedEvent', 'ApplicationUpgradeDomainCompleted': 'ApplicationUpgradeDomainCompletedEvent', 'ApplicationUpgradeRollbackCompleted': 'ApplicationUpgradeRollbackCompletedEvent', 'ApplicationUpgradeRollbackStarted': 'ApplicationUpgradeRollbackStartedEvent', 'ApplicationUpgradeStarted': 'ApplicationUpgradeStartedEvent', 'ChaosCodePackageRestartScheduled': 'ChaosCodePackageRestartScheduledEvent', 'DeployedApplicationHealthReportExpired': 'DeployedApplicationHealthReportExpiredEvent', 'DeployedApplicationNewHealthReport': 'DeployedApplicationNewHealthReportEvent', 'DeployedServicePackageHealthReportExpired': 'DeployedServicePackageHealthReportExpiredEvent', 'DeployedServicePackageNewHealthReport': 'DeployedServicePackageNewHealthReportEvent'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        """
        super(ApplicationEvent, self).__init__(**kwargs)
        self.kind = 'ApplicationEvent'  # type: str
        self.application_id = kwargs['application_id']


class ApplicationContainerInstanceExitedEvent(ApplicationEvent):
    """Container Exited event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar service_name: Required. Name of Service.
    :vartype service_name: str
    :ivar service_package_name: Required. Name of Service package.
    :vartype service_package_name: str
    :ivar service_package_activation_id: Required. Activation Id of Service package.
    :vartype service_package_activation_id: str
    :ivar is_exclusive: Required. Indicates IsExclusive flag.
    :vartype is_exclusive: bool
    :ivar code_package_name: Required. Name of Code package.
    :vartype code_package_name: str
    :ivar entry_point_type: Required. Type of EntryPoint.
    :vartype entry_point_type: str
    :ivar image_name: Required. Name of Container image.
    :vartype image_name: str
    :ivar container_name: Required. Name of Container.
    :vartype container_name: str
    :ivar host_id: Required. Host Id.
    :vartype host_id: str
    :ivar exit_code: Required. Exit code of process.
    :vartype exit_code: long
    :ivar unexpected_termination: Required. Indicates if termination is unexpected.
    :vartype unexpected_termination: bool
    :ivar start_time: Required. Start time of process.
    :vartype start_time: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'service_name': {'required': True},
        'service_package_name': {'required': True},
        'service_package_activation_id': {'required': True},
        'is_exclusive': {'required': True},
        'code_package_name': {'required': True},
        'entry_point_type': {'required': True},
        'image_name': {'required': True},
        'container_name': {'required': True},
        'host_id': {'required': True},
        'exit_code': {'required': True},
        'unexpected_termination': {'required': True},
        'start_time': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'service_package_name': {'key': 'ServicePackageName', 'type': 'str'},
        'service_package_activation_id': {'key': 'ServicePackageActivationId', 'type': 'str'},
        'is_exclusive': {'key': 'IsExclusive', 'type': 'bool'},
        'code_package_name': {'key': 'CodePackageName', 'type': 'str'},
        'entry_point_type': {'key': 'EntryPointType', 'type': 'str'},
        'image_name': {'key': 'ImageName', 'type': 'str'},
        'container_name': {'key': 'ContainerName', 'type': 'str'},
        'host_id': {'key': 'HostId', 'type': 'str'},
        'exit_code': {'key': 'ExitCode', 'type': 'long'},
        'unexpected_termination': {'key': 'UnexpectedTermination', 'type': 'bool'},
        'start_time': {'key': 'StartTime', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword service_name: Required. Name of Service.
        :paramtype service_name: str
        :keyword service_package_name: Required. Name of Service package.
        :paramtype service_package_name: str
        :keyword service_package_activation_id: Required. Activation Id of Service package.
        :paramtype service_package_activation_id: str
        :keyword is_exclusive: Required. Indicates IsExclusive flag.
        :paramtype is_exclusive: bool
        :keyword code_package_name: Required. Name of Code package.
        :paramtype code_package_name: str
        :keyword entry_point_type: Required. Type of EntryPoint.
        :paramtype entry_point_type: str
        :keyword image_name: Required. Name of Container image.
        :paramtype image_name: str
        :keyword container_name: Required. Name of Container.
        :paramtype container_name: str
        :keyword host_id: Required. Host Id.
        :paramtype host_id: str
        :keyword exit_code: Required. Exit code of process.
        :paramtype exit_code: long
        :keyword unexpected_termination: Required. Indicates if termination is unexpected.
        :paramtype unexpected_termination: bool
        :keyword start_time: Required. Start time of process.
        :paramtype start_time: ~datetime.datetime
        """
        super(ApplicationContainerInstanceExitedEvent, self).__init__(**kwargs)
        self.kind = 'ApplicationContainerInstanceExited'  # type: str
        self.service_name = kwargs['service_name']
        self.service_package_name = kwargs['service_package_name']
        self.service_package_activation_id = kwargs['service_package_activation_id']
        self.is_exclusive = kwargs['is_exclusive']
        self.code_package_name = kwargs['code_package_name']
        self.entry_point_type = kwargs['entry_point_type']
        self.image_name = kwargs['image_name']
        self.container_name = kwargs['container_name']
        self.host_id = kwargs['host_id']
        self.exit_code = kwargs['exit_code']
        self.unexpected_termination = kwargs['unexpected_termination']
        self.start_time = kwargs['start_time']


class ApplicationCreatedEvent(ApplicationEvent):
    """Application Created event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar application_type_name: Required. Application type name.
    :vartype application_type_name: str
    :ivar application_type_version: Required. Application type version.
    :vartype application_type_version: str
    :ivar application_definition_kind: Required. Application definition kind.
    :vartype application_definition_kind: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'application_type_name': {'required': True},
        'application_type_version': {'required': True},
        'application_definition_kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'application_type_name': {'key': 'ApplicationTypeName', 'type': 'str'},
        'application_type_version': {'key': 'ApplicationTypeVersion', 'type': 'str'},
        'application_definition_kind': {'key': 'ApplicationDefinitionKind', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword application_type_name: Required. Application type name.
        :paramtype application_type_name: str
        :keyword application_type_version: Required. Application type version.
        :paramtype application_type_version: str
        :keyword application_definition_kind: Required. Application definition kind.
        :paramtype application_definition_kind: str
        """
        super(ApplicationCreatedEvent, self).__init__(**kwargs)
        self.kind = 'ApplicationCreated'  # type: str
        self.application_type_name = kwargs['application_type_name']
        self.application_type_version = kwargs['application_type_version']
        self.application_definition_kind = kwargs['application_definition_kind']


class ApplicationDeletedEvent(ApplicationEvent):
    """Application Deleted event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar application_type_name: Required. Application type name.
    :vartype application_type_name: str
    :ivar application_type_version: Required. Application type version.
    :vartype application_type_version: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'application_type_name': {'required': True},
        'application_type_version': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'application_type_name': {'key': 'ApplicationTypeName', 'type': 'str'},
        'application_type_version': {'key': 'ApplicationTypeVersion', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword application_type_name: Required. Application type name.
        :paramtype application_type_name: str
        :keyword application_type_version: Required. Application type version.
        :paramtype application_type_version: str
        """
        super(ApplicationDeletedEvent, self).__init__(**kwargs)
        self.kind = 'ApplicationDeleted'  # type: str
        self.application_type_name = kwargs['application_type_name']
        self.application_type_version = kwargs['application_type_version']


class ApplicationDescription(msrest.serialization.Model):
    """Describes a Service Fabric application.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name of the application, including the 'fabric:' URI scheme.
    :vartype name: str
    :ivar type_name: Required. The application type name as defined in the application manifest.
    :vartype type_name: str
    :ivar type_version: Required. The version of the application type as defined in the application
     manifest.
    :vartype type_version: str
    :ivar parameter_list: List of application parameters with overridden values from their default
     values specified in the application manifest.
    :vartype parameter_list: list[~azure.servicefabric.models.ApplicationParameter]
    :ivar application_capacity: Describes capacity information for services of this application.
     This description can be used for describing the following.
    
    
     * Reserving the capacity for the services on the nodes
     * Limiting the total number of nodes that services of this application can run on
     * Limiting the custom capacity metrics to limit the total consumption of this metric by the
     services of this application.
    :vartype application_capacity: ~azure.servicefabric.models.ApplicationCapacityDescription
    :ivar managed_application_identity: Managed application identity description.
    :vartype managed_application_identity:
     ~azure.servicefabric.models.ManagedApplicationIdentityDescription
    """

    _validation = {
        'name': {'required': True},
        'type_name': {'required': True},
        'type_version': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'type_name': {'key': 'TypeName', 'type': 'str'},
        'type_version': {'key': 'TypeVersion', 'type': 'str'},
        'parameter_list': {'key': 'ParameterList', 'type': '[ApplicationParameter]'},
        'application_capacity': {'key': 'ApplicationCapacity', 'type': 'ApplicationCapacityDescription'},
        'managed_application_identity': {'key': 'ManagedApplicationIdentity', 'type': 'ManagedApplicationIdentityDescription'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. The name of the application, including the 'fabric:' URI scheme.
        :paramtype name: str
        :keyword type_name: Required. The application type name as defined in the application manifest.
        :paramtype type_name: str
        :keyword type_version: Required. The version of the application type as defined in the
         application manifest.
        :paramtype type_version: str
        :keyword parameter_list: List of application parameters with overridden values from their
         default values specified in the application manifest.
        :paramtype parameter_list: list[~azure.servicefabric.models.ApplicationParameter]
        :keyword application_capacity: Describes capacity information for services of this application.
         This description can be used for describing the following.
        
        
         * Reserving the capacity for the services on the nodes
         * Limiting the total number of nodes that services of this application can run on
         * Limiting the custom capacity metrics to limit the total consumption of this metric by the
         services of this application.
        :paramtype application_capacity: ~azure.servicefabric.models.ApplicationCapacityDescription
        :keyword managed_application_identity: Managed application identity description.
        :paramtype managed_application_identity:
         ~azure.servicefabric.models.ManagedApplicationIdentityDescription
        """
        super(ApplicationDescription, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.type_name = kwargs['type_name']
        self.type_version = kwargs['type_version']
        self.parameter_list = kwargs.get('parameter_list', None)
        self.application_capacity = kwargs.get('application_capacity', None)
        self.managed_application_identity = kwargs.get('managed_application_identity', None)


class EntityHealth(msrest.serialization.Model):
    """Health information common to all entities in the cluster. It contains the aggregated health state, health events and unhealthy evaluation.

    :ivar aggregated_health_state: The HealthState representing the aggregated health state of the
     entity computed by Health Manager.
     The health evaluation of the entity reflects all events reported on the entity and its
     children (if any).
     The aggregation is done by applying the desired health policy. Possible values include:
     "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar health_events: The list of health events reported on the entity.
    :vartype health_events: list[~azure.servicefabric.models.HealthEvent]
    :ivar unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
     health state was returned by Health Manager.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    :ivar health_statistics: Shows the health statistics for all children types of the queried
     entity.
    :vartype health_statistics: ~azure.servicefabric.models.HealthStatistics
    """

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'health_events': {'key': 'HealthEvents', 'type': '[HealthEvent]'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
        'health_statistics': {'key': 'HealthStatistics', 'type': 'HealthStatistics'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The HealthState representing the aggregated health state of
         the entity computed by Health Manager.
         The health evaluation of the entity reflects all events reported on the entity and its
         children (if any).
         The aggregation is done by applying the desired health policy. Possible values include:
         "Invalid", "Ok", "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword health_events: The list of health events reported on the entity.
        :paramtype health_events: list[~azure.servicefabric.models.HealthEvent]
        :keyword unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
         health state was returned by Health Manager.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        :keyword health_statistics: Shows the health statistics for all children types of the queried
         entity.
        :paramtype health_statistics: ~azure.servicefabric.models.HealthStatistics
        """
        super(EntityHealth, self).__init__(**kwargs)
        self.aggregated_health_state = kwargs.get('aggregated_health_state', None)
        self.health_events = kwargs.get('health_events', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)
        self.health_statistics = kwargs.get('health_statistics', None)


class ApplicationHealth(EntityHealth):
    """Represents the health of the application. Contains the application aggregated health state and the service and deployed application health states.

    :ivar aggregated_health_state: The HealthState representing the aggregated health state of the
     entity computed by Health Manager.
     The health evaluation of the entity reflects all events reported on the entity and its
     children (if any).
     The aggregation is done by applying the desired health policy. Possible values include:
     "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar health_events: The list of health events reported on the entity.
    :vartype health_events: list[~azure.servicefabric.models.HealthEvent]
    :ivar unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
     health state was returned by Health Manager.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    :ivar health_statistics: Shows the health statistics for all children types of the queried
     entity.
    :vartype health_statistics: ~azure.servicefabric.models.HealthStatistics
    :ivar name: The name of the application, including the 'fabric:' URI scheme.
    :vartype name: str
    :ivar service_health_states: Service health states as found in the health store.
    :vartype service_health_states: list[~azure.servicefabric.models.ServiceHealthState]
    :ivar deployed_application_health_states: Deployed application health states as found in the
     health store.
    :vartype deployed_application_health_states:
     list[~azure.servicefabric.models.DeployedApplicationHealthState]
    """

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'health_events': {'key': 'HealthEvents', 'type': '[HealthEvent]'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
        'health_statistics': {'key': 'HealthStatistics', 'type': 'HealthStatistics'},
        'name': {'key': 'Name', 'type': 'str'},
        'service_health_states': {'key': 'ServiceHealthStates', 'type': '[ServiceHealthState]'},
        'deployed_application_health_states': {'key': 'DeployedApplicationHealthStates', 'type': '[DeployedApplicationHealthState]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The HealthState representing the aggregated health state of
         the entity computed by Health Manager.
         The health evaluation of the entity reflects all events reported on the entity and its
         children (if any).
         The aggregation is done by applying the desired health policy. Possible values include:
         "Invalid", "Ok", "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword health_events: The list of health events reported on the entity.
        :paramtype health_events: list[~azure.servicefabric.models.HealthEvent]
        :keyword unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
         health state was returned by Health Manager.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        :keyword health_statistics: Shows the health statistics for all children types of the queried
         entity.
        :paramtype health_statistics: ~azure.servicefabric.models.HealthStatistics
        :keyword name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype name: str
        :keyword service_health_states: Service health states as found in the health store.
        :paramtype service_health_states: list[~azure.servicefabric.models.ServiceHealthState]
        :keyword deployed_application_health_states: Deployed application health states as found in the
         health store.
        :paramtype deployed_application_health_states:
         list[~azure.servicefabric.models.DeployedApplicationHealthState]
        """
        super(ApplicationHealth, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.service_health_states = kwargs.get('service_health_states', None)
        self.deployed_application_health_states = kwargs.get('deployed_application_health_states', None)


class HealthEvaluation(msrest.serialization.Model):
    """Represents a health evaluation which describes the data and the algorithm used by health manager to evaluate the health of an entity.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ApplicationHealthEvaluation, ApplicationTypeApplicationsHealthEvaluation, ApplicationsHealthEvaluation, DeltaNodesCheckHealthEvaluation, DeployedApplicationHealthEvaluation, DeployedApplicationsHealthEvaluation, DeployedServicePackageHealthEvaluation, DeployedServicePackagesHealthEvaluation, EventHealthEvaluation, NodeHealthEvaluation, NodeTypeNodesHealthEvaluation, NodesHealthEvaluation, PartitionHealthEvaluation, PartitionsHealthEvaluation, ReplicaHealthEvaluation, ReplicasHealthEvaluation, ServiceHealthEvaluation, ServicesHealthEvaluation, SystemApplicationHealthEvaluation, UpgradeDomainDeltaNodesCheckHealthEvaluation, UpgradeDomainDeployedApplicationsHealthEvaluation, UpgradeDomainNodesHealthEvaluation.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'Application': 'ApplicationHealthEvaluation', 'ApplicationTypeApplications': 'ApplicationTypeApplicationsHealthEvaluation', 'Applications': 'ApplicationsHealthEvaluation', 'DeltaNodesCheck': 'DeltaNodesCheckHealthEvaluation', 'DeployedApplication': 'DeployedApplicationHealthEvaluation', 'DeployedApplications': 'DeployedApplicationsHealthEvaluation', 'DeployedServicePackage': 'DeployedServicePackageHealthEvaluation', 'DeployedServicePackages': 'DeployedServicePackagesHealthEvaluation', 'Event': 'EventHealthEvaluation', 'Node': 'NodeHealthEvaluation', 'NodeTypeNodes': 'NodeTypeNodesHealthEvaluation', 'Nodes': 'NodesHealthEvaluation', 'Partition': 'PartitionHealthEvaluation', 'Partitions': 'PartitionsHealthEvaluation', 'Replica': 'ReplicaHealthEvaluation', 'Replicas': 'ReplicasHealthEvaluation', 'Service': 'ServiceHealthEvaluation', 'Services': 'ServicesHealthEvaluation', 'SystemApplication': 'SystemApplicationHealthEvaluation', 'UpgradeDomainDeltaNodesCheck': 'UpgradeDomainDeltaNodesCheckHealthEvaluation', 'UpgradeDomainDeployedApplications': 'UpgradeDomainDeployedApplicationsHealthEvaluation', 'UpgradeDomainNodes': 'UpgradeDomainNodesHealthEvaluation'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        """
        super(HealthEvaluation, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]
        self.aggregated_health_state = kwargs.get('aggregated_health_state', None)
        self.description = kwargs.get('description', None)


class ApplicationHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for an application, containing information about the data and the algorithm used by the health store to evaluate health.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar application_name: The name of the application, including the 'fabric:' URI scheme.
    :vartype application_name: str
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the current aggregated
     health state of the application. The types of the unhealthy evaluations can be
     DeployedApplicationsHealthEvaluation, ServicesHealthEvaluation or EventHealthEvaluation.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword application_name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype application_name: str
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the current
         aggregated health state of the application. The types of the unhealthy evaluations can be
         DeployedApplicationsHealthEvaluation, ServicesHealthEvaluation or EventHealthEvaluation.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(ApplicationHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'Application'  # type: str
        self.application_name = kwargs.get('application_name', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class ApplicationHealthPolicies(msrest.serialization.Model):
    """Defines the application health policy map used to evaluate the health of an application or one of its children entities.

    :ivar application_health_policy_map: The wrapper that contains the map with application health
     policies used to evaluate specific applications in the cluster.
    :vartype application_health_policy_map:
     list[~azure.servicefabric.models.ApplicationHealthPolicyMapItem]
    """

    _attribute_map = {
        'application_health_policy_map': {'key': 'ApplicationHealthPolicyMap', 'type': '[ApplicationHealthPolicyMapItem]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword application_health_policy_map: The wrapper that contains the map with application
         health policies used to evaluate specific applications in the cluster.
        :paramtype application_health_policy_map:
         list[~azure.servicefabric.models.ApplicationHealthPolicyMapItem]
        """
        super(ApplicationHealthPolicies, self).__init__(**kwargs)
        self.application_health_policy_map = kwargs.get('application_health_policy_map', None)


class ApplicationHealthPolicy(msrest.serialization.Model):
    """Defines a health policy used to evaluate the health of an application or one of its children entities.

    :ivar consider_warning_as_error: Indicates whether warnings are treated with the same severity
     as errors.
    :vartype consider_warning_as_error: bool
    :ivar max_percent_unhealthy_deployed_applications: The maximum allowed percentage of unhealthy
     deployed applications. Allowed values are Byte values from zero to 100.
     The percentage represents the maximum tolerated percentage of deployed applications that can
     be unhealthy before the application is considered in error.
     This is calculated by dividing the number of unhealthy deployed applications over the number
     of nodes where the application is currently deployed on in the cluster.
     The computation rounds up to tolerate one failure on small numbers of nodes. Default
     percentage is zero.
    :vartype max_percent_unhealthy_deployed_applications: int
    :ivar default_service_type_health_policy: The health policy used by default to evaluate the
     health of a service type.
    :vartype default_service_type_health_policy:
     ~azure.servicefabric.models.ServiceTypeHealthPolicy
    :ivar service_type_health_policy_map: The map with service type health policy per service type
     name. The map is empty by default.
    :vartype service_type_health_policy_map:
     list[~azure.servicefabric.models.ServiceTypeHealthPolicyMapItem]
    """

    _attribute_map = {
        'consider_warning_as_error': {'key': 'ConsiderWarningAsError', 'type': 'bool'},
        'max_percent_unhealthy_deployed_applications': {'key': 'MaxPercentUnhealthyDeployedApplications', 'type': 'int'},
        'default_service_type_health_policy': {'key': 'DefaultServiceTypeHealthPolicy', 'type': 'ServiceTypeHealthPolicy'},
        'service_type_health_policy_map': {'key': 'ServiceTypeHealthPolicyMap', 'type': '[ServiceTypeHealthPolicyMapItem]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword consider_warning_as_error: Indicates whether warnings are treated with the same
         severity as errors.
        :paramtype consider_warning_as_error: bool
        :keyword max_percent_unhealthy_deployed_applications: The maximum allowed percentage of
         unhealthy deployed applications. Allowed values are Byte values from zero to 100.
         The percentage represents the maximum tolerated percentage of deployed applications that can
         be unhealthy before the application is considered in error.
         This is calculated by dividing the number of unhealthy deployed applications over the number
         of nodes where the application is currently deployed on in the cluster.
         The computation rounds up to tolerate one failure on small numbers of nodes. Default
         percentage is zero.
        :paramtype max_percent_unhealthy_deployed_applications: int
        :keyword default_service_type_health_policy: The health policy used by default to evaluate the
         health of a service type.
        :paramtype default_service_type_health_policy:
         ~azure.servicefabric.models.ServiceTypeHealthPolicy
        :keyword service_type_health_policy_map: The map with service type health policy per service
         type name. The map is empty by default.
        :paramtype service_type_health_policy_map:
         list[~azure.servicefabric.models.ServiceTypeHealthPolicyMapItem]
        """
        super(ApplicationHealthPolicy, self).__init__(**kwargs)
        self.consider_warning_as_error = kwargs.get('consider_warning_as_error', False)
        self.max_percent_unhealthy_deployed_applications = kwargs.get('max_percent_unhealthy_deployed_applications', 0)
        self.default_service_type_health_policy = kwargs.get('default_service_type_health_policy', None)
        self.service_type_health_policy_map = kwargs.get('service_type_health_policy_map', None)


class ApplicationHealthPolicyMapItem(msrest.serialization.Model):
    """Defines an item in ApplicationHealthPolicyMap.

    All required parameters must be populated in order to send to Azure.

    :ivar key: Required. The key of the application health policy map item. This is the name of the
     application.
    :vartype key: str
    :ivar value: Required. The value of the application health policy map item. This is the
     ApplicationHealthPolicy for this application.
    :vartype value: ~azure.servicefabric.models.ApplicationHealthPolicy
    """

    _validation = {
        'key': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'key': {'key': 'Key', 'type': 'str'},
        'value': {'key': 'Value', 'type': 'ApplicationHealthPolicy'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword key: Required. The key of the application health policy map item. This is the name of
         the application.
        :paramtype key: str
        :keyword value: Required. The value of the application health policy map item. This is the
         ApplicationHealthPolicy for this application.
        :paramtype value: ~azure.servicefabric.models.ApplicationHealthPolicy
        """
        super(ApplicationHealthPolicyMapItem, self).__init__(**kwargs)
        self.key = kwargs['key']
        self.value = kwargs['value']


class ApplicationHealthPolicyMapObject(msrest.serialization.Model):
    """Represents the map of application health policies for a ServiceFabric cluster upgrade.

    :ivar application_health_policy_map: Defines a map that contains specific application health
     policies for different applications.
     Each entry specifies as key the application name and as value an ApplicationHealthPolicy used
     to evaluate the application health.
     If an application is not specified in the map, the application health evaluation uses the
     ApplicationHealthPolicy found in its application manifest or the default application health
     policy (if no health policy is defined in the manifest).
     The map is empty by default.
    :vartype application_health_policy_map:
     list[~azure.servicefabric.models.ApplicationHealthPolicyMapItem]
    """

    _attribute_map = {
        'application_health_policy_map': {'key': 'ApplicationHealthPolicyMap', 'type': '[ApplicationHealthPolicyMapItem]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword application_health_policy_map: Defines a map that contains specific application health
         policies for different applications.
         Each entry specifies as key the application name and as value an ApplicationHealthPolicy used
         to evaluate the application health.
         If an application is not specified in the map, the application health evaluation uses the
         ApplicationHealthPolicy found in its application manifest or the default application health
         policy (if no health policy is defined in the manifest).
         The map is empty by default.
        :paramtype application_health_policy_map:
         list[~azure.servicefabric.models.ApplicationHealthPolicyMapItem]
        """
        super(ApplicationHealthPolicyMapObject, self).__init__(**kwargs)
        self.application_health_policy_map = kwargs.get('application_health_policy_map', None)


class ApplicationHealthReportExpiredEvent(ApplicationEvent):
    """Application Health Report Expired event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar application_instance_id: Required. Id of Application instance.
    :vartype application_instance_id: long
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'application_instance_id': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'application_instance_id': {'key': 'ApplicationInstanceId', 'type': 'long'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword application_instance_id: Required. Id of Application instance.
        :paramtype application_instance_id: long
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(ApplicationHealthReportExpiredEvent, self).__init__(**kwargs)
        self.kind = 'ApplicationHealthReportExpired'  # type: str
        self.application_instance_id = kwargs['application_instance_id']
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class EntityHealthState(msrest.serialization.Model):
    """A base type for the health state of various entities in the cluster. It contains the aggregated health state.

    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    """

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        """
        super(EntityHealthState, self).__init__(**kwargs)
        self.aggregated_health_state = kwargs.get('aggregated_health_state', None)


class ApplicationHealthState(EntityHealthState):
    """Represents the health state of an application, which contains the application identifier and the aggregated health state.

    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar name: The name of the application, including the 'fabric:' URI scheme.
    :vartype name: str
    """

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'name': {'key': 'Name', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype name: str
        """
        super(ApplicationHealthState, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)


class EntityHealthStateChunk(msrest.serialization.Model):
    """A base type for the health state chunk of various entities in the cluster. It contains the aggregated health state.

    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    """

    _attribute_map = {
        'health_state': {'key': 'HealthState', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        """
        super(EntityHealthStateChunk, self).__init__(**kwargs)
        self.health_state = kwargs.get('health_state', None)


class ApplicationHealthStateChunk(EntityHealthStateChunk):
    """Represents the health state chunk of a application.
The application health state chunk contains the application name, its aggregated health state and any children services and deployed applications that respect the filters in cluster health chunk query description.

    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar application_name: The name of the application, including the 'fabric:' URI scheme.
    :vartype application_name: str
    :ivar application_type_name: The application type name as defined in the application manifest.
    :vartype application_type_name: str
    :ivar service_health_state_chunks: The list of service health state chunks in the cluster that
     respect the filters in the cluster health chunk query description.
    :vartype service_health_state_chunks: ~azure.servicefabric.models.ServiceHealthStateChunkList
    :ivar deployed_application_health_state_chunks: The list of deployed application health state
     chunks in the cluster that respect the filters in the cluster health chunk query description.
    :vartype deployed_application_health_state_chunks:
     ~azure.servicefabric.models.DeployedApplicationHealthStateChunkList
    """

    _attribute_map = {
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
        'application_type_name': {'key': 'ApplicationTypeName', 'type': 'str'},
        'service_health_state_chunks': {'key': 'ServiceHealthStateChunks', 'type': 'ServiceHealthStateChunkList'},
        'deployed_application_health_state_chunks': {'key': 'DeployedApplicationHealthStateChunks', 'type': 'DeployedApplicationHealthStateChunkList'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword application_name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype application_name: str
        :keyword application_type_name: The application type name as defined in the application
         manifest.
        :paramtype application_type_name: str
        :keyword service_health_state_chunks: The list of service health state chunks in the cluster
         that respect the filters in the cluster health chunk query description.
        :paramtype service_health_state_chunks: ~azure.servicefabric.models.ServiceHealthStateChunkList
        :keyword deployed_application_health_state_chunks: The list of deployed application health
         state chunks in the cluster that respect the filters in the cluster health chunk query
         description.
        :paramtype deployed_application_health_state_chunks:
         ~azure.servicefabric.models.DeployedApplicationHealthStateChunkList
        """
        super(ApplicationHealthStateChunk, self).__init__(**kwargs)
        self.application_name = kwargs.get('application_name', None)
        self.application_type_name = kwargs.get('application_type_name', None)
        self.service_health_state_chunks = kwargs.get('service_health_state_chunks', None)
        self.deployed_application_health_state_chunks = kwargs.get('deployed_application_health_state_chunks', None)


class EntityHealthStateChunkList(msrest.serialization.Model):
    """A base type for the list of health state chunks found in the cluster. It contains the total number of health states that match the input filters.

    :ivar total_count: Total number of entity health state objects that match the specified filters
     from the cluster health chunk query description.
    :vartype total_count: long
    """

    _attribute_map = {
        'total_count': {'key': 'TotalCount', 'type': 'long'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword total_count: Total number of entity health state objects that match the specified
         filters from the cluster health chunk query description.
        :paramtype total_count: long
        """
        super(EntityHealthStateChunkList, self).__init__(**kwargs)
        self.total_count = kwargs.get('total_count', None)


class ApplicationHealthStateChunkList(EntityHealthStateChunkList):
    """The list of application health state chunks in the cluster that respect the input filters in the chunk query. Returned by get cluster health state chunks query.

    :ivar total_count: Total number of entity health state objects that match the specified filters
     from the cluster health chunk query description.
    :vartype total_count: long
    :ivar items: The list of application health state chunks that respect the input filters in the
     chunk query.
    :vartype items: list[~azure.servicefabric.models.ApplicationHealthStateChunk]
    """

    _attribute_map = {
        'total_count': {'key': 'TotalCount', 'type': 'long'},
        'items': {'key': 'Items', 'type': '[ApplicationHealthStateChunk]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword total_count: Total number of entity health state objects that match the specified
         filters from the cluster health chunk query description.
        :paramtype total_count: long
        :keyword items: The list of application health state chunks that respect the input filters in
         the chunk query.
        :paramtype items: list[~azure.servicefabric.models.ApplicationHealthStateChunk]
        """
        super(ApplicationHealthStateChunkList, self).__init__(**kwargs)
        self.items = kwargs.get('items', None)


class ApplicationHealthStateFilter(msrest.serialization.Model):
    """Defines matching criteria to determine whether a application should be included in the cluster health chunk.
One filter can match zero, one or multiple applications, depending on its properties.

    :ivar application_name_filter: The name of the application that matches the filter, as a fabric
     uri. The filter is applied only to the specified application, if it exists.
     If the application doesn't exist, no application is returned in the cluster health chunk based
     on this filter.
     If the application exists, it is included in the cluster health chunk if it respects the other
     filter properties.
     If not specified, all applications are matched against the other filter members, like health
     state filter.
    :vartype application_name_filter: str
    :ivar application_type_name_filter: The name of the application type that matches the filter.
     If specified, the filter is applied only to applications of the selected application type, if
     any exists.
     If no applications of the specified application type exists, no application is returned in the
     cluster health chunk based on this filter.
     Each application of the specified application type is included in the cluster health chunk if
     it respects the other filter properties.
     If not specified, all applications are matched against the other filter members, like health
     state filter.
    :vartype application_type_name_filter: str
    :ivar health_state_filter: The filter for the health state of the applications. It allows
     selecting applications if they match the desired health states.
     The possible values are integer value of one of the following health states. Only applications
     that match the filter are returned. All applications are used to evaluate the cluster
     aggregated health state.
     If not specified, default value is None, unless the application name or the application type
     name are specified. If the filter has default value and application name is specified, the
     matching application is returned.
     The state values are flag-based enumeration, so the value could be a combination of these
     values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6, it matches applications with HealthState value of OK
     (2) and Warning (4).
    
    
     * Default - Default value. Matches any HealthState. The value is zero.
     * None - Filter that doesn't match any HealthState value. Used in order to return no results
     on a given collection of states. The value is 1.
     * Ok - Filter that matches input with HealthState value Ok. The value is 2.
     * Warning - Filter that matches input with HealthState value Warning. The value is 4.
     * Error - Filter that matches input with HealthState value Error. The value is 8.
     * All - Filter that matches input with any HealthState value. The value is 65535.
    :vartype health_state_filter: int
    :ivar service_filters: Defines a list of filters that specify which services to be included in
     the returned cluster health chunk as children of the application. The services are returned
     only if the parent application matches a filter.
     If the list is empty, no services are returned. All the services are used to evaluate the
     parent application aggregated health state, regardless of the input filters.
     The application filter may specify multiple service filters.
     For example, it can specify a filter to return all services with health state Error and
     another filter to always include a service identified by its service name.
    :vartype service_filters: list[~azure.servicefabric.models.ServiceHealthStateFilter]
    :ivar deployed_application_filters: Defines a list of filters that specify which deployed
     applications to be included in the returned cluster health chunk as children of the
     application. The deployed applications are returned only if the parent application matches a
     filter.
     If the list is empty, no deployed applications are returned. All the deployed applications are
     used to evaluate the parent application aggregated health state, regardless of the input
     filters.
     The application filter may specify multiple deployed application filters.
     For example, it can specify a filter to return all deployed applications with health state
     Error and another filter to always include a deployed application on a specified node.
    :vartype deployed_application_filters:
     list[~azure.servicefabric.models.DeployedApplicationHealthStateFilter]
    """

    _attribute_map = {
        'application_name_filter': {'key': 'ApplicationNameFilter', 'type': 'str'},
        'application_type_name_filter': {'key': 'ApplicationTypeNameFilter', 'type': 'str'},
        'health_state_filter': {'key': 'HealthStateFilter', 'type': 'int'},
        'service_filters': {'key': 'ServiceFilters', 'type': '[ServiceHealthStateFilter]'},
        'deployed_application_filters': {'key': 'DeployedApplicationFilters', 'type': '[DeployedApplicationHealthStateFilter]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword application_name_filter: The name of the application that matches the filter, as a
         fabric uri. The filter is applied only to the specified application, if it exists.
         If the application doesn't exist, no application is returned in the cluster health chunk based
         on this filter.
         If the application exists, it is included in the cluster health chunk if it respects the other
         filter properties.
         If not specified, all applications are matched against the other filter members, like health
         state filter.
        :paramtype application_name_filter: str
        :keyword application_type_name_filter: The name of the application type that matches the
         filter.
         If specified, the filter is applied only to applications of the selected application type, if
         any exists.
         If no applications of the specified application type exists, no application is returned in the
         cluster health chunk based on this filter.
         Each application of the specified application type is included in the cluster health chunk if
         it respects the other filter properties.
         If not specified, all applications are matched against the other filter members, like health
         state filter.
        :paramtype application_type_name_filter: str
        :keyword health_state_filter: The filter for the health state of the applications. It allows
         selecting applications if they match the desired health states.
         The possible values are integer value of one of the following health states. Only applications
         that match the filter are returned. All applications are used to evaluate the cluster
         aggregated health state.
         If not specified, default value is None, unless the application name or the application type
         name are specified. If the filter has default value and application name is specified, the
         matching application is returned.
         The state values are flag-based enumeration, so the value could be a combination of these
         values obtained using bitwise 'OR' operator.
         For example, if the provided value is 6, it matches applications with HealthState value of OK
         (2) and Warning (4).
        
        
         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535.
        :paramtype health_state_filter: int
        :keyword service_filters: Defines a list of filters that specify which services to be included
         in the returned cluster health chunk as children of the application. The services are returned
         only if the parent application matches a filter.
         If the list is empty, no services are returned. All the services are used to evaluate the
         parent application aggregated health state, regardless of the input filters.
         The application filter may specify multiple service filters.
         For example, it can specify a filter to return all services with health state Error and
         another filter to always include a service identified by its service name.
        :paramtype service_filters: list[~azure.servicefabric.models.ServiceHealthStateFilter]
        :keyword deployed_application_filters: Defines a list of filters that specify which deployed
         applications to be included in the returned cluster health chunk as children of the
         application. The deployed applications are returned only if the parent application matches a
         filter.
         If the list is empty, no deployed applications are returned. All the deployed applications are
         used to evaluate the parent application aggregated health state, regardless of the input
         filters.
         The application filter may specify multiple deployed application filters.
         For example, it can specify a filter to return all deployed applications with health state
         Error and another filter to always include a deployed application on a specified node.
        :paramtype deployed_application_filters:
         list[~azure.servicefabric.models.DeployedApplicationHealthStateFilter]
        """
        super(ApplicationHealthStateFilter, self).__init__(**kwargs)
        self.application_name_filter = kwargs.get('application_name_filter', None)
        self.application_type_name_filter = kwargs.get('application_type_name_filter', None)
        self.health_state_filter = kwargs.get('health_state_filter', 0)
        self.service_filters = kwargs.get('service_filters', None)
        self.deployed_application_filters = kwargs.get('deployed_application_filters', None)


class ApplicationInfo(msrest.serialization.Model):
    """Information about a Service Fabric application.

    :ivar id: The identity of the application. This is an encoded representation of the application
     name. This is used in the REST APIs to identify the application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype id: str
    :ivar name: The name of the application, including the 'fabric:' URI scheme.
    :vartype name: str
    :ivar type_name: The application type name as defined in the application manifest.
    :vartype type_name: str
    :ivar type_version: The version of the application type as defined in the application manifest.
    :vartype type_version: str
    :ivar status: The status of the application. Possible values include: "Invalid", "Ready",
     "Upgrading", "Creating", "Deleting", "Failed".
    :vartype status: str or ~azure.servicefabric.models.ApplicationStatus
    :ivar parameters: List of application parameters with overridden values from their default
     values specified in the application manifest.
    :vartype parameters: list[~azure.servicefabric.models.ApplicationParameter]
    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar application_definition_kind: The mechanism used to define a Service Fabric application.
     Possible values include: "Invalid", "ServiceFabricApplicationDescription", "Compose".
    :vartype application_definition_kind: str or
     ~azure.servicefabric.models.ApplicationDefinitionKind
    :ivar managed_application_identity: Managed application identity description.
    :vartype managed_application_identity:
     ~azure.servicefabric.models.ManagedApplicationIdentityDescription
    :ivar application_metadata: Metadata associated with a specific application.
    :vartype application_metadata: ~azure.servicefabric.models.ApplicationMetadata
    """

    _attribute_map = {
        'id': {'key': 'Id', 'type': 'str'},
        'name': {'key': 'Name', 'type': 'str'},
        'type_name': {'key': 'TypeName', 'type': 'str'},
        'type_version': {'key': 'TypeVersion', 'type': 'str'},
        'status': {'key': 'Status', 'type': 'str'},
        'parameters': {'key': 'Parameters', 'type': '[ApplicationParameter]'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'application_definition_kind': {'key': 'ApplicationDefinitionKind', 'type': 'str'},
        'managed_application_identity': {'key': 'ManagedApplicationIdentity', 'type': 'ManagedApplicationIdentityDescription'},
        'application_metadata': {'key': 'ApplicationMetadata', 'type': 'ApplicationMetadata'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword id: The identity of the application. This is an encoded representation of the
         application name. This is used in the REST APIs to identify the application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype id: str
        :keyword name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype name: str
        :keyword type_name: The application type name as defined in the application manifest.
        :paramtype type_name: str
        :keyword type_version: The version of the application type as defined in the application
         manifest.
        :paramtype type_version: str
        :keyword status: The status of the application. Possible values include: "Invalid", "Ready",
         "Upgrading", "Creating", "Deleting", "Failed".
        :paramtype status: str or ~azure.servicefabric.models.ApplicationStatus
        :keyword parameters: List of application parameters with overridden values from their default
         values specified in the application manifest.
        :paramtype parameters: list[~azure.servicefabric.models.ApplicationParameter]
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword application_definition_kind: The mechanism used to define a Service Fabric
         application. Possible values include: "Invalid", "ServiceFabricApplicationDescription",
         "Compose".
        :paramtype application_definition_kind: str or
         ~azure.servicefabric.models.ApplicationDefinitionKind
        :keyword managed_application_identity: Managed application identity description.
        :paramtype managed_application_identity:
         ~azure.servicefabric.models.ManagedApplicationIdentityDescription
        :keyword application_metadata: Metadata associated with a specific application.
        :paramtype application_metadata: ~azure.servicefabric.models.ApplicationMetadata
        """
        super(ApplicationInfo, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.name = kwargs.get('name', None)
        self.type_name = kwargs.get('type_name', None)
        self.type_version = kwargs.get('type_version', None)
        self.status = kwargs.get('status', None)
        self.parameters = kwargs.get('parameters', None)
        self.health_state = kwargs.get('health_state', None)
        self.application_definition_kind = kwargs.get('application_definition_kind', None)
        self.managed_application_identity = kwargs.get('managed_application_identity', None)
        self.application_metadata = kwargs.get('application_metadata', None)


class ApplicationLoadInfo(msrest.serialization.Model):
    """Load Information about a Service Fabric application.

    :ivar id: The identity of the application. This is an encoded representation of the application
     name. This is used in the REST APIs to identify the application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype id: str
    :ivar minimum_nodes: The minimum number of nodes for this application.
     It is the number of nodes where Service Fabric will reserve Capacity in the cluster which
     equals to ReservedLoad * MinimumNodes for this Application instance.
     For applications that do not have application capacity defined this value will be zero.
    :vartype minimum_nodes: long
    :ivar maximum_nodes: The maximum number of nodes where this application can be instantiated.
     It is the number of nodes this application is allowed to span.
     For applications that do not have application capacity defined this value will be zero.
    :vartype maximum_nodes: long
    :ivar node_count: The number of nodes on which this application is instantiated.
     For applications that do not have application capacity defined this value will be zero.
    :vartype node_count: long
    :ivar application_load_metric_information: List of application load metric information.
    :vartype application_load_metric_information:
     list[~azure.servicefabric.models.ApplicationLoadMetricInformation]
    """

    _attribute_map = {
        'id': {'key': 'Id', 'type': 'str'},
        'minimum_nodes': {'key': 'MinimumNodes', 'type': 'long'},
        'maximum_nodes': {'key': 'MaximumNodes', 'type': 'long'},
        'node_count': {'key': 'NodeCount', 'type': 'long'},
        'application_load_metric_information': {'key': 'ApplicationLoadMetricInformation', 'type': '[ApplicationLoadMetricInformation]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword id: The identity of the application. This is an encoded representation of the
         application name. This is used in the REST APIs to identify the application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype id: str
        :keyword minimum_nodes: The minimum number of nodes for this application.
         It is the number of nodes where Service Fabric will reserve Capacity in the cluster which
         equals to ReservedLoad * MinimumNodes for this Application instance.
         For applications that do not have application capacity defined this value will be zero.
        :paramtype minimum_nodes: long
        :keyword maximum_nodes: The maximum number of nodes where this application can be instantiated.
         It is the number of nodes this application is allowed to span.
         For applications that do not have application capacity defined this value will be zero.
        :paramtype maximum_nodes: long
        :keyword node_count: The number of nodes on which this application is instantiated.
         For applications that do not have application capacity defined this value will be zero.
        :paramtype node_count: long
        :keyword application_load_metric_information: List of application load metric information.
        :paramtype application_load_metric_information:
         list[~azure.servicefabric.models.ApplicationLoadMetricInformation]
        """
        super(ApplicationLoadInfo, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.minimum_nodes = kwargs.get('minimum_nodes', None)
        self.maximum_nodes = kwargs.get('maximum_nodes', None)
        self.node_count = kwargs.get('node_count', None)
        self.application_load_metric_information = kwargs.get('application_load_metric_information', None)


class ApplicationLoadMetricInformation(msrest.serialization.Model):
    """Describes load information for a custom resource balancing metric. This can be used to limit the total consumption of this metric by the services of this application.

    :ivar name: The name of the metric.
    :vartype name: str
    :ivar reservation_capacity: This is the capacity reserved in the cluster for the application.
     It's the product of NodeReservationCapacity and MinimumNodes.
     If set to zero, no capacity is reserved for this metric.
     When setting application capacity or when updating application capacity this value must be
     smaller than or equal to MaximumCapacity for each metric.
    :vartype reservation_capacity: long
    :ivar application_capacity: Total capacity for this metric in this application instance.
    :vartype application_capacity: long
    :ivar application_load: Current load for this metric in this application instance.
    :vartype application_load: long
    """

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'reservation_capacity': {'key': 'ReservationCapacity', 'type': 'long'},
        'application_capacity': {'key': 'ApplicationCapacity', 'type': 'long'},
        'application_load': {'key': 'ApplicationLoad', 'type': 'long'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: The name of the metric.
        :paramtype name: str
        :keyword reservation_capacity: This is the capacity reserved in the cluster for the
         application.
         It's the product of NodeReservationCapacity and MinimumNodes.
         If set to zero, no capacity is reserved for this metric.
         When setting application capacity or when updating application capacity this value must be
         smaller than or equal to MaximumCapacity for each metric.
        :paramtype reservation_capacity: long
        :keyword application_capacity: Total capacity for this metric in this application instance.
        :paramtype application_capacity: long
        :keyword application_load: Current load for this metric in this application instance.
        :paramtype application_load: long
        """
        super(ApplicationLoadMetricInformation, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.reservation_capacity = kwargs.get('reservation_capacity', None)
        self.application_capacity = kwargs.get('application_capacity', None)
        self.application_load = kwargs.get('application_load', None)


class ApplicationMetadata(msrest.serialization.Model):
    """Metadata associated with a specific application.

    :ivar arm_metadata: Common ArmMetadata assocaited with Service Fabric Entities.
    :vartype arm_metadata: ~azure.servicefabric.models.ArmMetadata
    """

    _attribute_map = {
        'arm_metadata': {'key': 'ArmMetadata', 'type': 'ArmMetadata'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword arm_metadata: Common ArmMetadata assocaited with Service Fabric Entities.
        :paramtype arm_metadata: ~azure.servicefabric.models.ArmMetadata
        """
        super(ApplicationMetadata, self).__init__(**kwargs)
        self.arm_metadata = kwargs.get('arm_metadata', None)


class ApplicationMetricDescription(msrest.serialization.Model):
    """Describes capacity information for a custom resource balancing metric. This can be used to limit the total consumption of this metric by the services of this application.

    :ivar name: The name of the metric.
    :vartype name: str
    :ivar maximum_capacity: The maximum node capacity for Service Fabric application.
     This is the maximum Load for an instance of this application on a single node. Even if the
     capacity of node is greater than this value, Service Fabric will limit the total load of
     services within the application on each node to this value.
     If set to zero, capacity for this metric is unlimited on each node.
     When creating a new application with application capacity defined, the product of MaximumNodes
     and this value must always be smaller than or equal to TotalApplicationCapacity.
     When updating existing application with application capacity, the product of MaximumNodes and
     this value must always be smaller than or equal to TotalApplicationCapacity.
    :vartype maximum_capacity: long
    :ivar reservation_capacity: The node reservation capacity for Service Fabric application.
     This is the amount of load which is reserved on nodes which have instances of this
     application.
     If MinimumNodes is specified, then the product of these values will be the capacity reserved
     in the cluster for the application.
     If set to zero, no capacity is reserved for this metric.
     When setting application capacity or when updating application capacity; this value must be
     smaller than or equal to MaximumCapacity for each metric.
    :vartype reservation_capacity: long
    :ivar total_application_capacity: The total metric capacity for Service Fabric application.
     This is the total metric capacity for this application in the cluster. Service Fabric will try
     to limit the sum of loads of services within the application to this value.
     When creating a new application with application capacity defined, the product of MaximumNodes
     and MaximumCapacity must always be smaller than or equal to this value.
    :vartype total_application_capacity: long
    """

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'maximum_capacity': {'key': 'MaximumCapacity', 'type': 'long'},
        'reservation_capacity': {'key': 'ReservationCapacity', 'type': 'long'},
        'total_application_capacity': {'key': 'TotalApplicationCapacity', 'type': 'long'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: The name of the metric.
        :paramtype name: str
        :keyword maximum_capacity: The maximum node capacity for Service Fabric application.
         This is the maximum Load for an instance of this application on a single node. Even if the
         capacity of node is greater than this value, Service Fabric will limit the total load of
         services within the application on each node to this value.
         If set to zero, capacity for this metric is unlimited on each node.
         When creating a new application with application capacity defined, the product of MaximumNodes
         and this value must always be smaller than or equal to TotalApplicationCapacity.
         When updating existing application with application capacity, the product of MaximumNodes and
         this value must always be smaller than or equal to TotalApplicationCapacity.
        :paramtype maximum_capacity: long
        :keyword reservation_capacity: The node reservation capacity for Service Fabric application.
         This is the amount of load which is reserved on nodes which have instances of this
         application.
         If MinimumNodes is specified, then the product of these values will be the capacity reserved
         in the cluster for the application.
         If set to zero, no capacity is reserved for this metric.
         When setting application capacity or when updating application capacity; this value must be
         smaller than or equal to MaximumCapacity for each metric.
        :paramtype reservation_capacity: long
        :keyword total_application_capacity: The total metric capacity for Service Fabric application.
         This is the total metric capacity for this application in the cluster. Service Fabric will try
         to limit the sum of loads of services within the application to this value.
         When creating a new application with application capacity defined, the product of MaximumNodes
         and MaximumCapacity must always be smaller than or equal to this value.
        :paramtype total_application_capacity: long
        """
        super(ApplicationMetricDescription, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.maximum_capacity = kwargs.get('maximum_capacity', None)
        self.reservation_capacity = kwargs.get('reservation_capacity', None)
        self.total_application_capacity = kwargs.get('total_application_capacity', None)


class ApplicationNameInfo(msrest.serialization.Model):
    """Information about the application name.

    :ivar id: The identity of the application. This is an encoded representation of the application
     name. This is used in the REST APIs to identify the application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype id: str
    :ivar name: The name of the application, including the 'fabric:' URI scheme.
    :vartype name: str
    """

    _attribute_map = {
        'id': {'key': 'Id', 'type': 'str'},
        'name': {'key': 'Name', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword id: The identity of the application. This is an encoded representation of the
         application name. This is used in the REST APIs to identify the application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype id: str
        :keyword name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype name: str
        """
        super(ApplicationNameInfo, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.name = kwargs.get('name', None)


class ApplicationNewHealthReportEvent(ApplicationEvent):
    """Application Health Report Created event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar application_instance_id: Required. Id of Application instance.
    :vartype application_instance_id: long
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'application_instance_id': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'application_instance_id': {'key': 'ApplicationInstanceId', 'type': 'long'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword application_instance_id: Required. Id of Application instance.
        :paramtype application_instance_id: long
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(ApplicationNewHealthReportEvent, self).__init__(**kwargs)
        self.kind = 'ApplicationNewHealthReport'  # type: str
        self.application_instance_id = kwargs['application_instance_id']
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class ApplicationParameter(msrest.serialization.Model):
    """Describes an application parameter override to be applied when creating or upgrading an application.

    All required parameters must be populated in order to send to Azure.

    :ivar key: Required. The name of the parameter.
    :vartype key: str
    :ivar value: Required. The value of the parameter.
    :vartype value: str
    """

    _validation = {
        'key': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'key': {'key': 'Key', 'type': 'str'},
        'value': {'key': 'Value', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword key: Required. The name of the parameter.
        :paramtype key: str
        :keyword value: Required. The value of the parameter.
        :paramtype value: str
        """
        super(ApplicationParameter, self).__init__(**kwargs)
        self.key = kwargs['key']
        self.value = kwargs['value']


class ApplicationProcessExitedEvent(ApplicationEvent):
    """Process Exited event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar service_name: Required. Name of Service.
    :vartype service_name: str
    :ivar service_package_name: Required. Name of Service package.
    :vartype service_package_name: str
    :ivar service_package_activation_id: Required. Activation Id of Service package.
    :vartype service_package_activation_id: str
    :ivar is_exclusive: Required. Indicates IsExclusive flag.
    :vartype is_exclusive: bool
    :ivar code_package_name: Required. Name of Code package.
    :vartype code_package_name: str
    :ivar entry_point_type: Required. Type of EntryPoint.
    :vartype entry_point_type: str
    :ivar exe_name: Required. Name of executable.
    :vartype exe_name: str
    :ivar process_id: Required. Process Id.
    :vartype process_id: long
    :ivar host_id: Required. Host Id.
    :vartype host_id: str
    :ivar exit_code: Required. Exit code of process.
    :vartype exit_code: long
    :ivar unexpected_termination: Required. Indicates if termination is unexpected.
    :vartype unexpected_termination: bool
    :ivar start_time: Required. Start time of process.
    :vartype start_time: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'service_name': {'required': True},
        'service_package_name': {'required': True},
        'service_package_activation_id': {'required': True},
        'is_exclusive': {'required': True},
        'code_package_name': {'required': True},
        'entry_point_type': {'required': True},
        'exe_name': {'required': True},
        'process_id': {'required': True},
        'host_id': {'required': True},
        'exit_code': {'required': True},
        'unexpected_termination': {'required': True},
        'start_time': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'service_package_name': {'key': 'ServicePackageName', 'type': 'str'},
        'service_package_activation_id': {'key': 'ServicePackageActivationId', 'type': 'str'},
        'is_exclusive': {'key': 'IsExclusive', 'type': 'bool'},
        'code_package_name': {'key': 'CodePackageName', 'type': 'str'},
        'entry_point_type': {'key': 'EntryPointType', 'type': 'str'},
        'exe_name': {'key': 'ExeName', 'type': 'str'},
        'process_id': {'key': 'ProcessId', 'type': 'long'},
        'host_id': {'key': 'HostId', 'type': 'str'},
        'exit_code': {'key': 'ExitCode', 'type': 'long'},
        'unexpected_termination': {'key': 'UnexpectedTermination', 'type': 'bool'},
        'start_time': {'key': 'StartTime', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword service_name: Required. Name of Service.
        :paramtype service_name: str
        :keyword service_package_name: Required. Name of Service package.
        :paramtype service_package_name: str
        :keyword service_package_activation_id: Required. Activation Id of Service package.
        :paramtype service_package_activation_id: str
        :keyword is_exclusive: Required. Indicates IsExclusive flag.
        :paramtype is_exclusive: bool
        :keyword code_package_name: Required. Name of Code package.
        :paramtype code_package_name: str
        :keyword entry_point_type: Required. Type of EntryPoint.
        :paramtype entry_point_type: str
        :keyword exe_name: Required. Name of executable.
        :paramtype exe_name: str
        :keyword process_id: Required. Process Id.
        :paramtype process_id: long
        :keyword host_id: Required. Host Id.
        :paramtype host_id: str
        :keyword exit_code: Required. Exit code of process.
        :paramtype exit_code: long
        :keyword unexpected_termination: Required. Indicates if termination is unexpected.
        :paramtype unexpected_termination: bool
        :keyword start_time: Required. Start time of process.
        :paramtype start_time: ~datetime.datetime
        """
        super(ApplicationProcessExitedEvent, self).__init__(**kwargs)
        self.kind = 'ApplicationProcessExited'  # type: str
        self.service_name = kwargs['service_name']
        self.service_package_name = kwargs['service_package_name']
        self.service_package_activation_id = kwargs['service_package_activation_id']
        self.is_exclusive = kwargs['is_exclusive']
        self.code_package_name = kwargs['code_package_name']
        self.entry_point_type = kwargs['entry_point_type']
        self.exe_name = kwargs['exe_name']
        self.process_id = kwargs['process_id']
        self.host_id = kwargs['host_id']
        self.exit_code = kwargs['exit_code']
        self.unexpected_termination = kwargs['unexpected_termination']
        self.start_time = kwargs['start_time']


class ApplicationResourceDescription(msrest.serialization.Model):
    """This type describes a application resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. Name of the Application resource.
    :vartype name: str
    :ivar identity: Describes the identity of the application.
    :vartype identity: ~azure.servicefabric.models.IdentityDescription
    :ivar description: User readable description of the application.
    :vartype description: str
    :ivar services: Describes the services in the application. This property is used to create or
     modify services of the application. On get only the name of the service is returned. The
     service description can be obtained by querying for the service resource.
    :vartype services: list[~azure.servicefabric.models.ServiceResourceDescription]
    :ivar diagnostics: Describes the diagnostics definition and usage for an application resource.
    :vartype diagnostics: ~azure.servicefabric.models.DiagnosticsDescription
    :ivar debug_params: Internal - used by Visual Studio to setup the debugging session on the
     local development environment.
    :vartype debug_params: str
    :ivar service_names: Names of the services in the application.
    :vartype service_names: list[str]
    :ivar status: Status of the application. Possible values include: "Unknown", "Ready",
     "Upgrading", "Creating", "Deleting", "Failed".
    :vartype status: str or ~azure.servicefabric.models.ResourceStatus
    :ivar status_details: Gives additional information about the current status of the application.
    :vartype status_details: str
    :ivar health_state: Describes the health state of an application resource. Possible values
     include: "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar unhealthy_evaluation: When the application's health state is not 'Ok', this additional
     details from service fabric Health Manager for the user to know why the application is marked
     unhealthy.
    :vartype unhealthy_evaluation: str
    """

    _validation = {
        'name': {'required': True},
        'service_names': {'readonly': True},
        'status': {'readonly': True},
        'status_details': {'readonly': True},
        'health_state': {'readonly': True},
        'unhealthy_evaluation': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'identity': {'key': 'identity', 'type': 'IdentityDescription'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'services': {'key': 'properties.services', 'type': '[ServiceResourceDescription]'},
        'diagnostics': {'key': 'properties.diagnostics', 'type': 'DiagnosticsDescription'},
        'debug_params': {'key': 'properties.debugParams', 'type': 'str'},
        'service_names': {'key': 'properties.serviceNames', 'type': '[str]'},
        'status': {'key': 'properties.status', 'type': 'str'},
        'status_details': {'key': 'properties.statusDetails', 'type': 'str'},
        'health_state': {'key': 'properties.healthState', 'type': 'str'},
        'unhealthy_evaluation': {'key': 'properties.unhealthyEvaluation', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. Name of the Application resource.
        :paramtype name: str
        :keyword identity: Describes the identity of the application.
        :paramtype identity: ~azure.servicefabric.models.IdentityDescription
        :keyword description: User readable description of the application.
        :paramtype description: str
        :keyword services: Describes the services in the application. This property is used to create
         or modify services of the application. On get only the name of the service is returned. The
         service description can be obtained by querying for the service resource.
        :paramtype services: list[~azure.servicefabric.models.ServiceResourceDescription]
        :keyword diagnostics: Describes the diagnostics definition and usage for an application
         resource.
        :paramtype diagnostics: ~azure.servicefabric.models.DiagnosticsDescription
        :keyword debug_params: Internal - used by Visual Studio to setup the debugging session on the
         local development environment.
        :paramtype debug_params: str
        """
        super(ApplicationResourceDescription, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.identity = kwargs.get('identity', None)
        self.description = kwargs.get('description', None)
        self.services = kwargs.get('services', None)
        self.diagnostics = kwargs.get('diagnostics', None)
        self.debug_params = kwargs.get('debug_params', None)
        self.service_names = None
        self.status = None
        self.status_details = None
        self.health_state = None
        self.unhealthy_evaluation = None


class ApplicationResourceUpgradeProgressInfo(msrest.serialization.Model):
    """This type describes an application resource upgrade.

    :ivar name: Name of the Application resource.
    :vartype name: str
    :ivar target_application_type_version: The target application version for the application
     upgrade.
    :vartype target_application_type_version: str
    :ivar start_timestamp_utc: The estimated UTC datetime when the upgrade started.
    :vartype start_timestamp_utc: str
    :ivar upgrade_state: The state of the application resource upgrade. Possible values include:
     "Invalid", "ProvisioningTarget", "RollingForward", "UnprovisioningCurrent",
     "CompletedRollforward", "RollingBack", "UnprovisioningTarget", "CompletedRollback", "Failed".
    :vartype upgrade_state: str or ~azure.servicefabric.models.ApplicationResourceUpgradeState
    :ivar percent_completed: The estimated percent of replicas are completed in the upgrade.
    :vartype percent_completed: str
    :ivar service_upgrade_progress: List of service upgrade progresses.
    :vartype service_upgrade_progress: list[~azure.servicefabric.models.ServiceUpgradeProgress]
    :ivar rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
     values are UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
     "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored". Default value: "Monitored".
    :vartype rolling_upgrade_mode: str or ~azure.servicefabric.models.RollingUpgradeMode
    :ivar upgrade_duration: The estimated amount of time that the overall upgrade elapsed. It is
     first interpreted as a string representing an ISO 8601 duration. If that fails, then it is
     interpreted as a number representing the total number of milliseconds.
    :vartype upgrade_duration: str
    :ivar application_upgrade_status_details: Additional detailed information about the status of
     the pending upgrade.
    :vartype application_upgrade_status_details: str
    :ivar upgrade_replica_set_check_timeout_in_seconds: The maximum amount of time to block
     processing of an upgrade domain and prevent loss of availability when there are unexpected
     issues. When this timeout expires, processing of the upgrade domain will proceed regardless of
     availability loss issues. The timeout is reset at the start of each upgrade domain. Valid
     values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
    :vartype upgrade_replica_set_check_timeout_in_seconds: long
    :ivar failure_timestamp_utc: The estimated UTC datetime when the upgrade failed and
     FailureAction was executed.
    :vartype failure_timestamp_utc: str
    """

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'target_application_type_version': {'key': 'TargetApplicationTypeVersion', 'type': 'str'},
        'start_timestamp_utc': {'key': 'StartTimestampUtc', 'type': 'str'},
        'upgrade_state': {'key': 'UpgradeState', 'type': 'str'},
        'percent_completed': {'key': 'PercentCompleted', 'type': 'str'},
        'service_upgrade_progress': {'key': 'ServiceUpgradeProgress', 'type': '[ServiceUpgradeProgress]'},
        'rolling_upgrade_mode': {'key': 'RollingUpgradeMode', 'type': 'str'},
        'upgrade_duration': {'key': 'UpgradeDuration', 'type': 'str'},
        'application_upgrade_status_details': {'key': 'ApplicationUpgradeStatusDetails', 'type': 'str'},
        'upgrade_replica_set_check_timeout_in_seconds': {'key': 'UpgradeReplicaSetCheckTimeoutInSeconds', 'type': 'long'},
        'failure_timestamp_utc': {'key': 'FailureTimestampUtc', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Name of the Application resource.
        :paramtype name: str
        :keyword target_application_type_version: The target application version for the application
         upgrade.
        :paramtype target_application_type_version: str
        :keyword start_timestamp_utc: The estimated UTC datetime when the upgrade started.
        :paramtype start_timestamp_utc: str
        :keyword upgrade_state: The state of the application resource upgrade. Possible values include:
         "Invalid", "ProvisioningTarget", "RollingForward", "UnprovisioningCurrent",
         "CompletedRollforward", "RollingBack", "UnprovisioningTarget", "CompletedRollback", "Failed".
        :paramtype upgrade_state: str or ~azure.servicefabric.models.ApplicationResourceUpgradeState
        :keyword percent_completed: The estimated percent of replicas are completed in the upgrade.
        :paramtype percent_completed: str
        :keyword service_upgrade_progress: List of service upgrade progresses.
        :paramtype service_upgrade_progress: list[~azure.servicefabric.models.ServiceUpgradeProgress]
        :keyword rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
         values are UnmonitoredAuto, UnmonitoredManual, and Monitored. Possible values include:
         "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored". Default value: "Monitored".
        :paramtype rolling_upgrade_mode: str or ~azure.servicefabric.models.RollingUpgradeMode
        :keyword upgrade_duration: The estimated amount of time that the overall upgrade elapsed. It is
         first interpreted as a string representing an ISO 8601 duration. If that fails, then it is
         interpreted as a number representing the total number of milliseconds.
        :paramtype upgrade_duration: str
        :keyword application_upgrade_status_details: Additional detailed information about the status
         of the pending upgrade.
        :paramtype application_upgrade_status_details: str
        :keyword upgrade_replica_set_check_timeout_in_seconds: The maximum amount of time to block
         processing of an upgrade domain and prevent loss of availability when there are unexpected
         issues. When this timeout expires, processing of the upgrade domain will proceed regardless of
         availability loss issues. The timeout is reset at the start of each upgrade domain. Valid
         values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
        :paramtype upgrade_replica_set_check_timeout_in_seconds: long
        :keyword failure_timestamp_utc: The estimated UTC datetime when the upgrade failed and
         FailureAction was executed.
        :paramtype failure_timestamp_utc: str
        """
        super(ApplicationResourceUpgradeProgressInfo, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.target_application_type_version = kwargs.get('target_application_type_version', None)
        self.start_timestamp_utc = kwargs.get('start_timestamp_utc', None)
        self.upgrade_state = kwargs.get('upgrade_state', None)
        self.percent_completed = kwargs.get('percent_completed', None)
        self.service_upgrade_progress = kwargs.get('service_upgrade_progress', None)
        self.rolling_upgrade_mode = kwargs.get('rolling_upgrade_mode', "Monitored")
        self.upgrade_duration = kwargs.get('upgrade_duration', "PT0H2M0S")
        self.application_upgrade_status_details = kwargs.get('application_upgrade_status_details', None)
        self.upgrade_replica_set_check_timeout_in_seconds = kwargs.get('upgrade_replica_set_check_timeout_in_seconds', 42949672925)
        self.failure_timestamp_utc = kwargs.get('failure_timestamp_utc', None)


class VolumeReference(msrest.serialization.Model):
    """Describes a reference to a volume resource.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. Name of the volume being referenced.
    :vartype name: str
    :ivar read_only: The flag indicating whether the volume is read only. Default is 'false'.
    :vartype read_only: bool
    :ivar destination_path: Required. The path within the container at which the volume should be
     mounted. Only valid path characters are allowed.
    :vartype destination_path: str
    """

    _validation = {
        'name': {'required': True},
        'destination_path': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'read_only': {'key': 'readOnly', 'type': 'bool'},
        'destination_path': {'key': 'destinationPath', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. Name of the volume being referenced.
        :paramtype name: str
        :keyword read_only: The flag indicating whether the volume is read only. Default is 'false'.
        :paramtype read_only: bool
        :keyword destination_path: Required. The path within the container at which the volume should
         be mounted. Only valid path characters are allowed.
        :paramtype destination_path: str
        """
        super(VolumeReference, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.read_only = kwargs.get('read_only', None)
        self.destination_path = kwargs['destination_path']


class ApplicationScopedVolume(VolumeReference):
    """Describes a volume whose lifetime is scoped to the application's lifetime.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. Name of the volume being referenced.
    :vartype name: str
    :ivar read_only: The flag indicating whether the volume is read only. Default is 'false'.
    :vartype read_only: bool
    :ivar destination_path: Required. The path within the container at which the volume should be
     mounted. Only valid path characters are allowed.
    :vartype destination_path: str
    :ivar creation_parameters: Required. Describes parameters for creating application-scoped
     volumes.
    :vartype creation_parameters:
     ~azure.servicefabric.models.ApplicationScopedVolumeCreationParameters
    """

    _validation = {
        'name': {'required': True},
        'destination_path': {'required': True},
        'creation_parameters': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'read_only': {'key': 'readOnly', 'type': 'bool'},
        'destination_path': {'key': 'destinationPath', 'type': 'str'},
        'creation_parameters': {'key': 'creationParameters', 'type': 'ApplicationScopedVolumeCreationParameters'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. Name of the volume being referenced.
        :paramtype name: str
        :keyword read_only: The flag indicating whether the volume is read only. Default is 'false'.
        :paramtype read_only: bool
        :keyword destination_path: Required. The path within the container at which the volume should
         be mounted. Only valid path characters are allowed.
        :paramtype destination_path: str
        :keyword creation_parameters: Required. Describes parameters for creating application-scoped
         volumes.
        :paramtype creation_parameters:
         ~azure.servicefabric.models.ApplicationScopedVolumeCreationParameters
        """
        super(ApplicationScopedVolume, self).__init__(**kwargs)
        self.creation_parameters = kwargs['creation_parameters']


class ApplicationScopedVolumeCreationParameters(msrest.serialization.Model):
    """Describes parameters for creating application-scoped volumes.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ApplicationScopedVolumeCreationParametersServiceFabricVolumeDisk.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. Specifies the application-scoped volume kind.Constant filled by server.
     Possible values include: "ServiceFabricVolumeDisk".
    :vartype kind: str or ~azure.servicefabric.models.ApplicationScopedVolumeKind
    :ivar description: User readable description of the volume.
    :vartype description: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'ServiceFabricVolumeDisk': 'ApplicationScopedVolumeCreationParametersServiceFabricVolumeDisk'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword description: User readable description of the volume.
        :paramtype description: str
        """
        super(ApplicationScopedVolumeCreationParameters, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]
        self.description = kwargs.get('description', None)


class ApplicationScopedVolumeCreationParametersServiceFabricVolumeDisk(ApplicationScopedVolumeCreationParameters):
    """Describes parameters for creating application-scoped volumes provided by Service Fabric Volume Disks.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. Specifies the application-scoped volume kind.Constant filled by server.
     Possible values include: "ServiceFabricVolumeDisk".
    :vartype kind: str or ~azure.servicefabric.models.ApplicationScopedVolumeKind
    :ivar description: User readable description of the volume.
    :vartype description: str
    :ivar size_disk: Required. Volume size. Possible values include: "Small", "Medium", "Large".
    :vartype size_disk: str or ~azure.servicefabric.models.SizeTypes
    """

    _validation = {
        'kind': {'required': True},
        'size_disk': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'size_disk': {'key': 'sizeDisk', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword description: User readable description of the volume.
        :paramtype description: str
        :keyword size_disk: Required. Volume size. Possible values include: "Small", "Medium", "Large".
        :paramtype size_disk: str or ~azure.servicefabric.models.SizeTypes
        """
        super(ApplicationScopedVolumeCreationParametersServiceFabricVolumeDisk, self).__init__(**kwargs)
        self.kind = 'ServiceFabricVolumeDisk'  # type: str
        self.size_disk = kwargs['size_disk']


class ApplicationsHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for applications, containing health evaluations for each unhealthy application that impacted current aggregated health state.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar max_percent_unhealthy_applications: Maximum allowed percentage of unhealthy applications
     from the ClusterHealthPolicy.
    :vartype max_percent_unhealthy_applications: int
    :ivar total_count: Total number of applications from the health store.
    :vartype total_count: long
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
     state. Includes all the unhealthy ApplicationHealthEvaluation that impacted the aggregated
     health.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'max_percent_unhealthy_applications': {'key': 'MaxPercentUnhealthyApplications', 'type': 'int'},
        'total_count': {'key': 'TotalCount', 'type': 'long'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword max_percent_unhealthy_applications: Maximum allowed percentage of unhealthy
         applications from the ClusterHealthPolicy.
        :paramtype max_percent_unhealthy_applications: int
        :keyword total_count: Total number of applications from the health store.
        :paramtype total_count: long
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
         state. Includes all the unhealthy ApplicationHealthEvaluation that impacted the aggregated
         health.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(ApplicationsHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'Applications'  # type: str
        self.max_percent_unhealthy_applications = kwargs.get('max_percent_unhealthy_applications', None)
        self.total_count = kwargs.get('total_count', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class ApplicationTypeApplicationsHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for applications of a particular application type. The application type applications evaluation can be returned when cluster health evaluation returns unhealthy aggregated health state, either Error or Warning. It contains health evaluations for each unhealthy application of the included application type that impacted current aggregated health state.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar application_type_name: The application type name as defined in the application manifest.
    :vartype application_type_name: str
    :ivar max_percent_unhealthy_applications: Maximum allowed percentage of unhealthy applications
     for the application type, specified as an entry in ApplicationTypeHealthPolicyMap.
    :vartype max_percent_unhealthy_applications: int
    :ivar total_count: Total number of applications of the application type found in the health
     store.
    :vartype total_count: long
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
     state. Includes all the unhealthy ApplicationHealthEvaluation of this application type that
     impacted the aggregated health.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'application_type_name': {'key': 'ApplicationTypeName', 'type': 'str'},
        'max_percent_unhealthy_applications': {'key': 'MaxPercentUnhealthyApplications', 'type': 'int'},
        'total_count': {'key': 'TotalCount', 'type': 'long'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword application_type_name: The application type name as defined in the application
         manifest.
        :paramtype application_type_name: str
        :keyword max_percent_unhealthy_applications: Maximum allowed percentage of unhealthy
         applications for the application type, specified as an entry in ApplicationTypeHealthPolicyMap.
        :paramtype max_percent_unhealthy_applications: int
        :keyword total_count: Total number of applications of the application type found in the health
         store.
        :paramtype total_count: long
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
         state. Includes all the unhealthy ApplicationHealthEvaluation of this application type that
         impacted the aggregated health.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(ApplicationTypeApplicationsHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'ApplicationTypeApplications'  # type: str
        self.application_type_name = kwargs.get('application_type_name', None)
        self.max_percent_unhealthy_applications = kwargs.get('max_percent_unhealthy_applications', None)
        self.total_count = kwargs.get('total_count', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class ApplicationTypeHealthPolicyMapItem(msrest.serialization.Model):
    """Defines an item in ApplicationTypeHealthPolicyMap.

    All required parameters must be populated in order to send to Azure.

    :ivar key: Required. The key of the application type health policy map item. This is the name
     of the application type.
    :vartype key: str
    :ivar value: Required. The value of the application type health policy map item.
     The max percent unhealthy applications allowed for the application type. Must be between zero
     and 100.
    :vartype value: int
    """

    _validation = {
        'key': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'key': {'key': 'Key', 'type': 'str'},
        'value': {'key': 'Value', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword key: Required. The key of the application type health policy map item. This is the
         name of the application type.
        :paramtype key: str
        :keyword value: Required. The value of the application type health policy map item.
         The max percent unhealthy applications allowed for the application type. Must be between zero
         and 100.
        :paramtype value: int
        """
        super(ApplicationTypeHealthPolicyMapItem, self).__init__(**kwargs)
        self.key = kwargs['key']
        self.value = kwargs['value']


class ApplicationTypeImageStorePath(msrest.serialization.Model):
    """Path description for the application package in the image store specified during the prior copy operation.

    All required parameters must be populated in order to send to Azure.

    :ivar application_type_build_path: Required. The relative image store path to the application
     package.
    :vartype application_type_build_path: str
    """

    _validation = {
        'application_type_build_path': {'required': True},
    }

    _attribute_map = {
        'application_type_build_path': {'key': 'ApplicationTypeBuildPath', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword application_type_build_path: Required. The relative image store path to the
         application package.
        :paramtype application_type_build_path: str
        """
        super(ApplicationTypeImageStorePath, self).__init__(**kwargs)
        self.application_type_build_path = kwargs['application_type_build_path']


class ApplicationTypeInfo(msrest.serialization.Model):
    """Information about an application type.

    :ivar name: The application type name as defined in the application manifest.
    :vartype name: str
    :ivar version: The version of the application type as defined in the application manifest.
    :vartype version: str
    :ivar default_parameter_list: List of application type parameters that can be overridden when
     creating or updating the application.
    :vartype default_parameter_list: list[~azure.servicefabric.models.ApplicationParameter]
    :ivar status: The status of the application type. Possible values include: "Invalid",
     "Provisioning", "Available", "Unprovisioning", "Failed".
    :vartype status: str or ~azure.servicefabric.models.ApplicationTypeStatus
    :ivar status_details: Additional detailed information about the status of the application type.
    :vartype status_details: str
    :ivar application_type_definition_kind: The mechanism used to define a Service Fabric
     application type. Possible values include: "Invalid", "ServiceFabricApplicationPackage",
     "Compose".
    :vartype application_type_definition_kind: str or
     ~azure.servicefabric.models.ApplicationTypeDefinitionKind
    :ivar application_type_metadata: Metadata associated with a specific application type.
    :vartype application_type_metadata: ~azure.servicefabric.models.ApplicationTypeMetadata
    """

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'version': {'key': 'Version', 'type': 'str'},
        'default_parameter_list': {'key': 'DefaultParameterList', 'type': '[ApplicationParameter]'},
        'status': {'key': 'Status', 'type': 'str'},
        'status_details': {'key': 'StatusDetails', 'type': 'str'},
        'application_type_definition_kind': {'key': 'ApplicationTypeDefinitionKind', 'type': 'str'},
        'application_type_metadata': {'key': 'ApplicationTypeMetadata', 'type': 'ApplicationTypeMetadata'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: The application type name as defined in the application manifest.
        :paramtype name: str
        :keyword version: The version of the application type as defined in the application manifest.
        :paramtype version: str
        :keyword default_parameter_list: List of application type parameters that can be overridden
         when creating or updating the application.
        :paramtype default_parameter_list: list[~azure.servicefabric.models.ApplicationParameter]
        :keyword status: The status of the application type. Possible values include: "Invalid",
         "Provisioning", "Available", "Unprovisioning", "Failed".
        :paramtype status: str or ~azure.servicefabric.models.ApplicationTypeStatus
        :keyword status_details: Additional detailed information about the status of the application
         type.
        :paramtype status_details: str
        :keyword application_type_definition_kind: The mechanism used to define a Service Fabric
         application type. Possible values include: "Invalid", "ServiceFabricApplicationPackage",
         "Compose".
        :paramtype application_type_definition_kind: str or
         ~azure.servicefabric.models.ApplicationTypeDefinitionKind
        :keyword application_type_metadata: Metadata associated with a specific application type.
        :paramtype application_type_metadata: ~azure.servicefabric.models.ApplicationTypeMetadata
        """
        super(ApplicationTypeInfo, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.version = kwargs.get('version', None)
        self.default_parameter_list = kwargs.get('default_parameter_list', None)
        self.status = kwargs.get('status', None)
        self.status_details = kwargs.get('status_details', None)
        self.application_type_definition_kind = kwargs.get('application_type_definition_kind', None)
        self.application_type_metadata = kwargs.get('application_type_metadata', None)


class ApplicationTypeManifest(msrest.serialization.Model):
    """Contains the manifest describing an application type registered in a Service Fabric cluster.

    :ivar manifest: The XML manifest as a string.
    :vartype manifest: str
    """

    _attribute_map = {
        'manifest': {'key': 'Manifest', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword manifest: The XML manifest as a string.
        :paramtype manifest: str
        """
        super(ApplicationTypeManifest, self).__init__(**kwargs)
        self.manifest = kwargs.get('manifest', None)


class ApplicationTypeMetadata(msrest.serialization.Model):
    """Metadata associated with a specific application type.

    :ivar application_type_provision_timestamp: The timestamp when the application type was
     provisioned.
    :vartype application_type_provision_timestamp: str
    :ivar arm_metadata: Common ArmMetadata assocaited with Service Fabric Entities.
    :vartype arm_metadata: ~azure.servicefabric.models.ArmMetadata
    """

    _attribute_map = {
        'application_type_provision_timestamp': {'key': 'ApplicationTypeProvisionTimestamp', 'type': 'str'},
        'arm_metadata': {'key': 'ArmMetadata', 'type': 'ArmMetadata'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword application_type_provision_timestamp: The timestamp when the application type was
         provisioned.
        :paramtype application_type_provision_timestamp: str
        :keyword arm_metadata: Common ArmMetadata assocaited with Service Fabric Entities.
        :paramtype arm_metadata: ~azure.servicefabric.models.ArmMetadata
        """
        super(ApplicationTypeMetadata, self).__init__(**kwargs)
        self.application_type_provision_timestamp = kwargs.get('application_type_provision_timestamp', None)
        self.arm_metadata = kwargs.get('arm_metadata', None)


class ApplicationUpdateDescription(msrest.serialization.Model):
    """Describes the parameters for updating an application instance.

    :ivar flags: Flags indicating whether other properties are set. Each of the associated
     properties corresponds to a flag, specified below, which, if set, indicate that the property is
     specified.
     If flags are not specified for a certain property, the property will not be updated even if
     the new value is provided.
     This property can be a combination of those flags obtained using bitwise 'OR' operator.
     Exception is RemoveApplicationCapacity which cannot be specified along with other parameters.
     For example, if the provided value is 3 then the flags for MinimumNodes (1) and MaximumNodes
     (2) are set.
    
    
     * None - Does not indicate any other properties are set. The value is 0.
     * MinimumNodes - Indicates whether the MinimumNodes property is set. The value is 1.
     * MaximumNodes - Indicates whether the MinimumNodes property is set. The value is  2.
     * ApplicationMetrics - Indicates whether the ApplicationMetrics property is set. The value is
     4.
    :vartype flags: str
    :ivar remove_application_capacity: Used to clear all parameters related to Application Capacity
     for this application. |
     It is not possible to specify this parameter together with other Application Capacity
     parameters.
    :vartype remove_application_capacity: bool
    :ivar minimum_nodes: The minimum number of nodes where Service Fabric will reserve capacity for
     this application. Note that this does not mean that the services of this application will be
     placed on all of those nodes. If this property is set to zero, no capacity will be reserved.
     The value of this property cannot be more than the value of the MaximumNodes property.
    :vartype minimum_nodes: long
    :ivar maximum_nodes: The maximum number of nodes where Service Fabric will reserve capacity for
     this application. Note that this does not mean that the services of this application will be
     placed on all of those nodes. By default, the value of this property is zero and it means that
     the services can be placed on any node.
    :vartype maximum_nodes: long
    :ivar application_metrics: List of application capacity metric description.
    :vartype application_metrics: list[~azure.servicefabric.models.ApplicationMetricDescription]
    """

    _validation = {
        'minimum_nodes': {'minimum': 0},
        'maximum_nodes': {'minimum': 0},
    }

    _attribute_map = {
        'flags': {'key': 'Flags', 'type': 'str'},
        'remove_application_capacity': {'key': 'RemoveApplicationCapacity', 'type': 'bool'},
        'minimum_nodes': {'key': 'MinimumNodes', 'type': 'long'},
        'maximum_nodes': {'key': 'MaximumNodes', 'type': 'long'},
        'application_metrics': {'key': 'ApplicationMetrics', 'type': '[ApplicationMetricDescription]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword flags: Flags indicating whether other properties are set. Each of the associated
         properties corresponds to a flag, specified below, which, if set, indicate that the property is
         specified.
         If flags are not specified for a certain property, the property will not be updated even if
         the new value is provided.
         This property can be a combination of those flags obtained using bitwise 'OR' operator.
         Exception is RemoveApplicationCapacity which cannot be specified along with other parameters.
         For example, if the provided value is 3 then the flags for MinimumNodes (1) and MaximumNodes
         (2) are set.
        
        
         * None - Does not indicate any other properties are set. The value is 0.
         * MinimumNodes - Indicates whether the MinimumNodes property is set. The value is 1.
         * MaximumNodes - Indicates whether the MinimumNodes property is set. The value is  2.
         * ApplicationMetrics - Indicates whether the ApplicationMetrics property is set. The value is
         4.
        :paramtype flags: str
        :keyword remove_application_capacity: Used to clear all parameters related to Application
         Capacity for this application. |
         It is not possible to specify this parameter together with other Application Capacity
         parameters.
        :paramtype remove_application_capacity: bool
        :keyword minimum_nodes: The minimum number of nodes where Service Fabric will reserve capacity
         for this application. Note that this does not mean that the services of this application will
         be placed on all of those nodes. If this property is set to zero, no capacity will be reserved.
         The value of this property cannot be more than the value of the MaximumNodes property.
        :paramtype minimum_nodes: long
        :keyword maximum_nodes: The maximum number of nodes where Service Fabric will reserve capacity
         for this application. Note that this does not mean that the services of this application will
         be placed on all of those nodes. By default, the value of this property is zero and it means
         that the services can be placed on any node.
        :paramtype maximum_nodes: long
        :keyword application_metrics: List of application capacity metric description.
        :paramtype application_metrics: list[~azure.servicefabric.models.ApplicationMetricDescription]
        """
        super(ApplicationUpdateDescription, self).__init__(**kwargs)
        self.flags = kwargs.get('flags', None)
        self.remove_application_capacity = kwargs.get('remove_application_capacity', False)
        self.minimum_nodes = kwargs.get('minimum_nodes', None)
        self.maximum_nodes = kwargs.get('maximum_nodes', 0)
        self.application_metrics = kwargs.get('application_metrics', None)


class ApplicationUpgradeCompletedEvent(ApplicationEvent):
    """Application Upgrade Completed event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar application_type_name: Required. Application type name.
    :vartype application_type_name: str
    :ivar application_type_version: Required. Application type version.
    :vartype application_type_version: str
    :ivar overall_upgrade_elapsed_time_in_ms: Required. Overall upgrade time in milli-seconds.
    :vartype overall_upgrade_elapsed_time_in_ms: float
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'application_type_name': {'required': True},
        'application_type_version': {'required': True},
        'overall_upgrade_elapsed_time_in_ms': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'application_type_name': {'key': 'ApplicationTypeName', 'type': 'str'},
        'application_type_version': {'key': 'ApplicationTypeVersion', 'type': 'str'},
        'overall_upgrade_elapsed_time_in_ms': {'key': 'OverallUpgradeElapsedTimeInMs', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword application_type_name: Required. Application type name.
        :paramtype application_type_name: str
        :keyword application_type_version: Required. Application type version.
        :paramtype application_type_version: str
        :keyword overall_upgrade_elapsed_time_in_ms: Required. Overall upgrade time in milli-seconds.
        :paramtype overall_upgrade_elapsed_time_in_ms: float
        """
        super(ApplicationUpgradeCompletedEvent, self).__init__(**kwargs)
        self.kind = 'ApplicationUpgradeCompleted'  # type: str
        self.application_type_name = kwargs['application_type_name']
        self.application_type_version = kwargs['application_type_version']
        self.overall_upgrade_elapsed_time_in_ms = kwargs['overall_upgrade_elapsed_time_in_ms']


class ApplicationUpgradeDescription(msrest.serialization.Model):
    """Describes the parameters for an application upgrade. Note that upgrade description replaces the existing application description. This means that if the parameters are not specified, the existing parameters on the applications will be overwritten with the empty parameters list. This would result in the application using the default value of the parameters from the application manifest. If you do not want to change any existing parameter values, please get the application parameters first using the GetApplicationInfo query and then supply those values as Parameters in this ApplicationUpgradeDescription.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name of the target application, including the 'fabric:' URI scheme.
    :vartype name: str
    :ivar target_application_type_version: Required. The target application type version (found in
     the application manifest) for the application upgrade.
    :vartype target_application_type_version: str
    :ivar parameters: List of application parameters with overridden values from their default
     values specified in the application manifest.
    :vartype parameters: list[~azure.servicefabric.models.ApplicationParameter]
    :ivar upgrade_kind: Required. The kind of upgrade out of the following possible values.
     Possible values include: "Invalid", "Rolling". Default value: "Rolling".
    :vartype upgrade_kind: str or ~azure.servicefabric.models.UpgradeKind
    :ivar rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
     values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred. Possible
     values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
     "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
    :vartype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
    :ivar upgrade_replica_set_check_timeout_in_seconds: The maximum amount of time to block
     processing of an upgrade domain and prevent loss of availability when there are unexpected
     issues. When this timeout expires, processing of the upgrade domain will proceed regardless of
     availability loss issues. The timeout is reset at the start of each upgrade domain. Valid
     values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
    :vartype upgrade_replica_set_check_timeout_in_seconds: long
    :ivar force_restart: If true, then processes are forcefully restarted during upgrade even when
     the code version has not changed (the upgrade only changes configuration or data).
    :vartype force_restart: bool
    :ivar sort_order: Defines the order in which an upgrade proceeds through the cluster. Possible
     values include: "Invalid", "Default", "Numeric", "Lexicographical", "ReverseNumeric",
     "ReverseLexicographical". Default value: "Default".
    :vartype sort_order: str or ~azure.servicefabric.models.UpgradeSortOrder
    :ivar monitoring_policy: Describes the parameters for monitoring an upgrade in Monitored mode.
    :vartype monitoring_policy: ~azure.servicefabric.models.MonitoringPolicyDescription
    :ivar application_health_policy: Defines a health policy used to evaluate the health of an
     application or one of its children entities.
    :vartype application_health_policy: ~azure.servicefabric.models.ApplicationHealthPolicy
    :ivar instance_close_delay_duration_in_seconds: Duration in seconds, to wait before a stateless
     instance is closed, to allow the active requests to drain gracefully. This would be effective
     when the instance is closing during the application/cluster
     upgrade, only for those instances which have a non-zero delay duration configured in the
     service description. See InstanceCloseDelayDurationSeconds property in $ref:
     "#/definitions/StatelessServiceDescription.yaml" for details.
     Note, the default value of InstanceCloseDelayDurationInSeconds is 4294967295, which indicates
     that the behavior will entirely depend on the delay configured in the stateless service
     description.
    :vartype instance_close_delay_duration_in_seconds: long
    :ivar managed_application_identity: Managed application identity description.
    :vartype managed_application_identity:
     ~azure.servicefabric.models.ManagedApplicationIdentityDescription
    """

    _validation = {
        'name': {'required': True},
        'target_application_type_version': {'required': True},
        'upgrade_kind': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'target_application_type_version': {'key': 'TargetApplicationTypeVersion', 'type': 'str'},
        'parameters': {'key': 'Parameters', 'type': '[ApplicationParameter]'},
        'upgrade_kind': {'key': 'UpgradeKind', 'type': 'str'},
        'rolling_upgrade_mode': {'key': 'RollingUpgradeMode', 'type': 'str'},
        'upgrade_replica_set_check_timeout_in_seconds': {'key': 'UpgradeReplicaSetCheckTimeoutInSeconds', 'type': 'long'},
        'force_restart': {'key': 'ForceRestart', 'type': 'bool'},
        'sort_order': {'key': 'SortOrder', 'type': 'str'},
        'monitoring_policy': {'key': 'MonitoringPolicy', 'type': 'MonitoringPolicyDescription'},
        'application_health_policy': {'key': 'ApplicationHealthPolicy', 'type': 'ApplicationHealthPolicy'},
        'instance_close_delay_duration_in_seconds': {'key': 'InstanceCloseDelayDurationInSeconds', 'type': 'long'},
        'managed_application_identity': {'key': 'ManagedApplicationIdentity', 'type': 'ManagedApplicationIdentityDescription'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. The name of the target application, including the 'fabric:' URI
         scheme.
        :paramtype name: str
        :keyword target_application_type_version: Required. The target application type version (found
         in the application manifest) for the application upgrade.
        :paramtype target_application_type_version: str
        :keyword parameters: List of application parameters with overridden values from their default
         values specified in the application manifest.
        :paramtype parameters: list[~azure.servicefabric.models.ApplicationParameter]
        :keyword upgrade_kind: Required. The kind of upgrade out of the following possible values.
         Possible values include: "Invalid", "Rolling". Default value: "Rolling".
        :paramtype upgrade_kind: str or ~azure.servicefabric.models.UpgradeKind
        :keyword rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
         values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred. Possible
         values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
         "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
        :paramtype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
        :keyword upgrade_replica_set_check_timeout_in_seconds: The maximum amount of time to block
         processing of an upgrade domain and prevent loss of availability when there are unexpected
         issues. When this timeout expires, processing of the upgrade domain will proceed regardless of
         availability loss issues. The timeout is reset at the start of each upgrade domain. Valid
         values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
        :paramtype upgrade_replica_set_check_timeout_in_seconds: long
        :keyword force_restart: If true, then processes are forcefully restarted during upgrade even
         when the code version has not changed (the upgrade only changes configuration or data).
        :paramtype force_restart: bool
        :keyword sort_order: Defines the order in which an upgrade proceeds through the cluster.
         Possible values include: "Invalid", "Default", "Numeric", "Lexicographical", "ReverseNumeric",
         "ReverseLexicographical". Default value: "Default".
        :paramtype sort_order: str or ~azure.servicefabric.models.UpgradeSortOrder
        :keyword monitoring_policy: Describes the parameters for monitoring an upgrade in Monitored
         mode.
        :paramtype monitoring_policy: ~azure.servicefabric.models.MonitoringPolicyDescription
        :keyword application_health_policy: Defines a health policy used to evaluate the health of an
         application or one of its children entities.
        :paramtype application_health_policy: ~azure.servicefabric.models.ApplicationHealthPolicy
        :keyword instance_close_delay_duration_in_seconds: Duration in seconds, to wait before a
         stateless instance is closed, to allow the active requests to drain gracefully. This would be
         effective when the instance is closing during the application/cluster
         upgrade, only for those instances which have a non-zero delay duration configured in the
         service description. See InstanceCloseDelayDurationSeconds property in $ref:
         "#/definitions/StatelessServiceDescription.yaml" for details.
         Note, the default value of InstanceCloseDelayDurationInSeconds is 4294967295, which indicates
         that the behavior will entirely depend on the delay configured in the stateless service
         description.
        :paramtype instance_close_delay_duration_in_seconds: long
        :keyword managed_application_identity: Managed application identity description.
        :paramtype managed_application_identity:
         ~azure.servicefabric.models.ManagedApplicationIdentityDescription
        """
        super(ApplicationUpgradeDescription, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.target_application_type_version = kwargs['target_application_type_version']
        self.parameters = kwargs.get('parameters', None)
        self.upgrade_kind = kwargs.get('upgrade_kind', "Rolling")
        self.rolling_upgrade_mode = kwargs.get('rolling_upgrade_mode', "UnmonitoredAuto")
        self.upgrade_replica_set_check_timeout_in_seconds = kwargs.get('upgrade_replica_set_check_timeout_in_seconds', 42949672925)
        self.force_restart = kwargs.get('force_restart', False)
        self.sort_order = kwargs.get('sort_order', "Default")
        self.monitoring_policy = kwargs.get('monitoring_policy', None)
        self.application_health_policy = kwargs.get('application_health_policy', None)
        self.instance_close_delay_duration_in_seconds = kwargs.get('instance_close_delay_duration_in_seconds', 4294967295)
        self.managed_application_identity = kwargs.get('managed_application_identity', None)


class ApplicationUpgradeDomainCompletedEvent(ApplicationEvent):
    """Application Upgrade Domain Completed event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar application_type_name: Required. Application type name.
    :vartype application_type_name: str
    :ivar current_application_type_version: Required. Current Application type version.
    :vartype current_application_type_version: str
    :ivar application_type_version: Required. Target Application type version.
    :vartype application_type_version: str
    :ivar upgrade_state: Required. State of upgrade.
    :vartype upgrade_state: str
    :ivar upgrade_domains: Required. Upgrade domains.
    :vartype upgrade_domains: str
    :ivar upgrade_domain_elapsed_time_in_ms: Required. Upgrade time of domain in milli-seconds.
    :vartype upgrade_domain_elapsed_time_in_ms: float
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'application_type_name': {'required': True},
        'current_application_type_version': {'required': True},
        'application_type_version': {'required': True},
        'upgrade_state': {'required': True},
        'upgrade_domains': {'required': True},
        'upgrade_domain_elapsed_time_in_ms': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'application_type_name': {'key': 'ApplicationTypeName', 'type': 'str'},
        'current_application_type_version': {'key': 'CurrentApplicationTypeVersion', 'type': 'str'},
        'application_type_version': {'key': 'ApplicationTypeVersion', 'type': 'str'},
        'upgrade_state': {'key': 'UpgradeState', 'type': 'str'},
        'upgrade_domains': {'key': 'UpgradeDomains', 'type': 'str'},
        'upgrade_domain_elapsed_time_in_ms': {'key': 'UpgradeDomainElapsedTimeInMs', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword application_type_name: Required. Application type name.
        :paramtype application_type_name: str
        :keyword current_application_type_version: Required. Current Application type version.
        :paramtype current_application_type_version: str
        :keyword application_type_version: Required. Target Application type version.
        :paramtype application_type_version: str
        :keyword upgrade_state: Required. State of upgrade.
        :paramtype upgrade_state: str
        :keyword upgrade_domains: Required. Upgrade domains.
        :paramtype upgrade_domains: str
        :keyword upgrade_domain_elapsed_time_in_ms: Required. Upgrade time of domain in milli-seconds.
        :paramtype upgrade_domain_elapsed_time_in_ms: float
        """
        super(ApplicationUpgradeDomainCompletedEvent, self).__init__(**kwargs)
        self.kind = 'ApplicationUpgradeDomainCompleted'  # type: str
        self.application_type_name = kwargs['application_type_name']
        self.current_application_type_version = kwargs['current_application_type_version']
        self.application_type_version = kwargs['application_type_version']
        self.upgrade_state = kwargs['upgrade_state']
        self.upgrade_domains = kwargs['upgrade_domains']
        self.upgrade_domain_elapsed_time_in_ms = kwargs['upgrade_domain_elapsed_time_in_ms']


class ApplicationUpgradeProgressInfo(msrest.serialization.Model):
    """Describes the parameters for an application upgrade.

    :ivar name: The name of the target application, including the 'fabric:' URI scheme.
    :vartype name: str
    :ivar type_name: The application type name as defined in the application manifest.
    :vartype type_name: str
    :ivar target_application_type_version: The target application type version (found in the
     application manifest) for the application upgrade.
    :vartype target_application_type_version: str
    :ivar upgrade_domains: List of upgrade domains and their statuses. Not applicable to
     node-by-node upgrades.
    :vartype upgrade_domains: list[~azure.servicefabric.models.UpgradeDomainInfo]
    :ivar upgrade_units: List of upgrade units and their statuses.
    :vartype upgrade_units: list[~azure.servicefabric.models.UpgradeUnitInfo]
    :ivar upgrade_state: The state of the upgrade domain. Possible values include: "Invalid",
     "RollingBackInProgress", "RollingBackCompleted", "RollingForwardPending",
     "RollingForwardInProgress", "RollingForwardCompleted", "Failed".
    :vartype upgrade_state: str or ~azure.servicefabric.models.UpgradeState
    :ivar next_upgrade_domain: The name of the next upgrade domain to be processed. Not applicable
     to node-by-node upgrades.
    :vartype next_upgrade_domain: str
    :ivar rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
     values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred. Possible
     values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
     "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
    :vartype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
    :ivar upgrade_description: Describes the parameters for an application upgrade. Note that
     upgrade description replaces the existing application description. This means that if the
     parameters are not specified, the existing parameters on the applications will be overwritten
     with the empty parameters list. This would result in the application using the default value of
     the parameters from the application manifest. If you do not want to change any existing
     parameter values, please get the application parameters first using the GetApplicationInfo
     query and then supply those values as Parameters in this ApplicationUpgradeDescription.
    :vartype upgrade_description: ~azure.servicefabric.models.ApplicationUpgradeDescription
    :ivar upgrade_duration_in_milliseconds: The estimated total amount of time spent processing the
     overall upgrade.
    :vartype upgrade_duration_in_milliseconds: str
    :ivar upgrade_domain_duration_in_milliseconds: The estimated total amount of time spent
     processing the current upgrade domain.
    :vartype upgrade_domain_duration_in_milliseconds: str
    :ivar unhealthy_evaluations: List of health evaluations that resulted in the current aggregated
     health state.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    :ivar current_upgrade_domain_progress: Information about the current in-progress upgrade
     domain. Not applicable to node-by-node upgrades.
    :vartype current_upgrade_domain_progress:
     ~azure.servicefabric.models.CurrentUpgradeDomainProgressInfo
    :ivar current_upgrade_units_progress: Information about the current in-progress upgrade units.
    :vartype current_upgrade_units_progress:
     ~azure.servicefabric.models.CurrentUpgradeUnitsProgressInfo
    :ivar start_timestamp_utc: The estimated UTC datetime when the upgrade started.
    :vartype start_timestamp_utc: str
    :ivar failure_timestamp_utc: The estimated UTC datetime when the upgrade failed and
     FailureAction was executed.
    :vartype failure_timestamp_utc: str
    :ivar failure_reason: The cause of an upgrade failure that resulted in FailureAction being
     executed. Possible values include: "None", "Interrupted", "HealthCheck",
     "UpgradeDomainTimeout", "OverallUpgradeTimeout".
    :vartype failure_reason: str or ~azure.servicefabric.models.FailureReason
    :ivar upgrade_domain_progress_at_failure: Information about the upgrade domain progress at the
     time of upgrade failure.
    :vartype upgrade_domain_progress_at_failure:
     ~azure.servicefabric.models.FailureUpgradeDomainProgressInfo
    :ivar upgrade_status_details: Additional detailed information about the status of the pending
     upgrade.
    :vartype upgrade_status_details: str
    :ivar is_node_by_node: Indicates whether this upgrade is node-by-node.
    :vartype is_node_by_node: bool
    """

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'type_name': {'key': 'TypeName', 'type': 'str'},
        'target_application_type_version': {'key': 'TargetApplicationTypeVersion', 'type': 'str'},
        'upgrade_domains': {'key': 'UpgradeDomains', 'type': '[UpgradeDomainInfo]'},
        'upgrade_units': {'key': 'UpgradeUnits', 'type': '[UpgradeUnitInfo]'},
        'upgrade_state': {'key': 'UpgradeState', 'type': 'str'},
        'next_upgrade_domain': {'key': 'NextUpgradeDomain', 'type': 'str'},
        'rolling_upgrade_mode': {'key': 'RollingUpgradeMode', 'type': 'str'},
        'upgrade_description': {'key': 'UpgradeDescription', 'type': 'ApplicationUpgradeDescription'},
        'upgrade_duration_in_milliseconds': {'key': 'UpgradeDurationInMilliseconds', 'type': 'str'},
        'upgrade_domain_duration_in_milliseconds': {'key': 'UpgradeDomainDurationInMilliseconds', 'type': 'str'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
        'current_upgrade_domain_progress': {'key': 'CurrentUpgradeDomainProgress', 'type': 'CurrentUpgradeDomainProgressInfo'},
        'current_upgrade_units_progress': {'key': 'CurrentUpgradeUnitsProgress', 'type': 'CurrentUpgradeUnitsProgressInfo'},
        'start_timestamp_utc': {'key': 'StartTimestampUtc', 'type': 'str'},
        'failure_timestamp_utc': {'key': 'FailureTimestampUtc', 'type': 'str'},
        'failure_reason': {'key': 'FailureReason', 'type': 'str'},
        'upgrade_domain_progress_at_failure': {'key': 'UpgradeDomainProgressAtFailure', 'type': 'FailureUpgradeDomainProgressInfo'},
        'upgrade_status_details': {'key': 'UpgradeStatusDetails', 'type': 'str'},
        'is_node_by_node': {'key': 'IsNodeByNode', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: The name of the target application, including the 'fabric:' URI scheme.
        :paramtype name: str
        :keyword type_name: The application type name as defined in the application manifest.
        :paramtype type_name: str
        :keyword target_application_type_version: The target application type version (found in the
         application manifest) for the application upgrade.
        :paramtype target_application_type_version: str
        :keyword upgrade_domains: List of upgrade domains and their statuses. Not applicable to
         node-by-node upgrades.
        :paramtype upgrade_domains: list[~azure.servicefabric.models.UpgradeDomainInfo]
        :keyword upgrade_units: List of upgrade units and their statuses.
        :paramtype upgrade_units: list[~azure.servicefabric.models.UpgradeUnitInfo]
        :keyword upgrade_state: The state of the upgrade domain. Possible values include: "Invalid",
         "RollingBackInProgress", "RollingBackCompleted", "RollingForwardPending",
         "RollingForwardInProgress", "RollingForwardCompleted", "Failed".
        :paramtype upgrade_state: str or ~azure.servicefabric.models.UpgradeState
        :keyword next_upgrade_domain: The name of the next upgrade domain to be processed. Not
         applicable to node-by-node upgrades.
        :paramtype next_upgrade_domain: str
        :keyword rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
         values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred. Possible
         values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
         "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
        :paramtype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
        :keyword upgrade_description: Describes the parameters for an application upgrade. Note that
         upgrade description replaces the existing application description. This means that if the
         parameters are not specified, the existing parameters on the applications will be overwritten
         with the empty parameters list. This would result in the application using the default value of
         the parameters from the application manifest. If you do not want to change any existing
         parameter values, please get the application parameters first using the GetApplicationInfo
         query and then supply those values as Parameters in this ApplicationUpgradeDescription.
        :paramtype upgrade_description: ~azure.servicefabric.models.ApplicationUpgradeDescription
        :keyword upgrade_duration_in_milliseconds: The estimated total amount of time spent processing
         the overall upgrade.
        :paramtype upgrade_duration_in_milliseconds: str
        :keyword upgrade_domain_duration_in_milliseconds: The estimated total amount of time spent
         processing the current upgrade domain.
        :paramtype upgrade_domain_duration_in_milliseconds: str
        :keyword unhealthy_evaluations: List of health evaluations that resulted in the current
         aggregated health state.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        :keyword current_upgrade_domain_progress: Information about the current in-progress upgrade
         domain. Not applicable to node-by-node upgrades.
        :paramtype current_upgrade_domain_progress:
         ~azure.servicefabric.models.CurrentUpgradeDomainProgressInfo
        :keyword current_upgrade_units_progress: Information about the current in-progress upgrade
         units.
        :paramtype current_upgrade_units_progress:
         ~azure.servicefabric.models.CurrentUpgradeUnitsProgressInfo
        :keyword start_timestamp_utc: The estimated UTC datetime when the upgrade started.
        :paramtype start_timestamp_utc: str
        :keyword failure_timestamp_utc: The estimated UTC datetime when the upgrade failed and
         FailureAction was executed.
        :paramtype failure_timestamp_utc: str
        :keyword failure_reason: The cause of an upgrade failure that resulted in FailureAction being
         executed. Possible values include: "None", "Interrupted", "HealthCheck",
         "UpgradeDomainTimeout", "OverallUpgradeTimeout".
        :paramtype failure_reason: str or ~azure.servicefabric.models.FailureReason
        :keyword upgrade_domain_progress_at_failure: Information about the upgrade domain progress at
         the time of upgrade failure.
        :paramtype upgrade_domain_progress_at_failure:
         ~azure.servicefabric.models.FailureUpgradeDomainProgressInfo
        :keyword upgrade_status_details: Additional detailed information about the status of the
         pending upgrade.
        :paramtype upgrade_status_details: str
        :keyword is_node_by_node: Indicates whether this upgrade is node-by-node.
        :paramtype is_node_by_node: bool
        """
        super(ApplicationUpgradeProgressInfo, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.type_name = kwargs.get('type_name', None)
        self.target_application_type_version = kwargs.get('target_application_type_version', None)
        self.upgrade_domains = kwargs.get('upgrade_domains', None)
        self.upgrade_units = kwargs.get('upgrade_units', None)
        self.upgrade_state = kwargs.get('upgrade_state', None)
        self.next_upgrade_domain = kwargs.get('next_upgrade_domain', None)
        self.rolling_upgrade_mode = kwargs.get('rolling_upgrade_mode', "UnmonitoredAuto")
        self.upgrade_description = kwargs.get('upgrade_description', None)
        self.upgrade_duration_in_milliseconds = kwargs.get('upgrade_duration_in_milliseconds', None)
        self.upgrade_domain_duration_in_milliseconds = kwargs.get('upgrade_domain_duration_in_milliseconds', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)
        self.current_upgrade_domain_progress = kwargs.get('current_upgrade_domain_progress', None)
        self.current_upgrade_units_progress = kwargs.get('current_upgrade_units_progress', None)
        self.start_timestamp_utc = kwargs.get('start_timestamp_utc', None)
        self.failure_timestamp_utc = kwargs.get('failure_timestamp_utc', None)
        self.failure_reason = kwargs.get('failure_reason', None)
        self.upgrade_domain_progress_at_failure = kwargs.get('upgrade_domain_progress_at_failure', None)
        self.upgrade_status_details = kwargs.get('upgrade_status_details', None)
        self.is_node_by_node = kwargs.get('is_node_by_node', False)


class ApplicationUpgradeRollbackCompletedEvent(ApplicationEvent):
    """Application Upgrade Rollback Completed event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar application_type_name: Required. Application type name.
    :vartype application_type_name: str
    :ivar application_type_version: Required. Application type version.
    :vartype application_type_version: str
    :ivar failure_reason: Required. Describes reason of failure.
    :vartype failure_reason: str
    :ivar overall_upgrade_elapsed_time_in_ms: Required. Overall upgrade time in milli-seconds.
    :vartype overall_upgrade_elapsed_time_in_ms: float
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'application_type_name': {'required': True},
        'application_type_version': {'required': True},
        'failure_reason': {'required': True},
        'overall_upgrade_elapsed_time_in_ms': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'application_type_name': {'key': 'ApplicationTypeName', 'type': 'str'},
        'application_type_version': {'key': 'ApplicationTypeVersion', 'type': 'str'},
        'failure_reason': {'key': 'FailureReason', 'type': 'str'},
        'overall_upgrade_elapsed_time_in_ms': {'key': 'OverallUpgradeElapsedTimeInMs', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword application_type_name: Required. Application type name.
        :paramtype application_type_name: str
        :keyword application_type_version: Required. Application type version.
        :paramtype application_type_version: str
        :keyword failure_reason: Required. Describes reason of failure.
        :paramtype failure_reason: str
        :keyword overall_upgrade_elapsed_time_in_ms: Required. Overall upgrade time in milli-seconds.
        :paramtype overall_upgrade_elapsed_time_in_ms: float
        """
        super(ApplicationUpgradeRollbackCompletedEvent, self).__init__(**kwargs)
        self.kind = 'ApplicationUpgradeRollbackCompleted'  # type: str
        self.application_type_name = kwargs['application_type_name']
        self.application_type_version = kwargs['application_type_version']
        self.failure_reason = kwargs['failure_reason']
        self.overall_upgrade_elapsed_time_in_ms = kwargs['overall_upgrade_elapsed_time_in_ms']


class ApplicationUpgradeRollbackStartedEvent(ApplicationEvent):
    """Application Upgrade Rollback Started event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar application_type_name: Required. Application type name.
    :vartype application_type_name: str
    :ivar current_application_type_version: Required. Current Application type version.
    :vartype current_application_type_version: str
    :ivar application_type_version: Required. Target Application type version.
    :vartype application_type_version: str
    :ivar failure_reason: Required. Describes reason of failure.
    :vartype failure_reason: str
    :ivar overall_upgrade_elapsed_time_in_ms: Required. Overall upgrade time in milli-seconds.
    :vartype overall_upgrade_elapsed_time_in_ms: float
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'application_type_name': {'required': True},
        'current_application_type_version': {'required': True},
        'application_type_version': {'required': True},
        'failure_reason': {'required': True},
        'overall_upgrade_elapsed_time_in_ms': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'application_type_name': {'key': 'ApplicationTypeName', 'type': 'str'},
        'current_application_type_version': {'key': 'CurrentApplicationTypeVersion', 'type': 'str'},
        'application_type_version': {'key': 'ApplicationTypeVersion', 'type': 'str'},
        'failure_reason': {'key': 'FailureReason', 'type': 'str'},
        'overall_upgrade_elapsed_time_in_ms': {'key': 'OverallUpgradeElapsedTimeInMs', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword application_type_name: Required. Application type name.
        :paramtype application_type_name: str
        :keyword current_application_type_version: Required. Current Application type version.
        :paramtype current_application_type_version: str
        :keyword application_type_version: Required. Target Application type version.
        :paramtype application_type_version: str
        :keyword failure_reason: Required. Describes reason of failure.
        :paramtype failure_reason: str
        :keyword overall_upgrade_elapsed_time_in_ms: Required. Overall upgrade time in milli-seconds.
        :paramtype overall_upgrade_elapsed_time_in_ms: float
        """
        super(ApplicationUpgradeRollbackStartedEvent, self).__init__(**kwargs)
        self.kind = 'ApplicationUpgradeRollbackStarted'  # type: str
        self.application_type_name = kwargs['application_type_name']
        self.current_application_type_version = kwargs['current_application_type_version']
        self.application_type_version = kwargs['application_type_version']
        self.failure_reason = kwargs['failure_reason']
        self.overall_upgrade_elapsed_time_in_ms = kwargs['overall_upgrade_elapsed_time_in_ms']


class ApplicationUpgradeStartedEvent(ApplicationEvent):
    """Application Upgrade Started event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar application_type_name: Required. Application type name.
    :vartype application_type_name: str
    :ivar current_application_type_version: Required. Current Application type version.
    :vartype current_application_type_version: str
    :ivar application_type_version: Required. Target Application type version.
    :vartype application_type_version: str
    :ivar upgrade_type: Required. Type of upgrade.
    :vartype upgrade_type: str
    :ivar rolling_upgrade_mode: Required. Mode of upgrade.
    :vartype rolling_upgrade_mode: str
    :ivar failure_action: Required. Action if failed.
    :vartype failure_action: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'application_type_name': {'required': True},
        'current_application_type_version': {'required': True},
        'application_type_version': {'required': True},
        'upgrade_type': {'required': True},
        'rolling_upgrade_mode': {'required': True},
        'failure_action': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'application_type_name': {'key': 'ApplicationTypeName', 'type': 'str'},
        'current_application_type_version': {'key': 'CurrentApplicationTypeVersion', 'type': 'str'},
        'application_type_version': {'key': 'ApplicationTypeVersion', 'type': 'str'},
        'upgrade_type': {'key': 'UpgradeType', 'type': 'str'},
        'rolling_upgrade_mode': {'key': 'RollingUpgradeMode', 'type': 'str'},
        'failure_action': {'key': 'FailureAction', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword application_type_name: Required. Application type name.
        :paramtype application_type_name: str
        :keyword current_application_type_version: Required. Current Application type version.
        :paramtype current_application_type_version: str
        :keyword application_type_version: Required. Target Application type version.
        :paramtype application_type_version: str
        :keyword upgrade_type: Required. Type of upgrade.
        :paramtype upgrade_type: str
        :keyword rolling_upgrade_mode: Required. Mode of upgrade.
        :paramtype rolling_upgrade_mode: str
        :keyword failure_action: Required. Action if failed.
        :paramtype failure_action: str
        """
        super(ApplicationUpgradeStartedEvent, self).__init__(**kwargs)
        self.kind = 'ApplicationUpgradeStarted'  # type: str
        self.application_type_name = kwargs['application_type_name']
        self.current_application_type_version = kwargs['current_application_type_version']
        self.application_type_version = kwargs['application_type_version']
        self.upgrade_type = kwargs['upgrade_type']
        self.rolling_upgrade_mode = kwargs['rolling_upgrade_mode']
        self.failure_action = kwargs['failure_action']


class ApplicationUpgradeUpdateDescription(msrest.serialization.Model):
    """Describes the parameters for updating an ongoing application upgrade.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name of the application, including the 'fabric:' URI scheme.
    :vartype name: str
    :ivar upgrade_kind: Required. The kind of upgrade out of the following possible values.
     Possible values include: "Invalid", "Rolling". Default value: "Rolling".
    :vartype upgrade_kind: str or ~azure.servicefabric.models.UpgradeKind
    :ivar application_health_policy: Defines a health policy used to evaluate the health of an
     application or one of its children entities.
    :vartype application_health_policy: ~azure.servicefabric.models.ApplicationHealthPolicy
    :ivar update_description: Describes the parameters for updating a rolling upgrade of
     application or cluster.
    :vartype update_description: ~azure.servicefabric.models.RollingUpgradeUpdateDescription
    """

    _validation = {
        'name': {'required': True},
        'upgrade_kind': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'upgrade_kind': {'key': 'UpgradeKind', 'type': 'str'},
        'application_health_policy': {'key': 'ApplicationHealthPolicy', 'type': 'ApplicationHealthPolicy'},
        'update_description': {'key': 'UpdateDescription', 'type': 'RollingUpgradeUpdateDescription'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. The name of the application, including the 'fabric:' URI scheme.
        :paramtype name: str
        :keyword upgrade_kind: Required. The kind of upgrade out of the following possible values.
         Possible values include: "Invalid", "Rolling". Default value: "Rolling".
        :paramtype upgrade_kind: str or ~azure.servicefabric.models.UpgradeKind
        :keyword application_health_policy: Defines a health policy used to evaluate the health of an
         application or one of its children entities.
        :paramtype application_health_policy: ~azure.servicefabric.models.ApplicationHealthPolicy
        :keyword update_description: Describes the parameters for updating a rolling upgrade of
         application or cluster.
        :paramtype update_description: ~azure.servicefabric.models.RollingUpgradeUpdateDescription
        """
        super(ApplicationUpgradeUpdateDescription, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.upgrade_kind = kwargs.get('upgrade_kind', "Rolling")
        self.application_health_policy = kwargs.get('application_health_policy', None)
        self.update_description = kwargs.get('update_description', None)


class ArmMetadata(msrest.serialization.Model):
    """Common ArmMetadata assocaited with Service Fabric Entities.

    :ivar arm_resource_id: A string containing the ArmResourceId.
    :vartype arm_resource_id: str
    """

    _attribute_map = {
        'arm_resource_id': {'key': 'ArmResourceId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword arm_resource_id: A string containing the ArmResourceId.
        :paramtype arm_resource_id: str
        """
        super(ArmMetadata, self).__init__(**kwargs)
        self.arm_resource_id = kwargs.get('arm_resource_id', None)


class AutoScalingMetric(msrest.serialization.Model):
    """Describes the metric that is used for triggering auto scaling operation. Derived classes will describe resources or metrics.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AutoScalingResourceMetric.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The type of auto scaling metric.Constant filled by server. Possible
     values include: "Resource".
    :vartype kind: str or ~azure.servicefabric.models.AutoScalingMetricKind
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'Resource': 'AutoScalingResourceMetric'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(AutoScalingMetric, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]


class AutoScalingPolicy(msrest.serialization.Model):
    """Describes the auto scaling policy.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name of the auto scaling policy.
    :vartype name: str
    :ivar trigger: Required. Determines when auto scaling operation will be invoked.
    :vartype trigger: ~azure.servicefabric.models.AutoScalingTrigger
    :ivar mechanism: Required. The mechanism that is used to scale when auto scaling operation is
     invoked.
    :vartype mechanism: ~azure.servicefabric.models.AutoScalingMechanism
    """

    _validation = {
        'name': {'required': True},
        'trigger': {'required': True},
        'mechanism': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'trigger': {'key': 'trigger', 'type': 'AutoScalingTrigger'},
        'mechanism': {'key': 'mechanism', 'type': 'AutoScalingMechanism'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. The name of the auto scaling policy.
        :paramtype name: str
        :keyword trigger: Required. Determines when auto scaling operation will be invoked.
        :paramtype trigger: ~azure.servicefabric.models.AutoScalingTrigger
        :keyword mechanism: Required. The mechanism that is used to scale when auto scaling operation
         is invoked.
        :paramtype mechanism: ~azure.servicefabric.models.AutoScalingMechanism
        """
        super(AutoScalingPolicy, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.trigger = kwargs['trigger']
        self.mechanism = kwargs['mechanism']


class AutoScalingResourceMetric(AutoScalingMetric):
    """Describes the resource that is used for triggering auto scaling.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The type of auto scaling metric.Constant filled by server. Possible
     values include: "Resource".
    :vartype kind: str or ~azure.servicefabric.models.AutoScalingMetricKind
    :ivar name: Required. Name of the resource. Possible values include: "cpu", "memoryInGB".
    :vartype name: str or ~azure.servicefabric.models.AutoScalingResourceMetricName
    """

    _validation = {
        'kind': {'required': True},
        'name': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. Name of the resource. Possible values include: "cpu", "memoryInGB".
        :paramtype name: str or ~azure.servicefabric.models.AutoScalingResourceMetricName
        """
        super(AutoScalingResourceMetric, self).__init__(**kwargs)
        self.kind = 'Resource'  # type: str
        self.name = kwargs['name']


class AutoScalingTrigger(msrest.serialization.Model):
    """Describes the trigger for performing auto scaling operation.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AverageLoadScalingTrigger.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The type of auto scaling trigger.Constant filled by server. Possible
     values include: "AverageLoad".
    :vartype kind: str or ~azure.servicefabric.models.AutoScalingTriggerKind
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'AverageLoad': 'AverageLoadScalingTrigger'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(AutoScalingTrigger, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]


class AverageLoadScalingTrigger(AutoScalingTrigger):
    """Describes the average load trigger used for auto scaling.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The type of auto scaling trigger.Constant filled by server. Possible
     values include: "AverageLoad".
    :vartype kind: str or ~azure.servicefabric.models.AutoScalingTriggerKind
    :ivar metric: Required. Description of the metric that is used for scaling.
    :vartype metric: ~azure.servicefabric.models.AutoScalingMetric
    :ivar lower_load_threshold: Required. Lower load threshold (if average load is below this
     threshold, service will scale down).
    :vartype lower_load_threshold: float
    :ivar upper_load_threshold: Required. Upper load threshold (if average load is above this
     threshold, service will scale up).
    :vartype upper_load_threshold: float
    :ivar scale_interval_in_seconds: Required. Scale interval that indicates how often will this
     trigger be checked.
    :vartype scale_interval_in_seconds: int
    """

    _validation = {
        'kind': {'required': True},
        'metric': {'required': True},
        'lower_load_threshold': {'required': True},
        'upper_load_threshold': {'required': True},
        'scale_interval_in_seconds': {'required': True, 'minimum': 60},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'metric': {'key': 'metric', 'type': 'AutoScalingMetric'},
        'lower_load_threshold': {'key': 'lowerLoadThreshold', 'type': 'float'},
        'upper_load_threshold': {'key': 'upperLoadThreshold', 'type': 'float'},
        'scale_interval_in_seconds': {'key': 'scaleIntervalInSeconds', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword metric: Required. Description of the metric that is used for scaling.
        :paramtype metric: ~azure.servicefabric.models.AutoScalingMetric
        :keyword lower_load_threshold: Required. Lower load threshold (if average load is below this
         threshold, service will scale down).
        :paramtype lower_load_threshold: float
        :keyword upper_load_threshold: Required. Upper load threshold (if average load is above this
         threshold, service will scale up).
        :paramtype upper_load_threshold: float
        :keyword scale_interval_in_seconds: Required. Scale interval that indicates how often will this
         trigger be checked.
        :paramtype scale_interval_in_seconds: int
        """
        super(AverageLoadScalingTrigger, self).__init__(**kwargs)
        self.kind = 'AverageLoad'  # type: str
        self.metric = kwargs['metric']
        self.lower_load_threshold = kwargs['lower_load_threshold']
        self.upper_load_threshold = kwargs['upper_load_threshold']
        self.scale_interval_in_seconds = kwargs['scale_interval_in_seconds']


class ScalingTriggerDescription(msrest.serialization.Model):
    """Describes the trigger for performing a scaling operation.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AveragePartitionLoadScalingTrigger, AverageServiceLoadScalingTrigger.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. Specifies the kind of scaling trigger.Constant filled by server. Possible
     values include: "Invalid", "AveragePartitionLoad", "AverageServiceLoad".
    :vartype kind: str or ~azure.servicefabric.models.ScalingTriggerKind
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'AveragePartitionLoad': 'AveragePartitionLoadScalingTrigger', 'AverageServiceLoad': 'AverageServiceLoadScalingTrigger'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(ScalingTriggerDescription, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]


class AveragePartitionLoadScalingTrigger(ScalingTriggerDescription):
    """Represents a scaling trigger related to an average load of a metric/resource of a partition.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. Specifies the kind of scaling trigger.Constant filled by server. Possible
     values include: "Invalid", "AveragePartitionLoad", "AverageServiceLoad".
    :vartype kind: str or ~azure.servicefabric.models.ScalingTriggerKind
    :ivar metric_name: Required. The name of the metric for which usage should be tracked.
    :vartype metric_name: str
    :ivar lower_load_threshold: Required. The lower limit of the load below which a scale in
     operation should be performed.
    :vartype lower_load_threshold: str
    :ivar upper_load_threshold: Required. The upper limit of the load beyond which a scale out
     operation should be performed.
    :vartype upper_load_threshold: str
    :ivar scale_interval_in_seconds: Required. The period in seconds on which a decision is made
     whether to scale or not.
    :vartype scale_interval_in_seconds: long
    """

    _validation = {
        'kind': {'required': True},
        'metric_name': {'required': True},
        'lower_load_threshold': {'required': True},
        'upper_load_threshold': {'required': True},
        'scale_interval_in_seconds': {'required': True, 'maximum': 4294967295, 'minimum': 0},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'metric_name': {'key': 'MetricName', 'type': 'str'},
        'lower_load_threshold': {'key': 'LowerLoadThreshold', 'type': 'str'},
        'upper_load_threshold': {'key': 'UpperLoadThreshold', 'type': 'str'},
        'scale_interval_in_seconds': {'key': 'ScaleIntervalInSeconds', 'type': 'long'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword metric_name: Required. The name of the metric for which usage should be tracked.
        :paramtype metric_name: str
        :keyword lower_load_threshold: Required. The lower limit of the load below which a scale in
         operation should be performed.
        :paramtype lower_load_threshold: str
        :keyword upper_load_threshold: Required. The upper limit of the load beyond which a scale out
         operation should be performed.
        :paramtype upper_load_threshold: str
        :keyword scale_interval_in_seconds: Required. The period in seconds on which a decision is made
         whether to scale or not.
        :paramtype scale_interval_in_seconds: long
        """
        super(AveragePartitionLoadScalingTrigger, self).__init__(**kwargs)
        self.kind = 'AveragePartitionLoad'  # type: str
        self.metric_name = kwargs['metric_name']
        self.lower_load_threshold = kwargs['lower_load_threshold']
        self.upper_load_threshold = kwargs['upper_load_threshold']
        self.scale_interval_in_seconds = kwargs['scale_interval_in_seconds']


class AverageServiceLoadScalingTrigger(ScalingTriggerDescription):
    """Represents a scaling policy related to an average load of a metric/resource of a service.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. Specifies the kind of scaling trigger.Constant filled by server. Possible
     values include: "Invalid", "AveragePartitionLoad", "AverageServiceLoad".
    :vartype kind: str or ~azure.servicefabric.models.ScalingTriggerKind
    :ivar metric_name: Required. The name of the metric for which usage should be tracked.
    :vartype metric_name: str
    :ivar lower_load_threshold: Required. The lower limit of the load below which a scale in
     operation should be performed.
    :vartype lower_load_threshold: str
    :ivar upper_load_threshold: Required. The upper limit of the load beyond which a scale out
     operation should be performed.
    :vartype upper_load_threshold: str
    :ivar scale_interval_in_seconds: Required. The period in seconds on which a decision is made
     whether to scale or not.
    :vartype scale_interval_in_seconds: long
    :ivar use_only_primary_load: Required. Flag determines whether only the load of primary replica
     should be considered for scaling.
     If set to true, then trigger will only consider the load of primary replicas of stateful
     service.
     If set to false, trigger will consider load of all replicas.
     This parameter cannot be set to true for stateless service.
    :vartype use_only_primary_load: bool
    """

    _validation = {
        'kind': {'required': True},
        'metric_name': {'required': True},
        'lower_load_threshold': {'required': True},
        'upper_load_threshold': {'required': True},
        'scale_interval_in_seconds': {'required': True, 'maximum': 4294967295, 'minimum': 0},
        'use_only_primary_load': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'metric_name': {'key': 'MetricName', 'type': 'str'},
        'lower_load_threshold': {'key': 'LowerLoadThreshold', 'type': 'str'},
        'upper_load_threshold': {'key': 'UpperLoadThreshold', 'type': 'str'},
        'scale_interval_in_seconds': {'key': 'ScaleIntervalInSeconds', 'type': 'long'},
        'use_only_primary_load': {'key': 'UseOnlyPrimaryLoad', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword metric_name: Required. The name of the metric for which usage should be tracked.
        :paramtype metric_name: str
        :keyword lower_load_threshold: Required. The lower limit of the load below which a scale in
         operation should be performed.
        :paramtype lower_load_threshold: str
        :keyword upper_load_threshold: Required. The upper limit of the load beyond which a scale out
         operation should be performed.
        :paramtype upper_load_threshold: str
        :keyword scale_interval_in_seconds: Required. The period in seconds on which a decision is made
         whether to scale or not.
        :paramtype scale_interval_in_seconds: long
        :keyword use_only_primary_load: Required. Flag determines whether only the load of primary
         replica should be considered for scaling.
         If set to true, then trigger will only consider the load of primary replicas of stateful
         service.
         If set to false, trigger will consider load of all replicas.
         This parameter cannot be set to true for stateless service.
        :paramtype use_only_primary_load: bool
        """
        super(AverageServiceLoadScalingTrigger, self).__init__(**kwargs)
        self.kind = 'AverageServiceLoad'  # type: str
        self.metric_name = kwargs['metric_name']
        self.lower_load_threshold = kwargs['lower_load_threshold']
        self.upper_load_threshold = kwargs['upper_load_threshold']
        self.scale_interval_in_seconds = kwargs['scale_interval_in_seconds']
        self.use_only_primary_load = kwargs['use_only_primary_load']


class BackupStorageDescription(msrest.serialization.Model):
    """Describes the parameters for the backup storage.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AzureBlobBackupStorageDescription, DsmsAzureBlobBackupStorageDescription, FileShareBackupStorageDescription, ManagedIdentityAzureBlobBackupStorageDescription.

    All required parameters must be populated in order to send to Azure.

    :ivar storage_kind: Required. The kind of backup storage, where backups are saved.Constant
     filled by server. Possible values include: "Invalid", "FileShare", "AzureBlobStore",
     "DsmsAzureBlobStore", "ManagedIdentityAzureBlobStore".
    :vartype storage_kind: str or ~azure.servicefabric.models.BackupStorageKind
    :ivar friendly_name: Friendly name for this backup storage.
    :vartype friendly_name: str
    """

    _validation = {
        'storage_kind': {'required': True},
    }

    _attribute_map = {
        'storage_kind': {'key': 'StorageKind', 'type': 'str'},
        'friendly_name': {'key': 'FriendlyName', 'type': 'str'},
    }

    _subtype_map = {
        'storage_kind': {'AzureBlobStore': 'AzureBlobBackupStorageDescription', 'DsmsAzureBlobStore': 'DsmsAzureBlobBackupStorageDescription', 'FileShare': 'FileShareBackupStorageDescription', 'ManagedIdentityAzureBlobStore': 'ManagedIdentityAzureBlobBackupStorageDescription'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword friendly_name: Friendly name for this backup storage.
        :paramtype friendly_name: str
        """
        super(BackupStorageDescription, self).__init__(**kwargs)
        self.storage_kind = None  # type: Optional[str]
        self.friendly_name = kwargs.get('friendly_name', None)


class AzureBlobBackupStorageDescription(BackupStorageDescription):
    """Describes the parameters for Azure blob store used for storing and enumerating backups.

    All required parameters must be populated in order to send to Azure.

    :ivar storage_kind: Required. The kind of backup storage, where backups are saved.Constant
     filled by server. Possible values include: "Invalid", "FileShare", "AzureBlobStore",
     "DsmsAzureBlobStore", "ManagedIdentityAzureBlobStore".
    :vartype storage_kind: str or ~azure.servicefabric.models.BackupStorageKind
    :ivar friendly_name: Friendly name for this backup storage.
    :vartype friendly_name: str
    :ivar connection_string: Required. The connection string to connect to the Azure blob store.
    :vartype connection_string: str
    :ivar container_name: Required. The name of the container in the blob store to store and
     enumerate backups from.
    :vartype container_name: str
    """

    _validation = {
        'storage_kind': {'required': True},
        'connection_string': {'required': True},
        'container_name': {'required': True},
    }

    _attribute_map = {
        'storage_kind': {'key': 'StorageKind', 'type': 'str'},
        'friendly_name': {'key': 'FriendlyName', 'type': 'str'},
        'connection_string': {'key': 'ConnectionString', 'type': 'str'},
        'container_name': {'key': 'ContainerName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword friendly_name: Friendly name for this backup storage.
        :paramtype friendly_name: str
        :keyword connection_string: Required. The connection string to connect to the Azure blob store.
        :paramtype connection_string: str
        :keyword container_name: Required. The name of the container in the blob store to store and
         enumerate backups from.
        :paramtype container_name: str
        """
        super(AzureBlobBackupStorageDescription, self).__init__(**kwargs)
        self.storage_kind = 'AzureBlobStore'  # type: str
        self.connection_string = kwargs['connection_string']
        self.container_name = kwargs['container_name']


class DiagnosticsSinkProperties(msrest.serialization.Model):
    """Properties of a DiagnosticsSink.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: AzureInternalMonitoringPipelineSinkDescription.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of DiagnosticsSink.Constant filled by server. Possible values
     include: "Invalid", "AzureInternalMonitoringPipeline".
    :vartype kind: str or ~azure.servicefabric.models.DiagnosticsSinkKind
    :ivar name: Name of the sink. This value is referenced by DiagnosticsReferenceDescription.
    :vartype name: str
    :ivar description: A description of the sink.
    :vartype description: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'AzureInternalMonitoringPipeline': 'AzureInternalMonitoringPipelineSinkDescription'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Name of the sink. This value is referenced by DiagnosticsReferenceDescription.
        :paramtype name: str
        :keyword description: A description of the sink.
        :paramtype description: str
        """
        super(DiagnosticsSinkProperties, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]
        self.name = kwargs.get('name', None)
        self.description = kwargs.get('description', None)


class AzureInternalMonitoringPipelineSinkDescription(DiagnosticsSinkProperties):
    """Diagnostics settings for Geneva.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of DiagnosticsSink.Constant filled by server. Possible values
     include: "Invalid", "AzureInternalMonitoringPipeline".
    :vartype kind: str or ~azure.servicefabric.models.DiagnosticsSinkKind
    :ivar name: Name of the sink. This value is referenced by DiagnosticsReferenceDescription.
    :vartype name: str
    :ivar description: A description of the sink.
    :vartype description: str
    :ivar account_name: Azure Internal monitoring pipeline account.
    :vartype account_name: str
    :ivar namespace: Azure Internal monitoring pipeline account namespace.
    :vartype namespace: str
    :ivar ma_config_url: Azure Internal monitoring agent configuration.
    :vartype ma_config_url: str
    :ivar fluentd_config_url: Azure Internal monitoring agent fluentd configuration.
    :vartype fluentd_config_url: str
    :ivar auto_key_config_url: Azure Internal monitoring pipeline autokey associated with the
     certificate.
    :vartype auto_key_config_url: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'account_name': {'key': 'accountName', 'type': 'str'},
        'namespace': {'key': 'namespace', 'type': 'str'},
        'ma_config_url': {'key': 'maConfigUrl', 'type': 'str'},
        'fluentd_config_url': {'key': 'fluentdConfigUrl', 'type': 'str'},
        'auto_key_config_url': {'key': 'autoKeyConfigUrl', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Name of the sink. This value is referenced by DiagnosticsReferenceDescription.
        :paramtype name: str
        :keyword description: A description of the sink.
        :paramtype description: str
        :keyword account_name: Azure Internal monitoring pipeline account.
        :paramtype account_name: str
        :keyword namespace: Azure Internal monitoring pipeline account namespace.
        :paramtype namespace: str
        :keyword ma_config_url: Azure Internal monitoring agent configuration.
        :paramtype ma_config_url: str
        :keyword fluentd_config_url: Azure Internal monitoring agent fluentd configuration.
        :paramtype fluentd_config_url: str
        :keyword auto_key_config_url: Azure Internal monitoring pipeline autokey associated with the
         certificate.
        :paramtype auto_key_config_url: str
        """
        super(AzureInternalMonitoringPipelineSinkDescription, self).__init__(**kwargs)
        self.kind = 'AzureInternalMonitoringPipeline'  # type: str
        self.account_name = kwargs.get('account_name', None)
        self.namespace = kwargs.get('namespace', None)
        self.ma_config_url = kwargs.get('ma_config_url', None)
        self.fluentd_config_url = kwargs.get('fluentd_config_url', None)
        self.auto_key_config_url = kwargs.get('auto_key_config_url', None)


class BackupInfo(msrest.serialization.Model):
    """Represents a backup point which can be used to trigger a restore.

    :ivar backup_id: Unique backup ID .
    :vartype backup_id: str
    :ivar backup_chain_id: Unique backup chain ID. All backups part of the same chain has the same
     backup chain id. A backup chain is comprised of 1 full backup and multiple incremental backups.
    :vartype backup_chain_id: str
    :ivar application_name: Name of the Service Fabric application this partition backup belongs
     to.
    :vartype application_name: str
    :ivar service_name: Name of the Service Fabric service this partition backup belongs to.
    :vartype service_name: str
    :ivar partition_information: Information about the partition to which this backup belongs to.
    :vartype partition_information: ~azure.servicefabric.models.PartitionInformation
    :ivar backup_location: Location of the backup, relative to the backup store.
    :vartype backup_location: str
    :ivar backup_type: Describes the type of backup, whether its full or incremental. Possible
     values include: "Invalid", "Full", "Incremental".
    :vartype backup_type: str or ~azure.servicefabric.models.BackupType
    :ivar epoch_of_last_backup_record: Epoch of the last record in this backup.
    :vartype epoch_of_last_backup_record: ~azure.servicefabric.models.Epoch
    :ivar lsn_of_last_backup_record: LSN of the last record in this backup.
    :vartype lsn_of_last_backup_record: str
    :ivar creation_time_utc: The date time when this backup was taken.
    :vartype creation_time_utc: ~datetime.datetime
    :ivar service_manifest_version: Manifest Version of the service this partition backup belongs
     to.
    :vartype service_manifest_version: str
    :ivar failure_error: Denotes the failure encountered in getting backup point information.
    :vartype failure_error: ~azure.servicefabric.models.FabricErrorError
    """

    _attribute_map = {
        'backup_id': {'key': 'BackupId', 'type': 'str'},
        'backup_chain_id': {'key': 'BackupChainId', 'type': 'str'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'partition_information': {'key': 'PartitionInformation', 'type': 'PartitionInformation'},
        'backup_location': {'key': 'BackupLocation', 'type': 'str'},
        'backup_type': {'key': 'BackupType', 'type': 'str'},
        'epoch_of_last_backup_record': {'key': 'EpochOfLastBackupRecord', 'type': 'Epoch'},
        'lsn_of_last_backup_record': {'key': 'LsnOfLastBackupRecord', 'type': 'str'},
        'creation_time_utc': {'key': 'CreationTimeUtc', 'type': 'iso-8601'},
        'service_manifest_version': {'key': 'ServiceManifestVersion', 'type': 'str'},
        'failure_error': {'key': 'FailureError', 'type': 'FabricErrorError'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword backup_id: Unique backup ID .
        :paramtype backup_id: str
        :keyword backup_chain_id: Unique backup chain ID. All backups part of the same chain has the
         same backup chain id. A backup chain is comprised of 1 full backup and multiple incremental
         backups.
        :paramtype backup_chain_id: str
        :keyword application_name: Name of the Service Fabric application this partition backup belongs
         to.
        :paramtype application_name: str
        :keyword service_name: Name of the Service Fabric service this partition backup belongs to.
        :paramtype service_name: str
        :keyword partition_information: Information about the partition to which this backup belongs
         to.
        :paramtype partition_information: ~azure.servicefabric.models.PartitionInformation
        :keyword backup_location: Location of the backup, relative to the backup store.
        :paramtype backup_location: str
        :keyword backup_type: Describes the type of backup, whether its full or incremental. Possible
         values include: "Invalid", "Full", "Incremental".
        :paramtype backup_type: str or ~azure.servicefabric.models.BackupType
        :keyword epoch_of_last_backup_record: Epoch of the last record in this backup.
        :paramtype epoch_of_last_backup_record: ~azure.servicefabric.models.Epoch
        :keyword lsn_of_last_backup_record: LSN of the last record in this backup.
        :paramtype lsn_of_last_backup_record: str
        :keyword creation_time_utc: The date time when this backup was taken.
        :paramtype creation_time_utc: ~datetime.datetime
        :keyword service_manifest_version: Manifest Version of the service this partition backup
         belongs to.
        :paramtype service_manifest_version: str
        :keyword failure_error: Denotes the failure encountered in getting backup point information.
        :paramtype failure_error: ~azure.servicefabric.models.FabricErrorError
        """
        super(BackupInfo, self).__init__(**kwargs)
        self.backup_id = kwargs.get('backup_id', None)
        self.backup_chain_id = kwargs.get('backup_chain_id', None)
        self.application_name = kwargs.get('application_name', None)
        self.service_name = kwargs.get('service_name', None)
        self.partition_information = kwargs.get('partition_information', None)
        self.backup_location = kwargs.get('backup_location', None)
        self.backup_type = kwargs.get('backup_type', None)
        self.epoch_of_last_backup_record = kwargs.get('epoch_of_last_backup_record', None)
        self.lsn_of_last_backup_record = kwargs.get('lsn_of_last_backup_record', None)
        self.creation_time_utc = kwargs.get('creation_time_utc', None)
        self.service_manifest_version = kwargs.get('service_manifest_version', None)
        self.failure_error = kwargs.get('failure_error', None)


class BackupPartitionDescription(msrest.serialization.Model):
    """Describes the parameters for triggering partition's backup.

    :ivar backup_storage: Specifies the details of the backup storage where to save the backup.
    :vartype backup_storage: ~azure.servicefabric.models.BackupStorageDescription
    """

    _attribute_map = {
        'backup_storage': {'key': 'BackupStorage', 'type': 'BackupStorageDescription'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword backup_storage: Specifies the details of the backup storage where to save the backup.
        :paramtype backup_storage: ~azure.servicefabric.models.BackupStorageDescription
        """
        super(BackupPartitionDescription, self).__init__(**kwargs)
        self.backup_storage = kwargs.get('backup_storage', None)


class BackupPolicyDescription(msrest.serialization.Model):
    """Describes a backup policy for configuring periodic backup.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The unique name identifying this backup policy.
    :vartype name: str
    :ivar auto_restore_on_data_loss: Required. Specifies whether to trigger restore automatically
     using the latest available backup in case the partition experiences a data loss event.
    :vartype auto_restore_on_data_loss: bool
    :ivar max_incremental_backups: Required. Defines the maximum number of incremental backups to
     be taken between two full backups. This is just the upper limit. A full backup may be taken
     before specified number of incremental backups are completed in one of the following conditions
    
    
     * The replica has never taken a full backup since it has become primary,
     * Some of the log records since the last backup has been truncated, or
     * Replica passed the MaxAccumulatedBackupLogSizeInMB limit.
    :vartype max_incremental_backups: int
    :ivar schedule: Required. Describes the backup schedule parameters.
    :vartype schedule: ~azure.servicefabric.models.BackupScheduleDescription
    :ivar storage: Required. Describes the details of backup storage where to store the periodic
     backups.
    :vartype storage: ~azure.servicefabric.models.BackupStorageDescription
    :ivar retention_policy: Describes the policy to retain backups in storage.
    :vartype retention_policy: ~azure.servicefabric.models.RetentionPolicyDescription
    """

    _validation = {
        'name': {'required': True},
        'auto_restore_on_data_loss': {'required': True},
        'max_incremental_backups': {'required': True, 'maximum': 255, 'minimum': 0},
        'schedule': {'required': True},
        'storage': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'auto_restore_on_data_loss': {'key': 'AutoRestoreOnDataLoss', 'type': 'bool'},
        'max_incremental_backups': {'key': 'MaxIncrementalBackups', 'type': 'int'},
        'schedule': {'key': 'Schedule', 'type': 'BackupScheduleDescription'},
        'storage': {'key': 'Storage', 'type': 'BackupStorageDescription'},
        'retention_policy': {'key': 'RetentionPolicy', 'type': 'RetentionPolicyDescription'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. The unique name identifying this backup policy.
        :paramtype name: str
        :keyword auto_restore_on_data_loss: Required. Specifies whether to trigger restore
         automatically using the latest available backup in case the partition experiences a data loss
         event.
        :paramtype auto_restore_on_data_loss: bool
        :keyword max_incremental_backups: Required. Defines the maximum number of incremental backups
         to be taken between two full backups. This is just the upper limit. A full backup may be taken
         before specified number of incremental backups are completed in one of the following conditions
        
        
         * The replica has never taken a full backup since it has become primary,
         * Some of the log records since the last backup has been truncated, or
         * Replica passed the MaxAccumulatedBackupLogSizeInMB limit.
        :paramtype max_incremental_backups: int
        :keyword schedule: Required. Describes the backup schedule parameters.
        :paramtype schedule: ~azure.servicefabric.models.BackupScheduleDescription
        :keyword storage: Required. Describes the details of backup storage where to store the periodic
         backups.
        :paramtype storage: ~azure.servicefabric.models.BackupStorageDescription
        :keyword retention_policy: Describes the policy to retain backups in storage.
        :paramtype retention_policy: ~azure.servicefabric.models.RetentionPolicyDescription
        """
        super(BackupPolicyDescription, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.auto_restore_on_data_loss = kwargs['auto_restore_on_data_loss']
        self.max_incremental_backups = kwargs['max_incremental_backups']
        self.schedule = kwargs['schedule']
        self.storage = kwargs['storage']
        self.retention_policy = kwargs.get('retention_policy', None)


class BackupProgressInfo(msrest.serialization.Model):
    """Describes the progress of a partition's backup.

    :ivar backup_state: Represents the current state of the partition backup operation. Possible
     values include: "Invalid", "Accepted", "BackupInProgress", "Success", "Failure", "Timeout".
    :vartype backup_state: str or ~azure.servicefabric.models.BackupState
    :ivar time_stamp_utc: TimeStamp in UTC when operation succeeded or failed.
    :vartype time_stamp_utc: ~datetime.datetime
    :ivar backup_id: Unique ID of the newly created backup.
    :vartype backup_id: str
    :ivar backup_location: Location, relative to the backup store, of the newly created backup.
    :vartype backup_location: str
    :ivar epoch_of_last_backup_record: Specifies the epoch of the last record included in backup.
    :vartype epoch_of_last_backup_record: ~azure.servicefabric.models.Epoch
    :ivar lsn_of_last_backup_record: The LSN of last record included in backup.
    :vartype lsn_of_last_backup_record: str
    :ivar failure_error: Denotes the failure encountered in performing backup operation.
    :vartype failure_error: ~azure.servicefabric.models.FabricErrorError
    """

    _attribute_map = {
        'backup_state': {'key': 'BackupState', 'type': 'str'},
        'time_stamp_utc': {'key': 'TimeStampUtc', 'type': 'iso-8601'},
        'backup_id': {'key': 'BackupId', 'type': 'str'},
        'backup_location': {'key': 'BackupLocation', 'type': 'str'},
        'epoch_of_last_backup_record': {'key': 'EpochOfLastBackupRecord', 'type': 'Epoch'},
        'lsn_of_last_backup_record': {'key': 'LsnOfLastBackupRecord', 'type': 'str'},
        'failure_error': {'key': 'FailureError', 'type': 'FabricErrorError'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword backup_state: Represents the current state of the partition backup operation. Possible
         values include: "Invalid", "Accepted", "BackupInProgress", "Success", "Failure", "Timeout".
        :paramtype backup_state: str or ~azure.servicefabric.models.BackupState
        :keyword time_stamp_utc: TimeStamp in UTC when operation succeeded or failed.
        :paramtype time_stamp_utc: ~datetime.datetime
        :keyword backup_id: Unique ID of the newly created backup.
        :paramtype backup_id: str
        :keyword backup_location: Location, relative to the backup store, of the newly created backup.
        :paramtype backup_location: str
        :keyword epoch_of_last_backup_record: Specifies the epoch of the last record included in
         backup.
        :paramtype epoch_of_last_backup_record: ~azure.servicefabric.models.Epoch
        :keyword lsn_of_last_backup_record: The LSN of last record included in backup.
        :paramtype lsn_of_last_backup_record: str
        :keyword failure_error: Denotes the failure encountered in performing backup operation.
        :paramtype failure_error: ~azure.servicefabric.models.FabricErrorError
        """
        super(BackupProgressInfo, self).__init__(**kwargs)
        self.backup_state = kwargs.get('backup_state', None)
        self.time_stamp_utc = kwargs.get('time_stamp_utc', None)
        self.backup_id = kwargs.get('backup_id', None)
        self.backup_location = kwargs.get('backup_location', None)
        self.epoch_of_last_backup_record = kwargs.get('epoch_of_last_backup_record', None)
        self.lsn_of_last_backup_record = kwargs.get('lsn_of_last_backup_record', None)
        self.failure_error = kwargs.get('failure_error', None)


class BackupScheduleDescription(msrest.serialization.Model):
    """Describes the backup schedule parameters.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: FrequencyBasedBackupScheduleDescription, TimeBasedBackupScheduleDescription.

    All required parameters must be populated in order to send to Azure.

    :ivar schedule_kind: Required. The kind of backup schedule, time based or frequency
     based.Constant filled by server. Possible values include: "Invalid", "TimeBased",
     "FrequencyBased".
    :vartype schedule_kind: str or ~azure.servicefabric.models.BackupScheduleKind
    """

    _validation = {
        'schedule_kind': {'required': True},
    }

    _attribute_map = {
        'schedule_kind': {'key': 'ScheduleKind', 'type': 'str'},
    }

    _subtype_map = {
        'schedule_kind': {'FrequencyBased': 'FrequencyBasedBackupScheduleDescription', 'TimeBased': 'TimeBasedBackupScheduleDescription'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(BackupScheduleDescription, self).__init__(**kwargs)
        self.schedule_kind = None  # type: Optional[str]


class BackupSuspensionInfo(msrest.serialization.Model):
    """Describes the backup suspension details.

    :ivar is_suspended: Indicates whether periodic backup is suspended at this level or not.
    :vartype is_suspended: bool
    :ivar suspension_inherited_from: Specifies the scope at which the backup suspension was
     applied. Possible values include: "Invalid", "Partition", "Service", "Application".
    :vartype suspension_inherited_from: str or ~azure.servicefabric.models.BackupSuspensionScope
    """

    _attribute_map = {
        'is_suspended': {'key': 'IsSuspended', 'type': 'bool'},
        'suspension_inherited_from': {'key': 'SuspensionInheritedFrom', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword is_suspended: Indicates whether periodic backup is suspended at this level or not.
        :paramtype is_suspended: bool
        :keyword suspension_inherited_from: Specifies the scope at which the backup suspension was
         applied. Possible values include: "Invalid", "Partition", "Service", "Application".
        :paramtype suspension_inherited_from: str or ~azure.servicefabric.models.BackupSuspensionScope
        """
        super(BackupSuspensionInfo, self).__init__(**kwargs)
        self.is_suspended = kwargs.get('is_suspended', None)
        self.suspension_inherited_from = kwargs.get('suspension_inherited_from', None)


class RetentionPolicyDescription(msrest.serialization.Model):
    """Describes the retention policy configured.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: BasicRetentionPolicyDescription.

    All required parameters must be populated in order to send to Azure.

    :ivar retention_policy_type: Required. The type of retention policy. Currently only "Basic"
     retention policy is supported.Constant filled by server. Possible values include: "Basic",
     "Invalid".
    :vartype retention_policy_type: str or ~azure.servicefabric.models.RetentionPolicyType
    """

    _validation = {
        'retention_policy_type': {'required': True},
    }

    _attribute_map = {
        'retention_policy_type': {'key': 'RetentionPolicyType', 'type': 'str'},
    }

    _subtype_map = {
        'retention_policy_type': {'Basic': 'BasicRetentionPolicyDescription'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(RetentionPolicyDescription, self).__init__(**kwargs)
        self.retention_policy_type = None  # type: Optional[str]


class BasicRetentionPolicyDescription(RetentionPolicyDescription):
    """Describes basic retention policy.

    All required parameters must be populated in order to send to Azure.

    :ivar retention_policy_type: Required. The type of retention policy. Currently only "Basic"
     retention policy is supported.Constant filled by server. Possible values include: "Basic",
     "Invalid".
    :vartype retention_policy_type: str or ~azure.servicefabric.models.RetentionPolicyType
    :ivar retention_duration: Required. It is the minimum duration for which a backup created, will
     remain stored in the storage and might get deleted after that span of time. It should be
     specified in ISO8601 format.
    :vartype retention_duration: ~datetime.timedelta
    :ivar minimum_number_of_backups: It is the minimum number of backups to be retained at any
     point of time. If specified with a non zero value, backups will not be deleted even if the
     backups have gone past retention duration and have number of backups less than or equal to it.
    :vartype minimum_number_of_backups: int
    """

    _validation = {
        'retention_policy_type': {'required': True},
        'retention_duration': {'required': True},
        'minimum_number_of_backups': {'minimum': 0},
    }

    _attribute_map = {
        'retention_policy_type': {'key': 'RetentionPolicyType', 'type': 'str'},
        'retention_duration': {'key': 'RetentionDuration', 'type': 'duration'},
        'minimum_number_of_backups': {'key': 'MinimumNumberOfBackups', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword retention_duration: Required. It is the minimum duration for which a backup created,
         will remain stored in the storage and might get deleted after that span of time. It should be
         specified in ISO8601 format.
        :paramtype retention_duration: ~datetime.timedelta
        :keyword minimum_number_of_backups: It is the minimum number of backups to be retained at any
         point of time. If specified with a non zero value, backups will not be deleted even if the
         backups have gone past retention duration and have number of backups less than or equal to it.
        :paramtype minimum_number_of_backups: int
        """
        super(BasicRetentionPolicyDescription, self).__init__(**kwargs)
        self.retention_policy_type = 'Basic'  # type: str
        self.retention_duration = kwargs['retention_duration']
        self.minimum_number_of_backups = kwargs.get('minimum_number_of_backups', None)


class PropertyValue(msrest.serialization.Model):
    """Describes a Service Fabric property value.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: BinaryPropertyValue, DoublePropertyValue, GuidPropertyValue, Int64PropertyValue, StringPropertyValue.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property, determined by the type of data. Following are the
     possible values.Constant filled by server. Possible values include: "Invalid", "Binary",
     "Int64", "Double", "String", "Guid".
    :vartype kind: str or ~azure.servicefabric.models.PropertyValueKind
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'Binary': 'BinaryPropertyValue', 'Double': 'DoublePropertyValue', 'Guid': 'GuidPropertyValue', 'Int64': 'Int64PropertyValue', 'String': 'StringPropertyValue'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(PropertyValue, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]


class BinaryPropertyValue(PropertyValue):
    """Describes a Service Fabric property value of type Binary.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property, determined by the type of data. Following are the
     possible values.Constant filled by server. Possible values include: "Invalid", "Binary",
     "Int64", "Double", "String", "Guid".
    :vartype kind: str or ~azure.servicefabric.models.PropertyValueKind
    :ivar data: Required. Array of bytes to be sent as an integer array. Each element of array is a
     number between 0 and 255.
    :vartype data: list[int]
    """

    _validation = {
        'kind': {'required': True},
        'data': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'data': {'key': 'Data', 'type': '[int]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword data: Required. Array of bytes to be sent as an integer array. Each element of array
         is a number between 0 and 255.
        :paramtype data: list[int]
        """
        super(BinaryPropertyValue, self).__init__(**kwargs)
        self.kind = 'Binary'  # type: str
        self.data = kwargs['data']


class Chaos(msrest.serialization.Model):
    """Contains a description of Chaos.

    :ivar chaos_parameters: If Chaos is running, these are the parameters Chaos is running with.
    :vartype chaos_parameters: ~azure.servicefabric.models.ChaosParameters
    :ivar status: Current status of the Chaos run. Possible values include: "Invalid", "Running",
     "Stopped".
    :vartype status: str or ~azure.servicefabric.models.ChaosStatus
    :ivar schedule_status: Current status of the schedule. Possible values include: "Invalid",
     "Stopped", "Active", "Expired", "Pending".
    :vartype schedule_status: str or ~azure.servicefabric.models.ChaosScheduleStatus
    """

    _attribute_map = {
        'chaos_parameters': {'key': 'ChaosParameters', 'type': 'ChaosParameters'},
        'status': {'key': 'Status', 'type': 'str'},
        'schedule_status': {'key': 'ScheduleStatus', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword chaos_parameters: If Chaos is running, these are the parameters Chaos is running with.
        :paramtype chaos_parameters: ~azure.servicefabric.models.ChaosParameters
        :keyword status: Current status of the Chaos run. Possible values include: "Invalid",
         "Running", "Stopped".
        :paramtype status: str or ~azure.servicefabric.models.ChaosStatus
        :keyword schedule_status: Current status of the schedule. Possible values include: "Invalid",
         "Stopped", "Active", "Expired", "Pending".
        :paramtype schedule_status: str or ~azure.servicefabric.models.ChaosScheduleStatus
        """
        super(Chaos, self).__init__(**kwargs)
        self.chaos_parameters = kwargs.get('chaos_parameters', None)
        self.status = kwargs.get('status', None)
        self.schedule_status = kwargs.get('schedule_status', None)


class ChaosCodePackageRestartScheduledEvent(ApplicationEvent):
    """Chaos Restart Code Package Fault Scheduled event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar fault_group_id: Required. Id of fault group.
    :vartype fault_group_id: str
    :ivar fault_id: Required. Id of fault.
    :vartype fault_id: str
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar service_manifest_name: Required. Service manifest name.
    :vartype service_manifest_name: str
    :ivar code_package_name: Required. Code package name.
    :vartype code_package_name: str
    :ivar service_package_activation_id: Required. Id of Service package activation.
    :vartype service_package_activation_id: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'fault_group_id': {'required': True},
        'fault_id': {'required': True},
        'node_name': {'required': True},
        'service_manifest_name': {'required': True},
        'code_package_name': {'required': True},
        'service_package_activation_id': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'fault_group_id': {'key': 'FaultGroupId', 'type': 'str'},
        'fault_id': {'key': 'FaultId', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'service_manifest_name': {'key': 'ServiceManifestName', 'type': 'str'},
        'code_package_name': {'key': 'CodePackageName', 'type': 'str'},
        'service_package_activation_id': {'key': 'ServicePackageActivationId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword fault_group_id: Required. Id of fault group.
        :paramtype fault_group_id: str
        :keyword fault_id: Required. Id of fault.
        :paramtype fault_id: str
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword service_manifest_name: Required. Service manifest name.
        :paramtype service_manifest_name: str
        :keyword code_package_name: Required. Code package name.
        :paramtype code_package_name: str
        :keyword service_package_activation_id: Required. Id of Service package activation.
        :paramtype service_package_activation_id: str
        """
        super(ChaosCodePackageRestartScheduledEvent, self).__init__(**kwargs)
        self.kind = 'ChaosCodePackageRestartScheduled'  # type: str
        self.fault_group_id = kwargs['fault_group_id']
        self.fault_id = kwargs['fault_id']
        self.node_name = kwargs['node_name']
        self.service_manifest_name = kwargs['service_manifest_name']
        self.code_package_name = kwargs['code_package_name']
        self.service_package_activation_id = kwargs['service_package_activation_id']


class ChaosContext(msrest.serialization.Model):
    """Describes a map, which is a collection of (string, string) type key-value pairs. The map can be used to record information about
the Chaos run. There cannot be more than 100 such pairs and each string (key or value) can be at most 4095 characters long.
This map is set by the starter of the Chaos run to optionally store the context about the specific run.

    :ivar map: Describes a map that contains a collection of ChaosContextMapItem's.
    :vartype map: dict[str, str]
    """

    _attribute_map = {
        'map': {'key': 'Map', 'type': '{str}'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword map: Describes a map that contains a collection of ChaosContextMapItem's.
        :paramtype map: dict[str, str]
        """
        super(ChaosContext, self).__init__(**kwargs)
        self.map = kwargs.get('map', None)


class ChaosEvent(msrest.serialization.Model):
    """Represents an event generated during a Chaos run.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ExecutingFaultsChaosEvent, StartedChaosEvent, StoppedChaosEvent, TestErrorChaosEvent, ValidationFailedChaosEvent, WaitingChaosEvent.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of Chaos event.Constant filled by server. Possible values
     include: "Invalid", "Started", "ExecutingFaults", "Waiting", "ValidationFailed", "TestError",
     "Stopped".
    :vartype kind: str or ~azure.servicefabric.models.ChaosEventKind
    :ivar time_stamp_utc: Required. The UTC timestamp when this Chaos event was generated.
    :vartype time_stamp_utc: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'time_stamp_utc': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'time_stamp_utc': {'key': 'TimeStampUtc', 'type': 'iso-8601'},
    }

    _subtype_map = {
        'kind': {'ExecutingFaults': 'ExecutingFaultsChaosEvent', 'Started': 'StartedChaosEvent', 'Stopped': 'StoppedChaosEvent', 'TestError': 'TestErrorChaosEvent', 'ValidationFailed': 'ValidationFailedChaosEvent', 'Waiting': 'WaitingChaosEvent'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword time_stamp_utc: Required. The UTC timestamp when this Chaos event was generated.
        :paramtype time_stamp_utc: ~datetime.datetime
        """
        super(ChaosEvent, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]
        self.time_stamp_utc = kwargs['time_stamp_utc']


class ChaosEventsSegment(msrest.serialization.Model):
    """Contains the list of Chaos events and the continuation token to get the next segment.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar history: List of Chaos events that meet the user-supplied criteria.
    :vartype history: list[~azure.servicefabric.models.ChaosEventWrapper]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'history': {'key': 'History', 'type': '[ChaosEventWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword history: List of Chaos events that meet the user-supplied criteria.
        :paramtype history: list[~azure.servicefabric.models.ChaosEventWrapper]
        """
        super(ChaosEventsSegment, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.history = kwargs.get('history', None)


class ChaosEventWrapper(msrest.serialization.Model):
    """Wrapper object for Chaos event.

    :ivar chaos_event: Represents an event generated during a Chaos run.
    :vartype chaos_event: ~azure.servicefabric.models.ChaosEvent
    """

    _attribute_map = {
        'chaos_event': {'key': 'ChaosEvent', 'type': 'ChaosEvent'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword chaos_event: Represents an event generated during a Chaos run.
        :paramtype chaos_event: ~azure.servicefabric.models.ChaosEvent
        """
        super(ChaosEventWrapper, self).__init__(**kwargs)
        self.chaos_event = kwargs.get('chaos_event', None)


class NodeEvent(FabricEvent):
    """Represents the base for all Node Events.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ChaosNodeRestartScheduledEvent, NodeAbortedEvent, NodeAddedToClusterEvent, NodeClosedEvent, NodeDeactivateCompletedEvent, NodeDeactivateStartedEvent, NodeDownEvent, NodeHealthReportExpiredEvent, NodeNewHealthReportEvent, NodeOpenFailedEvent, NodeOpenSucceededEvent, NodeRemovedFromClusterEvent, NodeUpEvent.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'node_name': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'ChaosNodeRestartScheduled': 'ChaosNodeRestartScheduledEvent', 'NodeAborted': 'NodeAbortedEvent', 'NodeAddedToCluster': 'NodeAddedToClusterEvent', 'NodeClosed': 'NodeClosedEvent', 'NodeDeactivateCompleted': 'NodeDeactivateCompletedEvent', 'NodeDeactivateStarted': 'NodeDeactivateStartedEvent', 'NodeDown': 'NodeDownEvent', 'NodeHealthReportExpired': 'NodeHealthReportExpiredEvent', 'NodeNewHealthReport': 'NodeNewHealthReportEvent', 'NodeOpenFailed': 'NodeOpenFailedEvent', 'NodeOpenSucceeded': 'NodeOpenSucceededEvent', 'NodeRemovedFromCluster': 'NodeRemovedFromClusterEvent', 'NodeUp': 'NodeUpEvent'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        """
        super(NodeEvent, self).__init__(**kwargs)
        self.kind = 'NodeEvent'  # type: str
        self.node_name = kwargs['node_name']


class ChaosNodeRestartScheduledEvent(NodeEvent):
    """Chaos Restart Node Fault Scheduled event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar node_instance_id: Required. Id of Node instance.
    :vartype node_instance_id: long
    :ivar fault_group_id: Required. Id of fault group.
    :vartype fault_group_id: str
    :ivar fault_id: Required. Id of fault.
    :vartype fault_id: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'node_name': {'required': True},
        'node_instance_id': {'required': True},
        'fault_group_id': {'required': True},
        'fault_id': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_instance_id': {'key': 'NodeInstanceId', 'type': 'long'},
        'fault_group_id': {'key': 'FaultGroupId', 'type': 'str'},
        'fault_id': {'key': 'FaultId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword node_instance_id: Required. Id of Node instance.
        :paramtype node_instance_id: long
        :keyword fault_group_id: Required. Id of fault group.
        :paramtype fault_group_id: str
        :keyword fault_id: Required. Id of fault.
        :paramtype fault_id: str
        """
        super(ChaosNodeRestartScheduledEvent, self).__init__(**kwargs)
        self.kind = 'ChaosNodeRestartScheduled'  # type: str
        self.node_instance_id = kwargs['node_instance_id']
        self.fault_group_id = kwargs['fault_group_id']
        self.fault_id = kwargs['fault_id']


class ChaosParameters(msrest.serialization.Model):
    """Defines all the parameters to configure a Chaos run.

    :ivar time_to_run_in_seconds: Total time (in seconds) for which Chaos will run before
     automatically stopping. The maximum allowed value is 4,294,967,295 (System.UInt32.MaxValue).
    :vartype time_to_run_in_seconds: str
    :ivar max_cluster_stabilization_timeout_in_seconds: The maximum amount of time to wait for all
     cluster entities to become stable and healthy. Chaos executes in iterations and at the start of
     each iteration it validates the health of cluster entities.
     During validation if a cluster entity is not stable and healthy within
     MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed event.
    :vartype max_cluster_stabilization_timeout_in_seconds: long
    :ivar max_concurrent_faults: MaxConcurrentFaults is the maximum number of concurrent faults
     induced per iteration.
     Chaos executes in iterations and two consecutive iterations are separated by a validation
     phase.
     The higher the concurrency, the more aggressive the injection of faults, leading to inducing
     more complex series of states to uncover bugs.
     The recommendation is to start with a value of 2 or 3 and to exercise caution while moving up.
    :vartype max_concurrent_faults: long
    :ivar enable_move_replica_faults: Enables or disables the move primary and move secondary
     faults.
    :vartype enable_move_replica_faults: bool
    :ivar wait_time_between_faults_in_seconds: Wait time (in seconds) between consecutive faults
     within a single iteration.
     The larger the value, the lower the overlapping between faults and the simpler the sequence of
     state transitions that the cluster goes through.
     The recommendation is to start with a value between 1 and 5 and exercise caution while moving
     up.
    :vartype wait_time_between_faults_in_seconds: long
    :ivar wait_time_between_iterations_in_seconds: Time-separation (in seconds) between two
     consecutive iterations of Chaos.
     The larger the value, the lower the fault injection rate.
    :vartype wait_time_between_iterations_in_seconds: long
    :ivar cluster_health_policy: Passed-in cluster health policy is used to validate health of the
     cluster in between Chaos iterations. If the cluster health is in error or if an unexpected
     exception happens during fault execution--to provide the cluster with some time to
     recuperate--Chaos will wait for 30 minutes before the next health-check.
    :vartype cluster_health_policy: ~azure.servicefabric.models.ClusterHealthPolicy
    :ivar context: Describes a map, which is a collection of (string, string) type key-value pairs.
     The map can be used to record information about
     the Chaos run. There cannot be more than 100 such pairs and each string (key or value) can be
     at most 4095 characters long.
     This map is set by the starter of the Chaos run to optionally store the context about the
     specific run.
    :vartype context: ~azure.servicefabric.models.ChaosContext
    :ivar chaos_target_filter: List of cluster entities to target for Chaos faults.
     This filter can be used to target Chaos faults only to certain node types or only to certain
     application instances. If ChaosTargetFilter is not used, Chaos faults all cluster entities.
     If ChaosTargetFilter is used, Chaos faults only the entities that meet the ChaosTargetFilter
     specification.
    :vartype chaos_target_filter: ~azure.servicefabric.models.ChaosTargetFilter
    """

    _validation = {
        'max_cluster_stabilization_timeout_in_seconds': {'maximum': 4294967295, 'minimum': 0},
        'max_concurrent_faults': {'maximum': 4294967295, 'minimum': 0},
        'wait_time_between_faults_in_seconds': {'maximum': 4294967295, 'minimum': 0},
        'wait_time_between_iterations_in_seconds': {'maximum': 4294967295, 'minimum': 0},
    }

    _attribute_map = {
        'time_to_run_in_seconds': {'key': 'TimeToRunInSeconds', 'type': 'str'},
        'max_cluster_stabilization_timeout_in_seconds': {'key': 'MaxClusterStabilizationTimeoutInSeconds', 'type': 'long'},
        'max_concurrent_faults': {'key': 'MaxConcurrentFaults', 'type': 'long'},
        'enable_move_replica_faults': {'key': 'EnableMoveReplicaFaults', 'type': 'bool'},
        'wait_time_between_faults_in_seconds': {'key': 'WaitTimeBetweenFaultsInSeconds', 'type': 'long'},
        'wait_time_between_iterations_in_seconds': {'key': 'WaitTimeBetweenIterationsInSeconds', 'type': 'long'},
        'cluster_health_policy': {'key': 'ClusterHealthPolicy', 'type': 'ClusterHealthPolicy'},
        'context': {'key': 'Context', 'type': 'ChaosContext'},
        'chaos_target_filter': {'key': 'ChaosTargetFilter', 'type': 'ChaosTargetFilter'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword time_to_run_in_seconds: Total time (in seconds) for which Chaos will run before
         automatically stopping. The maximum allowed value is 4,294,967,295 (System.UInt32.MaxValue).
        :paramtype time_to_run_in_seconds: str
        :keyword max_cluster_stabilization_timeout_in_seconds: The maximum amount of time to wait for
         all cluster entities to become stable and healthy. Chaos executes in iterations and at the
         start of each iteration it validates the health of cluster entities.
         During validation if a cluster entity is not stable and healthy within
         MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed event.
        :paramtype max_cluster_stabilization_timeout_in_seconds: long
        :keyword max_concurrent_faults: MaxConcurrentFaults is the maximum number of concurrent faults
         induced per iteration.
         Chaos executes in iterations and two consecutive iterations are separated by a validation
         phase.
         The higher the concurrency, the more aggressive the injection of faults, leading to inducing
         more complex series of states to uncover bugs.
         The recommendation is to start with a value of 2 or 3 and to exercise caution while moving up.
        :paramtype max_concurrent_faults: long
        :keyword enable_move_replica_faults: Enables or disables the move primary and move secondary
         faults.
        :paramtype enable_move_replica_faults: bool
        :keyword wait_time_between_faults_in_seconds: Wait time (in seconds) between consecutive faults
         within a single iteration.
         The larger the value, the lower the overlapping between faults and the simpler the sequence of
         state transitions that the cluster goes through.
         The recommendation is to start with a value between 1 and 5 and exercise caution while moving
         up.
        :paramtype wait_time_between_faults_in_seconds: long
        :keyword wait_time_between_iterations_in_seconds: Time-separation (in seconds) between two
         consecutive iterations of Chaos.
         The larger the value, the lower the fault injection rate.
        :paramtype wait_time_between_iterations_in_seconds: long
        :keyword cluster_health_policy: Passed-in cluster health policy is used to validate health of
         the cluster in between Chaos iterations. If the cluster health is in error or if an unexpected
         exception happens during fault execution--to provide the cluster with some time to
         recuperate--Chaos will wait for 30 minutes before the next health-check.
        :paramtype cluster_health_policy: ~azure.servicefabric.models.ClusterHealthPolicy
        :keyword context: Describes a map, which is a collection of (string, string) type key-value
         pairs. The map can be used to record information about
         the Chaos run. There cannot be more than 100 such pairs and each string (key or value) can be
         at most 4095 characters long.
         This map is set by the starter of the Chaos run to optionally store the context about the
         specific run.
        :paramtype context: ~azure.servicefabric.models.ChaosContext
        :keyword chaos_target_filter: List of cluster entities to target for Chaos faults.
         This filter can be used to target Chaos faults only to certain node types or only to certain
         application instances. If ChaosTargetFilter is not used, Chaos faults all cluster entities.
         If ChaosTargetFilter is used, Chaos faults only the entities that meet the ChaosTargetFilter
         specification.
        :paramtype chaos_target_filter: ~azure.servicefabric.models.ChaosTargetFilter
        """
        super(ChaosParameters, self).__init__(**kwargs)
        self.time_to_run_in_seconds = kwargs.get('time_to_run_in_seconds', "4294967295")
        self.max_cluster_stabilization_timeout_in_seconds = kwargs.get('max_cluster_stabilization_timeout_in_seconds', 60)
        self.max_concurrent_faults = kwargs.get('max_concurrent_faults', 1)
        self.enable_move_replica_faults = kwargs.get('enable_move_replica_faults', True)
        self.wait_time_between_faults_in_seconds = kwargs.get('wait_time_between_faults_in_seconds', 20)
        self.wait_time_between_iterations_in_seconds = kwargs.get('wait_time_between_iterations_in_seconds', 30)
        self.cluster_health_policy = kwargs.get('cluster_health_policy', None)
        self.context = kwargs.get('context', None)
        self.chaos_target_filter = kwargs.get('chaos_target_filter', None)


class ChaosParametersDictionaryItem(msrest.serialization.Model):
    """Defines an item in ChaosParametersDictionary of the Chaos Schedule.

    All required parameters must be populated in order to send to Azure.

    :ivar key: Required. The key identifying the Chaos Parameter in the dictionary. This key is
     referenced by Chaos Schedule Jobs.
    :vartype key: str
    :ivar value: Required. Defines all the parameters to configure a Chaos run.
    :vartype value: ~azure.servicefabric.models.ChaosParameters
    """

    _validation = {
        'key': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'key': {'key': 'Key', 'type': 'str'},
        'value': {'key': 'Value', 'type': 'ChaosParameters'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword key: Required. The key identifying the Chaos Parameter in the dictionary. This key is
         referenced by Chaos Schedule Jobs.
        :paramtype key: str
        :keyword value: Required. Defines all the parameters to configure a Chaos run.
        :paramtype value: ~azure.servicefabric.models.ChaosParameters
        """
        super(ChaosParametersDictionaryItem, self).__init__(**kwargs)
        self.key = kwargs['key']
        self.value = kwargs['value']


class PartitionEvent(FabricEvent):
    """Represents the base for all Partition Events.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ChaosPartitionPrimaryMoveScheduledEvent, ChaosPartitionSecondaryMoveScheduledEvent, PartitionAnalysisEvent, PartitionHealthReportExpiredEvent, PartitionNewHealthReportEvent, PartitionReconfiguredEvent.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'partition_id': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'ChaosPartitionPrimaryMoveScheduled': 'ChaosPartitionPrimaryMoveScheduledEvent', 'ChaosPartitionSecondaryMoveScheduled': 'ChaosPartitionSecondaryMoveScheduledEvent', 'PartitionAnalysisEvent': 'PartitionAnalysisEvent', 'PartitionHealthReportExpired': 'PartitionHealthReportExpiredEvent', 'PartitionNewHealthReport': 'PartitionNewHealthReportEvent', 'PartitionReconfigured': 'PartitionReconfiguredEvent'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        """
        super(PartitionEvent, self).__init__(**kwargs)
        self.kind = 'PartitionEvent'  # type: str
        self.partition_id = kwargs['partition_id']


class ChaosPartitionPrimaryMoveScheduledEvent(PartitionEvent):
    """Chaos Move Primary Fault Scheduled event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar fault_group_id: Required. Id of fault group.
    :vartype fault_group_id: str
    :ivar fault_id: Required. Id of fault.
    :vartype fault_id: str
    :ivar service_name: Required. Service name.
    :vartype service_name: str
    :ivar node_to: Required. The name of a Service Fabric node.
    :vartype node_to: str
    :ivar forced_move: Required. Indicates a forced move.
    :vartype forced_move: bool
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'partition_id': {'required': True},
        'fault_group_id': {'required': True},
        'fault_id': {'required': True},
        'service_name': {'required': True},
        'node_to': {'required': True},
        'forced_move': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'fault_group_id': {'key': 'FaultGroupId', 'type': 'str'},
        'fault_id': {'key': 'FaultId', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'node_to': {'key': 'NodeTo', 'type': 'str'},
        'forced_move': {'key': 'ForcedMove', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword fault_group_id: Required. Id of fault group.
        :paramtype fault_group_id: str
        :keyword fault_id: Required. Id of fault.
        :paramtype fault_id: str
        :keyword service_name: Required. Service name.
        :paramtype service_name: str
        :keyword node_to: Required. The name of a Service Fabric node.
        :paramtype node_to: str
        :keyword forced_move: Required. Indicates a forced move.
        :paramtype forced_move: bool
        """
        super(ChaosPartitionPrimaryMoveScheduledEvent, self).__init__(**kwargs)
        self.kind = 'ChaosPartitionPrimaryMoveScheduled'  # type: str
        self.fault_group_id = kwargs['fault_group_id']
        self.fault_id = kwargs['fault_id']
        self.service_name = kwargs['service_name']
        self.node_to = kwargs['node_to']
        self.forced_move = kwargs['forced_move']


class ChaosPartitionSecondaryMoveScheduledEvent(PartitionEvent):
    """Chaos Move Secondary Fault Scheduled event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar fault_group_id: Required. Id of fault group.
    :vartype fault_group_id: str
    :ivar fault_id: Required. Id of fault.
    :vartype fault_id: str
    :ivar service_name: Required. Service name.
    :vartype service_name: str
    :ivar source_node: Required. The name of a Service Fabric node.
    :vartype source_node: str
    :ivar destination_node: Required. The name of a Service Fabric node.
    :vartype destination_node: str
    :ivar forced_move: Required. Indicates a forced move.
    :vartype forced_move: bool
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'partition_id': {'required': True},
        'fault_group_id': {'required': True},
        'fault_id': {'required': True},
        'service_name': {'required': True},
        'source_node': {'required': True},
        'destination_node': {'required': True},
        'forced_move': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'fault_group_id': {'key': 'FaultGroupId', 'type': 'str'},
        'fault_id': {'key': 'FaultId', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'source_node': {'key': 'SourceNode', 'type': 'str'},
        'destination_node': {'key': 'DestinationNode', 'type': 'str'},
        'forced_move': {'key': 'ForcedMove', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword fault_group_id: Required. Id of fault group.
        :paramtype fault_group_id: str
        :keyword fault_id: Required. Id of fault.
        :paramtype fault_id: str
        :keyword service_name: Required. Service name.
        :paramtype service_name: str
        :keyword source_node: Required. The name of a Service Fabric node.
        :paramtype source_node: str
        :keyword destination_node: Required. The name of a Service Fabric node.
        :paramtype destination_node: str
        :keyword forced_move: Required. Indicates a forced move.
        :paramtype forced_move: bool
        """
        super(ChaosPartitionSecondaryMoveScheduledEvent, self).__init__(**kwargs)
        self.kind = 'ChaosPartitionSecondaryMoveScheduled'  # type: str
        self.fault_group_id = kwargs['fault_group_id']
        self.fault_id = kwargs['fault_id']
        self.service_name = kwargs['service_name']
        self.source_node = kwargs['source_node']
        self.destination_node = kwargs['destination_node']
        self.forced_move = kwargs['forced_move']


class ReplicaEvent(FabricEvent):
    """Represents the base for all Replica Events.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ChaosReplicaRemovalScheduledEvent, ChaosReplicaRestartScheduledEvent, StatefulReplicaHealthReportExpiredEvent, StatefulReplicaNewHealthReportEvent, StatelessReplicaHealthReportExpiredEvent, StatelessReplicaNewHealthReportEvent.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar replica_id: Required. Id of a stateful service replica. ReplicaId is used by Service
     Fabric to uniquely identify a replica of a partition. It is unique within a partition and does
     not change for the lifetime of the replica. If a replica gets dropped and another replica gets
     created on the same node for the same partition, it will get a different value for the id.
     Sometimes the id of a stateless service instance is also referred as a replica id.
    :vartype replica_id: long
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'partition_id': {'required': True},
        'replica_id': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_id': {'key': 'ReplicaId', 'type': 'long'},
    }

    _subtype_map = {
        'kind': {'ChaosReplicaRemovalScheduled': 'ChaosReplicaRemovalScheduledEvent', 'ChaosReplicaRestartScheduled': 'ChaosReplicaRestartScheduledEvent', 'StatefulReplicaHealthReportExpired': 'StatefulReplicaHealthReportExpiredEvent', 'StatefulReplicaNewHealthReport': 'StatefulReplicaNewHealthReportEvent', 'StatelessReplicaHealthReportExpired': 'StatelessReplicaHealthReportExpiredEvent', 'StatelessReplicaNewHealthReport': 'StatelessReplicaNewHealthReportEvent'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword replica_id: Required. Id of a stateful service replica. ReplicaId is used by Service
         Fabric to uniquely identify a replica of a partition. It is unique within a partition and does
         not change for the lifetime of the replica. If a replica gets dropped and another replica gets
         created on the same node for the same partition, it will get a different value for the id.
         Sometimes the id of a stateless service instance is also referred as a replica id.
        :paramtype replica_id: long
        """
        super(ReplicaEvent, self).__init__(**kwargs)
        self.kind = 'ReplicaEvent'  # type: str
        self.partition_id = kwargs['partition_id']
        self.replica_id = kwargs['replica_id']


class ChaosReplicaRemovalScheduledEvent(ReplicaEvent):
    """Chaos Remove Replica Fault Scheduled event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar replica_id: Required. Id of a stateful service replica. ReplicaId is used by Service
     Fabric to uniquely identify a replica of a partition. It is unique within a partition and does
     not change for the lifetime of the replica. If a replica gets dropped and another replica gets
     created on the same node for the same partition, it will get a different value for the id.
     Sometimes the id of a stateless service instance is also referred as a replica id.
    :vartype replica_id: long
    :ivar fault_group_id: Required. Id of fault group.
    :vartype fault_group_id: str
    :ivar fault_id: Required. Id of fault.
    :vartype fault_id: str
    :ivar service_uri: Required. Service name.
    :vartype service_uri: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'partition_id': {'required': True},
        'replica_id': {'required': True},
        'fault_group_id': {'required': True},
        'fault_id': {'required': True},
        'service_uri': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_id': {'key': 'ReplicaId', 'type': 'long'},
        'fault_group_id': {'key': 'FaultGroupId', 'type': 'str'},
        'fault_id': {'key': 'FaultId', 'type': 'str'},
        'service_uri': {'key': 'ServiceUri', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword replica_id: Required. Id of a stateful service replica. ReplicaId is used by Service
         Fabric to uniquely identify a replica of a partition. It is unique within a partition and does
         not change for the lifetime of the replica. If a replica gets dropped and another replica gets
         created on the same node for the same partition, it will get a different value for the id.
         Sometimes the id of a stateless service instance is also referred as a replica id.
        :paramtype replica_id: long
        :keyword fault_group_id: Required. Id of fault group.
        :paramtype fault_group_id: str
        :keyword fault_id: Required. Id of fault.
        :paramtype fault_id: str
        :keyword service_uri: Required. Service name.
        :paramtype service_uri: str
        """
        super(ChaosReplicaRemovalScheduledEvent, self).__init__(**kwargs)
        self.kind = 'ChaosReplicaRemovalScheduled'  # type: str
        self.fault_group_id = kwargs['fault_group_id']
        self.fault_id = kwargs['fault_id']
        self.service_uri = kwargs['service_uri']


class ChaosReplicaRestartScheduledEvent(ReplicaEvent):
    """Chaos Restart Replica Fault Scheduled event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar replica_id: Required. Id of a stateful service replica. ReplicaId is used by Service
     Fabric to uniquely identify a replica of a partition. It is unique within a partition and does
     not change for the lifetime of the replica. If a replica gets dropped and another replica gets
     created on the same node for the same partition, it will get a different value for the id.
     Sometimes the id of a stateless service instance is also referred as a replica id.
    :vartype replica_id: long
    :ivar fault_group_id: Required. Id of fault group.
    :vartype fault_group_id: str
    :ivar fault_id: Required. Id of fault.
    :vartype fault_id: str
    :ivar service_uri: Required. Service name.
    :vartype service_uri: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'partition_id': {'required': True},
        'replica_id': {'required': True},
        'fault_group_id': {'required': True},
        'fault_id': {'required': True},
        'service_uri': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_id': {'key': 'ReplicaId', 'type': 'long'},
        'fault_group_id': {'key': 'FaultGroupId', 'type': 'str'},
        'fault_id': {'key': 'FaultId', 'type': 'str'},
        'service_uri': {'key': 'ServiceUri', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword replica_id: Required. Id of a stateful service replica. ReplicaId is used by Service
         Fabric to uniquely identify a replica of a partition. It is unique within a partition and does
         not change for the lifetime of the replica. If a replica gets dropped and another replica gets
         created on the same node for the same partition, it will get a different value for the id.
         Sometimes the id of a stateless service instance is also referred as a replica id.
        :paramtype replica_id: long
        :keyword fault_group_id: Required. Id of fault group.
        :paramtype fault_group_id: str
        :keyword fault_id: Required. Id of fault.
        :paramtype fault_id: str
        :keyword service_uri: Required. Service name.
        :paramtype service_uri: str
        """
        super(ChaosReplicaRestartScheduledEvent, self).__init__(**kwargs)
        self.kind = 'ChaosReplicaRestartScheduled'  # type: str
        self.fault_group_id = kwargs['fault_group_id']
        self.fault_id = kwargs['fault_id']
        self.service_uri = kwargs['service_uri']


class ChaosSchedule(msrest.serialization.Model):
    """Defines the schedule used by Chaos.

    :ivar start_date: The date and time Chaos will start using this schedule.
    :vartype start_date: ~datetime.datetime
    :ivar expiry_date: The date and time Chaos will continue to use this schedule until.
    :vartype expiry_date: ~datetime.datetime
    :ivar chaos_parameters_dictionary: A mapping of string names to Chaos Parameters to be
     referenced by Chaos Schedule Jobs.
    :vartype chaos_parameters_dictionary:
     list[~azure.servicefabric.models.ChaosParametersDictionaryItem]
    :ivar jobs: A list of all Chaos Schedule Jobs that will be automated by the schedule.
    :vartype jobs: list[~azure.servicefabric.models.ChaosScheduleJob]
    """

    _attribute_map = {
        'start_date': {'key': 'StartDate', 'type': 'iso-8601'},
        'expiry_date': {'key': 'ExpiryDate', 'type': 'iso-8601'},
        'chaos_parameters_dictionary': {'key': 'ChaosParametersDictionary', 'type': '[ChaosParametersDictionaryItem]'},
        'jobs': {'key': 'Jobs', 'type': '[ChaosScheduleJob]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword start_date: The date and time Chaos will start using this schedule.
        :paramtype start_date: ~datetime.datetime
        :keyword expiry_date: The date and time Chaos will continue to use this schedule until.
        :paramtype expiry_date: ~datetime.datetime
        :keyword chaos_parameters_dictionary: A mapping of string names to Chaos Parameters to be
         referenced by Chaos Schedule Jobs.
        :paramtype chaos_parameters_dictionary:
         list[~azure.servicefabric.models.ChaosParametersDictionaryItem]
        :keyword jobs: A list of all Chaos Schedule Jobs that will be automated by the schedule.
        :paramtype jobs: list[~azure.servicefabric.models.ChaosScheduleJob]
        """
        super(ChaosSchedule, self).__init__(**kwargs)
        self.start_date = kwargs.get('start_date', "1601-01-01T00:00:00Z")
        self.expiry_date = kwargs.get('expiry_date', "9999-12-31T23:59:59.999Z")
        self.chaos_parameters_dictionary = kwargs.get('chaos_parameters_dictionary', None)
        self.jobs = kwargs.get('jobs', None)


class ChaosScheduleDescription(msrest.serialization.Model):
    """Defines the Chaos Schedule used by Chaos and the version of the Chaos Schedule. The version value wraps back to 0 after surpassing 2,147,483,647.

    :ivar version: The version number of the Schedule.
    :vartype version: int
    :ivar schedule: Defines the schedule used by Chaos.
    :vartype schedule: ~azure.servicefabric.models.ChaosSchedule
    """

    _validation = {
        'version': {'minimum': 0},
    }

    _attribute_map = {
        'version': {'key': 'Version', 'type': 'int'},
        'schedule': {'key': 'Schedule', 'type': 'ChaosSchedule'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword version: The version number of the Schedule.
        :paramtype version: int
        :keyword schedule: Defines the schedule used by Chaos.
        :paramtype schedule: ~azure.servicefabric.models.ChaosSchedule
        """
        super(ChaosScheduleDescription, self).__init__(**kwargs)
        self.version = kwargs.get('version', None)
        self.schedule = kwargs.get('schedule', None)


class ChaosScheduleJob(msrest.serialization.Model):
    """Defines a repetition rule and parameters of Chaos to be used with the Chaos Schedule.

    :ivar chaos_parameters: A reference to which Chaos Parameters of the Chaos Schedule to use.
    :vartype chaos_parameters: str
    :ivar days: Defines the days of the week that a Chaos Schedule Job will run for.
    :vartype days: ~azure.servicefabric.models.ChaosScheduleJobActiveDaysOfWeek
    :ivar times: A list of Time Ranges that specify when during active days that this job will run.
     The times are interpreted as UTC.
    :vartype times: list[~azure.servicefabric.models.TimeRange]
    """

    _attribute_map = {
        'chaos_parameters': {'key': 'ChaosParameters', 'type': 'str'},
        'days': {'key': 'Days', 'type': 'ChaosScheduleJobActiveDaysOfWeek'},
        'times': {'key': 'Times', 'type': '[TimeRange]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword chaos_parameters: A reference to which Chaos Parameters of the Chaos Schedule to use.
        :paramtype chaos_parameters: str
        :keyword days: Defines the days of the week that a Chaos Schedule Job will run for.
        :paramtype days: ~azure.servicefabric.models.ChaosScheduleJobActiveDaysOfWeek
        :keyword times: A list of Time Ranges that specify when during active days that this job will
         run. The times are interpreted as UTC.
        :paramtype times: list[~azure.servicefabric.models.TimeRange]
        """
        super(ChaosScheduleJob, self).__init__(**kwargs)
        self.chaos_parameters = kwargs.get('chaos_parameters', None)
        self.days = kwargs.get('days', None)
        self.times = kwargs.get('times', None)


class ChaosScheduleJobActiveDaysOfWeek(msrest.serialization.Model):
    """Defines the days of the week that a Chaos Schedule Job will run for.

    :ivar sunday: Indicates if the Chaos Schedule Job will run on Sunday.
    :vartype sunday: bool
    :ivar monday: Indicates if the Chaos Schedule Job will run on Monday.
    :vartype monday: bool
    :ivar tuesday: Indicates if the Chaos Schedule Job will run on Tuesday.
    :vartype tuesday: bool
    :ivar wednesday: Indicates if the Chaos Schedule Job will run on Wednesday.
    :vartype wednesday: bool
    :ivar thursday: Indicates if the Chaos Schedule Job will run on Thursday.
    :vartype thursday: bool
    :ivar friday: Indicates if the Chaos Schedule Job will run on Friday.
    :vartype friday: bool
    :ivar saturday: Indicates if the Chaos Schedule Job will run on Saturday.
    :vartype saturday: bool
    """

    _attribute_map = {
        'sunday': {'key': 'Sunday', 'type': 'bool'},
        'monday': {'key': 'Monday', 'type': 'bool'},
        'tuesday': {'key': 'Tuesday', 'type': 'bool'},
        'wednesday': {'key': 'Wednesday', 'type': 'bool'},
        'thursday': {'key': 'Thursday', 'type': 'bool'},
        'friday': {'key': 'Friday', 'type': 'bool'},
        'saturday': {'key': 'Saturday', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword sunday: Indicates if the Chaos Schedule Job will run on Sunday.
        :paramtype sunday: bool
        :keyword monday: Indicates if the Chaos Schedule Job will run on Monday.
        :paramtype monday: bool
        :keyword tuesday: Indicates if the Chaos Schedule Job will run on Tuesday.
        :paramtype tuesday: bool
        :keyword wednesday: Indicates if the Chaos Schedule Job will run on Wednesday.
        :paramtype wednesday: bool
        :keyword thursday: Indicates if the Chaos Schedule Job will run on Thursday.
        :paramtype thursday: bool
        :keyword friday: Indicates if the Chaos Schedule Job will run on Friday.
        :paramtype friday: bool
        :keyword saturday: Indicates if the Chaos Schedule Job will run on Saturday.
        :paramtype saturday: bool
        """
        super(ChaosScheduleJobActiveDaysOfWeek, self).__init__(**kwargs)
        self.sunday = kwargs.get('sunday', False)
        self.monday = kwargs.get('monday', False)
        self.tuesday = kwargs.get('tuesday', False)
        self.wednesday = kwargs.get('wednesday', False)
        self.thursday = kwargs.get('thursday', False)
        self.friday = kwargs.get('friday', False)
        self.saturday = kwargs.get('saturday', False)


class ClusterEvent(FabricEvent):
    """Represents the base for all Cluster Events.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ChaosStartedEvent, ChaosStoppedEvent, ClusterHealthReportExpiredEvent, ClusterNewHealthReportEvent, ClusterUpgradeCompletedEvent, ClusterUpgradeDomainCompletedEvent, ClusterUpgradeRollbackCompletedEvent, ClusterUpgradeRollbackStartedEvent, ClusterUpgradeStartedEvent.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
    }

    _subtype_map = {
        'kind': {'ChaosStarted': 'ChaosStartedEvent', 'ChaosStopped': 'ChaosStoppedEvent', 'ClusterHealthReportExpired': 'ClusterHealthReportExpiredEvent', 'ClusterNewHealthReport': 'ClusterNewHealthReportEvent', 'ClusterUpgradeCompleted': 'ClusterUpgradeCompletedEvent', 'ClusterUpgradeDomainCompleted': 'ClusterUpgradeDomainCompletedEvent', 'ClusterUpgradeRollbackCompleted': 'ClusterUpgradeRollbackCompletedEvent', 'ClusterUpgradeRollbackStarted': 'ClusterUpgradeRollbackStartedEvent', 'ClusterUpgradeStarted': 'ClusterUpgradeStartedEvent'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        """
        super(ClusterEvent, self).__init__(**kwargs)
        self.kind = 'ClusterEvent'  # type: str


class ChaosStartedEvent(ClusterEvent):
    """Chaos Started event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar max_concurrent_faults: Required. Maximum number of concurrent faults.
    :vartype max_concurrent_faults: long
    :ivar time_to_run_in_seconds: Required. Time to run in seconds.
    :vartype time_to_run_in_seconds: float
    :ivar max_cluster_stabilization_timeout_in_seconds: Required. Maximum timeout for cluster
     stabilization in seconds.
    :vartype max_cluster_stabilization_timeout_in_seconds: float
    :ivar wait_time_between_iterations_in_seconds: Required. Wait time between iterations in
     seconds.
    :vartype wait_time_between_iterations_in_seconds: float
    :ivar wait_time_between_faults_in_seconds: Required. Wait time between faults in seconds.
    :vartype wait_time_between_faults_in_seconds: float
    :ivar move_replica_fault_enabled: Required. Indicates MoveReplica fault is enabled.
    :vartype move_replica_fault_enabled: bool
    :ivar included_node_type_list: Required. List of included Node types.
    :vartype included_node_type_list: str
    :ivar included_application_list: Required. List of included Applications.
    :vartype included_application_list: str
    :ivar cluster_health_policy: Required. Health policy.
    :vartype cluster_health_policy: str
    :ivar chaos_context: Required. Chaos Context.
    :vartype chaos_context: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'max_concurrent_faults': {'required': True},
        'time_to_run_in_seconds': {'required': True},
        'max_cluster_stabilization_timeout_in_seconds': {'required': True},
        'wait_time_between_iterations_in_seconds': {'required': True},
        'wait_time_between_faults_in_seconds': {'required': True},
        'move_replica_fault_enabled': {'required': True},
        'included_node_type_list': {'required': True},
        'included_application_list': {'required': True},
        'cluster_health_policy': {'required': True},
        'chaos_context': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'max_concurrent_faults': {'key': 'MaxConcurrentFaults', 'type': 'long'},
        'time_to_run_in_seconds': {'key': 'TimeToRunInSeconds', 'type': 'float'},
        'max_cluster_stabilization_timeout_in_seconds': {'key': 'MaxClusterStabilizationTimeoutInSeconds', 'type': 'float'},
        'wait_time_between_iterations_in_seconds': {'key': 'WaitTimeBetweenIterationsInSeconds', 'type': 'float'},
        'wait_time_between_faults_in_seconds': {'key': 'WaitTimeBetweenFaultsInSeconds', 'type': 'float'},
        'move_replica_fault_enabled': {'key': 'MoveReplicaFaultEnabled', 'type': 'bool'},
        'included_node_type_list': {'key': 'IncludedNodeTypeList', 'type': 'str'},
        'included_application_list': {'key': 'IncludedApplicationList', 'type': 'str'},
        'cluster_health_policy': {'key': 'ClusterHealthPolicy', 'type': 'str'},
        'chaos_context': {'key': 'ChaosContext', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword max_concurrent_faults: Required. Maximum number of concurrent faults.
        :paramtype max_concurrent_faults: long
        :keyword time_to_run_in_seconds: Required. Time to run in seconds.
        :paramtype time_to_run_in_seconds: float
        :keyword max_cluster_stabilization_timeout_in_seconds: Required. Maximum timeout for cluster
         stabilization in seconds.
        :paramtype max_cluster_stabilization_timeout_in_seconds: float
        :keyword wait_time_between_iterations_in_seconds: Required. Wait time between iterations in
         seconds.
        :paramtype wait_time_between_iterations_in_seconds: float
        :keyword wait_time_between_faults_in_seconds: Required. Wait time between faults in seconds.
        :paramtype wait_time_between_faults_in_seconds: float
        :keyword move_replica_fault_enabled: Required. Indicates MoveReplica fault is enabled.
        :paramtype move_replica_fault_enabled: bool
        :keyword included_node_type_list: Required. List of included Node types.
        :paramtype included_node_type_list: str
        :keyword included_application_list: Required. List of included Applications.
        :paramtype included_application_list: str
        :keyword cluster_health_policy: Required. Health policy.
        :paramtype cluster_health_policy: str
        :keyword chaos_context: Required. Chaos Context.
        :paramtype chaos_context: str
        """
        super(ChaosStartedEvent, self).__init__(**kwargs)
        self.kind = 'ChaosStarted'  # type: str
        self.max_concurrent_faults = kwargs['max_concurrent_faults']
        self.time_to_run_in_seconds = kwargs['time_to_run_in_seconds']
        self.max_cluster_stabilization_timeout_in_seconds = kwargs['max_cluster_stabilization_timeout_in_seconds']
        self.wait_time_between_iterations_in_seconds = kwargs['wait_time_between_iterations_in_seconds']
        self.wait_time_between_faults_in_seconds = kwargs['wait_time_between_faults_in_seconds']
        self.move_replica_fault_enabled = kwargs['move_replica_fault_enabled']
        self.included_node_type_list = kwargs['included_node_type_list']
        self.included_application_list = kwargs['included_application_list']
        self.cluster_health_policy = kwargs['cluster_health_policy']
        self.chaos_context = kwargs['chaos_context']


class ChaosStoppedEvent(ClusterEvent):
    """Chaos Stopped event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar reason: Required. Describes reason.
    :vartype reason: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'reason': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'reason': {'key': 'Reason', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword reason: Required. Describes reason.
        :paramtype reason: str
        """
        super(ChaosStoppedEvent, self).__init__(**kwargs)
        self.kind = 'ChaosStopped'  # type: str
        self.reason = kwargs['reason']


class ChaosTargetFilter(msrest.serialization.Model):
    """Defines all filters for targeted Chaos faults, for example, faulting only certain node types or faulting only certain applications.
If ChaosTargetFilter is not used, Chaos faults all cluster entities. If ChaosTargetFilter is used, Chaos faults only the entities that meet the ChaosTargetFilter
specification. NodeTypeInclusionList and ApplicationInclusionList allow a union semantics only. It is not possible to specify an intersection
of NodeTypeInclusionList and ApplicationInclusionList. For example, it is not possible to specify "fault this application only when it is on that node type."
Once an entity is included in either NodeTypeInclusionList or ApplicationInclusionList, that entity cannot be excluded using ChaosTargetFilter. Even if
applicationX does not appear in ApplicationInclusionList, in some Chaos iteration applicationX can be faulted because it happens to be on a node of nodeTypeY that is included
in NodeTypeInclusionList. If both NodeTypeInclusionList and ApplicationInclusionList are null or empty, an ArgumentException is thrown.

    :ivar node_type_inclusion_list: A list of node types to include in Chaos faults.
     All types of faults (restart node, restart code package, remove replica, restart replica, move
     primary, and move secondary) are enabled for the nodes of these node types.
     If a node type (say NodeTypeX) does not appear in the NodeTypeInclusionList, then node level
     faults (like NodeRestart) will never be enabled for the nodes of
     NodeTypeX, but code package and replica faults can still be enabled for NodeTypeX if an
     application in the ApplicationInclusionList.
     happens to reside on a node of NodeTypeX.
     At most 100 node type names can be included in this list, to increase this number, a config
     upgrade is required for MaxNumberOfNodeTypesInChaosEntityFilter configuration.
    :vartype node_type_inclusion_list: list[str]
    :ivar application_inclusion_list: A list of application URIs to include in Chaos faults.
     All replicas belonging to services of these applications are amenable to replica faults
     (restart replica, remove replica, move primary, and move secondary) by Chaos.
     Chaos may restart a code package only if the code package hosts replicas of these applications
     only.
     If an application does not appear in this list, it can still be faulted in some Chaos
     iteration if the application ends up on a node of a node type that is included in
     NodeTypeInclusionList.
     However, if applicationX is tied to nodeTypeY through placement constraints and applicationX
     is absent from ApplicationInclusionList and nodeTypeY is absent from NodeTypeInclusionList,
     then applicationX will never be faulted.
     At most 1000 application names can be included in this list, to increase this number, a config
     upgrade is required for MaxNumberOfApplicationsInChaosEntityFilter configuration.
    :vartype application_inclusion_list: list[str]
    """

    _attribute_map = {
        'node_type_inclusion_list': {'key': 'NodeTypeInclusionList', 'type': '[str]'},
        'application_inclusion_list': {'key': 'ApplicationInclusionList', 'type': '[str]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword node_type_inclusion_list: A list of node types to include in Chaos faults.
         All types of faults (restart node, restart code package, remove replica, restart replica, move
         primary, and move secondary) are enabled for the nodes of these node types.
         If a node type (say NodeTypeX) does not appear in the NodeTypeInclusionList, then node level
         faults (like NodeRestart) will never be enabled for the nodes of
         NodeTypeX, but code package and replica faults can still be enabled for NodeTypeX if an
         application in the ApplicationInclusionList.
         happens to reside on a node of NodeTypeX.
         At most 100 node type names can be included in this list, to increase this number, a config
         upgrade is required for MaxNumberOfNodeTypesInChaosEntityFilter configuration.
        :paramtype node_type_inclusion_list: list[str]
        :keyword application_inclusion_list: A list of application URIs to include in Chaos faults.
         All replicas belonging to services of these applications are amenable to replica faults
         (restart replica, remove replica, move primary, and move secondary) by Chaos.
         Chaos may restart a code package only if the code package hosts replicas of these applications
         only.
         If an application does not appear in this list, it can still be faulted in some Chaos
         iteration if the application ends up on a node of a node type that is included in
         NodeTypeInclusionList.
         However, if applicationX is tied to nodeTypeY through placement constraints and applicationX
         is absent from ApplicationInclusionList and nodeTypeY is absent from NodeTypeInclusionList,
         then applicationX will never be faulted.
         At most 1000 application names can be included in this list, to increase this number, a config
         upgrade is required for MaxNumberOfApplicationsInChaosEntityFilter configuration.
        :paramtype application_inclusion_list: list[str]
        """
        super(ChaosTargetFilter, self).__init__(**kwargs)
        self.node_type_inclusion_list = kwargs.get('node_type_inclusion_list', None)
        self.application_inclusion_list = kwargs.get('application_inclusion_list', None)


class PropertyBatchOperation(msrest.serialization.Model):
    """Represents the base type for property operations that can be put into a batch and submitted.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: CheckExistsPropertyBatchOperation, CheckSequencePropertyBatchOperation, CheckValuePropertyBatchOperation, DeletePropertyBatchOperation, GetPropertyBatchOperation, PutPropertyBatchOperation.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property batch operation, determined by the operation to be
     performed. The following are the possible values.Constant filled by server. Possible values
     include: "Invalid", "Put", "Get", "CheckExists", "CheckSequence", "Delete", "CheckValue".
    :vartype kind: str or ~azure.servicefabric.models.PropertyBatchOperationKind
    :ivar property_name: Required. The name of the Service Fabric property.
    :vartype property_name: str
    """

    _validation = {
        'kind': {'required': True},
        'property_name': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'property_name': {'key': 'PropertyName', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'CheckExists': 'CheckExistsPropertyBatchOperation', 'CheckSequence': 'CheckSequencePropertyBatchOperation', 'CheckValue': 'CheckValuePropertyBatchOperation', 'Delete': 'DeletePropertyBatchOperation', 'Get': 'GetPropertyBatchOperation', 'Put': 'PutPropertyBatchOperation'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword property_name: Required. The name of the Service Fabric property.
        :paramtype property_name: str
        """
        super(PropertyBatchOperation, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]
        self.property_name = kwargs['property_name']


class CheckExistsPropertyBatchOperation(PropertyBatchOperation):
    """Represents a PropertyBatchOperation that compares the Boolean existence of a property with the Exists argument.
The PropertyBatchOperation operation fails if the property's existence is not equal to the Exists argument.
The CheckExistsPropertyBatchOperation is generally used as a precondition for the write operations in the batch.
Note that if one PropertyBatchOperation in a PropertyBatch fails,
the entire batch fails and cannot be committed in a transactional manner.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property batch operation, determined by the operation to be
     performed. The following are the possible values.Constant filled by server. Possible values
     include: "Invalid", "Put", "Get", "CheckExists", "CheckSequence", "Delete", "CheckValue".
    :vartype kind: str or ~azure.servicefabric.models.PropertyBatchOperationKind
    :ivar property_name: Required. The name of the Service Fabric property.
    :vartype property_name: str
    :ivar exists: Required. Whether or not the property should exist for the operation to pass.
    :vartype exists: bool
    """

    _validation = {
        'kind': {'required': True},
        'property_name': {'required': True},
        'exists': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'property_name': {'key': 'PropertyName', 'type': 'str'},
        'exists': {'key': 'Exists', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword property_name: Required. The name of the Service Fabric property.
        :paramtype property_name: str
        :keyword exists: Required. Whether or not the property should exist for the operation to pass.
        :paramtype exists: bool
        """
        super(CheckExistsPropertyBatchOperation, self).__init__(**kwargs)
        self.kind = 'CheckExists'  # type: str
        self.exists = kwargs['exists']


class CheckSequencePropertyBatchOperation(PropertyBatchOperation):
    """Compares the Sequence Number of a property with the SequenceNumber argument.
A property's sequence number can be thought of as that property's version.
Every time the property is modified, its sequence number is increased.
The sequence number can be found in a property's metadata.
The comparison fails if the sequence numbers are not equal.
CheckSequencePropertyBatchOperation is generally used as a precondition for the write operations in the batch.
Note that if one PropertyBatchOperation in a PropertyBatch fails,
the entire batch fails and cannot be committed in a transactional manner.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property batch operation, determined by the operation to be
     performed. The following are the possible values.Constant filled by server. Possible values
     include: "Invalid", "Put", "Get", "CheckExists", "CheckSequence", "Delete", "CheckValue".
    :vartype kind: str or ~azure.servicefabric.models.PropertyBatchOperationKind
    :ivar property_name: Required. The name of the Service Fabric property.
    :vartype property_name: str
    :ivar sequence_number: Required. The expected sequence number.
    :vartype sequence_number: str
    """

    _validation = {
        'kind': {'required': True},
        'property_name': {'required': True},
        'sequence_number': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'property_name': {'key': 'PropertyName', 'type': 'str'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword property_name: Required. The name of the Service Fabric property.
        :paramtype property_name: str
        :keyword sequence_number: Required. The expected sequence number.
        :paramtype sequence_number: str
        """
        super(CheckSequencePropertyBatchOperation, self).__init__(**kwargs)
        self.kind = 'CheckSequence'  # type: str
        self.sequence_number = kwargs['sequence_number']


class CheckValuePropertyBatchOperation(PropertyBatchOperation):
    """Represents a PropertyBatchOperation that compares the value of the property with the expected value.
The CheckValuePropertyBatchOperation is generally used as a precondition for the write operations in the batch.
Note that if one PropertyBatchOperation in a PropertyBatch fails,
the entire batch fails and cannot be committed in a transactional manner.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property batch operation, determined by the operation to be
     performed. The following are the possible values.Constant filled by server. Possible values
     include: "Invalid", "Put", "Get", "CheckExists", "CheckSequence", "Delete", "CheckValue".
    :vartype kind: str or ~azure.servicefabric.models.PropertyBatchOperationKind
    :ivar property_name: Required. The name of the Service Fabric property.
    :vartype property_name: str
    :ivar value: Required. The expected property value.
    :vartype value: ~azure.servicefabric.models.PropertyValue
    """

    _validation = {
        'kind': {'required': True},
        'property_name': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'property_name': {'key': 'PropertyName', 'type': 'str'},
        'value': {'key': 'Value', 'type': 'PropertyValue'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword property_name: Required. The name of the Service Fabric property.
        :paramtype property_name: str
        :keyword value: Required. The expected property value.
        :paramtype value: ~azure.servicefabric.models.PropertyValue
        """
        super(CheckValuePropertyBatchOperation, self).__init__(**kwargs)
        self.kind = 'CheckValue'  # type: str
        self.value = kwargs['value']


class ClusterConfiguration(msrest.serialization.Model):
    """Information about the standalone cluster configuration.

    :ivar cluster_configuration: The contents of the cluster configuration file.
    :vartype cluster_configuration: str
    """

    _attribute_map = {
        'cluster_configuration': {'key': 'ClusterConfiguration', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword cluster_configuration: The contents of the cluster configuration file.
        :paramtype cluster_configuration: str
        """
        super(ClusterConfiguration, self).__init__(**kwargs)
        self.cluster_configuration = kwargs.get('cluster_configuration', None)


class ClusterConfigurationUpgradeDescription(msrest.serialization.Model):
    """Describes the parameters for a standalone cluster configuration upgrade.

    All required parameters must be populated in order to send to Azure.

    :ivar cluster_config: Required. The cluster configuration as a JSON string. For example, `this
     file
     <https://github.com/Azure-Samples/service-fabric-dotnet-standalone-cluster-configuration/blob/master/Samples/ClusterConfig.Unsecure.DevCluster.json>`_
     contains JSON describing the `nodes and other properties of the cluster
     <https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-manifest>`_.
    :vartype cluster_config: str
    :ivar health_check_retry_timeout: The length of time between attempts to perform health checks
     if the application or cluster is not healthy.
    :vartype health_check_retry_timeout: ~datetime.timedelta
    :ivar health_check_wait_duration_in_seconds: The length of time to wait after completing an
     upgrade domain before starting the health checks process.
    :vartype health_check_wait_duration_in_seconds: ~datetime.timedelta
    :ivar health_check_stable_duration_in_seconds: The length of time that the application or
     cluster must remain healthy before the upgrade proceeds to the next upgrade domain.
    :vartype health_check_stable_duration_in_seconds: ~datetime.timedelta
    :ivar upgrade_domain_timeout_in_seconds: The timeout for the upgrade domain.
    :vartype upgrade_domain_timeout_in_seconds: ~datetime.timedelta
    :ivar upgrade_timeout_in_seconds: The upgrade timeout.
    :vartype upgrade_timeout_in_seconds: ~datetime.timedelta
    :ivar max_percent_unhealthy_applications: The maximum allowed percentage of unhealthy
     applications during the upgrade. Allowed values are integer values from zero to 100.
    :vartype max_percent_unhealthy_applications: int
    :ivar max_percent_unhealthy_nodes: The maximum allowed percentage of unhealthy nodes during the
     upgrade. Allowed values are integer values from zero to 100.
    :vartype max_percent_unhealthy_nodes: int
    :ivar max_percent_delta_unhealthy_nodes: The maximum allowed percentage of delta health
     degradation during the upgrade. Allowed values are integer values from zero to 100.
    :vartype max_percent_delta_unhealthy_nodes: int
    :ivar max_percent_upgrade_domain_delta_unhealthy_nodes: The maximum allowed percentage of
     upgrade domain delta health degradation during the upgrade. Allowed values are integer values
     from zero to 100.
    :vartype max_percent_upgrade_domain_delta_unhealthy_nodes: int
    :ivar application_health_policies: Defines the application health policy map used to evaluate
     the health of an application or one of its children entities.
    :vartype application_health_policies: ~azure.servicefabric.models.ApplicationHealthPolicies
    """

    _validation = {
        'cluster_config': {'required': True},
    }

    _attribute_map = {
        'cluster_config': {'key': 'ClusterConfig', 'type': 'str'},
        'health_check_retry_timeout': {'key': 'HealthCheckRetryTimeout', 'type': 'duration'},
        'health_check_wait_duration_in_seconds': {'key': 'HealthCheckWaitDurationInSeconds', 'type': 'duration'},
        'health_check_stable_duration_in_seconds': {'key': 'HealthCheckStableDurationInSeconds', 'type': 'duration'},
        'upgrade_domain_timeout_in_seconds': {'key': 'UpgradeDomainTimeoutInSeconds', 'type': 'duration'},
        'upgrade_timeout_in_seconds': {'key': 'UpgradeTimeoutInSeconds', 'type': 'duration'},
        'max_percent_unhealthy_applications': {'key': 'MaxPercentUnhealthyApplications', 'type': 'int'},
        'max_percent_unhealthy_nodes': {'key': 'MaxPercentUnhealthyNodes', 'type': 'int'},
        'max_percent_delta_unhealthy_nodes': {'key': 'MaxPercentDeltaUnhealthyNodes', 'type': 'int'},
        'max_percent_upgrade_domain_delta_unhealthy_nodes': {'key': 'MaxPercentUpgradeDomainDeltaUnhealthyNodes', 'type': 'int'},
        'application_health_policies': {'key': 'ApplicationHealthPolicies', 'type': 'ApplicationHealthPolicies'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword cluster_config: Required. The cluster configuration as a JSON string. For example,
         `this file
         <https://github.com/Azure-Samples/service-fabric-dotnet-standalone-cluster-configuration/blob/master/Samples/ClusterConfig.Unsecure.DevCluster.json>`_
         contains JSON describing the `nodes and other properties of the cluster
         <https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-manifest>`_.
        :paramtype cluster_config: str
        :keyword health_check_retry_timeout: The length of time between attempts to perform health
         checks if the application or cluster is not healthy.
        :paramtype health_check_retry_timeout: ~datetime.timedelta
        :keyword health_check_wait_duration_in_seconds: The length of time to wait after completing an
         upgrade domain before starting the health checks process.
        :paramtype health_check_wait_duration_in_seconds: ~datetime.timedelta
        :keyword health_check_stable_duration_in_seconds: The length of time that the application or
         cluster must remain healthy before the upgrade proceeds to the next upgrade domain.
        :paramtype health_check_stable_duration_in_seconds: ~datetime.timedelta
        :keyword upgrade_domain_timeout_in_seconds: The timeout for the upgrade domain.
        :paramtype upgrade_domain_timeout_in_seconds: ~datetime.timedelta
        :keyword upgrade_timeout_in_seconds: The upgrade timeout.
        :paramtype upgrade_timeout_in_seconds: ~datetime.timedelta
        :keyword max_percent_unhealthy_applications: The maximum allowed percentage of unhealthy
         applications during the upgrade. Allowed values are integer values from zero to 100.
        :paramtype max_percent_unhealthy_applications: int
        :keyword max_percent_unhealthy_nodes: The maximum allowed percentage of unhealthy nodes during
         the upgrade. Allowed values are integer values from zero to 100.
        :paramtype max_percent_unhealthy_nodes: int
        :keyword max_percent_delta_unhealthy_nodes: The maximum allowed percentage of delta health
         degradation during the upgrade. Allowed values are integer values from zero to 100.
        :paramtype max_percent_delta_unhealthy_nodes: int
        :keyword max_percent_upgrade_domain_delta_unhealthy_nodes: The maximum allowed percentage of
         upgrade domain delta health degradation during the upgrade. Allowed values are integer values
         from zero to 100.
        :paramtype max_percent_upgrade_domain_delta_unhealthy_nodes: int
        :keyword application_health_policies: Defines the application health policy map used to
         evaluate the health of an application or one of its children entities.
        :paramtype application_health_policies: ~azure.servicefabric.models.ApplicationHealthPolicies
        """
        super(ClusterConfigurationUpgradeDescription, self).__init__(**kwargs)
        self.cluster_config = kwargs['cluster_config']
        self.health_check_retry_timeout = kwargs.get('health_check_retry_timeout', "PT0H0M0S")
        self.health_check_wait_duration_in_seconds = kwargs.get('health_check_wait_duration_in_seconds', "PT0H0M0S")
        self.health_check_stable_duration_in_seconds = kwargs.get('health_check_stable_duration_in_seconds', "PT0H0M0S")
        self.upgrade_domain_timeout_in_seconds = kwargs.get('upgrade_domain_timeout_in_seconds', "PT0H0M0S")
        self.upgrade_timeout_in_seconds = kwargs.get('upgrade_timeout_in_seconds', "PT0H0M0S")
        self.max_percent_unhealthy_applications = kwargs.get('max_percent_unhealthy_applications', 0)
        self.max_percent_unhealthy_nodes = kwargs.get('max_percent_unhealthy_nodes', 0)
        self.max_percent_delta_unhealthy_nodes = kwargs.get('max_percent_delta_unhealthy_nodes', 0)
        self.max_percent_upgrade_domain_delta_unhealthy_nodes = kwargs.get('max_percent_upgrade_domain_delta_unhealthy_nodes', 0)
        self.application_health_policies = kwargs.get('application_health_policies', None)


class ClusterConfigurationUpgradeStatusInfo(msrest.serialization.Model):
    """Information about a standalone cluster configuration upgrade status.

    :ivar upgrade_state: The state of the upgrade domain. Possible values include: "Invalid",
     "RollingBackInProgress", "RollingBackCompleted", "RollingForwardPending",
     "RollingForwardInProgress", "RollingForwardCompleted", "Failed".
    :vartype upgrade_state: str or ~azure.servicefabric.models.UpgradeState
    :ivar progress_status: The cluster manifest version.
    :vartype progress_status: int
    :ivar config_version: The cluster configuration version.
    :vartype config_version: str
    :ivar details: The cluster upgrade status details.
    :vartype details: str
    """

    _attribute_map = {
        'upgrade_state': {'key': 'UpgradeState', 'type': 'str'},
        'progress_status': {'key': 'ProgressStatus', 'type': 'int'},
        'config_version': {'key': 'ConfigVersion', 'type': 'str'},
        'details': {'key': 'Details', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword upgrade_state: The state of the upgrade domain. Possible values include: "Invalid",
         "RollingBackInProgress", "RollingBackCompleted", "RollingForwardPending",
         "RollingForwardInProgress", "RollingForwardCompleted", "Failed".
        :paramtype upgrade_state: str or ~azure.servicefabric.models.UpgradeState
        :keyword progress_status: The cluster manifest version.
        :paramtype progress_status: int
        :keyword config_version: The cluster configuration version.
        :paramtype config_version: str
        :keyword details: The cluster upgrade status details.
        :paramtype details: str
        """
        super(ClusterConfigurationUpgradeStatusInfo, self).__init__(**kwargs)
        self.upgrade_state = kwargs.get('upgrade_state', None)
        self.progress_status = kwargs.get('progress_status', None)
        self.config_version = kwargs.get('config_version', None)
        self.details = kwargs.get('details', None)


class ClusterHealth(EntityHealth):
    """Represents the health of the cluster.
Contains the cluster aggregated health state, the cluster application and node health states as well as the health events and the unhealthy evaluations.

    :ivar aggregated_health_state: The HealthState representing the aggregated health state of the
     entity computed by Health Manager.
     The health evaluation of the entity reflects all events reported on the entity and its
     children (if any).
     The aggregation is done by applying the desired health policy. Possible values include:
     "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar health_events: The list of health events reported on the entity.
    :vartype health_events: list[~azure.servicefabric.models.HealthEvent]
    :ivar unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
     health state was returned by Health Manager.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    :ivar health_statistics: Shows the health statistics for all children types of the queried
     entity.
    :vartype health_statistics: ~azure.servicefabric.models.HealthStatistics
    :ivar node_health_states: Cluster node health states as found in the health store.
    :vartype node_health_states: list[~azure.servicefabric.models.NodeHealthState]
    :ivar application_health_states: Cluster application health states as found in the health
     store.
    :vartype application_health_states: list[~azure.servicefabric.models.ApplicationHealthState]
    """

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'health_events': {'key': 'HealthEvents', 'type': '[HealthEvent]'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
        'health_statistics': {'key': 'HealthStatistics', 'type': 'HealthStatistics'},
        'node_health_states': {'key': 'NodeHealthStates', 'type': '[NodeHealthState]'},
        'application_health_states': {'key': 'ApplicationHealthStates', 'type': '[ApplicationHealthState]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The HealthState representing the aggregated health state of
         the entity computed by Health Manager.
         The health evaluation of the entity reflects all events reported on the entity and its
         children (if any).
         The aggregation is done by applying the desired health policy. Possible values include:
         "Invalid", "Ok", "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword health_events: The list of health events reported on the entity.
        :paramtype health_events: list[~azure.servicefabric.models.HealthEvent]
        :keyword unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
         health state was returned by Health Manager.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        :keyword health_statistics: Shows the health statistics for all children types of the queried
         entity.
        :paramtype health_statistics: ~azure.servicefabric.models.HealthStatistics
        :keyword node_health_states: Cluster node health states as found in the health store.
        :paramtype node_health_states: list[~azure.servicefabric.models.NodeHealthState]
        :keyword application_health_states: Cluster application health states as found in the health
         store.
        :paramtype application_health_states: list[~azure.servicefabric.models.ApplicationHealthState]
        """
        super(ClusterHealth, self).__init__(**kwargs)
        self.node_health_states = kwargs.get('node_health_states', None)
        self.application_health_states = kwargs.get('application_health_states', None)


class ClusterHealthChunk(msrest.serialization.Model):
    """Represents the health chunk of the cluster.
Contains the cluster aggregated health state, and the cluster entities that respect the input filter.

    :ivar health_state: The HealthState representing the aggregated health state of the cluster
     computed by Health Manager.
     The health evaluation of the entity reflects all events reported on the entity and its
     children (if any).
     The aggregation is done by applying the desired cluster health policy and the application
     health policies. Possible values include: "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar node_health_state_chunks: The list of node health state chunks in the cluster that
     respect the filters in the cluster health chunk query description.
    :vartype node_health_state_chunks: ~azure.servicefabric.models.NodeHealthStateChunkList
    :ivar application_health_state_chunks: The list of application health state chunks in the
     cluster that respect the filters in the cluster health chunk query description.
    :vartype application_health_state_chunks:
     ~azure.servicefabric.models.ApplicationHealthStateChunkList
    """

    _attribute_map = {
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'node_health_state_chunks': {'key': 'NodeHealthStateChunks', 'type': 'NodeHealthStateChunkList'},
        'application_health_state_chunks': {'key': 'ApplicationHealthStateChunks', 'type': 'ApplicationHealthStateChunkList'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword health_state: The HealthState representing the aggregated health state of the cluster
         computed by Health Manager.
         The health evaluation of the entity reflects all events reported on the entity and its
         children (if any).
         The aggregation is done by applying the desired cluster health policy and the application
         health policies. Possible values include: "Invalid", "Ok", "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword node_health_state_chunks: The list of node health state chunks in the cluster that
         respect the filters in the cluster health chunk query description.
        :paramtype node_health_state_chunks: ~azure.servicefabric.models.NodeHealthStateChunkList
        :keyword application_health_state_chunks: The list of application health state chunks in the
         cluster that respect the filters in the cluster health chunk query description.
        :paramtype application_health_state_chunks:
         ~azure.servicefabric.models.ApplicationHealthStateChunkList
        """
        super(ClusterHealthChunk, self).__init__(**kwargs)
        self.health_state = kwargs.get('health_state', None)
        self.node_health_state_chunks = kwargs.get('node_health_state_chunks', None)
        self.application_health_state_chunks = kwargs.get('application_health_state_chunks', None)


class ClusterHealthChunkQueryDescription(msrest.serialization.Model):
    """The cluster health chunk query description, which can specify the health policies to evaluate cluster health and very expressive filters to select which cluster entities to include in response.

    :ivar node_filters: Defines a list of filters that specify which nodes to be included in the
     returned cluster health chunk.
     If no filters are specified, no nodes are returned. All the nodes are used to evaluate the
     cluster's aggregated health state, regardless of the input filters.
     The cluster health chunk query may specify multiple node filters.
     For example, it can specify a filter to return all nodes with health state Error and another
     filter to always include a node identified by its NodeName.
    :vartype node_filters: list[~azure.servicefabric.models.NodeHealthStateFilter]
    :ivar application_filters: Defines a list of filters that specify which applications to be
     included in the returned cluster health chunk.
     If no filters are specified, no applications are returned. All the applications are used to
     evaluate the cluster's aggregated health state, regardless of the input filters.
     The cluster health chunk query may specify multiple application filters.
     For example, it can specify a filter to return all applications with health state Error and
     another filter to always include applications of a specified application type.
    :vartype application_filters: list[~azure.servicefabric.models.ApplicationHealthStateFilter]
    :ivar cluster_health_policy: Defines a health policy used to evaluate the health of the cluster
     or of a cluster node.
    :vartype cluster_health_policy: ~azure.servicefabric.models.ClusterHealthPolicy
    :ivar application_health_policies: Defines the application health policy map used to evaluate
     the health of an application or one of its children entities.
    :vartype application_health_policies: ~azure.servicefabric.models.ApplicationHealthPolicies
    """

    _attribute_map = {
        'node_filters': {'key': 'NodeFilters', 'type': '[NodeHealthStateFilter]'},
        'application_filters': {'key': 'ApplicationFilters', 'type': '[ApplicationHealthStateFilter]'},
        'cluster_health_policy': {'key': 'ClusterHealthPolicy', 'type': 'ClusterHealthPolicy'},
        'application_health_policies': {'key': 'ApplicationHealthPolicies', 'type': 'ApplicationHealthPolicies'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword node_filters: Defines a list of filters that specify which nodes to be included in the
         returned cluster health chunk.
         If no filters are specified, no nodes are returned. All the nodes are used to evaluate the
         cluster's aggregated health state, regardless of the input filters.
         The cluster health chunk query may specify multiple node filters.
         For example, it can specify a filter to return all nodes with health state Error and another
         filter to always include a node identified by its NodeName.
        :paramtype node_filters: list[~azure.servicefabric.models.NodeHealthStateFilter]
        :keyword application_filters: Defines a list of filters that specify which applications to be
         included in the returned cluster health chunk.
         If no filters are specified, no applications are returned. All the applications are used to
         evaluate the cluster's aggregated health state, regardless of the input filters.
         The cluster health chunk query may specify multiple application filters.
         For example, it can specify a filter to return all applications with health state Error and
         another filter to always include applications of a specified application type.
        :paramtype application_filters: list[~azure.servicefabric.models.ApplicationHealthStateFilter]
        :keyword cluster_health_policy: Defines a health policy used to evaluate the health of the
         cluster or of a cluster node.
        :paramtype cluster_health_policy: ~azure.servicefabric.models.ClusterHealthPolicy
        :keyword application_health_policies: Defines the application health policy map used to
         evaluate the health of an application or one of its children entities.
        :paramtype application_health_policies: ~azure.servicefabric.models.ApplicationHealthPolicies
        """
        super(ClusterHealthChunkQueryDescription, self).__init__(**kwargs)
        self.node_filters = kwargs.get('node_filters', None)
        self.application_filters = kwargs.get('application_filters', None)
        self.cluster_health_policy = kwargs.get('cluster_health_policy', None)
        self.application_health_policies = kwargs.get('application_health_policies', None)


class ClusterHealthPolicies(msrest.serialization.Model):
    """Health policies to evaluate cluster health.

    :ivar application_health_policy_map: Defines a map that contains specific application health
     policies for different applications.
     Each entry specifies as key the application name and as value an ApplicationHealthPolicy used
     to evaluate the application health.
     If an application is not specified in the map, the application health evaluation uses the
     ApplicationHealthPolicy found in its application manifest or the default application health
     policy (if no health policy is defined in the manifest).
     The map is empty by default.
    :vartype application_health_policy_map:
     list[~azure.servicefabric.models.ApplicationHealthPolicyMapItem]
    :ivar cluster_health_policy: Defines a health policy used to evaluate the health of the cluster
     or of a cluster node.
    :vartype cluster_health_policy: ~azure.servicefabric.models.ClusterHealthPolicy
    """

    _attribute_map = {
        'application_health_policy_map': {'key': 'ApplicationHealthPolicyMap', 'type': '[ApplicationHealthPolicyMapItem]'},
        'cluster_health_policy': {'key': 'ClusterHealthPolicy', 'type': 'ClusterHealthPolicy'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword application_health_policy_map: Defines a map that contains specific application health
         policies for different applications.
         Each entry specifies as key the application name and as value an ApplicationHealthPolicy used
         to evaluate the application health.
         If an application is not specified in the map, the application health evaluation uses the
         ApplicationHealthPolicy found in its application manifest or the default application health
         policy (if no health policy is defined in the manifest).
         The map is empty by default.
        :paramtype application_health_policy_map:
         list[~azure.servicefabric.models.ApplicationHealthPolicyMapItem]
        :keyword cluster_health_policy: Defines a health policy used to evaluate the health of the
         cluster or of a cluster node.
        :paramtype cluster_health_policy: ~azure.servicefabric.models.ClusterHealthPolicy
        """
        super(ClusterHealthPolicies, self).__init__(**kwargs)
        self.application_health_policy_map = kwargs.get('application_health_policy_map', None)
        self.cluster_health_policy = kwargs.get('cluster_health_policy', None)


class ClusterHealthPolicy(msrest.serialization.Model):
    """Defines a health policy used to evaluate the health of the cluster or of a cluster node.

    :ivar consider_warning_as_error: Indicates whether warnings are treated with the same severity
     as errors.
    :vartype consider_warning_as_error: bool
    :ivar max_percent_unhealthy_nodes: The maximum allowed percentage of unhealthy nodes before
     reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.
    
     The percentage represents the maximum tolerated percentage of nodes that can be unhealthy
     before the cluster is considered in error.
     If the percentage is respected but there is at least one unhealthy node, the health is
     evaluated as Warning.
     The percentage is calculated by dividing the number of unhealthy nodes over the total number
     of nodes in the cluster.
     The computation rounds up to tolerate one failure on small numbers of nodes. Default
     percentage is zero.
    
     In large clusters, some nodes will always be down or out for repairs, so this percentage
     should be configured to tolerate that.
    :vartype max_percent_unhealthy_nodes: int
    :ivar max_percent_unhealthy_applications: The maximum allowed percentage of unhealthy
     applications before reporting an error. For example, to allow 10% of applications to be
     unhealthy, this value would be 10.
    
     The percentage represents the maximum tolerated percentage of applications that can be
     unhealthy before the cluster is considered in error.
     If the percentage is respected but there is at least one unhealthy application, the health is
     evaluated as Warning.
     This is calculated by dividing the number of unhealthy applications over the total number of
     application instances in the cluster, excluding applications of application types that are
     included in the ApplicationTypeHealthPolicyMap.
     The computation rounds up to tolerate one failure on small numbers of applications. Default
     percentage is zero.
    :vartype max_percent_unhealthy_applications: int
    :ivar application_type_health_policy_map: Defines a map with max percentage unhealthy
     applications for specific application types.
     Each entry specifies as key the application type name and as value an integer that represents
     the MaxPercentUnhealthyApplications percentage used to evaluate the applications of the
     specified application type.
    
     The application type health policy map can be used during cluster health evaluation to
     describe special application types.
     The application types included in the map are evaluated against the percentage specified in
     the map, and not with the global MaxPercentUnhealthyApplications defined in the cluster health
     policy.
     The applications of application types specified in the map are not counted against the global
     pool of applications.
     For example, if some applications of a type are critical, the cluster administrator can add an
     entry to the map for that application type
     and assign it a value of 0% (that is, do not tolerate any failures).
     All other applications can be evaluated with MaxPercentUnhealthyApplications set to 20% to
     tolerate some failures out of the thousands of application instances.
     The application type health policy map is used only if the cluster manifest enables
     application type health evaluation using the configuration entry for
     HealthManager/EnableApplicationTypeHealthEvaluation.
    :vartype application_type_health_policy_map:
     list[~azure.servicefabric.models.ApplicationTypeHealthPolicyMapItem]
    :ivar node_type_health_policy_map: Defines a map with max percentage unhealthy nodes for
     specific node types.
     Each entry specifies as key the node type name and as value an integer that represents the
     MaxPercentUnhealthyNodes percentage used to evaluate the nodes of the specified node type.
    
     The node type health policy map can be used during cluster health evaluation to describe
     special node types.
     They are evaluated against the percentages associated with their node type name in the map.
     Setting this has no impact on the global pool of nodes used for MaxPercentUnhealthyNodes.
     The node type health policy map is used only if the cluster manifest enables node type health
     evaluation using the configuration entry for HealthManager/EnableNodeTypeHealthEvaluation.
    
     For example, given a cluster with many nodes of different types, with important work hosted on
     node type "SpecialNodeType" that should not tolerate any nodes down.
     You can specify global MaxPercentUnhealthyNodes to 20% to tolerate some failures for all
     nodes, but for the node type "SpecialNodeType", set the MaxPercentUnhealthyNodes to 0 by
     setting the value in the key value pair in NodeTypeHealthPolicyMapItem. The key is the node
     type name.
     This way, as long as no nodes of type "SpecialNodeType" are in Error state,
     even if some of the many nodes in the global pool are in Error state, but below the global
     unhealthy percentage, the cluster would be evaluated to Warning.
     A Warning health state does not impact cluster upgrade or other monitoring triggered by Error
     health state.
     But even one node of type SpecialNodeType in Error would make cluster unhealthy (in Error
     rather than Warning/Ok), which triggers rollback or pauses the cluster upgrade, depending on
     the upgrade configuration.
    
     Conversely, setting the global MaxPercentUnhealthyNodes to 0, and setting SpecialNodeType's
     max percent unhealthy nodes to 100,
     with one node of type SpecialNodeType in Error state would still put the cluster in an Error
     state, since the global restriction is more strict in this case.
    :vartype node_type_health_policy_map:
     list[~azure.servicefabric.models.NodeTypeHealthPolicyMapItem]
    """

    _attribute_map = {
        'consider_warning_as_error': {'key': 'ConsiderWarningAsError', 'type': 'bool'},
        'max_percent_unhealthy_nodes': {'key': 'MaxPercentUnhealthyNodes', 'type': 'int'},
        'max_percent_unhealthy_applications': {'key': 'MaxPercentUnhealthyApplications', 'type': 'int'},
        'application_type_health_policy_map': {'key': 'ApplicationTypeHealthPolicyMap', 'type': '[ApplicationTypeHealthPolicyMapItem]'},
        'node_type_health_policy_map': {'key': 'NodeTypeHealthPolicyMap', 'type': '[NodeTypeHealthPolicyMapItem]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword consider_warning_as_error: Indicates whether warnings are treated with the same
         severity as errors.
        :paramtype consider_warning_as_error: bool
        :keyword max_percent_unhealthy_nodes: The maximum allowed percentage of unhealthy nodes before
         reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.
        
         The percentage represents the maximum tolerated percentage of nodes that can be unhealthy
         before the cluster is considered in error.
         If the percentage is respected but there is at least one unhealthy node, the health is
         evaluated as Warning.
         The percentage is calculated by dividing the number of unhealthy nodes over the total number
         of nodes in the cluster.
         The computation rounds up to tolerate one failure on small numbers of nodes. Default
         percentage is zero.
        
         In large clusters, some nodes will always be down or out for repairs, so this percentage
         should be configured to tolerate that.
        :paramtype max_percent_unhealthy_nodes: int
        :keyword max_percent_unhealthy_applications: The maximum allowed percentage of unhealthy
         applications before reporting an error. For example, to allow 10% of applications to be
         unhealthy, this value would be 10.
        
         The percentage represents the maximum tolerated percentage of applications that can be
         unhealthy before the cluster is considered in error.
         If the percentage is respected but there is at least one unhealthy application, the health is
         evaluated as Warning.
         This is calculated by dividing the number of unhealthy applications over the total number of
         application instances in the cluster, excluding applications of application types that are
         included in the ApplicationTypeHealthPolicyMap.
         The computation rounds up to tolerate one failure on small numbers of applications. Default
         percentage is zero.
        :paramtype max_percent_unhealthy_applications: int
        :keyword application_type_health_policy_map: Defines a map with max percentage unhealthy
         applications for specific application types.
         Each entry specifies as key the application type name and as value an integer that represents
         the MaxPercentUnhealthyApplications percentage used to evaluate the applications of the
         specified application type.
        
         The application type health policy map can be used during cluster health evaluation to
         describe special application types.
         The application types included in the map are evaluated against the percentage specified in
         the map, and not with the global MaxPercentUnhealthyApplications defined in the cluster health
         policy.
         The applications of application types specified in the map are not counted against the global
         pool of applications.
         For example, if some applications of a type are critical, the cluster administrator can add an
         entry to the map for that application type
         and assign it a value of 0% (that is, do not tolerate any failures).
         All other applications can be evaluated with MaxPercentUnhealthyApplications set to 20% to
         tolerate some failures out of the thousands of application instances.
         The application type health policy map is used only if the cluster manifest enables
         application type health evaluation using the configuration entry for
         HealthManager/EnableApplicationTypeHealthEvaluation.
        :paramtype application_type_health_policy_map:
         list[~azure.servicefabric.models.ApplicationTypeHealthPolicyMapItem]
        :keyword node_type_health_policy_map: Defines a map with max percentage unhealthy nodes for
         specific node types.
         Each entry specifies as key the node type name and as value an integer that represents the
         MaxPercentUnhealthyNodes percentage used to evaluate the nodes of the specified node type.
        
         The node type health policy map can be used during cluster health evaluation to describe
         special node types.
         They are evaluated against the percentages associated with their node type name in the map.
         Setting this has no impact on the global pool of nodes used for MaxPercentUnhealthyNodes.
         The node type health policy map is used only if the cluster manifest enables node type health
         evaluation using the configuration entry for HealthManager/EnableNodeTypeHealthEvaluation.
        
         For example, given a cluster with many nodes of different types, with important work hosted on
         node type "SpecialNodeType" that should not tolerate any nodes down.
         You can specify global MaxPercentUnhealthyNodes to 20% to tolerate some failures for all
         nodes, but for the node type "SpecialNodeType", set the MaxPercentUnhealthyNodes to 0 by
         setting the value in the key value pair in NodeTypeHealthPolicyMapItem. The key is the node
         type name.
         This way, as long as no nodes of type "SpecialNodeType" are in Error state,
         even if some of the many nodes in the global pool are in Error state, but below the global
         unhealthy percentage, the cluster would be evaluated to Warning.
         A Warning health state does not impact cluster upgrade or other monitoring triggered by Error
         health state.
         But even one node of type SpecialNodeType in Error would make cluster unhealthy (in Error
         rather than Warning/Ok), which triggers rollback or pauses the cluster upgrade, depending on
         the upgrade configuration.
        
         Conversely, setting the global MaxPercentUnhealthyNodes to 0, and setting SpecialNodeType's
         max percent unhealthy nodes to 100,
         with one node of type SpecialNodeType in Error state would still put the cluster in an Error
         state, since the global restriction is more strict in this case.
        :paramtype node_type_health_policy_map:
         list[~azure.servicefabric.models.NodeTypeHealthPolicyMapItem]
        """
        super(ClusterHealthPolicy, self).__init__(**kwargs)
        self.consider_warning_as_error = kwargs.get('consider_warning_as_error', False)
        self.max_percent_unhealthy_nodes = kwargs.get('max_percent_unhealthy_nodes', 0)
        self.max_percent_unhealthy_applications = kwargs.get('max_percent_unhealthy_applications', 0)
        self.application_type_health_policy_map = kwargs.get('application_type_health_policy_map', None)
        self.node_type_health_policy_map = kwargs.get('node_type_health_policy_map', None)


class ClusterHealthReportExpiredEvent(ClusterEvent):
    """Cluster Health Report Expired event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(ClusterHealthReportExpiredEvent, self).__init__(**kwargs)
        self.kind = 'ClusterHealthReportExpired'  # type: str
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class ClusterLoadInfo(msrest.serialization.Model):
    """Information about load in a Service Fabric cluster. It holds a summary of all metrics and their load in a cluster.

    :ivar last_balancing_start_time_utc: The starting time of last resource balancing run.
    :vartype last_balancing_start_time_utc: ~datetime.datetime
    :ivar last_balancing_end_time_utc: The end time of last resource balancing run.
    :vartype last_balancing_end_time_utc: ~datetime.datetime
    :ivar load_metric_information: List that contains metrics and their load information in this
     cluster.
    :vartype load_metric_information: list[~azure.servicefabric.models.LoadMetricInformation]
    """

    _attribute_map = {
        'last_balancing_start_time_utc': {'key': 'LastBalancingStartTimeUtc', 'type': 'iso-8601'},
        'last_balancing_end_time_utc': {'key': 'LastBalancingEndTimeUtc', 'type': 'iso-8601'},
        'load_metric_information': {'key': 'LoadMetricInformation', 'type': '[LoadMetricInformation]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword last_balancing_start_time_utc: The starting time of last resource balancing run.
        :paramtype last_balancing_start_time_utc: ~datetime.datetime
        :keyword last_balancing_end_time_utc: The end time of last resource balancing run.
        :paramtype last_balancing_end_time_utc: ~datetime.datetime
        :keyword load_metric_information: List that contains metrics and their load information in this
         cluster.
        :paramtype load_metric_information: list[~azure.servicefabric.models.LoadMetricInformation]
        """
        super(ClusterLoadInfo, self).__init__(**kwargs)
        self.last_balancing_start_time_utc = kwargs.get('last_balancing_start_time_utc', None)
        self.last_balancing_end_time_utc = kwargs.get('last_balancing_end_time_utc', None)
        self.load_metric_information = kwargs.get('load_metric_information', None)


class ClusterManifest(msrest.serialization.Model):
    """Information about the cluster manifest.

    :ivar manifest: The contents of the cluster manifest file.
    :vartype manifest: str
    """

    _attribute_map = {
        'manifest': {'key': 'Manifest', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword manifest: The contents of the cluster manifest file.
        :paramtype manifest: str
        """
        super(ClusterManifest, self).__init__(**kwargs)
        self.manifest = kwargs.get('manifest', None)


class ClusterNewHealthReportEvent(ClusterEvent):
    """Cluster Health Report Created event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(ClusterNewHealthReportEvent, self).__init__(**kwargs)
        self.kind = 'ClusterNewHealthReport'  # type: str
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class ClusterUpgradeCompletedEvent(ClusterEvent):
    """Cluster Upgrade Completed event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar target_cluster_version: Required. Target Cluster version.
    :vartype target_cluster_version: str
    :ivar overall_upgrade_elapsed_time_in_ms: Required. Overall duration of upgrade in
     milli-seconds.
    :vartype overall_upgrade_elapsed_time_in_ms: float
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'target_cluster_version': {'required': True},
        'overall_upgrade_elapsed_time_in_ms': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'target_cluster_version': {'key': 'TargetClusterVersion', 'type': 'str'},
        'overall_upgrade_elapsed_time_in_ms': {'key': 'OverallUpgradeElapsedTimeInMs', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword target_cluster_version: Required. Target Cluster version.
        :paramtype target_cluster_version: str
        :keyword overall_upgrade_elapsed_time_in_ms: Required. Overall duration of upgrade in
         milli-seconds.
        :paramtype overall_upgrade_elapsed_time_in_ms: float
        """
        super(ClusterUpgradeCompletedEvent, self).__init__(**kwargs)
        self.kind = 'ClusterUpgradeCompleted'  # type: str
        self.target_cluster_version = kwargs['target_cluster_version']
        self.overall_upgrade_elapsed_time_in_ms = kwargs['overall_upgrade_elapsed_time_in_ms']


class ClusterUpgradeDescriptionObject(msrest.serialization.Model):
    """Represents a ServiceFabric cluster upgrade.

    :ivar config_version: The cluster configuration version (specified in the cluster manifest).
    :vartype config_version: str
    :ivar code_version: The ServiceFabric code version of the cluster.
    :vartype code_version: str
    :ivar upgrade_kind: The kind of upgrade out of the following possible values. Possible values
     include: "Invalid", "Rolling". Default value: "Rolling".
    :vartype upgrade_kind: str or ~azure.servicefabric.models.UpgradeKind
    :ivar rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
     values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred. Possible
     values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
     "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
    :vartype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
    :ivar upgrade_replica_set_check_timeout_in_seconds: The maximum amount of time to block
     processing of an upgrade domain and prevent loss of availability when there are unexpected
     issues. When this timeout expires, processing of the upgrade domain will proceed regardless of
     availability loss issues. The timeout is reset at the start of each upgrade domain. Valid
     values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
    :vartype upgrade_replica_set_check_timeout_in_seconds: long
    :ivar force_restart: If true, then processes are forcefully restarted during upgrade even when
     the code version has not changed (the upgrade only changes configuration or data).
    :vartype force_restart: bool
    :ivar sort_order: Defines the order in which an upgrade proceeds through the cluster. Possible
     values include: "Invalid", "Default", "Numeric", "Lexicographical", "ReverseNumeric",
     "ReverseLexicographical". Default value: "Default".
    :vartype sort_order: str or ~azure.servicefabric.models.UpgradeSortOrder
    :ivar enable_delta_health_evaluation: When true, enables delta health evaluation rather than
     absolute health evaluation after completion of each upgrade domain.
    :vartype enable_delta_health_evaluation: bool
    :ivar monitoring_policy: Describes the parameters for monitoring an upgrade in Monitored mode.
    :vartype monitoring_policy: ~azure.servicefabric.models.MonitoringPolicyDescription
    :ivar cluster_health_policy: Defines a health policy used to evaluate the health of the cluster
     or of a cluster node.
    :vartype cluster_health_policy: ~azure.servicefabric.models.ClusterHealthPolicy
    :ivar cluster_upgrade_health_policy: Defines a health policy used to evaluate the health of the
     cluster during a cluster upgrade.
    :vartype cluster_upgrade_health_policy:
     ~azure.servicefabric.models.ClusterUpgradeHealthPolicyObject
    :ivar application_health_policy_map: Represents the map of application health policies for a
     ServiceFabric cluster upgrade.
    :vartype application_health_policy_map:
     ~azure.servicefabric.models.ApplicationHealthPolicyMapObject
    """

    _attribute_map = {
        'config_version': {'key': 'ConfigVersion', 'type': 'str'},
        'code_version': {'key': 'CodeVersion', 'type': 'str'},
        'upgrade_kind': {'key': 'UpgradeKind', 'type': 'str'},
        'rolling_upgrade_mode': {'key': 'RollingUpgradeMode', 'type': 'str'},
        'upgrade_replica_set_check_timeout_in_seconds': {'key': 'UpgradeReplicaSetCheckTimeoutInSeconds', 'type': 'long'},
        'force_restart': {'key': 'ForceRestart', 'type': 'bool'},
        'sort_order': {'key': 'SortOrder', 'type': 'str'},
        'enable_delta_health_evaluation': {'key': 'EnableDeltaHealthEvaluation', 'type': 'bool'},
        'monitoring_policy': {'key': 'MonitoringPolicy', 'type': 'MonitoringPolicyDescription'},
        'cluster_health_policy': {'key': 'ClusterHealthPolicy', 'type': 'ClusterHealthPolicy'},
        'cluster_upgrade_health_policy': {'key': 'ClusterUpgradeHealthPolicy', 'type': 'ClusterUpgradeHealthPolicyObject'},
        'application_health_policy_map': {'key': 'ApplicationHealthPolicyMap', 'type': 'ApplicationHealthPolicyMapObject'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword config_version: The cluster configuration version (specified in the cluster manifest).
        :paramtype config_version: str
        :keyword code_version: The ServiceFabric code version of the cluster.
        :paramtype code_version: str
        :keyword upgrade_kind: The kind of upgrade out of the following possible values. Possible
         values include: "Invalid", "Rolling". Default value: "Rolling".
        :paramtype upgrade_kind: str or ~azure.servicefabric.models.UpgradeKind
        :keyword rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
         values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred. Possible
         values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
         "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
        :paramtype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
        :keyword upgrade_replica_set_check_timeout_in_seconds: The maximum amount of time to block
         processing of an upgrade domain and prevent loss of availability when there are unexpected
         issues. When this timeout expires, processing of the upgrade domain will proceed regardless of
         availability loss issues. The timeout is reset at the start of each upgrade domain. Valid
         values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
        :paramtype upgrade_replica_set_check_timeout_in_seconds: long
        :keyword force_restart: If true, then processes are forcefully restarted during upgrade even
         when the code version has not changed (the upgrade only changes configuration or data).
        :paramtype force_restart: bool
        :keyword sort_order: Defines the order in which an upgrade proceeds through the cluster.
         Possible values include: "Invalid", "Default", "Numeric", "Lexicographical", "ReverseNumeric",
         "ReverseLexicographical". Default value: "Default".
        :paramtype sort_order: str or ~azure.servicefabric.models.UpgradeSortOrder
        :keyword enable_delta_health_evaluation: When true, enables delta health evaluation rather than
         absolute health evaluation after completion of each upgrade domain.
        :paramtype enable_delta_health_evaluation: bool
        :keyword monitoring_policy: Describes the parameters for monitoring an upgrade in Monitored
         mode.
        :paramtype monitoring_policy: ~azure.servicefabric.models.MonitoringPolicyDescription
        :keyword cluster_health_policy: Defines a health policy used to evaluate the health of the
         cluster or of a cluster node.
        :paramtype cluster_health_policy: ~azure.servicefabric.models.ClusterHealthPolicy
        :keyword cluster_upgrade_health_policy: Defines a health policy used to evaluate the health of
         the cluster during a cluster upgrade.
        :paramtype cluster_upgrade_health_policy:
         ~azure.servicefabric.models.ClusterUpgradeHealthPolicyObject
        :keyword application_health_policy_map: Represents the map of application health policies for a
         ServiceFabric cluster upgrade.
        :paramtype application_health_policy_map:
         ~azure.servicefabric.models.ApplicationHealthPolicyMapObject
        """
        super(ClusterUpgradeDescriptionObject, self).__init__(**kwargs)
        self.config_version = kwargs.get('config_version', None)
        self.code_version = kwargs.get('code_version', None)
        self.upgrade_kind = kwargs.get('upgrade_kind', "Rolling")
        self.rolling_upgrade_mode = kwargs.get('rolling_upgrade_mode', "UnmonitoredAuto")
        self.upgrade_replica_set_check_timeout_in_seconds = kwargs.get('upgrade_replica_set_check_timeout_in_seconds', 42949672925)
        self.force_restart = kwargs.get('force_restart', False)
        self.sort_order = kwargs.get('sort_order', "Default")
        self.enable_delta_health_evaluation = kwargs.get('enable_delta_health_evaluation', None)
        self.monitoring_policy = kwargs.get('monitoring_policy', None)
        self.cluster_health_policy = kwargs.get('cluster_health_policy', None)
        self.cluster_upgrade_health_policy = kwargs.get('cluster_upgrade_health_policy', None)
        self.application_health_policy_map = kwargs.get('application_health_policy_map', None)


class ClusterUpgradeDomainCompletedEvent(ClusterEvent):
    """Cluster Upgrade Domain Completed event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar target_cluster_version: Required. Target Cluster version.
    :vartype target_cluster_version: str
    :ivar upgrade_state: Required. State of upgrade.
    :vartype upgrade_state: str
    :ivar upgrade_domains: Required. Upgrade domains.
    :vartype upgrade_domains: str
    :ivar upgrade_domain_elapsed_time_in_ms: Required. Duration of domain upgrade in milli-seconds.
    :vartype upgrade_domain_elapsed_time_in_ms: float
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'target_cluster_version': {'required': True},
        'upgrade_state': {'required': True},
        'upgrade_domains': {'required': True},
        'upgrade_domain_elapsed_time_in_ms': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'target_cluster_version': {'key': 'TargetClusterVersion', 'type': 'str'},
        'upgrade_state': {'key': 'UpgradeState', 'type': 'str'},
        'upgrade_domains': {'key': 'UpgradeDomains', 'type': 'str'},
        'upgrade_domain_elapsed_time_in_ms': {'key': 'UpgradeDomainElapsedTimeInMs', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword target_cluster_version: Required. Target Cluster version.
        :paramtype target_cluster_version: str
        :keyword upgrade_state: Required. State of upgrade.
        :paramtype upgrade_state: str
        :keyword upgrade_domains: Required. Upgrade domains.
        :paramtype upgrade_domains: str
        :keyword upgrade_domain_elapsed_time_in_ms: Required. Duration of domain upgrade in
         milli-seconds.
        :paramtype upgrade_domain_elapsed_time_in_ms: float
        """
        super(ClusterUpgradeDomainCompletedEvent, self).__init__(**kwargs)
        self.kind = 'ClusterUpgradeDomainCompleted'  # type: str
        self.target_cluster_version = kwargs['target_cluster_version']
        self.upgrade_state = kwargs['upgrade_state']
        self.upgrade_domains = kwargs['upgrade_domains']
        self.upgrade_domain_elapsed_time_in_ms = kwargs['upgrade_domain_elapsed_time_in_ms']


class ClusterUpgradeHealthPolicyObject(msrest.serialization.Model):
    """Defines a health policy used to evaluate the health of the cluster during a cluster upgrade.

    :ivar max_percent_delta_unhealthy_nodes: The maximum allowed percentage of nodes health
     degradation allowed during cluster upgrades. The delta is measured between the state of the
     nodes at the beginning of upgrade and the state of the nodes at the time of the health
     evaluation. The check is performed after every upgrade domain upgrade completion to make sure
     the global state of the cluster is within tolerated limits. The default value is 10%.
    :vartype max_percent_delta_unhealthy_nodes: int
    :ivar max_percent_upgrade_domain_delta_unhealthy_nodes: The maximum allowed percentage of
     upgrade domain nodes health degradation allowed during cluster upgrades. The delta is measured
     between the state of the upgrade domain nodes at the beginning of upgrade and the state of the
     upgrade domain nodes at the time of the health evaluation. The check is performed after every
     upgrade domain upgrade completion for all completed upgrade domains to make sure the state of
     the upgrade domains is within tolerated limits. The default value is 15%.
    :vartype max_percent_upgrade_domain_delta_unhealthy_nodes: int
    """

    _validation = {
        'max_percent_delta_unhealthy_nodes': {'maximum': 100, 'minimum': 0},
        'max_percent_upgrade_domain_delta_unhealthy_nodes': {'maximum': 100, 'minimum': 0},
    }

    _attribute_map = {
        'max_percent_delta_unhealthy_nodes': {'key': 'MaxPercentDeltaUnhealthyNodes', 'type': 'int'},
        'max_percent_upgrade_domain_delta_unhealthy_nodes': {'key': 'MaxPercentUpgradeDomainDeltaUnhealthyNodes', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword max_percent_delta_unhealthy_nodes: The maximum allowed percentage of nodes health
         degradation allowed during cluster upgrades. The delta is measured between the state of the
         nodes at the beginning of upgrade and the state of the nodes at the time of the health
         evaluation. The check is performed after every upgrade domain upgrade completion to make sure
         the global state of the cluster is within tolerated limits. The default value is 10%.
        :paramtype max_percent_delta_unhealthy_nodes: int
        :keyword max_percent_upgrade_domain_delta_unhealthy_nodes: The maximum allowed percentage of
         upgrade domain nodes health degradation allowed during cluster upgrades. The delta is measured
         between the state of the upgrade domain nodes at the beginning of upgrade and the state of the
         upgrade domain nodes at the time of the health evaluation. The check is performed after every
         upgrade domain upgrade completion for all completed upgrade domains to make sure the state of
         the upgrade domains is within tolerated limits. The default value is 15%.
        :paramtype max_percent_upgrade_domain_delta_unhealthy_nodes: int
        """
        super(ClusterUpgradeHealthPolicyObject, self).__init__(**kwargs)
        self.max_percent_delta_unhealthy_nodes = kwargs.get('max_percent_delta_unhealthy_nodes', None)
        self.max_percent_upgrade_domain_delta_unhealthy_nodes = kwargs.get('max_percent_upgrade_domain_delta_unhealthy_nodes', None)


class ClusterUpgradeProgressObject(msrest.serialization.Model):
    """Information about a cluster upgrade.

    :ivar code_version: The ServiceFabric code version of the cluster.
    :vartype code_version: str
    :ivar config_version: The cluster configuration version (specified in the cluster manifest).
    :vartype config_version: str
    :ivar upgrade_domains: List of upgrade domains and their statuses. Not applicable to
     node-by-node upgrades.
    :vartype upgrade_domains: list[~azure.servicefabric.models.UpgradeDomainInfo]
    :ivar upgrade_units: List of upgrade units and their statuses.
    :vartype upgrade_units: list[~azure.servicefabric.models.UpgradeUnitInfo]
    :ivar upgrade_state: The state of the upgrade domain. Possible values include: "Invalid",
     "RollingBackInProgress", "RollingBackCompleted", "RollingForwardPending",
     "RollingForwardInProgress", "RollingForwardCompleted", "Failed".
    :vartype upgrade_state: str or ~azure.servicefabric.models.UpgradeState
    :ivar next_upgrade_domain: The name of the next upgrade domain to be processed. Not applicable
     to node-by-node upgrades.
    :vartype next_upgrade_domain: str
    :ivar rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
     values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred. Possible
     values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
     "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
    :vartype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
    :ivar upgrade_description: Represents a ServiceFabric cluster upgrade.
    :vartype upgrade_description: ~azure.servicefabric.models.ClusterUpgradeDescriptionObject
    :ivar upgrade_duration_in_milliseconds: The estimated elapsed time spent processing the current
     overall upgrade.
    :vartype upgrade_duration_in_milliseconds: str
    :ivar upgrade_domain_duration_in_milliseconds: The estimated elapsed time spent processing the
     current upgrade domain. Not applicable to node-by-node upgrades.
    :vartype upgrade_domain_duration_in_milliseconds: str
    :ivar unhealthy_evaluations: List of health evaluations that resulted in the current aggregated
     health state.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    :ivar current_upgrade_domain_progress: Information about the current in-progress upgrade
     domain. Not applicable to node-by-node upgrades.
    :vartype current_upgrade_domain_progress:
     ~azure.servicefabric.models.CurrentUpgradeDomainProgressInfo
    :ivar current_upgrade_units_progress: Information about the current in-progress upgrade units.
    :vartype current_upgrade_units_progress:
     ~azure.servicefabric.models.CurrentUpgradeUnitsProgressInfo
    :ivar start_timestamp_utc: The start time of the upgrade in UTC.
    :vartype start_timestamp_utc: str
    :ivar failure_timestamp_utc: The failure time of the upgrade in UTC.
    :vartype failure_timestamp_utc: str
    :ivar failure_reason: The cause of an upgrade failure that resulted in FailureAction being
     executed. Possible values include: "None", "Interrupted", "HealthCheck",
     "UpgradeDomainTimeout", "OverallUpgradeTimeout".
    :vartype failure_reason: str or ~azure.servicefabric.models.FailureReason
    :ivar upgrade_domain_progress_at_failure: The detailed upgrade progress for nodes in the
     current upgrade domain at the point of failure. Not applicable to node-by-node upgrades.
    :vartype upgrade_domain_progress_at_failure:
     ~azure.servicefabric.models.FailedUpgradeDomainProgressObject
    :ivar is_node_by_node: Indicates whether this upgrade is node-by-node.
    :vartype is_node_by_node: bool
    """

    _attribute_map = {
        'code_version': {'key': 'CodeVersion', 'type': 'str'},
        'config_version': {'key': 'ConfigVersion', 'type': 'str'},
        'upgrade_domains': {'key': 'UpgradeDomains', 'type': '[UpgradeDomainInfo]'},
        'upgrade_units': {'key': 'UpgradeUnits', 'type': '[UpgradeUnitInfo]'},
        'upgrade_state': {'key': 'UpgradeState', 'type': 'str'},
        'next_upgrade_domain': {'key': 'NextUpgradeDomain', 'type': 'str'},
        'rolling_upgrade_mode': {'key': 'RollingUpgradeMode', 'type': 'str'},
        'upgrade_description': {'key': 'UpgradeDescription', 'type': 'ClusterUpgradeDescriptionObject'},
        'upgrade_duration_in_milliseconds': {'key': 'UpgradeDurationInMilliseconds', 'type': 'str'},
        'upgrade_domain_duration_in_milliseconds': {'key': 'UpgradeDomainDurationInMilliseconds', 'type': 'str'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
        'current_upgrade_domain_progress': {'key': 'CurrentUpgradeDomainProgress', 'type': 'CurrentUpgradeDomainProgressInfo'},
        'current_upgrade_units_progress': {'key': 'CurrentUpgradeUnitsProgress', 'type': 'CurrentUpgradeUnitsProgressInfo'},
        'start_timestamp_utc': {'key': 'StartTimestampUtc', 'type': 'str'},
        'failure_timestamp_utc': {'key': 'FailureTimestampUtc', 'type': 'str'},
        'failure_reason': {'key': 'FailureReason', 'type': 'str'},
        'upgrade_domain_progress_at_failure': {'key': 'UpgradeDomainProgressAtFailure', 'type': 'FailedUpgradeDomainProgressObject'},
        'is_node_by_node': {'key': 'IsNodeByNode', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword code_version: The ServiceFabric code version of the cluster.
        :paramtype code_version: str
        :keyword config_version: The cluster configuration version (specified in the cluster manifest).
        :paramtype config_version: str
        :keyword upgrade_domains: List of upgrade domains and their statuses. Not applicable to
         node-by-node upgrades.
        :paramtype upgrade_domains: list[~azure.servicefabric.models.UpgradeDomainInfo]
        :keyword upgrade_units: List of upgrade units and their statuses.
        :paramtype upgrade_units: list[~azure.servicefabric.models.UpgradeUnitInfo]
        :keyword upgrade_state: The state of the upgrade domain. Possible values include: "Invalid",
         "RollingBackInProgress", "RollingBackCompleted", "RollingForwardPending",
         "RollingForwardInProgress", "RollingForwardCompleted", "Failed".
        :paramtype upgrade_state: str or ~azure.servicefabric.models.UpgradeState
        :keyword next_upgrade_domain: The name of the next upgrade domain to be processed. Not
         applicable to node-by-node upgrades.
        :paramtype next_upgrade_domain: str
        :keyword rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
         values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred. Possible
         values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
         "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
        :paramtype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
        :keyword upgrade_description: Represents a ServiceFabric cluster upgrade.
        :paramtype upgrade_description: ~azure.servicefabric.models.ClusterUpgradeDescriptionObject
        :keyword upgrade_duration_in_milliseconds: The estimated elapsed time spent processing the
         current overall upgrade.
        :paramtype upgrade_duration_in_milliseconds: str
        :keyword upgrade_domain_duration_in_milliseconds: The estimated elapsed time spent processing
         the current upgrade domain. Not applicable to node-by-node upgrades.
        :paramtype upgrade_domain_duration_in_milliseconds: str
        :keyword unhealthy_evaluations: List of health evaluations that resulted in the current
         aggregated health state.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        :keyword current_upgrade_domain_progress: Information about the current in-progress upgrade
         domain. Not applicable to node-by-node upgrades.
        :paramtype current_upgrade_domain_progress:
         ~azure.servicefabric.models.CurrentUpgradeDomainProgressInfo
        :keyword current_upgrade_units_progress: Information about the current in-progress upgrade
         units.
        :paramtype current_upgrade_units_progress:
         ~azure.servicefabric.models.CurrentUpgradeUnitsProgressInfo
        :keyword start_timestamp_utc: The start time of the upgrade in UTC.
        :paramtype start_timestamp_utc: str
        :keyword failure_timestamp_utc: The failure time of the upgrade in UTC.
        :paramtype failure_timestamp_utc: str
        :keyword failure_reason: The cause of an upgrade failure that resulted in FailureAction being
         executed. Possible values include: "None", "Interrupted", "HealthCheck",
         "UpgradeDomainTimeout", "OverallUpgradeTimeout".
        :paramtype failure_reason: str or ~azure.servicefabric.models.FailureReason
        :keyword upgrade_domain_progress_at_failure: The detailed upgrade progress for nodes in the
         current upgrade domain at the point of failure. Not applicable to node-by-node upgrades.
        :paramtype upgrade_domain_progress_at_failure:
         ~azure.servicefabric.models.FailedUpgradeDomainProgressObject
        :keyword is_node_by_node: Indicates whether this upgrade is node-by-node.
        :paramtype is_node_by_node: bool
        """
        super(ClusterUpgradeProgressObject, self).__init__(**kwargs)
        self.code_version = kwargs.get('code_version', None)
        self.config_version = kwargs.get('config_version', None)
        self.upgrade_domains = kwargs.get('upgrade_domains', None)
        self.upgrade_units = kwargs.get('upgrade_units', None)
        self.upgrade_state = kwargs.get('upgrade_state', None)
        self.next_upgrade_domain = kwargs.get('next_upgrade_domain', None)
        self.rolling_upgrade_mode = kwargs.get('rolling_upgrade_mode', "UnmonitoredAuto")
        self.upgrade_description = kwargs.get('upgrade_description', None)
        self.upgrade_duration_in_milliseconds = kwargs.get('upgrade_duration_in_milliseconds', None)
        self.upgrade_domain_duration_in_milliseconds = kwargs.get('upgrade_domain_duration_in_milliseconds', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)
        self.current_upgrade_domain_progress = kwargs.get('current_upgrade_domain_progress', None)
        self.current_upgrade_units_progress = kwargs.get('current_upgrade_units_progress', None)
        self.start_timestamp_utc = kwargs.get('start_timestamp_utc', None)
        self.failure_timestamp_utc = kwargs.get('failure_timestamp_utc', None)
        self.failure_reason = kwargs.get('failure_reason', None)
        self.upgrade_domain_progress_at_failure = kwargs.get('upgrade_domain_progress_at_failure', None)
        self.is_node_by_node = kwargs.get('is_node_by_node', False)


class ClusterUpgradeRollbackCompletedEvent(ClusterEvent):
    """Cluster Upgrade Rollback Completed event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar target_cluster_version: Required. Target Cluster version.
    :vartype target_cluster_version: str
    :ivar failure_reason: Required. Describes failure.
    :vartype failure_reason: str
    :ivar overall_upgrade_elapsed_time_in_ms: Required. Overall duration of upgrade in
     milli-seconds.
    :vartype overall_upgrade_elapsed_time_in_ms: float
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'target_cluster_version': {'required': True},
        'failure_reason': {'required': True},
        'overall_upgrade_elapsed_time_in_ms': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'target_cluster_version': {'key': 'TargetClusterVersion', 'type': 'str'},
        'failure_reason': {'key': 'FailureReason', 'type': 'str'},
        'overall_upgrade_elapsed_time_in_ms': {'key': 'OverallUpgradeElapsedTimeInMs', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword target_cluster_version: Required. Target Cluster version.
        :paramtype target_cluster_version: str
        :keyword failure_reason: Required. Describes failure.
        :paramtype failure_reason: str
        :keyword overall_upgrade_elapsed_time_in_ms: Required. Overall duration of upgrade in
         milli-seconds.
        :paramtype overall_upgrade_elapsed_time_in_ms: float
        """
        super(ClusterUpgradeRollbackCompletedEvent, self).__init__(**kwargs)
        self.kind = 'ClusterUpgradeRollbackCompleted'  # type: str
        self.target_cluster_version = kwargs['target_cluster_version']
        self.failure_reason = kwargs['failure_reason']
        self.overall_upgrade_elapsed_time_in_ms = kwargs['overall_upgrade_elapsed_time_in_ms']


class ClusterUpgradeRollbackStartedEvent(ClusterEvent):
    """Cluster Upgrade Rollback Started event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar target_cluster_version: Required. Target Cluster version.
    :vartype target_cluster_version: str
    :ivar failure_reason: Required. Describes failure.
    :vartype failure_reason: str
    :ivar overall_upgrade_elapsed_time_in_ms: Required. Overall duration of upgrade in
     milli-seconds.
    :vartype overall_upgrade_elapsed_time_in_ms: float
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'target_cluster_version': {'required': True},
        'failure_reason': {'required': True},
        'overall_upgrade_elapsed_time_in_ms': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'target_cluster_version': {'key': 'TargetClusterVersion', 'type': 'str'},
        'failure_reason': {'key': 'FailureReason', 'type': 'str'},
        'overall_upgrade_elapsed_time_in_ms': {'key': 'OverallUpgradeElapsedTimeInMs', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword target_cluster_version: Required. Target Cluster version.
        :paramtype target_cluster_version: str
        :keyword failure_reason: Required. Describes failure.
        :paramtype failure_reason: str
        :keyword overall_upgrade_elapsed_time_in_ms: Required. Overall duration of upgrade in
         milli-seconds.
        :paramtype overall_upgrade_elapsed_time_in_ms: float
        """
        super(ClusterUpgradeRollbackStartedEvent, self).__init__(**kwargs)
        self.kind = 'ClusterUpgradeRollbackStarted'  # type: str
        self.target_cluster_version = kwargs['target_cluster_version']
        self.failure_reason = kwargs['failure_reason']
        self.overall_upgrade_elapsed_time_in_ms = kwargs['overall_upgrade_elapsed_time_in_ms']


class ClusterUpgradeStartedEvent(ClusterEvent):
    """Cluster Upgrade Started event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar current_cluster_version: Required. Current Cluster version.
    :vartype current_cluster_version: str
    :ivar target_cluster_version: Required. Target Cluster version.
    :vartype target_cluster_version: str
    :ivar upgrade_type: Required. Type of upgrade.
    :vartype upgrade_type: str
    :ivar rolling_upgrade_mode: Required. Mode of upgrade.
    :vartype rolling_upgrade_mode: str
    :ivar failure_action: Required. Action if failed.
    :vartype failure_action: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'current_cluster_version': {'required': True},
        'target_cluster_version': {'required': True},
        'upgrade_type': {'required': True},
        'rolling_upgrade_mode': {'required': True},
        'failure_action': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'current_cluster_version': {'key': 'CurrentClusterVersion', 'type': 'str'},
        'target_cluster_version': {'key': 'TargetClusterVersion', 'type': 'str'},
        'upgrade_type': {'key': 'UpgradeType', 'type': 'str'},
        'rolling_upgrade_mode': {'key': 'RollingUpgradeMode', 'type': 'str'},
        'failure_action': {'key': 'FailureAction', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword current_cluster_version: Required. Current Cluster version.
        :paramtype current_cluster_version: str
        :keyword target_cluster_version: Required. Target Cluster version.
        :paramtype target_cluster_version: str
        :keyword upgrade_type: Required. Type of upgrade.
        :paramtype upgrade_type: str
        :keyword rolling_upgrade_mode: Required. Mode of upgrade.
        :paramtype rolling_upgrade_mode: str
        :keyword failure_action: Required. Action if failed.
        :paramtype failure_action: str
        """
        super(ClusterUpgradeStartedEvent, self).__init__(**kwargs)
        self.kind = 'ClusterUpgradeStarted'  # type: str
        self.current_cluster_version = kwargs['current_cluster_version']
        self.target_cluster_version = kwargs['target_cluster_version']
        self.upgrade_type = kwargs['upgrade_type']
        self.rolling_upgrade_mode = kwargs['rolling_upgrade_mode']
        self.failure_action = kwargs['failure_action']


class ClusterVersion(msrest.serialization.Model):
    """The cluster version.

    :ivar version: The Service Fabric cluster runtime version.
    :vartype version: str
    """

    _attribute_map = {
        'version': {'key': 'Version', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword version: The Service Fabric cluster runtime version.
        :paramtype version: str
        """
        super(ClusterVersion, self).__init__(**kwargs)
        self.version = kwargs.get('version', None)


class CodePackageEntryPoint(msrest.serialization.Model):
    """Information about setup or main entry point of a code package deployed on a Service Fabric node.

    :ivar entry_point_location: The location of entry point executable on the node.
    :vartype entry_point_location: str
    :ivar process_id: The process ID of the entry point.
    :vartype process_id: str
    :ivar run_as_user_name: The user name under which entry point executable is run on the node.
    :vartype run_as_user_name: str
    :ivar code_package_entry_point_statistics: Statistics about setup or main entry point  of a
     code package deployed on a Service Fabric node.
    :vartype code_package_entry_point_statistics:
     ~azure.servicefabric.models.CodePackageEntryPointStatistics
    :ivar status: Specifies the status of the code package entry point deployed on a Service Fabric
     node. Possible values include: "Invalid", "Pending", "Starting", "Started", "Stopping",
     "Stopped".
    :vartype status: str or ~azure.servicefabric.models.EntryPointStatus
    :ivar next_activation_time: The time (in UTC) when the entry point executable will be run next.
    :vartype next_activation_time: ~datetime.datetime
    :ivar instance_id: The instance ID for current running entry point. For a code package setup
     entry point (if specified) runs first and after it finishes main entry point is started. Each
     time entry point executable is run, its instance id will change.
    :vartype instance_id: str
    :ivar container_id: The container ID of the entry point. Only valid for container hosts.
    :vartype container_id: str
    """

    _attribute_map = {
        'entry_point_location': {'key': 'EntryPointLocation', 'type': 'str'},
        'process_id': {'key': 'ProcessId', 'type': 'str'},
        'run_as_user_name': {'key': 'RunAsUserName', 'type': 'str'},
        'code_package_entry_point_statistics': {'key': 'CodePackageEntryPointStatistics', 'type': 'CodePackageEntryPointStatistics'},
        'status': {'key': 'Status', 'type': 'str'},
        'next_activation_time': {'key': 'NextActivationTime', 'type': 'iso-8601'},
        'instance_id': {'key': 'InstanceId', 'type': 'str'},
        'container_id': {'key': 'ContainerId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword entry_point_location: The location of entry point executable on the node.
        :paramtype entry_point_location: str
        :keyword process_id: The process ID of the entry point.
        :paramtype process_id: str
        :keyword run_as_user_name: The user name under which entry point executable is run on the node.
        :paramtype run_as_user_name: str
        :keyword code_package_entry_point_statistics: Statistics about setup or main entry point  of a
         code package deployed on a Service Fabric node.
        :paramtype code_package_entry_point_statistics:
         ~azure.servicefabric.models.CodePackageEntryPointStatistics
        :keyword status: Specifies the status of the code package entry point deployed on a Service
         Fabric node. Possible values include: "Invalid", "Pending", "Starting", "Started", "Stopping",
         "Stopped".
        :paramtype status: str or ~azure.servicefabric.models.EntryPointStatus
        :keyword next_activation_time: The time (in UTC) when the entry point executable will be run
         next.
        :paramtype next_activation_time: ~datetime.datetime
        :keyword instance_id: The instance ID for current running entry point. For a code package setup
         entry point (if specified) runs first and after it finishes main entry point is started. Each
         time entry point executable is run, its instance id will change.
        :paramtype instance_id: str
        :keyword container_id: The container ID of the entry point. Only valid for container hosts.
        :paramtype container_id: str
        """
        super(CodePackageEntryPoint, self).__init__(**kwargs)
        self.entry_point_location = kwargs.get('entry_point_location', None)
        self.process_id = kwargs.get('process_id', None)
        self.run_as_user_name = kwargs.get('run_as_user_name', None)
        self.code_package_entry_point_statistics = kwargs.get('code_package_entry_point_statistics', None)
        self.status = kwargs.get('status', None)
        self.next_activation_time = kwargs.get('next_activation_time', None)
        self.instance_id = kwargs.get('instance_id', None)
        self.container_id = kwargs.get('container_id', None)


class CodePackageEntryPointStatistics(msrest.serialization.Model):
    """Statistics about setup or main entry point  of a code package deployed on a Service Fabric node.

    :ivar last_exit_code: The last exit code of the entry point.
    :vartype last_exit_code: str
    :ivar last_activation_time: The last time (in UTC) when Service Fabric attempted to run the
     entry point.
    :vartype last_activation_time: ~datetime.datetime
    :ivar last_exit_time: The last time (in UTC) when the entry point finished running.
    :vartype last_exit_time: ~datetime.datetime
    :ivar last_successful_activation_time: The last time (in UTC) when the entry point ran
     successfully.
    :vartype last_successful_activation_time: ~datetime.datetime
    :ivar last_successful_exit_time: The last time (in UTC) when the entry point finished running
     gracefully.
    :vartype last_successful_exit_time: ~datetime.datetime
    :ivar activation_count: Number of times the entry point has run.
    :vartype activation_count: str
    :ivar activation_failure_count: Number of times the entry point failed to run.
    :vartype activation_failure_count: str
    :ivar continuous_activation_failure_count: Number of times the entry point continuously failed
     to run.
    :vartype continuous_activation_failure_count: str
    :ivar exit_count: Number of times the entry point finished running.
    :vartype exit_count: str
    :ivar exit_failure_count: Number of times the entry point failed to exit gracefully.
    :vartype exit_failure_count: str
    :ivar continuous_exit_failure_count: Number of times the entry point continuously failed to
     exit gracefully.
    :vartype continuous_exit_failure_count: str
    """

    _attribute_map = {
        'last_exit_code': {'key': 'LastExitCode', 'type': 'str'},
        'last_activation_time': {'key': 'LastActivationTime', 'type': 'iso-8601'},
        'last_exit_time': {'key': 'LastExitTime', 'type': 'iso-8601'},
        'last_successful_activation_time': {'key': 'LastSuccessfulActivationTime', 'type': 'iso-8601'},
        'last_successful_exit_time': {'key': 'LastSuccessfulExitTime', 'type': 'iso-8601'},
        'activation_count': {'key': 'ActivationCount', 'type': 'str'},
        'activation_failure_count': {'key': 'ActivationFailureCount', 'type': 'str'},
        'continuous_activation_failure_count': {'key': 'ContinuousActivationFailureCount', 'type': 'str'},
        'exit_count': {'key': 'ExitCount', 'type': 'str'},
        'exit_failure_count': {'key': 'ExitFailureCount', 'type': 'str'},
        'continuous_exit_failure_count': {'key': 'ContinuousExitFailureCount', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword last_exit_code: The last exit code of the entry point.
        :paramtype last_exit_code: str
        :keyword last_activation_time: The last time (in UTC) when Service Fabric attempted to run the
         entry point.
        :paramtype last_activation_time: ~datetime.datetime
        :keyword last_exit_time: The last time (in UTC) when the entry point finished running.
        :paramtype last_exit_time: ~datetime.datetime
        :keyword last_successful_activation_time: The last time (in UTC) when the entry point ran
         successfully.
        :paramtype last_successful_activation_time: ~datetime.datetime
        :keyword last_successful_exit_time: The last time (in UTC) when the entry point finished
         running gracefully.
        :paramtype last_successful_exit_time: ~datetime.datetime
        :keyword activation_count: Number of times the entry point has run.
        :paramtype activation_count: str
        :keyword activation_failure_count: Number of times the entry point failed to run.
        :paramtype activation_failure_count: str
        :keyword continuous_activation_failure_count: Number of times the entry point continuously
         failed to run.
        :paramtype continuous_activation_failure_count: str
        :keyword exit_count: Number of times the entry point finished running.
        :paramtype exit_count: str
        :keyword exit_failure_count: Number of times the entry point failed to exit gracefully.
        :paramtype exit_failure_count: str
        :keyword continuous_exit_failure_count: Number of times the entry point continuously failed to
         exit gracefully.
        :paramtype continuous_exit_failure_count: str
        """
        super(CodePackageEntryPointStatistics, self).__init__(**kwargs)
        self.last_exit_code = kwargs.get('last_exit_code', None)
        self.last_activation_time = kwargs.get('last_activation_time', None)
        self.last_exit_time = kwargs.get('last_exit_time', None)
        self.last_successful_activation_time = kwargs.get('last_successful_activation_time', None)
        self.last_successful_exit_time = kwargs.get('last_successful_exit_time', None)
        self.activation_count = kwargs.get('activation_count', None)
        self.activation_failure_count = kwargs.get('activation_failure_count', None)
        self.continuous_activation_failure_count = kwargs.get('continuous_activation_failure_count', None)
        self.exit_count = kwargs.get('exit_count', None)
        self.exit_failure_count = kwargs.get('exit_failure_count', None)
        self.continuous_exit_failure_count = kwargs.get('continuous_exit_failure_count', None)


class ComposeDeploymentStatusInfo(msrest.serialization.Model):
    """Information about a Service Fabric compose deployment.

    :ivar name: The name of the deployment.
    :vartype name: str
    :ivar application_name: The name of the application, including the 'fabric:' URI scheme.
    :vartype application_name: str
    :ivar status: The status of the compose deployment. Possible values include: "Invalid",
     "Provisioning", "Creating", "Ready", "Unprovisioning", "Deleting", "Failed", "Upgrading".
    :vartype status: str or ~azure.servicefabric.models.ComposeDeploymentStatus
    :ivar status_details: The status details of compose deployment including failure message.
    :vartype status_details: str
    """

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
        'status': {'key': 'Status', 'type': 'str'},
        'status_details': {'key': 'StatusDetails', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: The name of the deployment.
        :paramtype name: str
        :keyword application_name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype application_name: str
        :keyword status: The status of the compose deployment. Possible values include: "Invalid",
         "Provisioning", "Creating", "Ready", "Unprovisioning", "Deleting", "Failed", "Upgrading".
        :paramtype status: str or ~azure.servicefabric.models.ComposeDeploymentStatus
        :keyword status_details: The status details of compose deployment including failure message.
        :paramtype status_details: str
        """
        super(ComposeDeploymentStatusInfo, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.application_name = kwargs.get('application_name', None)
        self.status = kwargs.get('status', None)
        self.status_details = kwargs.get('status_details', None)


class ComposeDeploymentUpgradeDescription(msrest.serialization.Model):
    """Describes the parameters for a compose deployment upgrade.

    All required parameters must be populated in order to send to Azure.

    :ivar deployment_name: Required. The name of the deployment.
    :vartype deployment_name: str
    :ivar compose_file_content: Required. The content of the compose file that describes the
     deployment to create.
    :vartype compose_file_content: str
    :ivar registry_credential: Credential information to connect to container registry.
    :vartype registry_credential: ~azure.servicefabric.models.RegistryCredential
    :ivar upgrade_kind: Required. The kind of upgrade out of the following possible values.
     Possible values include: "Invalid", "Rolling". Default value: "Rolling".
    :vartype upgrade_kind: str or ~azure.servicefabric.models.UpgradeKind
    :ivar rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
     values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred. Possible
     values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
     "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
    :vartype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
    :ivar upgrade_replica_set_check_timeout_in_seconds: The maximum amount of time to block
     processing of an upgrade domain and prevent loss of availability when there are unexpected
     issues. When this timeout expires, processing of the upgrade domain will proceed regardless of
     availability loss issues. The timeout is reset at the start of each upgrade domain. Valid
     values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
    :vartype upgrade_replica_set_check_timeout_in_seconds: long
    :ivar force_restart: If true, then processes are forcefully restarted during upgrade even when
     the code version has not changed (the upgrade only changes configuration or data).
    :vartype force_restart: bool
    :ivar monitoring_policy: Describes the parameters for monitoring an upgrade in Monitored mode.
    :vartype monitoring_policy: ~azure.servicefabric.models.MonitoringPolicyDescription
    :ivar application_health_policy: Defines a health policy used to evaluate the health of an
     application or one of its children entities.
    :vartype application_health_policy: ~azure.servicefabric.models.ApplicationHealthPolicy
    """

    _validation = {
        'deployment_name': {'required': True},
        'compose_file_content': {'required': True},
        'upgrade_kind': {'required': True},
    }

    _attribute_map = {
        'deployment_name': {'key': 'DeploymentName', 'type': 'str'},
        'compose_file_content': {'key': 'ComposeFileContent', 'type': 'str'},
        'registry_credential': {'key': 'RegistryCredential', 'type': 'RegistryCredential'},
        'upgrade_kind': {'key': 'UpgradeKind', 'type': 'str'},
        'rolling_upgrade_mode': {'key': 'RollingUpgradeMode', 'type': 'str'},
        'upgrade_replica_set_check_timeout_in_seconds': {'key': 'UpgradeReplicaSetCheckTimeoutInSeconds', 'type': 'long'},
        'force_restart': {'key': 'ForceRestart', 'type': 'bool'},
        'monitoring_policy': {'key': 'MonitoringPolicy', 'type': 'MonitoringPolicyDescription'},
        'application_health_policy': {'key': 'ApplicationHealthPolicy', 'type': 'ApplicationHealthPolicy'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword deployment_name: Required. The name of the deployment.
        :paramtype deployment_name: str
        :keyword compose_file_content: Required. The content of the compose file that describes the
         deployment to create.
        :paramtype compose_file_content: str
        :keyword registry_credential: Credential information to connect to container registry.
        :paramtype registry_credential: ~azure.servicefabric.models.RegistryCredential
        :keyword upgrade_kind: Required. The kind of upgrade out of the following possible values.
         Possible values include: "Invalid", "Rolling". Default value: "Rolling".
        :paramtype upgrade_kind: str or ~azure.servicefabric.models.UpgradeKind
        :keyword rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
         values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred. Possible
         values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
         "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
        :paramtype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
        :keyword upgrade_replica_set_check_timeout_in_seconds: The maximum amount of time to block
         processing of an upgrade domain and prevent loss of availability when there are unexpected
         issues. When this timeout expires, processing of the upgrade domain will proceed regardless of
         availability loss issues. The timeout is reset at the start of each upgrade domain. Valid
         values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
        :paramtype upgrade_replica_set_check_timeout_in_seconds: long
        :keyword force_restart: If true, then processes are forcefully restarted during upgrade even
         when the code version has not changed (the upgrade only changes configuration or data).
        :paramtype force_restart: bool
        :keyword monitoring_policy: Describes the parameters for monitoring an upgrade in Monitored
         mode.
        :paramtype monitoring_policy: ~azure.servicefabric.models.MonitoringPolicyDescription
        :keyword application_health_policy: Defines a health policy used to evaluate the health of an
         application or one of its children entities.
        :paramtype application_health_policy: ~azure.servicefabric.models.ApplicationHealthPolicy
        """
        super(ComposeDeploymentUpgradeDescription, self).__init__(**kwargs)
        self.deployment_name = kwargs['deployment_name']
        self.compose_file_content = kwargs['compose_file_content']
        self.registry_credential = kwargs.get('registry_credential', None)
        self.upgrade_kind = kwargs.get('upgrade_kind', "Rolling")
        self.rolling_upgrade_mode = kwargs.get('rolling_upgrade_mode', "UnmonitoredAuto")
        self.upgrade_replica_set_check_timeout_in_seconds = kwargs.get('upgrade_replica_set_check_timeout_in_seconds', 42949672925)
        self.force_restart = kwargs.get('force_restart', False)
        self.monitoring_policy = kwargs.get('monitoring_policy', None)
        self.application_health_policy = kwargs.get('application_health_policy', None)


class ComposeDeploymentUpgradeProgressInfo(msrest.serialization.Model):
    """Describes the parameters for a compose deployment upgrade.

    :ivar deployment_name: The name of the target deployment.
    :vartype deployment_name: str
    :ivar application_name: The name of the target application, including the 'fabric:' URI scheme.
    :vartype application_name: str
    :ivar upgrade_state: The state of the compose deployment upgrade. Possible values include:
     "Invalid", "ProvisioningTarget", "RollingForwardInProgress", "RollingForwardPending",
     "UnprovisioningCurrent", "RollingForwardCompleted", "RollingBackInProgress",
     "UnprovisioningTarget", "RollingBackCompleted", "Failed".
    :vartype upgrade_state: str or ~azure.servicefabric.models.ComposeDeploymentUpgradeState
    :ivar upgrade_status_details: Additional detailed information about the status of the pending
     upgrade.
    :vartype upgrade_status_details: str
    :ivar upgrade_kind: The kind of upgrade out of the following possible values. Possible values
     include: "Invalid", "Rolling". Default value: "Rolling".
    :vartype upgrade_kind: str or ~azure.servicefabric.models.UpgradeKind
    :ivar rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
     values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred. Possible
     values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
     "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
    :vartype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
    :ivar force_restart: If true, then processes are forcefully restarted during upgrade even when
     the code version has not changed (the upgrade only changes configuration or data).
    :vartype force_restart: bool
    :ivar upgrade_replica_set_check_timeout_in_seconds: The maximum amount of time to block
     processing of an upgrade domain and prevent loss of availability when there are unexpected
     issues. When this timeout expires, processing of the upgrade domain will proceed regardless of
     availability loss issues. The timeout is reset at the start of each upgrade domain. Valid
     values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
    :vartype upgrade_replica_set_check_timeout_in_seconds: long
    :ivar monitoring_policy: Describes the parameters for monitoring an upgrade in Monitored mode.
    :vartype monitoring_policy: ~azure.servicefabric.models.MonitoringPolicyDescription
    :ivar application_health_policy: Defines a health policy used to evaluate the health of an
     application or one of its children entities.
    :vartype application_health_policy: ~azure.servicefabric.models.ApplicationHealthPolicy
    :ivar target_application_type_version: The target application type version (found in the
     application manifest) for the application upgrade.
    :vartype target_application_type_version: str
    :ivar upgrade_duration: The estimated amount of time that the overall upgrade elapsed. It is
     first interpreted as a string representing an ISO 8601 duration. If that fails, then it is
     interpreted as a number representing the total number of milliseconds.
    :vartype upgrade_duration: str
    :ivar current_upgrade_domain_duration: The estimated amount of time spent processing current
     Upgrade Domain. It is first interpreted as a string representing an ISO 8601 duration. If that
     fails, then it is interpreted as a number representing the total number of milliseconds.
    :vartype current_upgrade_domain_duration: str
    :ivar application_unhealthy_evaluations: List of health evaluations that resulted in the
     current aggregated health state.
    :vartype application_unhealthy_evaluations:
     list[~azure.servicefabric.models.HealthEvaluationWrapper]
    :ivar current_upgrade_domain_progress: Information about the current in-progress upgrade
     domain. Not applicable to node-by-node upgrades.
    :vartype current_upgrade_domain_progress:
     ~azure.servicefabric.models.CurrentUpgradeDomainProgressInfo
    :ivar start_timestamp_utc: The estimated UTC datetime when the upgrade started.
    :vartype start_timestamp_utc: str
    :ivar failure_timestamp_utc: The estimated UTC datetime when the upgrade failed and
     FailureAction was executed.
    :vartype failure_timestamp_utc: str
    :ivar failure_reason: The cause of an upgrade failure that resulted in FailureAction being
     executed. Possible values include: "None", "Interrupted", "HealthCheck",
     "UpgradeDomainTimeout", "OverallUpgradeTimeout".
    :vartype failure_reason: str or ~azure.servicefabric.models.FailureReason
    :ivar upgrade_domain_progress_at_failure: Information about the upgrade domain progress at the
     time of upgrade failure.
    :vartype upgrade_domain_progress_at_failure:
     ~azure.servicefabric.models.FailureUpgradeDomainProgressInfo
    :ivar application_upgrade_status_details: Additional details of application upgrade including
     failure message.
    :vartype application_upgrade_status_details: str
    """

    _attribute_map = {
        'deployment_name': {'key': 'DeploymentName', 'type': 'str'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
        'upgrade_state': {'key': 'UpgradeState', 'type': 'str'},
        'upgrade_status_details': {'key': 'UpgradeStatusDetails', 'type': 'str'},
        'upgrade_kind': {'key': 'UpgradeKind', 'type': 'str'},
        'rolling_upgrade_mode': {'key': 'RollingUpgradeMode', 'type': 'str'},
        'force_restart': {'key': 'ForceRestart', 'type': 'bool'},
        'upgrade_replica_set_check_timeout_in_seconds': {'key': 'UpgradeReplicaSetCheckTimeoutInSeconds', 'type': 'long'},
        'monitoring_policy': {'key': 'MonitoringPolicy', 'type': 'MonitoringPolicyDescription'},
        'application_health_policy': {'key': 'ApplicationHealthPolicy', 'type': 'ApplicationHealthPolicy'},
        'target_application_type_version': {'key': 'TargetApplicationTypeVersion', 'type': 'str'},
        'upgrade_duration': {'key': 'UpgradeDuration', 'type': 'str'},
        'current_upgrade_domain_duration': {'key': 'CurrentUpgradeDomainDuration', 'type': 'str'},
        'application_unhealthy_evaluations': {'key': 'ApplicationUnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
        'current_upgrade_domain_progress': {'key': 'CurrentUpgradeDomainProgress', 'type': 'CurrentUpgradeDomainProgressInfo'},
        'start_timestamp_utc': {'key': 'StartTimestampUtc', 'type': 'str'},
        'failure_timestamp_utc': {'key': 'FailureTimestampUtc', 'type': 'str'},
        'failure_reason': {'key': 'FailureReason', 'type': 'str'},
        'upgrade_domain_progress_at_failure': {'key': 'UpgradeDomainProgressAtFailure', 'type': 'FailureUpgradeDomainProgressInfo'},
        'application_upgrade_status_details': {'key': 'ApplicationUpgradeStatusDetails', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword deployment_name: The name of the target deployment.
        :paramtype deployment_name: str
        :keyword application_name: The name of the target application, including the 'fabric:' URI
         scheme.
        :paramtype application_name: str
        :keyword upgrade_state: The state of the compose deployment upgrade. Possible values include:
         "Invalid", "ProvisioningTarget", "RollingForwardInProgress", "RollingForwardPending",
         "UnprovisioningCurrent", "RollingForwardCompleted", "RollingBackInProgress",
         "UnprovisioningTarget", "RollingBackCompleted", "Failed".
        :paramtype upgrade_state: str or ~azure.servicefabric.models.ComposeDeploymentUpgradeState
        :keyword upgrade_status_details: Additional detailed information about the status of the
         pending upgrade.
        :paramtype upgrade_status_details: str
        :keyword upgrade_kind: The kind of upgrade out of the following possible values. Possible
         values include: "Invalid", "Rolling". Default value: "Rolling".
        :paramtype upgrade_kind: str or ~azure.servicefabric.models.UpgradeKind
        :keyword rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
         values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred. Possible
         values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
         "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
        :paramtype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
        :keyword force_restart: If true, then processes are forcefully restarted during upgrade even
         when the code version has not changed (the upgrade only changes configuration or data).
        :paramtype force_restart: bool
        :keyword upgrade_replica_set_check_timeout_in_seconds: The maximum amount of time to block
         processing of an upgrade domain and prevent loss of availability when there are unexpected
         issues. When this timeout expires, processing of the upgrade domain will proceed regardless of
         availability loss issues. The timeout is reset at the start of each upgrade domain. Valid
         values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
        :paramtype upgrade_replica_set_check_timeout_in_seconds: long
        :keyword monitoring_policy: Describes the parameters for monitoring an upgrade in Monitored
         mode.
        :paramtype monitoring_policy: ~azure.servicefabric.models.MonitoringPolicyDescription
        :keyword application_health_policy: Defines a health policy used to evaluate the health of an
         application or one of its children entities.
        :paramtype application_health_policy: ~azure.servicefabric.models.ApplicationHealthPolicy
        :keyword target_application_type_version: The target application type version (found in the
         application manifest) for the application upgrade.
        :paramtype target_application_type_version: str
        :keyword upgrade_duration: The estimated amount of time that the overall upgrade elapsed. It is
         first interpreted as a string representing an ISO 8601 duration. If that fails, then it is
         interpreted as a number representing the total number of milliseconds.
        :paramtype upgrade_duration: str
        :keyword current_upgrade_domain_duration: The estimated amount of time spent processing current
         Upgrade Domain. It is first interpreted as a string representing an ISO 8601 duration. If that
         fails, then it is interpreted as a number representing the total number of milliseconds.
        :paramtype current_upgrade_domain_duration: str
        :keyword application_unhealthy_evaluations: List of health evaluations that resulted in the
         current aggregated health state.
        :paramtype application_unhealthy_evaluations:
         list[~azure.servicefabric.models.HealthEvaluationWrapper]
        :keyword current_upgrade_domain_progress: Information about the current in-progress upgrade
         domain. Not applicable to node-by-node upgrades.
        :paramtype current_upgrade_domain_progress:
         ~azure.servicefabric.models.CurrentUpgradeDomainProgressInfo
        :keyword start_timestamp_utc: The estimated UTC datetime when the upgrade started.
        :paramtype start_timestamp_utc: str
        :keyword failure_timestamp_utc: The estimated UTC datetime when the upgrade failed and
         FailureAction was executed.
        :paramtype failure_timestamp_utc: str
        :keyword failure_reason: The cause of an upgrade failure that resulted in FailureAction being
         executed. Possible values include: "None", "Interrupted", "HealthCheck",
         "UpgradeDomainTimeout", "OverallUpgradeTimeout".
        :paramtype failure_reason: str or ~azure.servicefabric.models.FailureReason
        :keyword upgrade_domain_progress_at_failure: Information about the upgrade domain progress at
         the time of upgrade failure.
        :paramtype upgrade_domain_progress_at_failure:
         ~azure.servicefabric.models.FailureUpgradeDomainProgressInfo
        :keyword application_upgrade_status_details: Additional details of application upgrade
         including failure message.
        :paramtype application_upgrade_status_details: str
        """
        super(ComposeDeploymentUpgradeProgressInfo, self).__init__(**kwargs)
        self.deployment_name = kwargs.get('deployment_name', None)
        self.application_name = kwargs.get('application_name', None)
        self.upgrade_state = kwargs.get('upgrade_state', None)
        self.upgrade_status_details = kwargs.get('upgrade_status_details', None)
        self.upgrade_kind = kwargs.get('upgrade_kind', "Rolling")
        self.rolling_upgrade_mode = kwargs.get('rolling_upgrade_mode', "UnmonitoredAuto")
        self.force_restart = kwargs.get('force_restart', False)
        self.upgrade_replica_set_check_timeout_in_seconds = kwargs.get('upgrade_replica_set_check_timeout_in_seconds', 42949672925)
        self.monitoring_policy = kwargs.get('monitoring_policy', None)
        self.application_health_policy = kwargs.get('application_health_policy', None)
        self.target_application_type_version = kwargs.get('target_application_type_version', None)
        self.upgrade_duration = kwargs.get('upgrade_duration', "PT0H2M0S")
        self.current_upgrade_domain_duration = kwargs.get('current_upgrade_domain_duration', "PT0H2M0S")
        self.application_unhealthy_evaluations = kwargs.get('application_unhealthy_evaluations', None)
        self.current_upgrade_domain_progress = kwargs.get('current_upgrade_domain_progress', None)
        self.start_timestamp_utc = kwargs.get('start_timestamp_utc', None)
        self.failure_timestamp_utc = kwargs.get('failure_timestamp_utc', None)
        self.failure_reason = kwargs.get('failure_reason', None)
        self.upgrade_domain_progress_at_failure = kwargs.get('upgrade_domain_progress_at_failure', None)
        self.application_upgrade_status_details = kwargs.get('application_upgrade_status_details', None)


class ConfigParameterOverride(msrest.serialization.Model):
    """Information about a configuration parameter override.

    All required parameters must be populated in order to send to Azure.

    :ivar section_name: Required. Name of the section for the parameter override.
    :vartype section_name: str
    :ivar parameter_name: Required. Name of the parameter that has been overridden.
    :vartype parameter_name: str
    :ivar parameter_value: Required. Value of the overridden parameter.
    :vartype parameter_value: str
    :ivar timeout: The duration until config override is considered as valid.
    :vartype timeout: ~datetime.timedelta
    :ivar persist_across_upgrade: A value that indicates whether config override will be removed on
     upgrade or will still be considered as valid.
    :vartype persist_across_upgrade: bool
    """

    _validation = {
        'section_name': {'required': True},
        'parameter_name': {'required': True},
        'parameter_value': {'required': True},
    }

    _attribute_map = {
        'section_name': {'key': 'SectionName', 'type': 'str'},
        'parameter_name': {'key': 'ParameterName', 'type': 'str'},
        'parameter_value': {'key': 'ParameterValue', 'type': 'str'},
        'timeout': {'key': 'Timeout', 'type': 'duration'},
        'persist_across_upgrade': {'key': 'PersistAcrossUpgrade', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword section_name: Required. Name of the section for the parameter override.
        :paramtype section_name: str
        :keyword parameter_name: Required. Name of the parameter that has been overridden.
        :paramtype parameter_name: str
        :keyword parameter_value: Required. Value of the overridden parameter.
        :paramtype parameter_value: str
        :keyword timeout: The duration until config override is considered as valid.
        :paramtype timeout: ~datetime.timedelta
        :keyword persist_across_upgrade: A value that indicates whether config override will be removed
         on upgrade or will still be considered as valid.
        :paramtype persist_across_upgrade: bool
        """
        super(ConfigParameterOverride, self).__init__(**kwargs)
        self.section_name = kwargs['section_name']
        self.parameter_name = kwargs['parameter_name']
        self.parameter_value = kwargs['parameter_value']
        self.timeout = kwargs.get('timeout', None)
        self.persist_across_upgrade = kwargs.get('persist_across_upgrade', None)


class ContainerApiRequestBody(msrest.serialization.Model):
    """parameters for making container API call.

    All required parameters must be populated in order to send to Azure.

    :ivar http_verb: HTTP verb of container REST API, defaults to "GET".
    :vartype http_verb: str
    :ivar uri_path: Required. URI path of container REST API.
    :vartype uri_path: str
    :ivar content_type: Content type of container REST API request, defaults to "application/json".
    :vartype content_type: str
    :ivar body: HTTP request body of container REST API.
    :vartype body: str
    """

    _validation = {
        'uri_path': {'required': True},
    }

    _attribute_map = {
        'http_verb': {'key': 'HttpVerb', 'type': 'str'},
        'uri_path': {'key': 'UriPath', 'type': 'str'},
        'content_type': {'key': 'Content-Type', 'type': 'str'},
        'body': {'key': 'Body', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword http_verb: HTTP verb of container REST API, defaults to "GET".
        :paramtype http_verb: str
        :keyword uri_path: Required. URI path of container REST API.
        :paramtype uri_path: str
        :keyword content_type: Content type of container REST API request, defaults to
         "application/json".
        :paramtype content_type: str
        :keyword body: HTTP request body of container REST API.
        :paramtype body: str
        """
        super(ContainerApiRequestBody, self).__init__(**kwargs)
        self.http_verb = kwargs.get('http_verb', None)
        self.uri_path = kwargs['uri_path']
        self.content_type = kwargs.get('content_type', None)
        self.body = kwargs.get('body', None)


class ContainerApiResponse(msrest.serialization.Model):
    """Response body that wraps container API result.

    All required parameters must be populated in order to send to Azure.

    :ivar container_api_result: Required. Container API result.
    :vartype container_api_result: ~azure.servicefabric.models.ContainerApiResult
    """

    _validation = {
        'container_api_result': {'required': True},
    }

    _attribute_map = {
        'container_api_result': {'key': 'ContainerApiResult', 'type': 'ContainerApiResult'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword container_api_result: Required. Container API result.
        :paramtype container_api_result: ~azure.servicefabric.models.ContainerApiResult
        """
        super(ContainerApiResponse, self).__init__(**kwargs)
        self.container_api_result = kwargs['container_api_result']


class ContainerApiResult(msrest.serialization.Model):
    """Container API result.

    All required parameters must be populated in order to send to Azure.

    :ivar status: Required. HTTP status code returned by the target container API.
    :vartype status: int
    :ivar content_type: HTTP content type.
    :vartype content_type: str
    :ivar content_encoding: HTTP content encoding.
    :vartype content_encoding: str
    :ivar body: container API result body.
    :vartype body: str
    """

    _validation = {
        'status': {'required': True},
    }

    _attribute_map = {
        'status': {'key': 'Status', 'type': 'int'},
        'content_type': {'key': 'Content-Type', 'type': 'str'},
        'content_encoding': {'key': 'Content-Encoding', 'type': 'str'},
        'body': {'key': 'Body', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword status: Required. HTTP status code returned by the target container API.
        :paramtype status: int
        :keyword content_type: HTTP content type.
        :paramtype content_type: str
        :keyword content_encoding: HTTP content encoding.
        :paramtype content_encoding: str
        :keyword body: container API result body.
        :paramtype body: str
        """
        super(ContainerApiResult, self).__init__(**kwargs)
        self.status = kwargs['status']
        self.content_type = kwargs.get('content_type', None)
        self.content_encoding = kwargs.get('content_encoding', None)
        self.body = kwargs.get('body', None)


class ContainerCodePackageProperties(msrest.serialization.Model):
    """Describes a container and its runtime properties.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name of the code package.
    :vartype name: str
    :ivar image: Required. The Container image to use.
    :vartype image: str
    :ivar image_registry_credential: Image registry credential.
    :vartype image_registry_credential: ~azure.servicefabric.models.ImageRegistryCredential
    :ivar entry_point: Override for the default entry point in the container.
    :vartype entry_point: str
    :ivar commands: Command array to execute within the container in exec form.
    :vartype commands: list[str]
    :ivar environment_variables: The environment variables to set in this container.
    :vartype environment_variables: list[~azure.servicefabric.models.EnvironmentVariable]
    :ivar settings: The settings to set in this container. The setting file path can be fetched
     from environment variable "Fabric_SettingPath". The path for Windows container is "C:\secrets".
     The path for Linux container is "/var/secrets".
    :vartype settings: list[~azure.servicefabric.models.Setting]
    :ivar labels: The labels to set in this container.
    :vartype labels: list[~azure.servicefabric.models.ContainerLabel]
    :ivar endpoints: The endpoints exposed by this container.
    :vartype endpoints: list[~azure.servicefabric.models.EndpointProperties]
    :ivar resources: Required. The resources required by this container.
    :vartype resources: ~azure.servicefabric.models.ResourceRequirements
    :ivar volume_refs: Volumes to be attached to the container. The lifetime of these volumes is
     independent of the application's lifetime.
    :vartype volume_refs: list[~azure.servicefabric.models.VolumeReference]
    :ivar volumes: Volumes to be attached to the container. The lifetime of these volumes is scoped
     to the application's lifetime.
    :vartype volumes: list[~azure.servicefabric.models.ApplicationScopedVolume]
    :ivar diagnostics: Reference to sinks in DiagnosticsDescription.
    :vartype diagnostics: ~azure.servicefabric.models.DiagnosticsRef
    :ivar reliable_collections_refs: A list of ReliableCollection resources used by this particular
     code package. Please refer to ReliableCollectionsRef for more details.
    :vartype reliable_collections_refs: list[~azure.servicefabric.models.ReliableCollectionsRef]
    :ivar instance_view: Runtime information of a container instance.
    :vartype instance_view: ~azure.servicefabric.models.ContainerInstanceView
    :ivar liveness_probe: An array of liveness probes for a code package. It determines when to
     restart a code package.
    :vartype liveness_probe: list[~azure.servicefabric.models.Probe]
    :ivar readiness_probe: An array of readiness probes for a code package. It determines when to
     unpublish an endpoint.
    :vartype readiness_probe: list[~azure.servicefabric.models.Probe]
    """

    _validation = {
        'name': {'required': True},
        'image': {'required': True},
        'resources': {'required': True},
        'instance_view': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'image': {'key': 'image', 'type': 'str'},
        'image_registry_credential': {'key': 'imageRegistryCredential', 'type': 'ImageRegistryCredential'},
        'entry_point': {'key': 'entryPoint', 'type': 'str'},
        'commands': {'key': 'commands', 'type': '[str]'},
        'environment_variables': {'key': 'environmentVariables', 'type': '[EnvironmentVariable]'},
        'settings': {'key': 'settings', 'type': '[Setting]'},
        'labels': {'key': 'labels', 'type': '[ContainerLabel]'},
        'endpoints': {'key': 'endpoints', 'type': '[EndpointProperties]'},
        'resources': {'key': 'resources', 'type': 'ResourceRequirements'},
        'volume_refs': {'key': 'volumeRefs', 'type': '[VolumeReference]'},
        'volumes': {'key': 'volumes', 'type': '[ApplicationScopedVolume]'},
        'diagnostics': {'key': 'diagnostics', 'type': 'DiagnosticsRef'},
        'reliable_collections_refs': {'key': 'reliableCollectionsRefs', 'type': '[ReliableCollectionsRef]'},
        'instance_view': {'key': 'instanceView', 'type': 'ContainerInstanceView'},
        'liveness_probe': {'key': 'livenessProbe', 'type': '[Probe]'},
        'readiness_probe': {'key': 'readinessProbe', 'type': '[Probe]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. The name of the code package.
        :paramtype name: str
        :keyword image: Required. The Container image to use.
        :paramtype image: str
        :keyword image_registry_credential: Image registry credential.
        :paramtype image_registry_credential: ~azure.servicefabric.models.ImageRegistryCredential
        :keyword entry_point: Override for the default entry point in the container.
        :paramtype entry_point: str
        :keyword commands: Command array to execute within the container in exec form.
        :paramtype commands: list[str]
        :keyword environment_variables: The environment variables to set in this container.
        :paramtype environment_variables: list[~azure.servicefabric.models.EnvironmentVariable]
        :keyword settings: The settings to set in this container. The setting file path can be fetched
         from environment variable "Fabric_SettingPath". The path for Windows container is "C:\secrets".
         The path for Linux container is "/var/secrets".
        :paramtype settings: list[~azure.servicefabric.models.Setting]
        :keyword labels: The labels to set in this container.
        :paramtype labels: list[~azure.servicefabric.models.ContainerLabel]
        :keyword endpoints: The endpoints exposed by this container.
        :paramtype endpoints: list[~azure.servicefabric.models.EndpointProperties]
        :keyword resources: Required. The resources required by this container.
        :paramtype resources: ~azure.servicefabric.models.ResourceRequirements
        :keyword volume_refs: Volumes to be attached to the container. The lifetime of these volumes is
         independent of the application's lifetime.
        :paramtype volume_refs: list[~azure.servicefabric.models.VolumeReference]
        :keyword volumes: Volumes to be attached to the container. The lifetime of these volumes is
         scoped to the application's lifetime.
        :paramtype volumes: list[~azure.servicefabric.models.ApplicationScopedVolume]
        :keyword diagnostics: Reference to sinks in DiagnosticsDescription.
        :paramtype diagnostics: ~azure.servicefabric.models.DiagnosticsRef
        :keyword reliable_collections_refs: A list of ReliableCollection resources used by this
         particular code package. Please refer to ReliableCollectionsRef for more details.
        :paramtype reliable_collections_refs: list[~azure.servicefabric.models.ReliableCollectionsRef]
        :keyword liveness_probe: An array of liveness probes for a code package. It determines when to
         restart a code package.
        :paramtype liveness_probe: list[~azure.servicefabric.models.Probe]
        :keyword readiness_probe: An array of readiness probes for a code package. It determines when
         to unpublish an endpoint.
        :paramtype readiness_probe: list[~azure.servicefabric.models.Probe]
        """
        super(ContainerCodePackageProperties, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.image = kwargs['image']
        self.image_registry_credential = kwargs.get('image_registry_credential', None)
        self.entry_point = kwargs.get('entry_point', None)
        self.commands = kwargs.get('commands', None)
        self.environment_variables = kwargs.get('environment_variables', None)
        self.settings = kwargs.get('settings', None)
        self.labels = kwargs.get('labels', None)
        self.endpoints = kwargs.get('endpoints', None)
        self.resources = kwargs['resources']
        self.volume_refs = kwargs.get('volume_refs', None)
        self.volumes = kwargs.get('volumes', None)
        self.diagnostics = kwargs.get('diagnostics', None)
        self.reliable_collections_refs = kwargs.get('reliable_collections_refs', None)
        self.instance_view = None
        self.liveness_probe = kwargs.get('liveness_probe', None)
        self.readiness_probe = kwargs.get('readiness_probe', None)


class ContainerEvent(msrest.serialization.Model):
    """A container event.

    :ivar name: The name of the container event.
    :vartype name: str
    :ivar count: The count of the event.
    :vartype count: int
    :ivar first_timestamp: Date/time of the first event.
    :vartype first_timestamp: str
    :ivar last_timestamp: Date/time of the last event.
    :vartype last_timestamp: str
    :ivar message: The event message.
    :vartype message: str
    :ivar type: The event type.
    :vartype type: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'count': {'key': 'count', 'type': 'int'},
        'first_timestamp': {'key': 'firstTimestamp', 'type': 'str'},
        'last_timestamp': {'key': 'lastTimestamp', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: The name of the container event.
        :paramtype name: str
        :keyword count: The count of the event.
        :paramtype count: int
        :keyword first_timestamp: Date/time of the first event.
        :paramtype first_timestamp: str
        :keyword last_timestamp: Date/time of the last event.
        :paramtype last_timestamp: str
        :keyword message: The event message.
        :paramtype message: str
        :keyword type: The event type.
        :paramtype type: str
        """
        super(ContainerEvent, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.count = kwargs.get('count', None)
        self.first_timestamp = kwargs.get('first_timestamp', None)
        self.last_timestamp = kwargs.get('last_timestamp', None)
        self.message = kwargs.get('message', None)
        self.type = kwargs.get('type', None)


class ContainerInstanceEvent(FabricEvent):
    """Represents the base for all Container Events.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        """
        super(ContainerInstanceEvent, self).__init__(**kwargs)
        self.kind = 'ContainerInstanceEvent'  # type: str


class ContainerInstanceView(msrest.serialization.Model):
    """Runtime information of a container instance.

    :ivar restart_count: The number of times the container has been restarted.
    :vartype restart_count: int
    :ivar current_state: Current container instance state.
    :vartype current_state: ~azure.servicefabric.models.ContainerState
    :ivar previous_state: Previous container instance state.
    :vartype previous_state: ~azure.servicefabric.models.ContainerState
    :ivar events: The events of this container instance.
    :vartype events: list[~azure.servicefabric.models.ContainerEvent]
    """

    _attribute_map = {
        'restart_count': {'key': 'restartCount', 'type': 'int'},
        'current_state': {'key': 'currentState', 'type': 'ContainerState'},
        'previous_state': {'key': 'previousState', 'type': 'ContainerState'},
        'events': {'key': 'events', 'type': '[ContainerEvent]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword restart_count: The number of times the container has been restarted.
        :paramtype restart_count: int
        :keyword current_state: Current container instance state.
        :paramtype current_state: ~azure.servicefabric.models.ContainerState
        :keyword previous_state: Previous container instance state.
        :paramtype previous_state: ~azure.servicefabric.models.ContainerState
        :keyword events: The events of this container instance.
        :paramtype events: list[~azure.servicefabric.models.ContainerEvent]
        """
        super(ContainerInstanceView, self).__init__(**kwargs)
        self.restart_count = kwargs.get('restart_count', None)
        self.current_state = kwargs.get('current_state', None)
        self.previous_state = kwargs.get('previous_state', None)
        self.events = kwargs.get('events', None)


class ContainerLabel(msrest.serialization.Model):
    """Describes a container label.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name of the container label.
    :vartype name: str
    :ivar value: Required. The value of the container label.
    :vartype value: str
    """

    _validation = {
        'name': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. The name of the container label.
        :paramtype name: str
        :keyword value: Required. The value of the container label.
        :paramtype value: str
        """
        super(ContainerLabel, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.value = kwargs['value']


class ContainerLogs(msrest.serialization.Model):
    """Container logs.

    :ivar content: Container logs.
    :vartype content: str
    """

    _attribute_map = {
        'content': {'key': 'Content', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword content: Container logs.
        :paramtype content: str
        """
        super(ContainerLogs, self).__init__(**kwargs)
        self.content = kwargs.get('content', None)


class ContainerState(msrest.serialization.Model):
    """The container state.

    :ivar state: The state of this container.
    :vartype state: str
    :ivar start_time: Date/time when the container state started.
    :vartype start_time: ~datetime.datetime
    :ivar exit_code: The container exit code.
    :vartype exit_code: str
    :ivar finish_time: Date/time when the container state finished.
    :vartype finish_time: ~datetime.datetime
    :ivar detail_status: Human-readable status of this state.
    :vartype detail_status: str
    """

    _attribute_map = {
        'state': {'key': 'state', 'type': 'str'},
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'exit_code': {'key': 'exitCode', 'type': 'str'},
        'finish_time': {'key': 'finishTime', 'type': 'iso-8601'},
        'detail_status': {'key': 'detailStatus', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword state: The state of this container.
        :paramtype state: str
        :keyword start_time: Date/time when the container state started.
        :paramtype start_time: ~datetime.datetime
        :keyword exit_code: The container exit code.
        :paramtype exit_code: str
        :keyword finish_time: Date/time when the container state finished.
        :paramtype finish_time: ~datetime.datetime
        :keyword detail_status: Human-readable status of this state.
        :paramtype detail_status: str
        """
        super(ContainerState, self).__init__(**kwargs)
        self.state = kwargs.get('state', None)
        self.start_time = kwargs.get('start_time', None)
        self.exit_code = kwargs.get('exit_code', None)
        self.finish_time = kwargs.get('finish_time', None)
        self.detail_status = kwargs.get('detail_status', None)


class CreateComposeDeploymentDescription(msrest.serialization.Model):
    """Defines description for creating a Service Fabric compose deployment.

    All required parameters must be populated in order to send to Azure.

    :ivar deployment_name: Required. The name of the deployment.
    :vartype deployment_name: str
    :ivar compose_file_content: Required. The content of the compose file that describes the
     deployment to create.
    :vartype compose_file_content: str
    :ivar registry_credential: Credential information to connect to container registry.
    :vartype registry_credential: ~azure.servicefabric.models.RegistryCredential
    """

    _validation = {
        'deployment_name': {'required': True},
        'compose_file_content': {'required': True},
    }

    _attribute_map = {
        'deployment_name': {'key': 'DeploymentName', 'type': 'str'},
        'compose_file_content': {'key': 'ComposeFileContent', 'type': 'str'},
        'registry_credential': {'key': 'RegistryCredential', 'type': 'RegistryCredential'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword deployment_name: Required. The name of the deployment.
        :paramtype deployment_name: str
        :keyword compose_file_content: Required. The content of the compose file that describes the
         deployment to create.
        :paramtype compose_file_content: str
        :keyword registry_credential: Credential information to connect to container registry.
        :paramtype registry_credential: ~azure.servicefabric.models.RegistryCredential
        """
        super(CreateComposeDeploymentDescription, self).__init__(**kwargs)
        self.deployment_name = kwargs['deployment_name']
        self.compose_file_content = kwargs['compose_file_content']
        self.registry_credential = kwargs.get('registry_credential', None)


class CurrentUpgradeDomainProgressInfo(msrest.serialization.Model):
    """Information about the current in-progress upgrade domain. Not applicable to node-by-node upgrades.

    :ivar domain_name: The name of the upgrade domain.
    :vartype domain_name: str
    :ivar node_upgrade_progress_list: List of upgrading nodes and their statuses.
    :vartype node_upgrade_progress_list: list[~azure.servicefabric.models.NodeUpgradeProgressInfo]
    """

    _attribute_map = {
        'domain_name': {'key': 'DomainName', 'type': 'str'},
        'node_upgrade_progress_list': {'key': 'NodeUpgradeProgressList', 'type': '[NodeUpgradeProgressInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword domain_name: The name of the upgrade domain.
        :paramtype domain_name: str
        :keyword node_upgrade_progress_list: List of upgrading nodes and their statuses.
        :paramtype node_upgrade_progress_list:
         list[~azure.servicefabric.models.NodeUpgradeProgressInfo]
        """
        super(CurrentUpgradeDomainProgressInfo, self).__init__(**kwargs)
        self.domain_name = kwargs.get('domain_name', None)
        self.node_upgrade_progress_list = kwargs.get('node_upgrade_progress_list', None)


class CurrentUpgradeUnitsProgressInfo(msrest.serialization.Model):
    """Information about the current in-progress upgrade units.

    :ivar domain_name: The name of the upgrade domain. Not applicable to node-by-node upgrades.
    :vartype domain_name: str
    :ivar node_upgrade_progress_list: List of upgrading nodes and their statuses.
    :vartype node_upgrade_progress_list: list[~azure.servicefabric.models.NodeUpgradeProgressInfo]
    """

    _attribute_map = {
        'domain_name': {'key': 'DomainName', 'type': 'str'},
        'node_upgrade_progress_list': {'key': 'NodeUpgradeProgressList', 'type': '[NodeUpgradeProgressInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword domain_name: The name of the upgrade domain. Not applicable to node-by-node upgrades.
        :paramtype domain_name: str
        :keyword node_upgrade_progress_list: List of upgrading nodes and their statuses.
        :paramtype node_upgrade_progress_list:
         list[~azure.servicefabric.models.NodeUpgradeProgressInfo]
        """
        super(CurrentUpgradeUnitsProgressInfo, self).__init__(**kwargs)
        self.domain_name = kwargs.get('domain_name', None)
        self.node_upgrade_progress_list = kwargs.get('node_upgrade_progress_list', None)


class DeactivationIntentDescription(msrest.serialization.Model):
    """Describes the intent or reason for deactivating the node.

    :ivar deactivation_intent: Describes the intent or reason for deactivating the node. The
     possible values are following. Possible values include: "Pause", "Restart", "RemoveData".
    :vartype deactivation_intent: str or ~azure.servicefabric.models.DeactivationIntent
    """

    _attribute_map = {
        'deactivation_intent': {'key': 'DeactivationIntent', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword deactivation_intent: Describes the intent or reason for deactivating the node. The
         possible values are following. Possible values include: "Pause", "Restart", "RemoveData".
        :paramtype deactivation_intent: str or ~azure.servicefabric.models.DeactivationIntent
        """
        super(DeactivationIntentDescription, self).__init__(**kwargs)
        self.deactivation_intent = kwargs.get('deactivation_intent', None)


class ExecutionPolicy(msrest.serialization.Model):
    """The execution policy of the service.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: DefaultExecutionPolicy, RunToCompletionExecutionPolicy.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. Enumerates the execution policy types for services.Constant filled by
     server. Possible values include: "Default", "RunToCompletion".
    :vartype type: str or ~azure.servicefabric.models.ExecutionPolicyType
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'Default': 'DefaultExecutionPolicy', 'RunToCompletion': 'RunToCompletionExecutionPolicy'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(ExecutionPolicy, self).__init__(**kwargs)
        self.type = None  # type: Optional[str]


class DefaultExecutionPolicy(ExecutionPolicy):
    """The default execution policy. Always restart the service if an exit occurs.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. Enumerates the execution policy types for services.Constant filled by
     server. Possible values include: "Default", "RunToCompletion".
    :vartype type: str or ~azure.servicefabric.models.ExecutionPolicyType
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(DefaultExecutionPolicy, self).__init__(**kwargs)
        self.type = 'Default'  # type: str


class DeletePropertyBatchOperation(PropertyBatchOperation):
    """Represents a PropertyBatchOperation that deletes a specified property if it exists.
Note that if one PropertyBatchOperation in a PropertyBatch fails,
the entire batch fails and cannot be committed in a transactional manner.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property batch operation, determined by the operation to be
     performed. The following are the possible values.Constant filled by server. Possible values
     include: "Invalid", "Put", "Get", "CheckExists", "CheckSequence", "Delete", "CheckValue".
    :vartype kind: str or ~azure.servicefabric.models.PropertyBatchOperationKind
    :ivar property_name: Required. The name of the Service Fabric property.
    :vartype property_name: str
    """

    _validation = {
        'kind': {'required': True},
        'property_name': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'property_name': {'key': 'PropertyName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword property_name: Required. The name of the Service Fabric property.
        :paramtype property_name: str
        """
        super(DeletePropertyBatchOperation, self).__init__(**kwargs)
        self.kind = 'Delete'  # type: str


class DeltaNodesCheckHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for delta nodes, containing health evaluations for each unhealthy node that impacted current aggregated health state.
Can be returned during cluster upgrade when the aggregated health state of the cluster is Warning or Error.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar baseline_error_count: Number of nodes with aggregated heath state Error in the health
     store at the beginning of the cluster upgrade.
    :vartype baseline_error_count: long
    :ivar baseline_total_count: Total number of nodes in the health store at the beginning of the
     cluster upgrade.
    :vartype baseline_total_count: long
    :ivar max_percent_delta_unhealthy_nodes: Maximum allowed percentage of delta unhealthy nodes
     from the ClusterUpgradeHealthPolicy.
    :vartype max_percent_delta_unhealthy_nodes: int
    :ivar total_count: Total number of nodes in the health store.
    :vartype total_count: long
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
     state.
     Includes all the unhealthy NodeHealthEvaluation that impacted the aggregated health.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'baseline_error_count': {'key': 'BaselineErrorCount', 'type': 'long'},
        'baseline_total_count': {'key': 'BaselineTotalCount', 'type': 'long'},
        'max_percent_delta_unhealthy_nodes': {'key': 'MaxPercentDeltaUnhealthyNodes', 'type': 'int'},
        'total_count': {'key': 'TotalCount', 'type': 'long'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword baseline_error_count: Number of nodes with aggregated heath state Error in the health
         store at the beginning of the cluster upgrade.
        :paramtype baseline_error_count: long
        :keyword baseline_total_count: Total number of nodes in the health store at the beginning of
         the cluster upgrade.
        :paramtype baseline_total_count: long
        :keyword max_percent_delta_unhealthy_nodes: Maximum allowed percentage of delta unhealthy nodes
         from the ClusterUpgradeHealthPolicy.
        :paramtype max_percent_delta_unhealthy_nodes: int
        :keyword total_count: Total number of nodes in the health store.
        :paramtype total_count: long
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
         state.
         Includes all the unhealthy NodeHealthEvaluation that impacted the aggregated health.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(DeltaNodesCheckHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'DeltaNodesCheck'  # type: str
        self.baseline_error_count = kwargs.get('baseline_error_count', None)
        self.baseline_total_count = kwargs.get('baseline_total_count', None)
        self.max_percent_delta_unhealthy_nodes = kwargs.get('max_percent_delta_unhealthy_nodes', None)
        self.total_count = kwargs.get('total_count', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class DeployedApplicationHealth(EntityHealth):
    """Information about the health of an application deployed on a Service Fabric node.

    :ivar aggregated_health_state: The HealthState representing the aggregated health state of the
     entity computed by Health Manager.
     The health evaluation of the entity reflects all events reported on the entity and its
     children (if any).
     The aggregation is done by applying the desired health policy. Possible values include:
     "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar health_events: The list of health events reported on the entity.
    :vartype health_events: list[~azure.servicefabric.models.HealthEvent]
    :ivar unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
     health state was returned by Health Manager.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    :ivar health_statistics: Shows the health statistics for all children types of the queried
     entity.
    :vartype health_statistics: ~azure.servicefabric.models.HealthStatistics
    :ivar name: Name of the application deployed on the node whose health information is described
     by this object.
    :vartype name: str
    :ivar node_name: Name of the node where this application is deployed.
    :vartype node_name: str
    :ivar deployed_service_package_health_states: Deployed service package health states for the
     current deployed application as found in the health store.
    :vartype deployed_service_package_health_states:
     list[~azure.servicefabric.models.DeployedServicePackageHealthState]
    """

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'health_events': {'key': 'HealthEvents', 'type': '[HealthEvent]'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
        'health_statistics': {'key': 'HealthStatistics', 'type': 'HealthStatistics'},
        'name': {'key': 'Name', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'deployed_service_package_health_states': {'key': 'DeployedServicePackageHealthStates', 'type': '[DeployedServicePackageHealthState]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The HealthState representing the aggregated health state of
         the entity computed by Health Manager.
         The health evaluation of the entity reflects all events reported on the entity and its
         children (if any).
         The aggregation is done by applying the desired health policy. Possible values include:
         "Invalid", "Ok", "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword health_events: The list of health events reported on the entity.
        :paramtype health_events: list[~azure.servicefabric.models.HealthEvent]
        :keyword unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
         health state was returned by Health Manager.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        :keyword health_statistics: Shows the health statistics for all children types of the queried
         entity.
        :paramtype health_statistics: ~azure.servicefabric.models.HealthStatistics
        :keyword name: Name of the application deployed on the node whose health information is
         described by this object.
        :paramtype name: str
        :keyword node_name: Name of the node where this application is deployed.
        :paramtype node_name: str
        :keyword deployed_service_package_health_states: Deployed service package health states for the
         current deployed application as found in the health store.
        :paramtype deployed_service_package_health_states:
         list[~azure.servicefabric.models.DeployedServicePackageHealthState]
        """
        super(DeployedApplicationHealth, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.node_name = kwargs.get('node_name', None)
        self.deployed_service_package_health_states = kwargs.get('deployed_service_package_health_states', None)


class DeployedApplicationHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for a deployed application, containing information about the data and the algorithm used by the health store to evaluate health.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar node_name: Name of the node where the application is deployed to.
    :vartype node_name: str
    :ivar application_name: The name of the application, including the 'fabric:' URI scheme.
    :vartype application_name: str
    :ivar unhealthy_evaluations: List of  unhealthy evaluations that led to the current aggregated
     health state of the deployed application.
     The types of the unhealthy evaluations can be DeployedServicePackagesHealthEvaluation or
     EventHealthEvaluation.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword node_name: Name of the node where the application is deployed to.
        :paramtype node_name: str
        :keyword application_name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype application_name: str
        :keyword unhealthy_evaluations: List of  unhealthy evaluations that led to the current
         aggregated health state of the deployed application.
         The types of the unhealthy evaluations can be DeployedServicePackagesHealthEvaluation or
         EventHealthEvaluation.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(DeployedApplicationHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'DeployedApplication'  # type: str
        self.node_name = kwargs.get('node_name', None)
        self.application_name = kwargs.get('application_name', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class DeployedApplicationHealthReportExpiredEvent(ApplicationEvent):
    """Deployed Application Health Report Expired event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar application_instance_id: Required. Id of Application instance.
    :vartype application_instance_id: long
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'application_instance_id': {'required': True},
        'node_name': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'application_instance_id': {'key': 'ApplicationInstanceId', 'type': 'long'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword application_instance_id: Required. Id of Application instance.
        :paramtype application_instance_id: long
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(DeployedApplicationHealthReportExpiredEvent, self).__init__(**kwargs)
        self.kind = 'DeployedApplicationHealthReportExpired'  # type: str
        self.application_instance_id = kwargs['application_instance_id']
        self.node_name = kwargs['node_name']
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class DeployedApplicationHealthState(EntityHealthState):
    """Represents the health state of a deployed application, which contains the entity identifier and the aggregated health state.

    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar node_name: Name of the node on which the service package is deployed.
    :vartype node_name: str
    :ivar application_name: The name of the application, including the 'fabric:' URI scheme.
    :vartype application_name: str
    """

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword node_name: Name of the node on which the service package is deployed.
        :paramtype node_name: str
        :keyword application_name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype application_name: str
        """
        super(DeployedApplicationHealthState, self).__init__(**kwargs)
        self.node_name = kwargs.get('node_name', None)
        self.application_name = kwargs.get('application_name', None)


class DeployedApplicationHealthStateChunk(EntityHealthStateChunk):
    """Represents the health state chunk of a deployed application, which contains the node where the application is deployed, the aggregated health state and any deployed service packages that respect the chunk query description filters.

    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar node_name: The name of node where the application is deployed.
    :vartype node_name: str
    :ivar deployed_service_package_health_state_chunks: The list of deployed service package health
     state chunks belonging to the deployed application that respect the filters in the cluster
     health chunk query description.
    :vartype deployed_service_package_health_state_chunks:
     ~azure.servicefabric.models.DeployedServicePackageHealthStateChunkList
    """

    _attribute_map = {
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'deployed_service_package_health_state_chunks': {'key': 'DeployedServicePackageHealthStateChunks', 'type': 'DeployedServicePackageHealthStateChunkList'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword node_name: The name of node where the application is deployed.
        :paramtype node_name: str
        :keyword deployed_service_package_health_state_chunks: The list of deployed service package
         health state chunks belonging to the deployed application that respect the filters in the
         cluster health chunk query description.
        :paramtype deployed_service_package_health_state_chunks:
         ~azure.servicefabric.models.DeployedServicePackageHealthStateChunkList
        """
        super(DeployedApplicationHealthStateChunk, self).__init__(**kwargs)
        self.node_name = kwargs.get('node_name', None)
        self.deployed_service_package_health_state_chunks = kwargs.get('deployed_service_package_health_state_chunks', None)


class DeployedApplicationHealthStateChunkList(msrest.serialization.Model):
    """The list of deployed application health state chunks that respect the input filters in the chunk query. Returned by get cluster health state chunks query.

    :ivar items: The list of deployed application health state chunks that respect the input
     filters in the chunk query.
    :vartype items: list[~azure.servicefabric.models.DeployedApplicationHealthStateChunk]
    """

    _attribute_map = {
        'items': {'key': 'Items', 'type': '[DeployedApplicationHealthStateChunk]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword items: The list of deployed application health state chunks that respect the input
         filters in the chunk query.
        :paramtype items: list[~azure.servicefabric.models.DeployedApplicationHealthStateChunk]
        """
        super(DeployedApplicationHealthStateChunkList, self).__init__(**kwargs)
        self.items = kwargs.get('items', None)


class DeployedApplicationHealthStateFilter(msrest.serialization.Model):
    """Defines matching criteria to determine whether a deployed application should be included as a child of an application in the cluster health chunk.
The deployed applications are only returned if the parent application matches a filter specified in the cluster health chunk query description.
One filter can match zero, one or multiple deployed applications, depending on its properties.

    :ivar node_name_filter: The name of the node where the application is deployed in order to
     match the filter.
     If specified, the filter is applied only to the application deployed on the specified node.
     If the application is not deployed on the node with the specified name, no deployed
     application is returned in the cluster health chunk based on this filter.
     Otherwise, the deployed application is included in the cluster health chunk if it respects the
     other filter properties.
     If not specified, all deployed applications that match the parent filters (if any) are taken
     into consideration and matched against the other filter members, like health state filter.
    :vartype node_name_filter: str
    :ivar health_state_filter: The filter for the health state of the deployed applications. It
     allows selecting deployed applications if they match the desired health states.
     The possible values are integer value of one of the following health states. Only deployed
     applications that match the filter are returned. All deployed applications are used to evaluate
     the cluster aggregated health state.
     If not specified, default value is None, unless the node name is specified. If the filter has
     default value and node name is specified, the matching deployed application is returned.
     The state values are flag-based enumeration, so the value could be a combination of these
     values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6, it matches deployed applications with HealthState
     value of OK (2) and Warning (4).
    
    
     * Default - Default value. Matches any HealthState. The value is zero.
     * None - Filter that doesn't match any HealthState value. Used in order to return no results
     on a given collection of states. The value is 1.
     * Ok - Filter that matches input with HealthState value Ok. The value is 2.
     * Warning - Filter that matches input with HealthState value Warning. The value is 4.
     * Error - Filter that matches input with HealthState value Error. The value is 8.
     * All - Filter that matches input with any HealthState value. The value is 65535.
    :vartype health_state_filter: int
    :ivar deployed_service_package_filters: Defines a list of filters that specify which deployed
     service packages to be included in the returned cluster health chunk as children of the parent
     deployed application. The deployed service packages are returned only if the parent deployed
     application matches a filter.
     If the list is empty, no deployed service packages are returned. All the deployed service
     packages are used to evaluate the parent deployed application aggregated health state,
     regardless of the input filters.
     The deployed application filter may specify multiple deployed service package filters.
     For example, it can specify a filter to return all deployed service packages with health state
     Error and another filter to always include a deployed service package on a node.
    :vartype deployed_service_package_filters:
     list[~azure.servicefabric.models.DeployedServicePackageHealthStateFilter]
    """

    _attribute_map = {
        'node_name_filter': {'key': 'NodeNameFilter', 'type': 'str'},
        'health_state_filter': {'key': 'HealthStateFilter', 'type': 'int'},
        'deployed_service_package_filters': {'key': 'DeployedServicePackageFilters', 'type': '[DeployedServicePackageHealthStateFilter]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword node_name_filter: The name of the node where the application is deployed in order to
         match the filter.
         If specified, the filter is applied only to the application deployed on the specified node.
         If the application is not deployed on the node with the specified name, no deployed
         application is returned in the cluster health chunk based on this filter.
         Otherwise, the deployed application is included in the cluster health chunk if it respects the
         other filter properties.
         If not specified, all deployed applications that match the parent filters (if any) are taken
         into consideration and matched against the other filter members, like health state filter.
        :paramtype node_name_filter: str
        :keyword health_state_filter: The filter for the health state of the deployed applications. It
         allows selecting deployed applications if they match the desired health states.
         The possible values are integer value of one of the following health states. Only deployed
         applications that match the filter are returned. All deployed applications are used to evaluate
         the cluster aggregated health state.
         If not specified, default value is None, unless the node name is specified. If the filter has
         default value and node name is specified, the matching deployed application is returned.
         The state values are flag-based enumeration, so the value could be a combination of these
         values obtained using bitwise 'OR' operator.
         For example, if the provided value is 6, it matches deployed applications with HealthState
         value of OK (2) and Warning (4).
        
        
         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535.
        :paramtype health_state_filter: int
        :keyword deployed_service_package_filters: Defines a list of filters that specify which
         deployed service packages to be included in the returned cluster health chunk as children of
         the parent deployed application. The deployed service packages are returned only if the parent
         deployed application matches a filter.
         If the list is empty, no deployed service packages are returned. All the deployed service
         packages are used to evaluate the parent deployed application aggregated health state,
         regardless of the input filters.
         The deployed application filter may specify multiple deployed service package filters.
         For example, it can specify a filter to return all deployed service packages with health state
         Error and another filter to always include a deployed service package on a node.
        :paramtype deployed_service_package_filters:
         list[~azure.servicefabric.models.DeployedServicePackageHealthStateFilter]
        """
        super(DeployedApplicationHealthStateFilter, self).__init__(**kwargs)
        self.node_name_filter = kwargs.get('node_name_filter', None)
        self.health_state_filter = kwargs.get('health_state_filter', 0)
        self.deployed_service_package_filters = kwargs.get('deployed_service_package_filters', None)


class DeployedApplicationInfo(msrest.serialization.Model):
    """Information about application deployed on the node.

    :ivar id: The identity of the application. This is an encoded representation of the application
     name. This is used in the REST APIs to identify the application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype id: str
    :ivar name: The name of the application, including the 'fabric:' URI scheme.
    :vartype name: str
    :ivar type_name: The application type name as defined in the application manifest.
    :vartype type_name: str
    :ivar type_version: The version of the application type as defined in the application manifest.
    :vartype type_version: str
    :ivar status: The status of the application deployed on the node. Following are the possible
     values. Possible values include: "Invalid", "Downloading", "Activating", "Active", "Upgrading",
     "Deactivating".
    :vartype status: str or ~azure.servicefabric.models.DeployedApplicationStatus
    :ivar work_directory: The work directory of the application on the node. The work directory can
     be used to store application data.
    :vartype work_directory: str
    :ivar log_directory: The log directory of the application on the node. The log directory can be
     used to store application logs.
    :vartype log_directory: str
    :ivar temp_directory: The temp directory of the application on the node. The code packages
     belonging to the application are forked with this directory set as their temporary directory.
    :vartype temp_directory: str
    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    """

    _attribute_map = {
        'id': {'key': 'Id', 'type': 'str'},
        'name': {'key': 'Name', 'type': 'str'},
        'type_name': {'key': 'TypeName', 'type': 'str'},
        'type_version': {'key': 'TypeVersion', 'type': 'str'},
        'status': {'key': 'Status', 'type': 'str'},
        'work_directory': {'key': 'WorkDirectory', 'type': 'str'},
        'log_directory': {'key': 'LogDirectory', 'type': 'str'},
        'temp_directory': {'key': 'TempDirectory', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword id: The identity of the application. This is an encoded representation of the
         application name. This is used in the REST APIs to identify the application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype id: str
        :keyword name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype name: str
        :keyword type_name: The application type name as defined in the application manifest.
        :paramtype type_name: str
        :keyword type_version: The version of the application type as defined in the application
         manifest.
        :paramtype type_version: str
        :keyword status: The status of the application deployed on the node. Following are the possible
         values. Possible values include: "Invalid", "Downloading", "Activating", "Active", "Upgrading",
         "Deactivating".
        :paramtype status: str or ~azure.servicefabric.models.DeployedApplicationStatus
        :keyword work_directory: The work directory of the application on the node. The work directory
         can be used to store application data.
        :paramtype work_directory: str
        :keyword log_directory: The log directory of the application on the node. The log directory can
         be used to store application logs.
        :paramtype log_directory: str
        :keyword temp_directory: The temp directory of the application on the node. The code packages
         belonging to the application are forked with this directory set as their temporary directory.
        :paramtype temp_directory: str
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        """
        super(DeployedApplicationInfo, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.name = kwargs.get('name', None)
        self.type_name = kwargs.get('type_name', None)
        self.type_version = kwargs.get('type_version', None)
        self.status = kwargs.get('status', None)
        self.work_directory = kwargs.get('work_directory', None)
        self.log_directory = kwargs.get('log_directory', None)
        self.temp_directory = kwargs.get('temp_directory', None)
        self.health_state = kwargs.get('health_state', None)


class DeployedApplicationNewHealthReportEvent(ApplicationEvent):
    """Deployed Application Health Report Created event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar application_instance_id: Required. Id of Application instance.
    :vartype application_instance_id: long
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'application_instance_id': {'required': True},
        'node_name': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'application_instance_id': {'key': 'ApplicationInstanceId', 'type': 'long'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword application_instance_id: Required. Id of Application instance.
        :paramtype application_instance_id: long
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(DeployedApplicationNewHealthReportEvent, self).__init__(**kwargs)
        self.kind = 'DeployedApplicationNewHealthReport'  # type: str
        self.application_instance_id = kwargs['application_instance_id']
        self.node_name = kwargs['node_name']
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class DeployedApplicationsHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for deployed applications, containing health evaluations for each unhealthy deployed application that impacted current aggregated health state.
Can be returned when evaluating application health and the aggregated health state is either Error or Warning.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar max_percent_unhealthy_deployed_applications: Maximum allowed percentage of unhealthy
     deployed applications from the ApplicationHealthPolicy.
    :vartype max_percent_unhealthy_deployed_applications: int
    :ivar total_count: Total number of deployed applications of the application in the health
     store.
    :vartype total_count: long
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
     state. Includes all the unhealthy DeployedApplicationHealthEvaluation that impacted the
     aggregated health.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'max_percent_unhealthy_deployed_applications': {'key': 'MaxPercentUnhealthyDeployedApplications', 'type': 'int'},
        'total_count': {'key': 'TotalCount', 'type': 'long'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword max_percent_unhealthy_deployed_applications: Maximum allowed percentage of unhealthy
         deployed applications from the ApplicationHealthPolicy.
        :paramtype max_percent_unhealthy_deployed_applications: int
        :keyword total_count: Total number of deployed applications of the application in the health
         store.
        :paramtype total_count: long
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
         state. Includes all the unhealthy DeployedApplicationHealthEvaluation that impacted the
         aggregated health.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(DeployedApplicationsHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'DeployedApplications'  # type: str
        self.max_percent_unhealthy_deployed_applications = kwargs.get('max_percent_unhealthy_deployed_applications', None)
        self.total_count = kwargs.get('total_count', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class DeployedCodePackageInfo(msrest.serialization.Model):
    """Information about code package deployed on a Service Fabric node.

    :ivar name: The name of the code package.
    :vartype name: str
    :ivar version: The version of the code package specified in service manifest.
    :vartype version: str
    :ivar service_manifest_name: The name of service manifest that specified this code package.
    :vartype service_manifest_name: str
    :ivar service_package_activation_id: The ActivationId of a deployed service package. If
     ServicePackageActivationMode specified at the time of creating the service
     is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
     then value of ServicePackageActivationId
     is always an empty string.
    :vartype service_package_activation_id: str
    :ivar host_type: Specifies the type of host for main entry point of a code package as specified
     in service manifest. Possible values include: "Invalid", "ExeHost", "ContainerHost".
    :vartype host_type: str or ~azure.servicefabric.models.HostType
    :ivar host_isolation_mode: Specifies the isolation mode of main entry point of a code package
     when it's host type is ContainerHost. This is specified as part of container host policies in
     application manifest while importing service manifest. Possible values include: "None",
     "Process", "HyperV".
    :vartype host_isolation_mode: str or ~azure.servicefabric.models.HostIsolationMode
    :ivar status: Specifies the status of a deployed application or service package on a Service
     Fabric node. Possible values include: "Invalid", "Downloading", "Activating", "Active",
     "Upgrading", "Deactivating", "RanToCompletion", "Failed".
    :vartype status: str or ~azure.servicefabric.models.DeploymentStatus
    :ivar run_frequency_interval: The interval at which code package is run. This is used for
     periodic code package.
    :vartype run_frequency_interval: str
    :ivar setup_entry_point: Information about setup or main entry point of a code package deployed
     on a Service Fabric node.
    :vartype setup_entry_point: ~azure.servicefabric.models.CodePackageEntryPoint
    :ivar main_entry_point: Information about setup or main entry point of a code package deployed
     on a Service Fabric node.
    :vartype main_entry_point: ~azure.servicefabric.models.CodePackageEntryPoint
    """

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'version': {'key': 'Version', 'type': 'str'},
        'service_manifest_name': {'key': 'ServiceManifestName', 'type': 'str'},
        'service_package_activation_id': {'key': 'ServicePackageActivationId', 'type': 'str'},
        'host_type': {'key': 'HostType', 'type': 'str'},
        'host_isolation_mode': {'key': 'HostIsolationMode', 'type': 'str'},
        'status': {'key': 'Status', 'type': 'str'},
        'run_frequency_interval': {'key': 'RunFrequencyInterval', 'type': 'str'},
        'setup_entry_point': {'key': 'SetupEntryPoint', 'type': 'CodePackageEntryPoint'},
        'main_entry_point': {'key': 'MainEntryPoint', 'type': 'CodePackageEntryPoint'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: The name of the code package.
        :paramtype name: str
        :keyword version: The version of the code package specified in service manifest.
        :paramtype version: str
        :keyword service_manifest_name: The name of service manifest that specified this code package.
        :paramtype service_manifest_name: str
        :keyword service_package_activation_id: The ActivationId of a deployed service package. If
         ServicePackageActivationMode specified at the time of creating the service
         is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
         then value of ServicePackageActivationId
         is always an empty string.
        :paramtype service_package_activation_id: str
        :keyword host_type: Specifies the type of host for main entry point of a code package as
         specified in service manifest. Possible values include: "Invalid", "ExeHost", "ContainerHost".
        :paramtype host_type: str or ~azure.servicefabric.models.HostType
        :keyword host_isolation_mode: Specifies the isolation mode of main entry point of a code
         package when it's host type is ContainerHost. This is specified as part of container host
         policies in application manifest while importing service manifest. Possible values include:
         "None", "Process", "HyperV".
        :paramtype host_isolation_mode: str or ~azure.servicefabric.models.HostIsolationMode
        :keyword status: Specifies the status of a deployed application or service package on a Service
         Fabric node. Possible values include: "Invalid", "Downloading", "Activating", "Active",
         "Upgrading", "Deactivating", "RanToCompletion", "Failed".
        :paramtype status: str or ~azure.servicefabric.models.DeploymentStatus
        :keyword run_frequency_interval: The interval at which code package is run. This is used for
         periodic code package.
        :paramtype run_frequency_interval: str
        :keyword setup_entry_point: Information about setup or main entry point of a code package
         deployed on a Service Fabric node.
        :paramtype setup_entry_point: ~azure.servicefabric.models.CodePackageEntryPoint
        :keyword main_entry_point: Information about setup or main entry point of a code package
         deployed on a Service Fabric node.
        :paramtype main_entry_point: ~azure.servicefabric.models.CodePackageEntryPoint
        """
        super(DeployedCodePackageInfo, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.version = kwargs.get('version', None)
        self.service_manifest_name = kwargs.get('service_manifest_name', None)
        self.service_package_activation_id = kwargs.get('service_package_activation_id', None)
        self.host_type = kwargs.get('host_type', None)
        self.host_isolation_mode = kwargs.get('host_isolation_mode', None)
        self.status = kwargs.get('status', None)
        self.run_frequency_interval = kwargs.get('run_frequency_interval', None)
        self.setup_entry_point = kwargs.get('setup_entry_point', None)
        self.main_entry_point = kwargs.get('main_entry_point', None)


class DeployedServicePackageHealth(EntityHealth):
    """Information about the health of a service package for a specific application deployed on a Service Fabric node.

    :ivar aggregated_health_state: The HealthState representing the aggregated health state of the
     entity computed by Health Manager.
     The health evaluation of the entity reflects all events reported on the entity and its
     children (if any).
     The aggregation is done by applying the desired health policy. Possible values include:
     "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar health_events: The list of health events reported on the entity.
    :vartype health_events: list[~azure.servicefabric.models.HealthEvent]
    :ivar unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
     health state was returned by Health Manager.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    :ivar health_statistics: Shows the health statistics for all children types of the queried
     entity.
    :vartype health_statistics: ~azure.servicefabric.models.HealthStatistics
    :ivar application_name: The name of the application, including the 'fabric:' URI scheme.
    :vartype application_name: str
    :ivar service_manifest_name: Name of the service manifest.
    :vartype service_manifest_name: str
    :ivar node_name: Name of the node where this service package is deployed.
    :vartype node_name: str
    """

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'health_events': {'key': 'HealthEvents', 'type': '[HealthEvent]'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
        'health_statistics': {'key': 'HealthStatistics', 'type': 'HealthStatistics'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
        'service_manifest_name': {'key': 'ServiceManifestName', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The HealthState representing the aggregated health state of
         the entity computed by Health Manager.
         The health evaluation of the entity reflects all events reported on the entity and its
         children (if any).
         The aggregation is done by applying the desired health policy. Possible values include:
         "Invalid", "Ok", "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword health_events: The list of health events reported on the entity.
        :paramtype health_events: list[~azure.servicefabric.models.HealthEvent]
        :keyword unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
         health state was returned by Health Manager.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        :keyword health_statistics: Shows the health statistics for all children types of the queried
         entity.
        :paramtype health_statistics: ~azure.servicefabric.models.HealthStatistics
        :keyword application_name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype application_name: str
        :keyword service_manifest_name: Name of the service manifest.
        :paramtype service_manifest_name: str
        :keyword node_name: Name of the node where this service package is deployed.
        :paramtype node_name: str
        """
        super(DeployedServicePackageHealth, self).__init__(**kwargs)
        self.application_name = kwargs.get('application_name', None)
        self.service_manifest_name = kwargs.get('service_manifest_name', None)
        self.node_name = kwargs.get('node_name', None)


class DeployedServicePackageHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for a deployed service package, containing information about the data and the algorithm used by health store to evaluate health. The evaluation is returned only when the aggregated health state is either Error or Warning.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar node_name: The name of a Service Fabric node.
    :vartype node_name: str
    :ivar application_name: The name of the application, including the 'fabric:' URI scheme.
    :vartype application_name: str
    :ivar service_manifest_name: The name of the service manifest.
    :vartype service_manifest_name: str
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the current aggregated
     health state. The type of the unhealthy evaluations can be EventHealthEvaluation.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
        'service_manifest_name': {'key': 'ServiceManifestName', 'type': 'str'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword node_name: The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword application_name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype application_name: str
        :keyword service_manifest_name: The name of the service manifest.
        :paramtype service_manifest_name: str
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the current
         aggregated health state. The type of the unhealthy evaluations can be EventHealthEvaluation.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(DeployedServicePackageHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'DeployedServicePackage'  # type: str
        self.node_name = kwargs.get('node_name', None)
        self.application_name = kwargs.get('application_name', None)
        self.service_manifest_name = kwargs.get('service_manifest_name', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class DeployedServicePackageHealthReportExpiredEvent(ApplicationEvent):
    """Deployed Service Health Report Expired event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar service_manifest: Required. Service manifest name.
    :vartype service_manifest: str
    :ivar service_package_instance_id: Required. Id of Service package instance.
    :vartype service_package_instance_id: long
    :ivar service_package_activation_id: Required. Id of Service package activation.
    :vartype service_package_activation_id: str
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'service_manifest': {'required': True},
        'service_package_instance_id': {'required': True},
        'service_package_activation_id': {'required': True},
        'node_name': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'service_manifest': {'key': 'ServiceManifest', 'type': 'str'},
        'service_package_instance_id': {'key': 'ServicePackageInstanceId', 'type': 'long'},
        'service_package_activation_id': {'key': 'ServicePackageActivationId', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword service_manifest: Required. Service manifest name.
        :paramtype service_manifest: str
        :keyword service_package_instance_id: Required. Id of Service package instance.
        :paramtype service_package_instance_id: long
        :keyword service_package_activation_id: Required. Id of Service package activation.
        :paramtype service_package_activation_id: str
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(DeployedServicePackageHealthReportExpiredEvent, self).__init__(**kwargs)
        self.kind = 'DeployedServicePackageHealthReportExpired'  # type: str
        self.service_manifest = kwargs['service_manifest']
        self.service_package_instance_id = kwargs['service_package_instance_id']
        self.service_package_activation_id = kwargs['service_package_activation_id']
        self.node_name = kwargs['node_name']
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class DeployedServicePackageHealthState(EntityHealthState):
    """Represents the health state of a deployed service package, containing the entity identifier and the aggregated health state.

    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar node_name: Name of the node on which the service package is deployed.
    :vartype node_name: str
    :ivar application_name: The name of the application, including the 'fabric:' URI scheme.
    :vartype application_name: str
    :ivar service_manifest_name: Name of the manifest describing the service package.
    :vartype service_manifest_name: str
    :ivar service_package_activation_id: The ActivationId of a deployed service package. If
     ServicePackageActivationMode specified at the time of creating the service
     is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
     then value of ServicePackageActivationId
     is always an empty string.
    :vartype service_package_activation_id: str
    """

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
        'service_manifest_name': {'key': 'ServiceManifestName', 'type': 'str'},
        'service_package_activation_id': {'key': 'ServicePackageActivationId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword node_name: Name of the node on which the service package is deployed.
        :paramtype node_name: str
        :keyword application_name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype application_name: str
        :keyword service_manifest_name: Name of the manifest describing the service package.
        :paramtype service_manifest_name: str
        :keyword service_package_activation_id: The ActivationId of a deployed service package. If
         ServicePackageActivationMode specified at the time of creating the service
         is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
         then value of ServicePackageActivationId
         is always an empty string.
        :paramtype service_package_activation_id: str
        """
        super(DeployedServicePackageHealthState, self).__init__(**kwargs)
        self.node_name = kwargs.get('node_name', None)
        self.application_name = kwargs.get('application_name', None)
        self.service_manifest_name = kwargs.get('service_manifest_name', None)
        self.service_package_activation_id = kwargs.get('service_package_activation_id', None)


class DeployedServicePackageHealthStateChunk(EntityHealthStateChunk):
    """Represents the health state chunk of a deployed service package, which contains the service manifest name and the service package aggregated health state.

    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar service_manifest_name: The name of the service manifest.
    :vartype service_manifest_name: str
    :ivar service_package_activation_id: The ActivationId of a deployed service package. If
     ServicePackageActivationMode specified at the time of creating the service
     is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
     then value of ServicePackageActivationId
     is always an empty string.
    :vartype service_package_activation_id: str
    """

    _attribute_map = {
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'service_manifest_name': {'key': 'ServiceManifestName', 'type': 'str'},
        'service_package_activation_id': {'key': 'ServicePackageActivationId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword service_manifest_name: The name of the service manifest.
        :paramtype service_manifest_name: str
        :keyword service_package_activation_id: The ActivationId of a deployed service package. If
         ServicePackageActivationMode specified at the time of creating the service
         is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
         then value of ServicePackageActivationId
         is always an empty string.
        :paramtype service_package_activation_id: str
        """
        super(DeployedServicePackageHealthStateChunk, self).__init__(**kwargs)
        self.service_manifest_name = kwargs.get('service_manifest_name', None)
        self.service_package_activation_id = kwargs.get('service_package_activation_id', None)


class DeployedServicePackageHealthStateChunkList(msrest.serialization.Model):
    """The list of deployed service package health state chunks that respect the input filters in the chunk query. Returned by get cluster health state chunks query.

    :ivar items: The list of deployed service package health state chunks that respect the input
     filters in the chunk query.
    :vartype items: list[~azure.servicefabric.models.DeployedServicePackageHealthStateChunk]
    """

    _attribute_map = {
        'items': {'key': 'Items', 'type': '[DeployedServicePackageHealthStateChunk]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword items: The list of deployed service package health state chunks that respect the input
         filters in the chunk query.
        :paramtype items: list[~azure.servicefabric.models.DeployedServicePackageHealthStateChunk]
        """
        super(DeployedServicePackageHealthStateChunkList, self).__init__(**kwargs)
        self.items = kwargs.get('items', None)


class DeployedServicePackageHealthStateFilter(msrest.serialization.Model):
    """Defines matching criteria to determine whether a deployed service package should be included as a child of a deployed application in the cluster health chunk.
The deployed service packages are only returned if the parent entities match a filter specified in the cluster health chunk query description. The parent deployed application and its parent application must be included in the cluster health chunk.
One filter can match zero, one or multiple deployed service packages, depending on its properties.

    :ivar service_manifest_name_filter: The name of the service manifest which identifies the
     deployed service packages that matches the filter.
     If specified, the filter is applied only to the specified deployed service packages, if any.
     If no deployed service packages with specified manifest name exist, nothing is returned in the
     cluster health chunk based on this filter.
     If any deployed service package exists, they are included in the cluster health chunk if it
     respects the other filter properties.
     If not specified, all deployed service packages that match the parent filters (if any) are
     taken into consideration and matched against the other filter members, like health state
     filter.
    :vartype service_manifest_name_filter: str
    :ivar service_package_activation_id_filter: The activation ID of a deployed service package
     that matches the filter.
     If not specified, the filter applies to all deployed service packages that match the other
     parameters.
     If specified, the filter matches only the deployed service package with the specified
     activation ID.
    :vartype service_package_activation_id_filter: str
    :ivar health_state_filter: The filter for the health state of the deployed service packages. It
     allows selecting deployed service packages if they match the desired health states.
     The possible values are integer value of one of the following health states. Only deployed
     service packages that match the filter are returned. All deployed service packages are used to
     evaluate the parent deployed application aggregated health state.
     If not specified, default value is None, unless the deployed service package ID is specified.
     If the filter has default value and deployed service package ID is specified, the matching
     deployed service package is returned.
     The state values are flag-based enumeration, so the value could be a combination of these
     values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6, it matches deployed service packages with HealthState
     value of OK (2) and Warning (4).
    
    
     * Default - Default value. Matches any HealthState. The value is zero.
     * None - Filter that doesn't match any HealthState value. Used in order to return no results
     on a given collection of states. The value is 1.
     * Ok - Filter that matches input with HealthState value Ok. The value is 2.
     * Warning - Filter that matches input with HealthState value Warning. The value is 4.
     * Error - Filter that matches input with HealthState value Error. The value is 8.
     * All - Filter that matches input with any HealthState value. The value is 65535.
    :vartype health_state_filter: int
    """

    _attribute_map = {
        'service_manifest_name_filter': {'key': 'ServiceManifestNameFilter', 'type': 'str'},
        'service_package_activation_id_filter': {'key': 'ServicePackageActivationIdFilter', 'type': 'str'},
        'health_state_filter': {'key': 'HealthStateFilter', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_manifest_name_filter: The name of the service manifest which identifies the
         deployed service packages that matches the filter.
         If specified, the filter is applied only to the specified deployed service packages, if any.
         If no deployed service packages with specified manifest name exist, nothing is returned in the
         cluster health chunk based on this filter.
         If any deployed service package exists, they are included in the cluster health chunk if it
         respects the other filter properties.
         If not specified, all deployed service packages that match the parent filters (if any) are
         taken into consideration and matched against the other filter members, like health state
         filter.
        :paramtype service_manifest_name_filter: str
        :keyword service_package_activation_id_filter: The activation ID of a deployed service package
         that matches the filter.
         If not specified, the filter applies to all deployed service packages that match the other
         parameters.
         If specified, the filter matches only the deployed service package with the specified
         activation ID.
        :paramtype service_package_activation_id_filter: str
        :keyword health_state_filter: The filter for the health state of the deployed service packages.
         It allows selecting deployed service packages if they match the desired health states.
         The possible values are integer value of one of the following health states. Only deployed
         service packages that match the filter are returned. All deployed service packages are used to
         evaluate the parent deployed application aggregated health state.
         If not specified, default value is None, unless the deployed service package ID is specified.
         If the filter has default value and deployed service package ID is specified, the matching
         deployed service package is returned.
         The state values are flag-based enumeration, so the value could be a combination of these
         values obtained using bitwise 'OR' operator.
         For example, if the provided value is 6, it matches deployed service packages with HealthState
         value of OK (2) and Warning (4).
        
        
         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535.
        :paramtype health_state_filter: int
        """
        super(DeployedServicePackageHealthStateFilter, self).__init__(**kwargs)
        self.service_manifest_name_filter = kwargs.get('service_manifest_name_filter', None)
        self.service_package_activation_id_filter = kwargs.get('service_package_activation_id_filter', None)
        self.health_state_filter = kwargs.get('health_state_filter', 0)


class DeployedServicePackageInfo(msrest.serialization.Model):
    """Information about service package deployed on a Service Fabric node.

    :ivar name: The name of the service package as specified in the service manifest.
    :vartype name: str
    :ivar version: The version of the service package specified in service manifest.
    :vartype version: str
    :ivar status: Specifies the status of a deployed application or service package on a Service
     Fabric node. Possible values include: "Invalid", "Downloading", "Activating", "Active",
     "Upgrading", "Deactivating", "RanToCompletion", "Failed".
    :vartype status: str or ~azure.servicefabric.models.DeploymentStatus
    :ivar service_package_activation_id: The ActivationId of a deployed service package. If
     ServicePackageActivationMode specified at the time of creating the service
     is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
     then value of ServicePackageActivationId
     is always an empty string.
    :vartype service_package_activation_id: str
    """

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'version': {'key': 'Version', 'type': 'str'},
        'status': {'key': 'Status', 'type': 'str'},
        'service_package_activation_id': {'key': 'ServicePackageActivationId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: The name of the service package as specified in the service manifest.
        :paramtype name: str
        :keyword version: The version of the service package specified in service manifest.
        :paramtype version: str
        :keyword status: Specifies the status of a deployed application or service package on a Service
         Fabric node. Possible values include: "Invalid", "Downloading", "Activating", "Active",
         "Upgrading", "Deactivating", "RanToCompletion", "Failed".
        :paramtype status: str or ~azure.servicefabric.models.DeploymentStatus
        :keyword service_package_activation_id: The ActivationId of a deployed service package. If
         ServicePackageActivationMode specified at the time of creating the service
         is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
         then value of ServicePackageActivationId
         is always an empty string.
        :paramtype service_package_activation_id: str
        """
        super(DeployedServicePackageInfo, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.version = kwargs.get('version', None)
        self.status = kwargs.get('status', None)
        self.service_package_activation_id = kwargs.get('service_package_activation_id', None)


class DeployedServicePackageNewHealthReportEvent(ApplicationEvent):
    """Deployed Service Health Report Created event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar application_id: Required. The identity of the application. This is an encoded
     representation of the application name. This is used in the REST APIs to identify the
     application resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the application name is "fabric:/myapp/app1",
     the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
    :vartype application_id: str
    :ivar service_manifest_name: Required. Service manifest name.
    :vartype service_manifest_name: str
    :ivar service_package_instance_id: Required. Id of Service package instance.
    :vartype service_package_instance_id: long
    :ivar service_package_activation_id: Required. Id of Service package activation.
    :vartype service_package_activation_id: str
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'application_id': {'required': True},
        'service_manifest_name': {'required': True},
        'service_package_instance_id': {'required': True},
        'service_package_activation_id': {'required': True},
        'node_name': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'application_id': {'key': 'ApplicationId', 'type': 'str'},
        'service_manifest_name': {'key': 'ServiceManifestName', 'type': 'str'},
        'service_package_instance_id': {'key': 'ServicePackageInstanceId', 'type': 'long'},
        'service_package_activation_id': {'key': 'ServicePackageActivationId', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword application_id: Required. The identity of the application. This is an encoded
         representation of the application name. This is used in the REST APIs to identify the
         application resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the application name is "fabric:/myapp/app1",
         the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :paramtype application_id: str
        :keyword service_manifest_name: Required. Service manifest name.
        :paramtype service_manifest_name: str
        :keyword service_package_instance_id: Required. Id of Service package instance.
        :paramtype service_package_instance_id: long
        :keyword service_package_activation_id: Required. Id of Service package activation.
        :paramtype service_package_activation_id: str
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(DeployedServicePackageNewHealthReportEvent, self).__init__(**kwargs)
        self.kind = 'DeployedServicePackageNewHealthReport'  # type: str
        self.service_manifest_name = kwargs['service_manifest_name']
        self.service_package_instance_id = kwargs['service_package_instance_id']
        self.service_package_activation_id = kwargs['service_package_activation_id']
        self.node_name = kwargs['node_name']
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class DeployedServicePackagesHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for deployed service packages, containing health evaluations for each unhealthy deployed service package that impacted current aggregated health state. Can be returned when evaluating deployed application health and the aggregated health state is either Error or Warning.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar total_count: Total number of deployed service packages of the deployed application in the
     health store.
    :vartype total_count: long
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
     state. Includes all the unhealthy DeployedServicePackageHealthEvaluation that impacted the
     aggregated health.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'total_count': {'key': 'TotalCount', 'type': 'long'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword total_count: Total number of deployed service packages of the deployed application in
         the health store.
        :paramtype total_count: long
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
         state. Includes all the unhealthy DeployedServicePackageHealthEvaluation that impacted the
         aggregated health.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(DeployedServicePackagesHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'DeployedServicePackages'  # type: str
        self.total_count = kwargs.get('total_count', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class DeployedServiceReplicaDetailInfo(msrest.serialization.Model):
    """Information about a Service Fabric service replica deployed on a node.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: DeployedStatefulServiceReplicaDetailInfo, DeployedStatelessServiceInstanceDetailInfo.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar service_name: Full hierarchical name of the service in URI format starting with
     ``fabric:``.
    :vartype service_name: str
    :ivar partition_id: An internal ID used by Service Fabric to uniquely identify a partition.
     This is a randomly generated GUID when the service was created. The partition ID is unique and
     does not change for the lifetime of the service. If the same service was deleted and recreated
     the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar current_service_operation: Specifies the current active life-cycle operation on a
     stateful service replica or stateless service instance. Possible values include: "Unknown",
     "None", "Open", "ChangeRole", "Close", "Abort".
    :vartype current_service_operation: str or ~azure.servicefabric.models.ServiceOperationName
    :ivar current_service_operation_start_time_utc: The start time of the current service operation
     in UTC format.
    :vartype current_service_operation_start_time_utc: ~datetime.datetime
    :ivar reported_load: List of load reported by replica.
    :vartype reported_load: list[~azure.servicefabric.models.LoadMetricReportInfo]
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'current_service_operation': {'key': 'CurrentServiceOperation', 'type': 'str'},
        'current_service_operation_start_time_utc': {'key': 'CurrentServiceOperationStartTimeUtc', 'type': 'iso-8601'},
        'reported_load': {'key': 'ReportedLoad', 'type': '[LoadMetricReportInfo]'},
    }

    _subtype_map = {
        'service_kind': {'Stateful': 'DeployedStatefulServiceReplicaDetailInfo', 'Stateless': 'DeployedStatelessServiceInstanceDetailInfo'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_name: Full hierarchical name of the service in URI format starting with
         ``fabric:``.
        :paramtype service_name: str
        :keyword partition_id: An internal ID used by Service Fabric to uniquely identify a partition.
         This is a randomly generated GUID when the service was created. The partition ID is unique and
         does not change for the lifetime of the service. If the same service was deleted and recreated
         the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword current_service_operation: Specifies the current active life-cycle operation on a
         stateful service replica or stateless service instance. Possible values include: "Unknown",
         "None", "Open", "ChangeRole", "Close", "Abort".
        :paramtype current_service_operation: str or ~azure.servicefabric.models.ServiceOperationName
        :keyword current_service_operation_start_time_utc: The start time of the current service
         operation in UTC format.
        :paramtype current_service_operation_start_time_utc: ~datetime.datetime
        :keyword reported_load: List of load reported by replica.
        :paramtype reported_load: list[~azure.servicefabric.models.LoadMetricReportInfo]
        """
        super(DeployedServiceReplicaDetailInfo, self).__init__(**kwargs)
        self.service_kind = None  # type: Optional[str]
        self.service_name = kwargs.get('service_name', None)
        self.partition_id = kwargs.get('partition_id', None)
        self.current_service_operation = kwargs.get('current_service_operation', None)
        self.current_service_operation_start_time_utc = kwargs.get('current_service_operation_start_time_utc', None)
        self.reported_load = kwargs.get('reported_load', None)


class DeployedServiceReplicaInfo(msrest.serialization.Model):
    """Information about a Service Fabric service replica deployed on a node.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: DeployedStatefulServiceReplicaInfo, DeployedStatelessServiceInstanceInfo.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar service_name: The full name of the service with 'fabric:' URI scheme.
    :vartype service_name: str
    :ivar service_type_name: Name of the service type as specified in the service manifest.
    :vartype service_type_name: str
    :ivar service_manifest_name: The name of the service manifest in which this service type is
     defined.
    :vartype service_manifest_name: str
    :ivar code_package_name: The name of the code package that hosts this replica.
    :vartype code_package_name: str
    :ivar partition_id: An internal ID used by Service Fabric to uniquely identify a partition.
     This is a randomly generated GUID when the service was created. The partition ID is unique and
     does not change for the lifetime of the service. If the same service was deleted and recreated
     the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar replica_status: The status of a replica of a service. Possible values include: "Invalid",
     "InBuild", "Standby", "Ready", "Down", "Dropped".
    :vartype replica_status: str or ~azure.servicefabric.models.ReplicaStatus
    :ivar address: The last address returned by the replica in Open or ChangeRole.
    :vartype address: str
    :ivar service_package_activation_id: The ActivationId of a deployed service package. If
     ServicePackageActivationMode specified at the time of creating the service
     is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
     then value of ServicePackageActivationId
     is always an empty string.
    :vartype service_package_activation_id: str
    :ivar host_process_id: Host process ID of the process that is hosting the replica. This will be
     zero if the replica is down. In hyper-v containers this host process ID will be from different
     kernel.
    :vartype host_process_id: str
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'service_type_name': {'key': 'ServiceTypeName', 'type': 'str'},
        'service_manifest_name': {'key': 'ServiceManifestName', 'type': 'str'},
        'code_package_name': {'key': 'CodePackageName', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_status': {'key': 'ReplicaStatus', 'type': 'str'},
        'address': {'key': 'Address', 'type': 'str'},
        'service_package_activation_id': {'key': 'ServicePackageActivationId', 'type': 'str'},
        'host_process_id': {'key': 'HostProcessId', 'type': 'str'},
    }

    _subtype_map = {
        'service_kind': {'Stateful': 'DeployedStatefulServiceReplicaInfo', 'Stateless': 'DeployedStatelessServiceInstanceInfo'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_name: The full name of the service with 'fabric:' URI scheme.
        :paramtype service_name: str
        :keyword service_type_name: Name of the service type as specified in the service manifest.
        :paramtype service_type_name: str
        :keyword service_manifest_name: The name of the service manifest in which this service type is
         defined.
        :paramtype service_manifest_name: str
        :keyword code_package_name: The name of the code package that hosts this replica.
        :paramtype code_package_name: str
        :keyword partition_id: An internal ID used by Service Fabric to uniquely identify a partition.
         This is a randomly generated GUID when the service was created. The partition ID is unique and
         does not change for the lifetime of the service. If the same service was deleted and recreated
         the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword replica_status: The status of a replica of a service. Possible values include:
         "Invalid", "InBuild", "Standby", "Ready", "Down", "Dropped".
        :paramtype replica_status: str or ~azure.servicefabric.models.ReplicaStatus
        :keyword address: The last address returned by the replica in Open or ChangeRole.
        :paramtype address: str
        :keyword service_package_activation_id: The ActivationId of a deployed service package. If
         ServicePackageActivationMode specified at the time of creating the service
         is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
         then value of ServicePackageActivationId
         is always an empty string.
        :paramtype service_package_activation_id: str
        :keyword host_process_id: Host process ID of the process that is hosting the replica. This will
         be zero if the replica is down. In hyper-v containers this host process ID will be from
         different kernel.
        :paramtype host_process_id: str
        """
        super(DeployedServiceReplicaInfo, self).__init__(**kwargs)
        self.service_kind = None  # type: Optional[str]
        self.service_name = kwargs.get('service_name', None)
        self.service_type_name = kwargs.get('service_type_name', None)
        self.service_manifest_name = kwargs.get('service_manifest_name', None)
        self.code_package_name = kwargs.get('code_package_name', None)
        self.partition_id = kwargs.get('partition_id', None)
        self.replica_status = kwargs.get('replica_status', None)
        self.address = kwargs.get('address', None)
        self.service_package_activation_id = kwargs.get('service_package_activation_id', None)
        self.host_process_id = kwargs.get('host_process_id', None)


class DeployedServiceTypeInfo(msrest.serialization.Model):
    """Information about service type deployed on a node, information such as the status of the service type registration on a node.

    :ivar service_type_name: Name of the service type as specified in the service manifest.
    :vartype service_type_name: str
    :ivar service_manifest_name: The name of the service manifest in which this service type is
     defined.
    :vartype service_manifest_name: str
    :ivar code_package_name: The name of the code package that registered the service type.
    :vartype code_package_name: str
    :ivar status: The status of the service type registration on the node. Possible values include:
     "Invalid", "Disabled", "Enabled", "Registered".
    :vartype status: str or ~azure.servicefabric.models.ServiceTypeRegistrationStatus
    :ivar service_package_activation_id: The ActivationId of a deployed service package. If
     ServicePackageActivationMode specified at the time of creating the service
     is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
     then value of ServicePackageActivationId
     is always an empty string.
    :vartype service_package_activation_id: str
    """

    _attribute_map = {
        'service_type_name': {'key': 'ServiceTypeName', 'type': 'str'},
        'service_manifest_name': {'key': 'ServiceManifestName', 'type': 'str'},
        'code_package_name': {'key': 'CodePackageName', 'type': 'str'},
        'status': {'key': 'Status', 'type': 'str'},
        'service_package_activation_id': {'key': 'ServicePackageActivationId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_type_name: Name of the service type as specified in the service manifest.
        :paramtype service_type_name: str
        :keyword service_manifest_name: The name of the service manifest in which this service type is
         defined.
        :paramtype service_manifest_name: str
        :keyword code_package_name: The name of the code package that registered the service type.
        :paramtype code_package_name: str
        :keyword status: The status of the service type registration on the node. Possible values
         include: "Invalid", "Disabled", "Enabled", "Registered".
        :paramtype status: str or ~azure.servicefabric.models.ServiceTypeRegistrationStatus
        :keyword service_package_activation_id: The ActivationId of a deployed service package. If
         ServicePackageActivationMode specified at the time of creating the service
         is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
         then value of ServicePackageActivationId
         is always an empty string.
        :paramtype service_package_activation_id: str
        """
        super(DeployedServiceTypeInfo, self).__init__(**kwargs)
        self.service_type_name = kwargs.get('service_type_name', None)
        self.service_manifest_name = kwargs.get('service_manifest_name', None)
        self.code_package_name = kwargs.get('code_package_name', None)
        self.status = kwargs.get('status', None)
        self.service_package_activation_id = kwargs.get('service_package_activation_id', None)


class DeployedStatefulServiceReplicaDetailInfo(DeployedServiceReplicaDetailInfo):
    """Information about a stateful replica running in a code package. Note DeployedServiceReplicaQueryResult will contain duplicate data like ServiceKind, ServiceName, PartitionId and replicaId.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar service_name: Full hierarchical name of the service in URI format starting with
     ``fabric:``.
    :vartype service_name: str
    :ivar partition_id: An internal ID used by Service Fabric to uniquely identify a partition.
     This is a randomly generated GUID when the service was created. The partition ID is unique and
     does not change for the lifetime of the service. If the same service was deleted and recreated
     the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar current_service_operation: Specifies the current active life-cycle operation on a
     stateful service replica or stateless service instance. Possible values include: "Unknown",
     "None", "Open", "ChangeRole", "Close", "Abort".
    :vartype current_service_operation: str or ~azure.servicefabric.models.ServiceOperationName
    :ivar current_service_operation_start_time_utc: The start time of the current service operation
     in UTC format.
    :vartype current_service_operation_start_time_utc: ~datetime.datetime
    :ivar reported_load: List of load reported by replica.
    :vartype reported_load: list[~azure.servicefabric.models.LoadMetricReportInfo]
    :ivar replica_id: Id of a stateful service replica. ReplicaId is used by Service Fabric to
     uniquely identify a replica of a partition. It is unique within a partition and does not change
     for the lifetime of the replica. If a replica gets dropped and another replica gets created on
     the same node for the same partition, it will get a different value for the id. Sometimes the
     id of a stateless service instance is also referred as a replica id.
    :vartype replica_id: str
    :ivar current_replicator_operation: Specifies the operation currently being executed by the
     Replicator. Possible values include: "Invalid", "None", "Open", "ChangeRole", "UpdateEpoch",
     "Close", "Abort", "OnDataLoss", "WaitForCatchup", "Build".
    :vartype current_replicator_operation: str or
     ~azure.servicefabric.models.ReplicatorOperationName
    :ivar read_status: Specifies the access status of the partition. Possible values include:
     "Invalid", "Granted", "ReconfigurationPending", "NotPrimary", "NoWriteQuorum".
    :vartype read_status: str or ~azure.servicefabric.models.PartitionAccessStatus
    :ivar write_status: Specifies the access status of the partition. Possible values include:
     "Invalid", "Granted", "ReconfigurationPending", "NotPrimary", "NoWriteQuorum".
    :vartype write_status: str or ~azure.servicefabric.models.PartitionAccessStatus
    :ivar replicator_status: Represents a base class for primary or secondary replicator status.
     Contains information about the service fabric replicator like the replication/copy queue
     utilization, last acknowledgement received timestamp, etc.
    :vartype replicator_status: ~azure.servicefabric.models.ReplicatorStatus
    :ivar replica_status: Key value store related information for the replica.
    :vartype replica_status: ~azure.servicefabric.models.KeyValueStoreReplicaStatus
    :ivar deployed_service_replica_query_result: Information about a stateful service replica
     deployed on a node.
    :vartype deployed_service_replica_query_result:
     ~azure.servicefabric.models.DeployedStatefulServiceReplicaInfo
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'current_service_operation': {'key': 'CurrentServiceOperation', 'type': 'str'},
        'current_service_operation_start_time_utc': {'key': 'CurrentServiceOperationStartTimeUtc', 'type': 'iso-8601'},
        'reported_load': {'key': 'ReportedLoad', 'type': '[LoadMetricReportInfo]'},
        'replica_id': {'key': 'ReplicaId', 'type': 'str'},
        'current_replicator_operation': {'key': 'CurrentReplicatorOperation', 'type': 'str'},
        'read_status': {'key': 'ReadStatus', 'type': 'str'},
        'write_status': {'key': 'WriteStatus', 'type': 'str'},
        'replicator_status': {'key': 'ReplicatorStatus', 'type': 'ReplicatorStatus'},
        'replica_status': {'key': 'ReplicaStatus', 'type': 'KeyValueStoreReplicaStatus'},
        'deployed_service_replica_query_result': {'key': 'DeployedServiceReplicaQueryResult', 'type': 'DeployedStatefulServiceReplicaInfo'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_name: Full hierarchical name of the service in URI format starting with
         ``fabric:``.
        :paramtype service_name: str
        :keyword partition_id: An internal ID used by Service Fabric to uniquely identify a partition.
         This is a randomly generated GUID when the service was created. The partition ID is unique and
         does not change for the lifetime of the service. If the same service was deleted and recreated
         the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword current_service_operation: Specifies the current active life-cycle operation on a
         stateful service replica or stateless service instance. Possible values include: "Unknown",
         "None", "Open", "ChangeRole", "Close", "Abort".
        :paramtype current_service_operation: str or ~azure.servicefabric.models.ServiceOperationName
        :keyword current_service_operation_start_time_utc: The start time of the current service
         operation in UTC format.
        :paramtype current_service_operation_start_time_utc: ~datetime.datetime
        :keyword reported_load: List of load reported by replica.
        :paramtype reported_load: list[~azure.servicefabric.models.LoadMetricReportInfo]
        :keyword replica_id: Id of a stateful service replica. ReplicaId is used by Service Fabric to
         uniquely identify a replica of a partition. It is unique within a partition and does not change
         for the lifetime of the replica. If a replica gets dropped and another replica gets created on
         the same node for the same partition, it will get a different value for the id. Sometimes the
         id of a stateless service instance is also referred as a replica id.
        :paramtype replica_id: str
        :keyword current_replicator_operation: Specifies the operation currently being executed by the
         Replicator. Possible values include: "Invalid", "None", "Open", "ChangeRole", "UpdateEpoch",
         "Close", "Abort", "OnDataLoss", "WaitForCatchup", "Build".
        :paramtype current_replicator_operation: str or
         ~azure.servicefabric.models.ReplicatorOperationName
        :keyword read_status: Specifies the access status of the partition. Possible values include:
         "Invalid", "Granted", "ReconfigurationPending", "NotPrimary", "NoWriteQuorum".
        :paramtype read_status: str or ~azure.servicefabric.models.PartitionAccessStatus
        :keyword write_status: Specifies the access status of the partition. Possible values include:
         "Invalid", "Granted", "ReconfigurationPending", "NotPrimary", "NoWriteQuorum".
        :paramtype write_status: str or ~azure.servicefabric.models.PartitionAccessStatus
        :keyword replicator_status: Represents a base class for primary or secondary replicator status.
         Contains information about the service fabric replicator like the replication/copy queue
         utilization, last acknowledgement received timestamp, etc.
        :paramtype replicator_status: ~azure.servicefabric.models.ReplicatorStatus
        :keyword replica_status: Key value store related information for the replica.
        :paramtype replica_status: ~azure.servicefabric.models.KeyValueStoreReplicaStatus
        :keyword deployed_service_replica_query_result: Information about a stateful service replica
         deployed on a node.
        :paramtype deployed_service_replica_query_result:
         ~azure.servicefabric.models.DeployedStatefulServiceReplicaInfo
        """
        super(DeployedStatefulServiceReplicaDetailInfo, self).__init__(**kwargs)
        self.service_kind = 'Stateful'  # type: str
        self.replica_id = kwargs.get('replica_id', None)
        self.current_replicator_operation = kwargs.get('current_replicator_operation', None)
        self.read_status = kwargs.get('read_status', None)
        self.write_status = kwargs.get('write_status', None)
        self.replicator_status = kwargs.get('replicator_status', None)
        self.replica_status = kwargs.get('replica_status', None)
        self.deployed_service_replica_query_result = kwargs.get('deployed_service_replica_query_result', None)


class DeployedStatefulServiceReplicaInfo(DeployedServiceReplicaInfo):
    """Information about a stateful service replica deployed on a node.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar service_name: The full name of the service with 'fabric:' URI scheme.
    :vartype service_name: str
    :ivar service_type_name: Name of the service type as specified in the service manifest.
    :vartype service_type_name: str
    :ivar service_manifest_name: The name of the service manifest in which this service type is
     defined.
    :vartype service_manifest_name: str
    :ivar code_package_name: The name of the code package that hosts this replica.
    :vartype code_package_name: str
    :ivar partition_id: An internal ID used by Service Fabric to uniquely identify a partition.
     This is a randomly generated GUID when the service was created. The partition ID is unique and
     does not change for the lifetime of the service. If the same service was deleted and recreated
     the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar replica_status: The status of a replica of a service. Possible values include: "Invalid",
     "InBuild", "Standby", "Ready", "Down", "Dropped".
    :vartype replica_status: str or ~azure.servicefabric.models.ReplicaStatus
    :ivar address: The last address returned by the replica in Open or ChangeRole.
    :vartype address: str
    :ivar service_package_activation_id: The ActivationId of a deployed service package. If
     ServicePackageActivationMode specified at the time of creating the service
     is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
     then value of ServicePackageActivationId
     is always an empty string.
    :vartype service_package_activation_id: str
    :ivar host_process_id: Host process ID of the process that is hosting the replica. This will be
     zero if the replica is down. In hyper-v containers this host process ID will be from different
     kernel.
    :vartype host_process_id: str
    :ivar replica_id: Id of a stateful service replica. ReplicaId is used by Service Fabric to
     uniquely identify a replica of a partition. It is unique within a partition and does not change
     for the lifetime of the replica. If a replica gets dropped and another replica gets created on
     the same node for the same partition, it will get a different value for the id. Sometimes the
     id of a stateless service instance is also referred as a replica id.
    :vartype replica_id: str
    :ivar replica_role: The role of a replica of a stateful service. Possible values include:
     "Unknown", "None", "Primary", "IdleSecondary", "ActiveSecondary", "IdleAuxiliary",
     "ActiveAuxiliary", "PrimaryAuxiliary".
    :vartype replica_role: str or ~azure.servicefabric.models.ReplicaRole
    :ivar reconfiguration_information: Information about current reconfiguration like phase, type,
     previous configuration role of replica and reconfiguration start date time.
    :vartype reconfiguration_information: ~azure.servicefabric.models.ReconfigurationInformation
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'service_type_name': {'key': 'ServiceTypeName', 'type': 'str'},
        'service_manifest_name': {'key': 'ServiceManifestName', 'type': 'str'},
        'code_package_name': {'key': 'CodePackageName', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_status': {'key': 'ReplicaStatus', 'type': 'str'},
        'address': {'key': 'Address', 'type': 'str'},
        'service_package_activation_id': {'key': 'ServicePackageActivationId', 'type': 'str'},
        'host_process_id': {'key': 'HostProcessId', 'type': 'str'},
        'replica_id': {'key': 'ReplicaId', 'type': 'str'},
        'replica_role': {'key': 'ReplicaRole', 'type': 'str'},
        'reconfiguration_information': {'key': 'ReconfigurationInformation', 'type': 'ReconfigurationInformation'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_name: The full name of the service with 'fabric:' URI scheme.
        :paramtype service_name: str
        :keyword service_type_name: Name of the service type as specified in the service manifest.
        :paramtype service_type_name: str
        :keyword service_manifest_name: The name of the service manifest in which this service type is
         defined.
        :paramtype service_manifest_name: str
        :keyword code_package_name: The name of the code package that hosts this replica.
        :paramtype code_package_name: str
        :keyword partition_id: An internal ID used by Service Fabric to uniquely identify a partition.
         This is a randomly generated GUID when the service was created. The partition ID is unique and
         does not change for the lifetime of the service. If the same service was deleted and recreated
         the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword replica_status: The status of a replica of a service. Possible values include:
         "Invalid", "InBuild", "Standby", "Ready", "Down", "Dropped".
        :paramtype replica_status: str or ~azure.servicefabric.models.ReplicaStatus
        :keyword address: The last address returned by the replica in Open or ChangeRole.
        :paramtype address: str
        :keyword service_package_activation_id: The ActivationId of a deployed service package. If
         ServicePackageActivationMode specified at the time of creating the service
         is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
         then value of ServicePackageActivationId
         is always an empty string.
        :paramtype service_package_activation_id: str
        :keyword host_process_id: Host process ID of the process that is hosting the replica. This will
         be zero if the replica is down. In hyper-v containers this host process ID will be from
         different kernel.
        :paramtype host_process_id: str
        :keyword replica_id: Id of a stateful service replica. ReplicaId is used by Service Fabric to
         uniquely identify a replica of a partition. It is unique within a partition and does not change
         for the lifetime of the replica. If a replica gets dropped and another replica gets created on
         the same node for the same partition, it will get a different value for the id. Sometimes the
         id of a stateless service instance is also referred as a replica id.
        :paramtype replica_id: str
        :keyword replica_role: The role of a replica of a stateful service. Possible values include:
         "Unknown", "None", "Primary", "IdleSecondary", "ActiveSecondary", "IdleAuxiliary",
         "ActiveAuxiliary", "PrimaryAuxiliary".
        :paramtype replica_role: str or ~azure.servicefabric.models.ReplicaRole
        :keyword reconfiguration_information: Information about current reconfiguration like phase,
         type, previous configuration role of replica and reconfiguration start date time.
        :paramtype reconfiguration_information: ~azure.servicefabric.models.ReconfigurationInformation
        """
        super(DeployedStatefulServiceReplicaInfo, self).__init__(**kwargs)
        self.service_kind = 'Stateful'  # type: str
        self.replica_id = kwargs.get('replica_id', None)
        self.replica_role = kwargs.get('replica_role', None)
        self.reconfiguration_information = kwargs.get('reconfiguration_information', None)


class DeployedStatelessServiceInstanceDetailInfo(DeployedServiceReplicaDetailInfo):
    """Information about a stateless instance running in a code package. Note that DeployedServiceReplicaQueryResult will contain duplicate data like ServiceKind, ServiceName, PartitionId and InstanceId.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar service_name: Full hierarchical name of the service in URI format starting with
     ``fabric:``.
    :vartype service_name: str
    :ivar partition_id: An internal ID used by Service Fabric to uniquely identify a partition.
     This is a randomly generated GUID when the service was created. The partition ID is unique and
     does not change for the lifetime of the service. If the same service was deleted and recreated
     the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar current_service_operation: Specifies the current active life-cycle operation on a
     stateful service replica or stateless service instance. Possible values include: "Unknown",
     "None", "Open", "ChangeRole", "Close", "Abort".
    :vartype current_service_operation: str or ~azure.servicefabric.models.ServiceOperationName
    :ivar current_service_operation_start_time_utc: The start time of the current service operation
     in UTC format.
    :vartype current_service_operation_start_time_utc: ~datetime.datetime
    :ivar reported_load: List of load reported by replica.
    :vartype reported_load: list[~azure.servicefabric.models.LoadMetricReportInfo]
    :ivar instance_id: Id of a stateless service instance. InstanceId is used by Service Fabric to
     uniquely identify an instance of a partition of a stateless service. It is unique within a
     partition and does not change for the lifetime of the instance. If the instance has failed over
     on the same or different node, it will get a different value for the InstanceId.
    :vartype instance_id: str
    :ivar deployed_service_replica_query_result: Information about a stateless service instance
     deployed on a node.
    :vartype deployed_service_replica_query_result:
     ~azure.servicefabric.models.DeployedStatelessServiceInstanceInfo
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'current_service_operation': {'key': 'CurrentServiceOperation', 'type': 'str'},
        'current_service_operation_start_time_utc': {'key': 'CurrentServiceOperationStartTimeUtc', 'type': 'iso-8601'},
        'reported_load': {'key': 'ReportedLoad', 'type': '[LoadMetricReportInfo]'},
        'instance_id': {'key': 'InstanceId', 'type': 'str'},
        'deployed_service_replica_query_result': {'key': 'DeployedServiceReplicaQueryResult', 'type': 'DeployedStatelessServiceInstanceInfo'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_name: Full hierarchical name of the service in URI format starting with
         ``fabric:``.
        :paramtype service_name: str
        :keyword partition_id: An internal ID used by Service Fabric to uniquely identify a partition.
         This is a randomly generated GUID when the service was created. The partition ID is unique and
         does not change for the lifetime of the service. If the same service was deleted and recreated
         the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword current_service_operation: Specifies the current active life-cycle operation on a
         stateful service replica or stateless service instance. Possible values include: "Unknown",
         "None", "Open", "ChangeRole", "Close", "Abort".
        :paramtype current_service_operation: str or ~azure.servicefabric.models.ServiceOperationName
        :keyword current_service_operation_start_time_utc: The start time of the current service
         operation in UTC format.
        :paramtype current_service_operation_start_time_utc: ~datetime.datetime
        :keyword reported_load: List of load reported by replica.
        :paramtype reported_load: list[~azure.servicefabric.models.LoadMetricReportInfo]
        :keyword instance_id: Id of a stateless service instance. InstanceId is used by Service Fabric
         to uniquely identify an instance of a partition of a stateless service. It is unique within a
         partition and does not change for the lifetime of the instance. If the instance has failed over
         on the same or different node, it will get a different value for the InstanceId.
        :paramtype instance_id: str
        :keyword deployed_service_replica_query_result: Information about a stateless service instance
         deployed on a node.
        :paramtype deployed_service_replica_query_result:
         ~azure.servicefabric.models.DeployedStatelessServiceInstanceInfo
        """
        super(DeployedStatelessServiceInstanceDetailInfo, self).__init__(**kwargs)
        self.service_kind = 'Stateless'  # type: str
        self.instance_id = kwargs.get('instance_id', None)
        self.deployed_service_replica_query_result = kwargs.get('deployed_service_replica_query_result', None)


class DeployedStatelessServiceInstanceInfo(DeployedServiceReplicaInfo):
    """Information about a stateless service instance deployed on a node.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar service_name: The full name of the service with 'fabric:' URI scheme.
    :vartype service_name: str
    :ivar service_type_name: Name of the service type as specified in the service manifest.
    :vartype service_type_name: str
    :ivar service_manifest_name: The name of the service manifest in which this service type is
     defined.
    :vartype service_manifest_name: str
    :ivar code_package_name: The name of the code package that hosts this replica.
    :vartype code_package_name: str
    :ivar partition_id: An internal ID used by Service Fabric to uniquely identify a partition.
     This is a randomly generated GUID when the service was created. The partition ID is unique and
     does not change for the lifetime of the service. If the same service was deleted and recreated
     the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar replica_status: The status of a replica of a service. Possible values include: "Invalid",
     "InBuild", "Standby", "Ready", "Down", "Dropped".
    :vartype replica_status: str or ~azure.servicefabric.models.ReplicaStatus
    :ivar address: The last address returned by the replica in Open or ChangeRole.
    :vartype address: str
    :ivar service_package_activation_id: The ActivationId of a deployed service package. If
     ServicePackageActivationMode specified at the time of creating the service
     is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
     then value of ServicePackageActivationId
     is always an empty string.
    :vartype service_package_activation_id: str
    :ivar host_process_id: Host process ID of the process that is hosting the replica. This will be
     zero if the replica is down. In hyper-v containers this host process ID will be from different
     kernel.
    :vartype host_process_id: str
    :ivar instance_id: Id of a stateless service instance. InstanceId is used by Service Fabric to
     uniquely identify an instance of a partition of a stateless service. It is unique within a
     partition and does not change for the lifetime of the instance. If the instance has failed over
     on the same or different node, it will get a different value for the InstanceId.
    :vartype instance_id: str
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'service_type_name': {'key': 'ServiceTypeName', 'type': 'str'},
        'service_manifest_name': {'key': 'ServiceManifestName', 'type': 'str'},
        'code_package_name': {'key': 'CodePackageName', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_status': {'key': 'ReplicaStatus', 'type': 'str'},
        'address': {'key': 'Address', 'type': 'str'},
        'service_package_activation_id': {'key': 'ServicePackageActivationId', 'type': 'str'},
        'host_process_id': {'key': 'HostProcessId', 'type': 'str'},
        'instance_id': {'key': 'InstanceId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_name: The full name of the service with 'fabric:' URI scheme.
        :paramtype service_name: str
        :keyword service_type_name: Name of the service type as specified in the service manifest.
        :paramtype service_type_name: str
        :keyword service_manifest_name: The name of the service manifest in which this service type is
         defined.
        :paramtype service_manifest_name: str
        :keyword code_package_name: The name of the code package that hosts this replica.
        :paramtype code_package_name: str
        :keyword partition_id: An internal ID used by Service Fabric to uniquely identify a partition.
         This is a randomly generated GUID when the service was created. The partition ID is unique and
         does not change for the lifetime of the service. If the same service was deleted and recreated
         the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword replica_status: The status of a replica of a service. Possible values include:
         "Invalid", "InBuild", "Standby", "Ready", "Down", "Dropped".
        :paramtype replica_status: str or ~azure.servicefabric.models.ReplicaStatus
        :keyword address: The last address returned by the replica in Open or ChangeRole.
        :paramtype address: str
        :keyword service_package_activation_id: The ActivationId of a deployed service package. If
         ServicePackageActivationMode specified at the time of creating the service
         is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
         then value of ServicePackageActivationId
         is always an empty string.
        :paramtype service_package_activation_id: str
        :keyword host_process_id: Host process ID of the process that is hosting the replica. This will
         be zero if the replica is down. In hyper-v containers this host process ID will be from
         different kernel.
        :paramtype host_process_id: str
        :keyword instance_id: Id of a stateless service instance. InstanceId is used by Service Fabric
         to uniquely identify an instance of a partition of a stateless service. It is unique within a
         partition and does not change for the lifetime of the instance. If the instance has failed over
         on the same or different node, it will get a different value for the InstanceId.
        :paramtype instance_id: str
        """
        super(DeployedStatelessServiceInstanceInfo, self).__init__(**kwargs)
        self.service_kind = 'Stateless'  # type: str
        self.instance_id = kwargs.get('instance_id', None)


class DeployServicePackageToNodeDescription(msrest.serialization.Model):
    """Defines description for downloading packages associated with a service manifest to image cache on a Service Fabric node.

    All required parameters must be populated in order to send to Azure.

    :ivar service_manifest_name: Required. The name of service manifest whose packages need to be
     downloaded.
    :vartype service_manifest_name: str
    :ivar application_type_name: Required. The application type name as defined in the application
     manifest.
    :vartype application_type_name: str
    :ivar application_type_version: Required. The version of the application type as defined in the
     application manifest.
    :vartype application_type_version: str
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar package_sharing_policy: List of package sharing policy information.
    :vartype package_sharing_policy: list[~azure.servicefabric.models.PackageSharingPolicyInfo]
    """

    _validation = {
        'service_manifest_name': {'required': True},
        'application_type_name': {'required': True},
        'application_type_version': {'required': True},
        'node_name': {'required': True},
    }

    _attribute_map = {
        'service_manifest_name': {'key': 'ServiceManifestName', 'type': 'str'},
        'application_type_name': {'key': 'ApplicationTypeName', 'type': 'str'},
        'application_type_version': {'key': 'ApplicationTypeVersion', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'package_sharing_policy': {'key': 'PackageSharingPolicy', 'type': '[PackageSharingPolicyInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_manifest_name: Required. The name of service manifest whose packages need to
         be downloaded.
        :paramtype service_manifest_name: str
        :keyword application_type_name: Required. The application type name as defined in the
         application manifest.
        :paramtype application_type_name: str
        :keyword application_type_version: Required. The version of the application type as defined in
         the application manifest.
        :paramtype application_type_version: str
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword package_sharing_policy: List of package sharing policy information.
        :paramtype package_sharing_policy: list[~azure.servicefabric.models.PackageSharingPolicyInfo]
        """
        super(DeployServicePackageToNodeDescription, self).__init__(**kwargs)
        self.service_manifest_name = kwargs['service_manifest_name']
        self.application_type_name = kwargs['application_type_name']
        self.application_type_version = kwargs['application_type_version']
        self.node_name = kwargs['node_name']
        self.package_sharing_policy = kwargs.get('package_sharing_policy', None)


class DiagnosticsDescription(msrest.serialization.Model):
    """Describes the diagnostics options available.

    :ivar sinks: List of supported sinks that can be referenced.
    :vartype sinks: list[~azure.servicefabric.models.DiagnosticsSinkProperties]
    :ivar enabled: Status of whether or not sinks are enabled.
    :vartype enabled: bool
    :ivar default_sink_refs: The sinks to be used if diagnostics is enabled. Sink choices can be
     overridden at the service and code package level.
    :vartype default_sink_refs: list[str]
    """

    _attribute_map = {
        'sinks': {'key': 'sinks', 'type': '[DiagnosticsSinkProperties]'},
        'enabled': {'key': 'enabled', 'type': 'bool'},
        'default_sink_refs': {'key': 'defaultSinkRefs', 'type': '[str]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword sinks: List of supported sinks that can be referenced.
        :paramtype sinks: list[~azure.servicefabric.models.DiagnosticsSinkProperties]
        :keyword enabled: Status of whether or not sinks are enabled.
        :paramtype enabled: bool
        :keyword default_sink_refs: The sinks to be used if diagnostics is enabled. Sink choices can be
         overridden at the service and code package level.
        :paramtype default_sink_refs: list[str]
        """
        super(DiagnosticsDescription, self).__init__(**kwargs)
        self.sinks = kwargs.get('sinks', None)
        self.enabled = kwargs.get('enabled', None)
        self.default_sink_refs = kwargs.get('default_sink_refs', None)


class DiagnosticsRef(msrest.serialization.Model):
    """Reference to sinks in DiagnosticsDescription.

    :ivar enabled: Status of whether or not sinks are enabled.
    :vartype enabled: bool
    :ivar sink_refs: List of sinks to be used if enabled. References the list of sinks in
     DiagnosticsDescription.
    :vartype sink_refs: list[str]
    """

    _attribute_map = {
        'enabled': {'key': 'enabled', 'type': 'bool'},
        'sink_refs': {'key': 'sinkRefs', 'type': '[str]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword enabled: Status of whether or not sinks are enabled.
        :paramtype enabled: bool
        :keyword sink_refs: List of sinks to be used if enabled. References the list of sinks in
         DiagnosticsDescription.
        :paramtype sink_refs: list[str]
        """
        super(DiagnosticsRef, self).__init__(**kwargs)
        self.enabled = kwargs.get('enabled', None)
        self.sink_refs = kwargs.get('sink_refs', None)


class DisableBackupDescription(msrest.serialization.Model):
    """It describes the body parameters while disabling backup of a backup entity(Application/Service/Partition).

    All required parameters must be populated in order to send to Azure.

    :ivar clean_backup: Required. Boolean flag to delete backups. It can be set to true for
     deleting all the backups which were created for the backup entity that is getting disabled for
     backup.
    :vartype clean_backup: bool
    """

    _validation = {
        'clean_backup': {'required': True},
    }

    _attribute_map = {
        'clean_backup': {'key': 'CleanBackup', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword clean_backup: Required. Boolean flag to delete backups. It can be set to true for
         deleting all the backups which were created for the backup entity that is getting disabled for
         backup.
        :paramtype clean_backup: bool
        """
        super(DisableBackupDescription, self).__init__(**kwargs)
        self.clean_backup = kwargs['clean_backup']


class DiskInfo(msrest.serialization.Model):
    """Information about the disk.

    :ivar capacity: the disk size in bytes.
    :vartype capacity: str
    :ivar available_space: the available disk space in bytes.
    :vartype available_space: str
    """

    _attribute_map = {
        'capacity': {'key': 'Capacity', 'type': 'str'},
        'available_space': {'key': 'AvailableSpace', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword capacity: the disk size in bytes.
        :paramtype capacity: str
        :keyword available_space: the available disk space in bytes.
        :paramtype available_space: str
        """
        super(DiskInfo, self).__init__(**kwargs)
        self.capacity = kwargs.get('capacity', None)
        self.available_space = kwargs.get('available_space', None)


class DoublePropertyValue(PropertyValue):
    """Describes a Service Fabric property value of type Double.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property, determined by the type of data. Following are the
     possible values.Constant filled by server. Possible values include: "Invalid", "Binary",
     "Int64", "Double", "String", "Guid".
    :vartype kind: str or ~azure.servicefabric.models.PropertyValueKind
    :ivar data: Required. The data of the property value.
    :vartype data: float
    """

    _validation = {
        'kind': {'required': True},
        'data': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'data': {'key': 'Data', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword data: Required. The data of the property value.
        :paramtype data: float
        """
        super(DoublePropertyValue, self).__init__(**kwargs)
        self.kind = 'Double'  # type: str
        self.data = kwargs['data']


class DsmsAzureBlobBackupStorageDescription(BackupStorageDescription):
    """Describes the parameters for Dsms Azure blob store used for storing and enumerating backups.

    All required parameters must be populated in order to send to Azure.

    :ivar storage_kind: Required. The kind of backup storage, where backups are saved.Constant
     filled by server. Possible values include: "Invalid", "FileShare", "AzureBlobStore",
     "DsmsAzureBlobStore", "ManagedIdentityAzureBlobStore".
    :vartype storage_kind: str or ~azure.servicefabric.models.BackupStorageKind
    :ivar friendly_name: Friendly name for this backup storage.
    :vartype friendly_name: str
    :ivar storage_credentials_source_location: Required. The source location of the storage
     credentials to connect to the Dsms Azure blob store.
    :vartype storage_credentials_source_location: str
    :ivar container_name: Required. The name of the container in the blob store to store and
     enumerate backups from.
    :vartype container_name: str
    """

    _validation = {
        'storage_kind': {'required': True},
        'storage_credentials_source_location': {'required': True},
        'container_name': {'required': True},
    }

    _attribute_map = {
        'storage_kind': {'key': 'StorageKind', 'type': 'str'},
        'friendly_name': {'key': 'FriendlyName', 'type': 'str'},
        'storage_credentials_source_location': {'key': 'StorageCredentialsSourceLocation', 'type': 'str'},
        'container_name': {'key': 'ContainerName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword friendly_name: Friendly name for this backup storage.
        :paramtype friendly_name: str
        :keyword storage_credentials_source_location: Required. The source location of the storage
         credentials to connect to the Dsms Azure blob store.
        :paramtype storage_credentials_source_location: str
        :keyword container_name: Required. The name of the container in the blob store to store and
         enumerate backups from.
        :paramtype container_name: str
        """
        super(DsmsAzureBlobBackupStorageDescription, self).__init__(**kwargs)
        self.storage_kind = 'DsmsAzureBlobStore'  # type: str
        self.storage_credentials_source_location = kwargs['storage_credentials_source_location']
        self.container_name = kwargs['container_name']


class EnableBackupDescription(msrest.serialization.Model):
    """Specifies the parameters needed to enable periodic backup.

    All required parameters must be populated in order to send to Azure.

    :ivar backup_policy_name: Required. Name of the backup policy to be used for enabling periodic
     backups.
    :vartype backup_policy_name: str
    """

    _validation = {
        'backup_policy_name': {'required': True},
    }

    _attribute_map = {
        'backup_policy_name': {'key': 'BackupPolicyName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword backup_policy_name: Required. Name of the backup policy to be used for enabling
         periodic backups.
        :paramtype backup_policy_name: str
        """
        super(EnableBackupDescription, self).__init__(**kwargs)
        self.backup_policy_name = kwargs['backup_policy_name']


class EndpointProperties(msrest.serialization.Model):
    """Describes a container endpoint.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name of the endpoint.
    :vartype name: str
    :ivar port: Port used by the container.
    :vartype port: int
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. The name of the endpoint.
        :paramtype name: str
        :keyword port: Port used by the container.
        :paramtype port: int
        """
        super(EndpointProperties, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.port = kwargs.get('port', None)


class EndpointRef(msrest.serialization.Model):
    """Describes a reference to a service endpoint.

    :ivar name: Name of the endpoint.
    :vartype name: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Name of the endpoint.
        :paramtype name: str
        """
        super(EndpointRef, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)


class SafetyCheck(msrest.serialization.Model):
    """Represents a safety check performed by service fabric before continuing with the operations. These checks ensure the availability of the service and the reliability of the state.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: SeedNodeSafetyCheck, PartitionSafetyCheck.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of safety check performed by service fabric before continuing
     with the operations. These checks ensure the availability of the service and the reliability of
     the state. Following are the kinds of safety checks.Constant filled by server. Possible values
     include: "Invalid", "EnsureSeedNodeQuorum", "EnsurePartitionQuorum", "WaitForPrimaryPlacement",
     "WaitForPrimarySwap", "WaitForReconfiguration", "WaitForInbuildReplica", "EnsureAvailability".
    :vartype kind: str or ~azure.servicefabric.models.SafetyCheckKind
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'EnsureSeedNodeQuorum': 'SeedNodeSafetyCheck', 'PartitionSafetyCheck': 'PartitionSafetyCheck'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(SafetyCheck, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]


class PartitionSafetyCheck(SafetyCheck):
    """Represents a safety check for the service partition being performed by service fabric before continuing with operations.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: EnsureAvailabilitySafetyCheck, EnsurePartitionQuorumSafetyCheck, WaitForInbuildReplicaSafetyCheck, WaitForPrimaryPlacementSafetyCheck, WaitForPrimarySwapSafetyCheck, WaitForReconfigurationSafetyCheck.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of safety check performed by service fabric before continuing
     with the operations. These checks ensure the availability of the service and the reliability of
     the state. Following are the kinds of safety checks.Constant filled by server. Possible values
     include: "Invalid", "EnsureSeedNodeQuorum", "EnsurePartitionQuorum", "WaitForPrimaryPlacement",
     "WaitForPrimarySwap", "WaitForReconfiguration", "WaitForInbuildReplica", "EnsureAvailability".
    :vartype kind: str or ~azure.servicefabric.models.SafetyCheckKind
    :ivar partition_id: Id of the partition which is undergoing the safety check.
    :vartype partition_id: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'EnsureAvailability': 'EnsureAvailabilitySafetyCheck', 'EnsurePartitionQuorum': 'EnsurePartitionQuorumSafetyCheck', 'WaitForInbuildReplica': 'WaitForInbuildReplicaSafetyCheck', 'WaitForPrimaryPlacement': 'WaitForPrimaryPlacementSafetyCheck', 'WaitForPrimarySwap': 'WaitForPrimarySwapSafetyCheck', 'WaitForReconfiguration': 'WaitForReconfigurationSafetyCheck'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword partition_id: Id of the partition which is undergoing the safety check.
        :paramtype partition_id: str
        """
        super(PartitionSafetyCheck, self).__init__(**kwargs)
        self.kind = 'PartitionSafetyCheck'  # type: str
        self.partition_id = kwargs.get('partition_id', None)


class EnsureAvailabilitySafetyCheck(PartitionSafetyCheck):
    """Safety check that waits to ensure the availability of the partition. It waits until there are replicas available such that bringing down this replica will not cause availability loss for the partition.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of safety check performed by service fabric before continuing
     with the operations. These checks ensure the availability of the service and the reliability of
     the state. Following are the kinds of safety checks.Constant filled by server. Possible values
     include: "Invalid", "EnsureSeedNodeQuorum", "EnsurePartitionQuorum", "WaitForPrimaryPlacement",
     "WaitForPrimarySwap", "WaitForReconfiguration", "WaitForInbuildReplica", "EnsureAvailability".
    :vartype kind: str or ~azure.servicefabric.models.SafetyCheckKind
    :ivar partition_id: Id of the partition which is undergoing the safety check.
    :vartype partition_id: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword partition_id: Id of the partition which is undergoing the safety check.
        :paramtype partition_id: str
        """
        super(EnsureAvailabilitySafetyCheck, self).__init__(**kwargs)
        self.kind = 'EnsureAvailability'  # type: str


class EnsurePartitionQuorumSafetyCheck(PartitionSafetyCheck):
    """Safety check that ensures that a quorum of replicas are not lost for a partition.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of safety check performed by service fabric before continuing
     with the operations. These checks ensure the availability of the service and the reliability of
     the state. Following are the kinds of safety checks.Constant filled by server. Possible values
     include: "Invalid", "EnsureSeedNodeQuorum", "EnsurePartitionQuorum", "WaitForPrimaryPlacement",
     "WaitForPrimarySwap", "WaitForReconfiguration", "WaitForInbuildReplica", "EnsureAvailability".
    :vartype kind: str or ~azure.servicefabric.models.SafetyCheckKind
    :ivar partition_id: Id of the partition which is undergoing the safety check.
    :vartype partition_id: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword partition_id: Id of the partition which is undergoing the safety check.
        :paramtype partition_id: str
        """
        super(EnsurePartitionQuorumSafetyCheck, self).__init__(**kwargs)
        self.kind = 'EnsurePartitionQuorum'  # type: str


class EntityKindHealthStateCount(msrest.serialization.Model):
    """Represents health state count for entities of the specified entity kind.

    :ivar entity_kind: The entity kind for which health states are evaluated. Possible values
     include: "Invalid", "Node", "Partition", "Service", "Application", "Replica",
     "DeployedApplication", "DeployedServicePackage", "Cluster".
    :vartype entity_kind: str or ~azure.servicefabric.models.EntityKind
    :ivar health_state_count: The health state count for the entities of the specified kind.
    :vartype health_state_count: ~azure.servicefabric.models.HealthStateCount
    """

    _attribute_map = {
        'entity_kind': {'key': 'EntityKind', 'type': 'str'},
        'health_state_count': {'key': 'HealthStateCount', 'type': 'HealthStateCount'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword entity_kind: The entity kind for which health states are evaluated. Possible values
         include: "Invalid", "Node", "Partition", "Service", "Application", "Replica",
         "DeployedApplication", "DeployedServicePackage", "Cluster".
        :paramtype entity_kind: str or ~azure.servicefabric.models.EntityKind
        :keyword health_state_count: The health state count for the entities of the specified kind.
        :paramtype health_state_count: ~azure.servicefabric.models.HealthStateCount
        """
        super(EntityKindHealthStateCount, self).__init__(**kwargs)
        self.entity_kind = kwargs.get('entity_kind', None)
        self.health_state_count = kwargs.get('health_state_count', None)


class EnvironmentVariable(msrest.serialization.Model):
    """Describes an environment variable for the container.

    :ivar type: The type of the environment variable being given in value. Possible values include:
     "ClearText", "KeyVaultReference", "SecretValueReference". Default value: "ClearText".
    :vartype type: str or ~azure.servicefabric.models.EnvironmentVariableType
    :ivar name: The name of the environment variable.
    :vartype name: str
    :ivar value: The value of the environment variable, will be processed based on the type
     provided.
    :vartype value: str
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword type: The type of the environment variable being given in value. Possible values
         include: "ClearText", "KeyVaultReference", "SecretValueReference". Default value: "ClearText".
        :paramtype type: str or ~azure.servicefabric.models.EnvironmentVariableType
        :keyword name: The name of the environment variable.
        :paramtype name: str
        :keyword value: The value of the environment variable, will be processed based on the type
         provided.
        :paramtype value: str
        """
        super(EnvironmentVariable, self).__init__(**kwargs)
        self.type = kwargs.get('type', "ClearText")
        self.name = kwargs.get('name', None)
        self.value = kwargs.get('value', None)


class Epoch(msrest.serialization.Model):
    """An Epoch is a configuration number for the partition as a whole. When the configuration of the replica set changes, for example when the Primary replica changes, the operations that are replicated from the new Primary replica are said to be a new Epoch from the ones which were sent by the old Primary replica.

    :ivar configuration_version: The current configuration number of this Epoch. The configuration
     number is an increasing value that is updated whenever the configuration of this replica set
     changes.
    :vartype configuration_version: str
    :ivar data_loss_version: The current data loss number of this Epoch. The data loss number
     property is an increasing value which is updated whenever data loss is suspected, as when loss
     of a quorum of replicas in the replica set that includes the Primary replica.
    :vartype data_loss_version: str
    """

    _attribute_map = {
        'configuration_version': {'key': 'ConfigurationVersion', 'type': 'str'},
        'data_loss_version': {'key': 'DataLossVersion', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword configuration_version: The current configuration number of this Epoch. The
         configuration number is an increasing value that is updated whenever the configuration of this
         replica set changes.
        :paramtype configuration_version: str
        :keyword data_loss_version: The current data loss number of this Epoch. The data loss number
         property is an increasing value which is updated whenever data loss is suspected, as when loss
         of a quorum of replicas in the replica set that includes the Primary replica.
        :paramtype data_loss_version: str
        """
        super(Epoch, self).__init__(**kwargs)
        self.configuration_version = kwargs.get('configuration_version', None)
        self.data_loss_version = kwargs.get('data_loss_version', None)


class EventHealthEvaluation(HealthEvaluation):
    """Represents health evaluation of a HealthEvent that was reported on the entity.
The health evaluation is returned when evaluating health of an entity results in Error or Warning.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar consider_warning_as_error: Indicates whether warnings are treated with the same severity
     as errors. The field is specified in the health policy used to evaluate the entity.
    :vartype consider_warning_as_error: bool
    :ivar unhealthy_event: Represents health information reported on a health entity, such as
     cluster, application or node, with additional metadata added by the Health Manager.
    :vartype unhealthy_event: ~azure.servicefabric.models.HealthEvent
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'consider_warning_as_error': {'key': 'ConsiderWarningAsError', 'type': 'bool'},
        'unhealthy_event': {'key': 'UnhealthyEvent', 'type': 'HealthEvent'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword consider_warning_as_error: Indicates whether warnings are treated with the same
         severity as errors. The field is specified in the health policy used to evaluate the entity.
        :paramtype consider_warning_as_error: bool
        :keyword unhealthy_event: Represents health information reported on a health entity, such as
         cluster, application or node, with additional metadata added by the Health Manager.
        :paramtype unhealthy_event: ~azure.servicefabric.models.HealthEvent
        """
        super(EventHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'Event'  # type: str
        self.consider_warning_as_error = kwargs.get('consider_warning_as_error', None)
        self.unhealthy_event = kwargs.get('unhealthy_event', None)


class ExecutingFaultsChaosEvent(ChaosEvent):
    """Describes a Chaos event that gets generated when Chaos has decided on the faults for an iteration. This Chaos event contains the details of the faults as a list of strings.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of Chaos event.Constant filled by server. Possible values
     include: "Invalid", "Started", "ExecutingFaults", "Waiting", "ValidationFailed", "TestError",
     "Stopped".
    :vartype kind: str or ~azure.servicefabric.models.ChaosEventKind
    :ivar time_stamp_utc: Required. The UTC timestamp when this Chaos event was generated.
    :vartype time_stamp_utc: ~datetime.datetime
    :ivar faults: List of string description of the faults that Chaos decided to execute in an
     iteration.
    :vartype faults: list[str]
    """

    _validation = {
        'kind': {'required': True},
        'time_stamp_utc': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'time_stamp_utc': {'key': 'TimeStampUtc', 'type': 'iso-8601'},
        'faults': {'key': 'Faults', 'type': '[str]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword time_stamp_utc: Required. The UTC timestamp when this Chaos event was generated.
        :paramtype time_stamp_utc: ~datetime.datetime
        :keyword faults: List of string description of the faults that Chaos decided to execute in an
         iteration.
        :paramtype faults: list[str]
        """
        super(ExecutingFaultsChaosEvent, self).__init__(**kwargs)
        self.kind = 'ExecutingFaults'  # type: str
        self.faults = kwargs.get('faults', None)


class ProvisionApplicationTypeDescriptionBase(msrest.serialization.Model):
    """Represents the type of registration or provision requested, and if the operation needs to be asynchronous or not. Supported types of provision operations are from either image store or external store.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ExternalStoreProvisionApplicationTypeDescription, ProvisionApplicationTypeDescription.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of application type registration or provision requested. The
     application package can be registered or provisioned either from the image store or from an
     external store. Following are the kinds of the application type provision.Constant filled by
     server. Possible values include: "Invalid", "ImageStorePath", "ExternalStore".
    :vartype kind: str or ~azure.servicefabric.models.ProvisionApplicationTypeKind
    :ivar async_property: Required. Indicates whether or not provisioning should occur
     asynchronously. When set to true, the provision operation returns when the request is accepted
     by the system, and the provision operation continues without any timeout limit. The default
     value is false. For large application packages, we recommend setting the value to true.
    :vartype async_property: bool
    """

    _validation = {
        'kind': {'required': True},
        'async_property': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'async_property': {'key': 'Async', 'type': 'bool'},
    }

    _subtype_map = {
        'kind': {'ExternalStore': 'ExternalStoreProvisionApplicationTypeDescription', 'ImageStorePath': 'ProvisionApplicationTypeDescription'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword async_property: Required. Indicates whether or not provisioning should occur
         asynchronously. When set to true, the provision operation returns when the request is accepted
         by the system, and the provision operation continues without any timeout limit. The default
         value is false. For large application packages, we recommend setting the value to true.
        :paramtype async_property: bool
        """
        super(ProvisionApplicationTypeDescriptionBase, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]
        self.async_property = kwargs['async_property']


class ExternalStoreProvisionApplicationTypeDescription(ProvisionApplicationTypeDescriptionBase):
    """Describes the operation to register or provision an application type using an application package from an external store instead of a package uploaded to the Service Fabric image store.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of application type registration or provision requested. The
     application package can be registered or provisioned either from the image store or from an
     external store. Following are the kinds of the application type provision.Constant filled by
     server. Possible values include: "Invalid", "ImageStorePath", "ExternalStore".
    :vartype kind: str or ~azure.servicefabric.models.ProvisionApplicationTypeKind
    :ivar async_property: Required. Indicates whether or not provisioning should occur
     asynchronously. When set to true, the provision operation returns when the request is accepted
     by the system, and the provision operation continues without any timeout limit. The default
     value is false. For large application packages, we recommend setting the value to true.
    :vartype async_property: bool
    :ivar application_package_download_uri: Required. The path to the '.sfpkg' application package
     from where the application package can be downloaded using HTTP or HTTPS protocols. The
     application package can be stored in an external store that provides GET operation to download
     the file. Supported protocols are HTTP and HTTPS, and the path must allow READ access.
    :vartype application_package_download_uri: str
    :ivar application_type_name: Required. The application type name represents the name of the
     application type found in the application manifest.
    :vartype application_type_name: str
    :ivar application_type_version: Required. The application type version represents the version
     of the application type found in the application manifest.
    :vartype application_type_version: str
    """

    _validation = {
        'kind': {'required': True},
        'async_property': {'required': True},
        'application_package_download_uri': {'required': True},
        'application_type_name': {'required': True},
        'application_type_version': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'async_property': {'key': 'Async', 'type': 'bool'},
        'application_package_download_uri': {'key': 'ApplicationPackageDownloadUri', 'type': 'str'},
        'application_type_name': {'key': 'ApplicationTypeName', 'type': 'str'},
        'application_type_version': {'key': 'ApplicationTypeVersion', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword async_property: Required. Indicates whether or not provisioning should occur
         asynchronously. When set to true, the provision operation returns when the request is accepted
         by the system, and the provision operation continues without any timeout limit. The default
         value is false. For large application packages, we recommend setting the value to true.
        :paramtype async_property: bool
        :keyword application_package_download_uri: Required. The path to the '.sfpkg' application
         package from where the application package can be downloaded using HTTP or HTTPS protocols. The
         application package can be stored in an external store that provides GET operation to download
         the file. Supported protocols are HTTP and HTTPS, and the path must allow READ access.
        :paramtype application_package_download_uri: str
        :keyword application_type_name: Required. The application type name represents the name of the
         application type found in the application manifest.
        :paramtype application_type_name: str
        :keyword application_type_version: Required. The application type version represents the
         version of the application type found in the application manifest.
        :paramtype application_type_version: str
        """
        super(ExternalStoreProvisionApplicationTypeDescription, self).__init__(**kwargs)
        self.kind = 'ExternalStore'  # type: str
        self.application_package_download_uri = kwargs['application_package_download_uri']
        self.application_type_name = kwargs['application_type_name']
        self.application_type_version = kwargs['application_type_version']


class FabricCodeVersionInfo(msrest.serialization.Model):
    """Information about a Service Fabric code version.

    :ivar code_version: The product version of Service Fabric.
    :vartype code_version: str
    """

    _attribute_map = {
        'code_version': {'key': 'CodeVersion', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword code_version: The product version of Service Fabric.
        :paramtype code_version: str
        """
        super(FabricCodeVersionInfo, self).__init__(**kwargs)
        self.code_version = kwargs.get('code_version', None)


class FabricConfigVersionInfo(msrest.serialization.Model):
    """Information about a Service Fabric config version.

    :ivar config_version: The config version of Service Fabric.
    :vartype config_version: str
    """

    _attribute_map = {
        'config_version': {'key': 'ConfigVersion', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword config_version: The config version of Service Fabric.
        :paramtype config_version: str
        """
        super(FabricConfigVersionInfo, self).__init__(**kwargs)
        self.config_version = kwargs.get('config_version', None)


class FabricError(msrest.serialization.Model):
    """The REST API operations for Service Fabric return standard HTTP status codes. This type defines the additional information returned from the Service Fabric API operations that are not successful.

    All required parameters must be populated in order to send to Azure.

    :ivar error: Required. Error object containing error code and error message.
    :vartype error: ~azure.servicefabric.models.FabricErrorError
    """

    _validation = {
        'error': {'required': True},
    }

    _attribute_map = {
        'error': {'key': 'Error', 'type': 'FabricErrorError'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword error: Required. Error object containing error code and error message.
        :paramtype error: ~azure.servicefabric.models.FabricErrorError
        """
        super(FabricError, self).__init__(**kwargs)
        self.error = kwargs['error']


class FabricErrorError(msrest.serialization.Model):
    """Error object containing error code and error message.

    All required parameters must be populated in order to send to Azure.

    :ivar code: Required. Defines the fabric error codes that be returned as part of the error
     object in response to Service Fabric API operations that are not successful. Following are the
     error code values that can be returned for a specific HTTP status code.
    
    
     *
       Possible values of the error code for HTTP status code 400 (Bad Request)
    
    
       * "FABRIC_E_INVALID_PARTITION_KEY"
       * "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR"
       * "FABRIC_E_INVALID_ADDRESS"
       * "FABRIC_E_APPLICATION_NOT_UPGRADING"
       * "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR"
       * "FABRIC_E_FABRIC_NOT_UPGRADING"
       * "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR"
       * "FABRIC_E_INVALID_CONFIGURATION"
       * "FABRIC_E_INVALID_NAME_URI"
       * "FABRIC_E_PATH_TOO_LONG"
       * "FABRIC_E_KEY_TOO_LARGE"
       * "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED"
       * "FABRIC_E_INVALID_ATOMIC_GROUP"
       * "FABRIC_E_VALUE_EMPTY"
       * "FABRIC_E_BACKUP_IS_ENABLED"
       * "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH"
       * "FABRIC_E_INVALID_FOR_STATELESS_SERVICES"
       * "FABRIC_E_INVALID_SERVICE_SCALING_POLICY"
       * "E_INVALIDARG"
    
     *
       Possible values of the error code for HTTP status code 404 (Not Found)
    
    
       * "FABRIC_E_NODE_NOT_FOUND"
       * "FABRIC_E_APPLICATION_TYPE_NOT_FOUND"
       * "FABRIC_E_APPLICATION_NOT_FOUND"
       * "FABRIC_E_SERVICE_TYPE_NOT_FOUND"
       * "FABRIC_E_SERVICE_DOES_NOT_EXIST"
       * "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND"
       * "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND"
       * "FABRIC_E_PARTITION_NOT_FOUND"
       * "FABRIC_E_REPLICA_DOES_NOT_EXIST"
       * "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST"
       * "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND"
       * "FABRIC_E_DIRECTORY_NOT_FOUND"
       * "FABRIC_E_FABRIC_VERSION_NOT_FOUND"
       * "FABRIC_E_FILE_NOT_FOUND"
       * "FABRIC_E_NAME_DOES_NOT_EXIST"
       * "FABRIC_E_PROPERTY_DOES_NOT_EXIST"
       * "FABRIC_E_ENUMERATION_COMPLETED"
       * "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND"
       * "FABRIC_E_KEY_NOT_FOUND"
       * "FABRIC_E_HEALTH_ENTITY_NOT_FOUND"
       * "FABRIC_E_BACKUP_NOT_ENABLED"
       * "FABRIC_E_BACKUP_POLICY_NOT_EXISTING"
       * "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING"
       * "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR"
    
     *
       Possible values of the error code for HTTP status code 409 (Conflict)
    
    
       * "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS"
       * "FABRIC_E_APPLICATION_ALREADY_EXISTS"
       * "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION"
       * "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS"
       * "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS"
       * "FABRIC_E_SERVICE_ALREADY_EXISTS"
       * "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS"
       * "FABRIC_E_APPLICATION_TYPE_IN_USE"
       * "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION"
       * "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS"
       * "FABRIC_E_FABRIC_VERSION_IN_USE"
       * "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS"
       * "FABRIC_E_NAME_ALREADY_EXISTS"
       * "FABRIC_E_NAME_NOT_EMPTY"
       * "FABRIC_E_PROPERTY_CHECK_FAILED"
       * "FABRIC_E_SERVICE_METADATA_MISMATCH"
       * "FABRIC_E_SERVICE_TYPE_MISMATCH"
       * "FABRIC_E_HEALTH_STALE_REPORT"
       * "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED"
       * "FABRIC_E_NODE_HAS_NOT_STOPPED_YET"
       * "FABRIC_E_INSTANCE_ID_MISMATCH"
       * "FABRIC_E_BACKUP_IN_PROGRESS"
       * "FABRIC_E_RESTORE_IN_PROGRESS"
       * "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING"
    
     *
       Possible values of the error code for HTTP status code 413 (Request Entity Too Large)
    
    
       * "FABRIC_E_VALUE_TOO_LARGE"
    
     *
       Possible values of the error code for HTTP status code 500 (Internal Server Error)
    
    
       * "FABRIC_E_NODE_IS_UP"
       * "E_FAIL"
       * "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS"
       * "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND"
       * "FABRIC_E_VOLUME_ALREADY_EXISTS"
       * "FABRIC_E_VOLUME_NOT_FOUND"
       * "SerializationError"
       * "FABRIC_E_CERTIFICATE_NOT_FOUND"
    
     *
       Possible values of the error code for HTTP status code 503 (Service Unavailable)
    
    
       * "FABRIC_E_NO_WRITE_QUORUM"
       * "FABRIC_E_NOT_PRIMARY"
       * "FABRIC_E_NOT_READY"
       * "FABRIC_E_RECONFIGURATION_PENDING"
       * "FABRIC_E_SERVICE_OFFLINE"
       * "E_ABORT"
       * "FABRIC_E_VALUE_TOO_LARGE"
    
     *
       Possible values of the error code for HTTP status code 504 (Gateway Timeout)
    
    
       * "FABRIC_E_COMMUNICATION_ERROR"
       * "FABRIC_E_OPERATION_NOT_COMPLETE"
       * "FABRIC_E_TIMEOUT". Possible values include: "FABRIC_E_INVALID_PARTITION_KEY",
     "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR", "FABRIC_E_INVALID_ADDRESS",
     "FABRIC_E_APPLICATION_NOT_UPGRADING", "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR",
     "FABRIC_E_FABRIC_NOT_UPGRADING", "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR",
     "FABRIC_E_INVALID_CONFIGURATION", "FABRIC_E_INVALID_NAME_URI", "FABRIC_E_PATH_TOO_LONG",
     "FABRIC_E_KEY_TOO_LARGE", "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED",
     "FABRIC_E_INVALID_ATOMIC_GROUP", "FABRIC_E_VALUE_EMPTY", "FABRIC_E_NODE_NOT_FOUND",
     "FABRIC_E_APPLICATION_TYPE_NOT_FOUND", "FABRIC_E_APPLICATION_NOT_FOUND",
     "FABRIC_E_SERVICE_TYPE_NOT_FOUND", "FABRIC_E_SERVICE_DOES_NOT_EXIST",
     "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND", "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND",
     "FABRIC_E_PARTITION_NOT_FOUND", "FABRIC_E_REPLICA_DOES_NOT_EXIST",
     "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST", "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND",
     "FABRIC_E_DIRECTORY_NOT_FOUND", "FABRIC_E_FABRIC_VERSION_NOT_FOUND", "FABRIC_E_FILE_NOT_FOUND",
     "FABRIC_E_NAME_DOES_NOT_EXIST", "FABRIC_E_PROPERTY_DOES_NOT_EXIST",
     "FABRIC_E_ENUMERATION_COMPLETED", "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND",
     "FABRIC_E_KEY_NOT_FOUND", "FABRIC_E_HEALTH_ENTITY_NOT_FOUND",
     "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS", "FABRIC_E_APPLICATION_ALREADY_EXISTS",
     "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION",
     "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS", "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS",
     "FABRIC_E_SERVICE_ALREADY_EXISTS", "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS",
     "FABRIC_E_APPLICATION_TYPE_IN_USE", "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION",
     "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS", "FABRIC_E_FABRIC_VERSION_IN_USE",
     "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS", "FABRIC_E_NAME_ALREADY_EXISTS",
     "FABRIC_E_NAME_NOT_EMPTY", "FABRIC_E_PROPERTY_CHECK_FAILED",
     "FABRIC_E_SERVICE_METADATA_MISMATCH", "FABRIC_E_SERVICE_TYPE_MISMATCH",
     "FABRIC_E_HEALTH_STALE_REPORT", "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED",
     "FABRIC_E_NODE_HAS_NOT_STOPPED_YET", "FABRIC_E_INSTANCE_ID_MISMATCH",
     "FABRIC_E_VALUE_TOO_LARGE", "FABRIC_E_NO_WRITE_QUORUM", "FABRIC_E_NOT_PRIMARY",
     "FABRIC_E_NOT_READY", "FABRIC_E_RECONFIGURATION_PENDING", "FABRIC_E_SERVICE_OFFLINE",
     "E_ABORT", "FABRIC_E_COMMUNICATION_ERROR", "FABRIC_E_OPERATION_NOT_COMPLETE",
     "FABRIC_E_TIMEOUT", "FABRIC_E_NODE_IS_UP", "E_FAIL", "FABRIC_E_BACKUP_IS_ENABLED",
     "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH", "FABRIC_E_INVALID_FOR_STATELESS_SERVICES",
     "FABRIC_E_BACKUP_NOT_ENABLED", "FABRIC_E_BACKUP_POLICY_NOT_EXISTING",
     "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING", "FABRIC_E_BACKUP_IN_PROGRESS",
     "FABRIC_E_RESTORE_IN_PROGRESS", "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING",
     "FABRIC_E_INVALID_SERVICE_SCALING_POLICY", "E_INVALIDARG",
     "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS",
     "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND", "FABRIC_E_VOLUME_ALREADY_EXISTS",
     "FABRIC_E_VOLUME_NOT_FOUND", "SerializationError",
     "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR", "FABRIC_E_CERTIFICATE_NOT_FOUND".
    :vartype code: str or ~azure.servicefabric.models.FabricErrorCodes
    :ivar message: Error message.
    :vartype message: str
    """

    _validation = {
        'code': {'required': True},
    }

    _attribute_map = {
        'code': {'key': 'Code', 'type': 'str'},
        'message': {'key': 'Message', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword code: Required. Defines the fabric error codes that be returned as part of the error
         object in response to Service Fabric API operations that are not successful. Following are the
         error code values that can be returned for a specific HTTP status code.
        
        
         *
           Possible values of the error code for HTTP status code 400 (Bad Request)
        
        
           * "FABRIC_E_INVALID_PARTITION_KEY"
           * "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR"
           * "FABRIC_E_INVALID_ADDRESS"
           * "FABRIC_E_APPLICATION_NOT_UPGRADING"
           * "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR"
           * "FABRIC_E_FABRIC_NOT_UPGRADING"
           * "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR"
           * "FABRIC_E_INVALID_CONFIGURATION"
           * "FABRIC_E_INVALID_NAME_URI"
           * "FABRIC_E_PATH_TOO_LONG"
           * "FABRIC_E_KEY_TOO_LARGE"
           * "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED"
           * "FABRIC_E_INVALID_ATOMIC_GROUP"
           * "FABRIC_E_VALUE_EMPTY"
           * "FABRIC_E_BACKUP_IS_ENABLED"
           * "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH"
           * "FABRIC_E_INVALID_FOR_STATELESS_SERVICES"
           * "FABRIC_E_INVALID_SERVICE_SCALING_POLICY"
           * "E_INVALIDARG"
        
         *
           Possible values of the error code for HTTP status code 404 (Not Found)
        
        
           * "FABRIC_E_NODE_NOT_FOUND"
           * "FABRIC_E_APPLICATION_TYPE_NOT_FOUND"
           * "FABRIC_E_APPLICATION_NOT_FOUND"
           * "FABRIC_E_SERVICE_TYPE_NOT_FOUND"
           * "FABRIC_E_SERVICE_DOES_NOT_EXIST"
           * "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND"
           * "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND"
           * "FABRIC_E_PARTITION_NOT_FOUND"
           * "FABRIC_E_REPLICA_DOES_NOT_EXIST"
           * "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST"
           * "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND"
           * "FABRIC_E_DIRECTORY_NOT_FOUND"
           * "FABRIC_E_FABRIC_VERSION_NOT_FOUND"
           * "FABRIC_E_FILE_NOT_FOUND"
           * "FABRIC_E_NAME_DOES_NOT_EXIST"
           * "FABRIC_E_PROPERTY_DOES_NOT_EXIST"
           * "FABRIC_E_ENUMERATION_COMPLETED"
           * "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND"
           * "FABRIC_E_KEY_NOT_FOUND"
           * "FABRIC_E_HEALTH_ENTITY_NOT_FOUND"
           * "FABRIC_E_BACKUP_NOT_ENABLED"
           * "FABRIC_E_BACKUP_POLICY_NOT_EXISTING"
           * "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING"
           * "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR"
        
         *
           Possible values of the error code for HTTP status code 409 (Conflict)
        
        
           * "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS"
           * "FABRIC_E_APPLICATION_ALREADY_EXISTS"
           * "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION"
           * "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS"
           * "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS"
           * "FABRIC_E_SERVICE_ALREADY_EXISTS"
           * "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS"
           * "FABRIC_E_APPLICATION_TYPE_IN_USE"
           * "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION"
           * "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS"
           * "FABRIC_E_FABRIC_VERSION_IN_USE"
           * "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS"
           * "FABRIC_E_NAME_ALREADY_EXISTS"
           * "FABRIC_E_NAME_NOT_EMPTY"
           * "FABRIC_E_PROPERTY_CHECK_FAILED"
           * "FABRIC_E_SERVICE_METADATA_MISMATCH"
           * "FABRIC_E_SERVICE_TYPE_MISMATCH"
           * "FABRIC_E_HEALTH_STALE_REPORT"
           * "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED"
           * "FABRIC_E_NODE_HAS_NOT_STOPPED_YET"
           * "FABRIC_E_INSTANCE_ID_MISMATCH"
           * "FABRIC_E_BACKUP_IN_PROGRESS"
           * "FABRIC_E_RESTORE_IN_PROGRESS"
           * "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING"
        
         *
           Possible values of the error code for HTTP status code 413 (Request Entity Too Large)
        
        
           * "FABRIC_E_VALUE_TOO_LARGE"
        
         *
           Possible values of the error code for HTTP status code 500 (Internal Server Error)
        
        
           * "FABRIC_E_NODE_IS_UP"
           * "E_FAIL"
           * "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS"
           * "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND"
           * "FABRIC_E_VOLUME_ALREADY_EXISTS"
           * "FABRIC_E_VOLUME_NOT_FOUND"
           * "SerializationError"
           * "FABRIC_E_CERTIFICATE_NOT_FOUND"
        
         *
           Possible values of the error code for HTTP status code 503 (Service Unavailable)
        
        
           * "FABRIC_E_NO_WRITE_QUORUM"
           * "FABRIC_E_NOT_PRIMARY"
           * "FABRIC_E_NOT_READY"
           * "FABRIC_E_RECONFIGURATION_PENDING"
           * "FABRIC_E_SERVICE_OFFLINE"
           * "E_ABORT"
           * "FABRIC_E_VALUE_TOO_LARGE"
        
         *
           Possible values of the error code for HTTP status code 504 (Gateway Timeout)
        
        
           * "FABRIC_E_COMMUNICATION_ERROR"
           * "FABRIC_E_OPERATION_NOT_COMPLETE"
           * "FABRIC_E_TIMEOUT". Possible values include: "FABRIC_E_INVALID_PARTITION_KEY",
         "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR", "FABRIC_E_INVALID_ADDRESS",
         "FABRIC_E_APPLICATION_NOT_UPGRADING", "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR",
         "FABRIC_E_FABRIC_NOT_UPGRADING", "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR",
         "FABRIC_E_INVALID_CONFIGURATION", "FABRIC_E_INVALID_NAME_URI", "FABRIC_E_PATH_TOO_LONG",
         "FABRIC_E_KEY_TOO_LARGE", "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED",
         "FABRIC_E_INVALID_ATOMIC_GROUP", "FABRIC_E_VALUE_EMPTY", "FABRIC_E_NODE_NOT_FOUND",
         "FABRIC_E_APPLICATION_TYPE_NOT_FOUND", "FABRIC_E_APPLICATION_NOT_FOUND",
         "FABRIC_E_SERVICE_TYPE_NOT_FOUND", "FABRIC_E_SERVICE_DOES_NOT_EXIST",
         "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND", "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND",
         "FABRIC_E_PARTITION_NOT_FOUND", "FABRIC_E_REPLICA_DOES_NOT_EXIST",
         "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST", "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND",
         "FABRIC_E_DIRECTORY_NOT_FOUND", "FABRIC_E_FABRIC_VERSION_NOT_FOUND", "FABRIC_E_FILE_NOT_FOUND",
         "FABRIC_E_NAME_DOES_NOT_EXIST", "FABRIC_E_PROPERTY_DOES_NOT_EXIST",
         "FABRIC_E_ENUMERATION_COMPLETED", "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND",
         "FABRIC_E_KEY_NOT_FOUND", "FABRIC_E_HEALTH_ENTITY_NOT_FOUND",
         "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS", "FABRIC_E_APPLICATION_ALREADY_EXISTS",
         "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION",
         "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS", "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS",
         "FABRIC_E_SERVICE_ALREADY_EXISTS", "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS",
         "FABRIC_E_APPLICATION_TYPE_IN_USE", "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION",
         "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS", "FABRIC_E_FABRIC_VERSION_IN_USE",
         "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS", "FABRIC_E_NAME_ALREADY_EXISTS",
         "FABRIC_E_NAME_NOT_EMPTY", "FABRIC_E_PROPERTY_CHECK_FAILED",
         "FABRIC_E_SERVICE_METADATA_MISMATCH", "FABRIC_E_SERVICE_TYPE_MISMATCH",
         "FABRIC_E_HEALTH_STALE_REPORT", "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED",
         "FABRIC_E_NODE_HAS_NOT_STOPPED_YET", "FABRIC_E_INSTANCE_ID_MISMATCH",
         "FABRIC_E_VALUE_TOO_LARGE", "FABRIC_E_NO_WRITE_QUORUM", "FABRIC_E_NOT_PRIMARY",
         "FABRIC_E_NOT_READY", "FABRIC_E_RECONFIGURATION_PENDING", "FABRIC_E_SERVICE_OFFLINE",
         "E_ABORT", "FABRIC_E_COMMUNICATION_ERROR", "FABRIC_E_OPERATION_NOT_COMPLETE",
         "FABRIC_E_TIMEOUT", "FABRIC_E_NODE_IS_UP", "E_FAIL", "FABRIC_E_BACKUP_IS_ENABLED",
         "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH", "FABRIC_E_INVALID_FOR_STATELESS_SERVICES",
         "FABRIC_E_BACKUP_NOT_ENABLED", "FABRIC_E_BACKUP_POLICY_NOT_EXISTING",
         "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING", "FABRIC_E_BACKUP_IN_PROGRESS",
         "FABRIC_E_RESTORE_IN_PROGRESS", "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING",
         "FABRIC_E_INVALID_SERVICE_SCALING_POLICY", "E_INVALIDARG",
         "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS",
         "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND", "FABRIC_E_VOLUME_ALREADY_EXISTS",
         "FABRIC_E_VOLUME_NOT_FOUND", "SerializationError",
         "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR", "FABRIC_E_CERTIFICATE_NOT_FOUND".
        :paramtype code: str or ~azure.servicefabric.models.FabricErrorCodes
        :keyword message: Error message.
        :paramtype message: str
        """
        super(FabricErrorError, self).__init__(**kwargs)
        self.code = kwargs['code']
        self.message = kwargs.get('message', None)


class PropertyBatchInfo(msrest.serialization.Model):
    """Information about the results of a property batch.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: FailedPropertyBatchInfo, SuccessfulPropertyBatchInfo.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property batch info, determined by the results of a property
     batch. The following are the possible values.Constant filled by server. Possible values
     include: "Invalid", "Successful", "Failed".
    :vartype kind: str or ~azure.servicefabric.models.PropertyBatchInfoKind
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'Failed': 'FailedPropertyBatchInfo', 'Successful': 'SuccessfulPropertyBatchInfo'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(PropertyBatchInfo, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]


class FailedPropertyBatchInfo(PropertyBatchInfo):
    """Derived from PropertyBatchInfo. Represents the property batch failing. Contains information about the specific batch failure.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property batch info, determined by the results of a property
     batch. The following are the possible values.Constant filled by server. Possible values
     include: "Invalid", "Successful", "Failed".
    :vartype kind: str or ~azure.servicefabric.models.PropertyBatchInfoKind
    :ivar error_message: The error message of the failed operation. Describes the exception thrown
     due to the first unsuccessful operation in the property batch.
    :vartype error_message: str
    :ivar operation_index: The index of the unsuccessful operation in the property batch.
    :vartype operation_index: int
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'error_message': {'key': 'ErrorMessage', 'type': 'str'},
        'operation_index': {'key': 'OperationIndex', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword error_message: The error message of the failed operation. Describes the exception
         thrown due to the first unsuccessful operation in the property batch.
        :paramtype error_message: str
        :keyword operation_index: The index of the unsuccessful operation in the property batch.
        :paramtype operation_index: int
        """
        super(FailedPropertyBatchInfo, self).__init__(**kwargs)
        self.kind = 'Failed'  # type: str
        self.error_message = kwargs.get('error_message', None)
        self.operation_index = kwargs.get('operation_index', None)


class FailedUpgradeDomainProgressObject(msrest.serialization.Model):
    """The detailed upgrade progress for nodes in the current upgrade domain at the point of failure. Not applicable to node-by-node upgrades.

    :ivar domain_name: The name of the upgrade domain.
    :vartype domain_name: str
    :ivar node_upgrade_progress_list: List of upgrading nodes and their statuses.
    :vartype node_upgrade_progress_list: list[~azure.servicefabric.models.NodeUpgradeProgressInfo]
    """

    _attribute_map = {
        'domain_name': {'key': 'DomainName', 'type': 'str'},
        'node_upgrade_progress_list': {'key': 'NodeUpgradeProgressList', 'type': '[NodeUpgradeProgressInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword domain_name: The name of the upgrade domain.
        :paramtype domain_name: str
        :keyword node_upgrade_progress_list: List of upgrading nodes and their statuses.
        :paramtype node_upgrade_progress_list:
         list[~azure.servicefabric.models.NodeUpgradeProgressInfo]
        """
        super(FailedUpgradeDomainProgressObject, self).__init__(**kwargs)
        self.domain_name = kwargs.get('domain_name', None)
        self.node_upgrade_progress_list = kwargs.get('node_upgrade_progress_list', None)


class FailureUpgradeDomainProgressInfo(msrest.serialization.Model):
    """Information about the upgrade domain progress at the time of upgrade failure.

    :ivar domain_name: The name of the upgrade domain.
    :vartype domain_name: str
    :ivar node_upgrade_progress_list: List of upgrading nodes and their statuses.
    :vartype node_upgrade_progress_list: list[~azure.servicefabric.models.NodeUpgradeProgressInfo]
    """

    _attribute_map = {
        'domain_name': {'key': 'DomainName', 'type': 'str'},
        'node_upgrade_progress_list': {'key': 'NodeUpgradeProgressList', 'type': '[NodeUpgradeProgressInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword domain_name: The name of the upgrade domain.
        :paramtype domain_name: str
        :keyword node_upgrade_progress_list: List of upgrading nodes and their statuses.
        :paramtype node_upgrade_progress_list:
         list[~azure.servicefabric.models.NodeUpgradeProgressInfo]
        """
        super(FailureUpgradeDomainProgressInfo, self).__init__(**kwargs)
        self.domain_name = kwargs.get('domain_name', None)
        self.node_upgrade_progress_list = kwargs.get('node_upgrade_progress_list', None)


class FileInfo(msrest.serialization.Model):
    """Information about a image store file.

    :ivar file_size: The size of file in bytes.
    :vartype file_size: str
    :ivar file_version: Information about the version of image store file.
    :vartype file_version: ~azure.servicefabric.models.FileVersion
    :ivar modified_date: The date and time when the image store file was last modified.
    :vartype modified_date: ~datetime.datetime
    :ivar store_relative_path: The file path relative to the image store root path.
    :vartype store_relative_path: str
    """

    _attribute_map = {
        'file_size': {'key': 'FileSize', 'type': 'str'},
        'file_version': {'key': 'FileVersion', 'type': 'FileVersion'},
        'modified_date': {'key': 'ModifiedDate', 'type': 'iso-8601'},
        'store_relative_path': {'key': 'StoreRelativePath', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword file_size: The size of file in bytes.
        :paramtype file_size: str
        :keyword file_version: Information about the version of image store file.
        :paramtype file_version: ~azure.servicefabric.models.FileVersion
        :keyword modified_date: The date and time when the image store file was last modified.
        :paramtype modified_date: ~datetime.datetime
        :keyword store_relative_path: The file path relative to the image store root path.
        :paramtype store_relative_path: str
        """
        super(FileInfo, self).__init__(**kwargs)
        self.file_size = kwargs.get('file_size', None)
        self.file_version = kwargs.get('file_version', None)
        self.modified_date = kwargs.get('modified_date', None)
        self.store_relative_path = kwargs.get('store_relative_path', None)


class FileShareBackupStorageDescription(BackupStorageDescription):
    """Describes the parameters for file share storage used for storing or enumerating backups.

    All required parameters must be populated in order to send to Azure.

    :ivar storage_kind: Required. The kind of backup storage, where backups are saved.Constant
     filled by server. Possible values include: "Invalid", "FileShare", "AzureBlobStore",
     "DsmsAzureBlobStore", "ManagedIdentityAzureBlobStore".
    :vartype storage_kind: str or ~azure.servicefabric.models.BackupStorageKind
    :ivar friendly_name: Friendly name for this backup storage.
    :vartype friendly_name: str
    :ivar path: Required. UNC path of the file share where to store or enumerate backups from.
    :vartype path: str
    :ivar primary_user_name: Primary user name to access the file share.
    :vartype primary_user_name: str
    :ivar primary_password: Primary password to access the share location.
    :vartype primary_password: str
    :ivar secondary_user_name: Secondary user name to access the file share.
    :vartype secondary_user_name: str
    :ivar secondary_password: Secondary password to access the share location.
    :vartype secondary_password: str
    """

    _validation = {
        'storage_kind': {'required': True},
        'path': {'required': True},
    }

    _attribute_map = {
        'storage_kind': {'key': 'StorageKind', 'type': 'str'},
        'friendly_name': {'key': 'FriendlyName', 'type': 'str'},
        'path': {'key': 'Path', 'type': 'str'},
        'primary_user_name': {'key': 'PrimaryUserName', 'type': 'str'},
        'primary_password': {'key': 'PrimaryPassword', 'type': 'str'},
        'secondary_user_name': {'key': 'SecondaryUserName', 'type': 'str'},
        'secondary_password': {'key': 'SecondaryPassword', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword friendly_name: Friendly name for this backup storage.
        :paramtype friendly_name: str
        :keyword path: Required. UNC path of the file share where to store or enumerate backups from.
        :paramtype path: str
        :keyword primary_user_name: Primary user name to access the file share.
        :paramtype primary_user_name: str
        :keyword primary_password: Primary password to access the share location.
        :paramtype primary_password: str
        :keyword secondary_user_name: Secondary user name to access the file share.
        :paramtype secondary_user_name: str
        :keyword secondary_password: Secondary password to access the share location.
        :paramtype secondary_password: str
        """
        super(FileShareBackupStorageDescription, self).__init__(**kwargs)
        self.storage_kind = 'FileShare'  # type: str
        self.path = kwargs['path']
        self.primary_user_name = kwargs.get('primary_user_name', None)
        self.primary_password = kwargs.get('primary_password', None)
        self.secondary_user_name = kwargs.get('secondary_user_name', None)
        self.secondary_password = kwargs.get('secondary_password', None)


class FileVersion(msrest.serialization.Model):
    """Information about the version of image store file.

    :ivar version_number: The current image store version number for the file is used in image
     store for checking whether it need to be updated.
    :vartype version_number: str
    :ivar epoch_data_loss_number: The epoch data loss number of image store replica when this file
     entry was updated or created.
    :vartype epoch_data_loss_number: str
    :ivar epoch_configuration_number: The epoch configuration version number of the image store
     replica when this file entry was created or updated.
    :vartype epoch_configuration_number: str
    """

    _attribute_map = {
        'version_number': {'key': 'VersionNumber', 'type': 'str'},
        'epoch_data_loss_number': {'key': 'EpochDataLossNumber', 'type': 'str'},
        'epoch_configuration_number': {'key': 'EpochConfigurationNumber', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword version_number: The current image store version number for the file is used in image
         store for checking whether it need to be updated.
        :paramtype version_number: str
        :keyword epoch_data_loss_number: The epoch data loss number of image store replica when this
         file entry was updated or created.
        :paramtype epoch_data_loss_number: str
        :keyword epoch_configuration_number: The epoch configuration version number of the image store
         replica when this file entry was created or updated.
        :paramtype epoch_configuration_number: str
        """
        super(FileVersion, self).__init__(**kwargs)
        self.version_number = kwargs.get('version_number', None)
        self.epoch_data_loss_number = kwargs.get('epoch_data_loss_number', None)
        self.epoch_configuration_number = kwargs.get('epoch_configuration_number', None)


class FolderInfo(msrest.serialization.Model):
    """Information about a image store folder. It includes how many files this folder contains and its image store relative path.

    :ivar store_relative_path: The remote location within image store. This path is relative to the
     image store root.
    :vartype store_relative_path: str
    :ivar file_count: The number of files from within the image store folder.
    :vartype file_count: str
    """

    _attribute_map = {
        'store_relative_path': {'key': 'StoreRelativePath', 'type': 'str'},
        'file_count': {'key': 'FileCount', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword store_relative_path: The remote location within image store. This path is relative to
         the image store root.
        :paramtype store_relative_path: str
        :keyword file_count: The number of files from within the image store folder.
        :paramtype file_count: str
        """
        super(FolderInfo, self).__init__(**kwargs)
        self.store_relative_path = kwargs.get('store_relative_path', None)
        self.file_count = kwargs.get('file_count', None)


class FolderSizeInfo(msrest.serialization.Model):
    """Information of a image store folder size.

    :ivar store_relative_path: The remote location within image store. This path is relative to the
     image store root.
    :vartype store_relative_path: str
    :ivar folder_size: The size of folder in bytes.
    :vartype folder_size: str
    """

    _attribute_map = {
        'store_relative_path': {'key': 'StoreRelativePath', 'type': 'str'},
        'folder_size': {'key': 'FolderSize', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword store_relative_path: The remote location within image store. This path is relative to
         the image store root.
        :paramtype store_relative_path: str
        :keyword folder_size: The size of folder in bytes.
        :paramtype folder_size: str
        """
        super(FolderSizeInfo, self).__init__(**kwargs)
        self.store_relative_path = kwargs.get('store_relative_path', None)
        self.folder_size = kwargs.get('folder_size', None)


class FrequencyBasedBackupScheduleDescription(BackupScheduleDescription):
    """Describes the frequency based backup schedule.

    All required parameters must be populated in order to send to Azure.

    :ivar schedule_kind: Required. The kind of backup schedule, time based or frequency
     based.Constant filled by server. Possible values include: "Invalid", "TimeBased",
     "FrequencyBased".
    :vartype schedule_kind: str or ~azure.servicefabric.models.BackupScheduleKind
    :ivar interval: Required. Defines the interval with which backups are periodically taken. It
     should be specified in ISO8601 format. Timespan in seconds is not supported and will be ignored
     while creating the policy.
    :vartype interval: ~datetime.timedelta
    """

    _validation = {
        'schedule_kind': {'required': True},
        'interval': {'required': True},
    }

    _attribute_map = {
        'schedule_kind': {'key': 'ScheduleKind', 'type': 'str'},
        'interval': {'key': 'Interval', 'type': 'duration'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword interval: Required. Defines the interval with which backups are periodically taken. It
         should be specified in ISO8601 format. Timespan in seconds is not supported and will be ignored
         while creating the policy.
        :paramtype interval: ~datetime.timedelta
        """
        super(FrequencyBasedBackupScheduleDescription, self).__init__(**kwargs)
        self.schedule_kind = 'FrequencyBased'  # type: str
        self.interval = kwargs['interval']


class GatewayDestination(msrest.serialization.Model):
    """Describes destination endpoint for routing traffic.

    All required parameters must be populated in order to send to Azure.

    :ivar application_name: Required. Name of the service fabric Mesh application.
    :vartype application_name: str
    :ivar service_name: Required. service that contains the endpoint.
    :vartype service_name: str
    :ivar endpoint_name: Required. name of the endpoint in the service.
    :vartype endpoint_name: str
    """

    _validation = {
        'application_name': {'required': True},
        'service_name': {'required': True},
        'endpoint_name': {'required': True},
    }

    _attribute_map = {
        'application_name': {'key': 'applicationName', 'type': 'str'},
        'service_name': {'key': 'serviceName', 'type': 'str'},
        'endpoint_name': {'key': 'endpointName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword application_name: Required. Name of the service fabric Mesh application.
        :paramtype application_name: str
        :keyword service_name: Required. service that contains the endpoint.
        :paramtype service_name: str
        :keyword endpoint_name: Required. name of the endpoint in the service.
        :paramtype endpoint_name: str
        """
        super(GatewayDestination, self).__init__(**kwargs)
        self.application_name = kwargs['application_name']
        self.service_name = kwargs['service_name']
        self.endpoint_name = kwargs['endpoint_name']


class GatewayResourceDescription(msrest.serialization.Model):
    """This type describes a gateway resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. Name of the Gateway resource.
    :vartype name: str
    :ivar description: User readable description of the gateway.
    :vartype description: str
    :ivar source_network: Required. Network the gateway should listen on for requests.
    :vartype source_network: ~azure.servicefabric.models.NetworkRef
    :ivar destination_network: Required. Network that the Application is using.
    :vartype destination_network: ~azure.servicefabric.models.NetworkRef
    :ivar tcp: Configuration for tcp connectivity for this gateway.
    :vartype tcp: list[~azure.servicefabric.models.TcpConfig]
    :ivar http: Configuration for http connectivity for this gateway.
    :vartype http: list[~azure.servicefabric.models.HttpConfig]
    :ivar status: Status of the resource. Possible values include: "Unknown", "Ready", "Upgrading",
     "Creating", "Deleting", "Failed".
    :vartype status: str or ~azure.servicefabric.models.ResourceStatus
    :ivar status_details: Gives additional information about the current status of the gateway.
    :vartype status_details: str
    :ivar ip_address: IP address of the gateway. This is populated in the response and is ignored
     for incoming requests.
    :vartype ip_address: str
    """

    _validation = {
        'name': {'required': True},
        'source_network': {'required': True},
        'destination_network': {'required': True},
        'status': {'readonly': True},
        'status_details': {'readonly': True},
        'ip_address': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'source_network': {'key': 'properties.sourceNetwork', 'type': 'NetworkRef'},
        'destination_network': {'key': 'properties.destinationNetwork', 'type': 'NetworkRef'},
        'tcp': {'key': 'properties.tcp', 'type': '[TcpConfig]'},
        'http': {'key': 'properties.http', 'type': '[HttpConfig]'},
        'status': {'key': 'properties.status', 'type': 'str'},
        'status_details': {'key': 'properties.statusDetails', 'type': 'str'},
        'ip_address': {'key': 'properties.ipAddress', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. Name of the Gateway resource.
        :paramtype name: str
        :keyword description: User readable description of the gateway.
        :paramtype description: str
        :keyword source_network: Required. Network the gateway should listen on for requests.
        :paramtype source_network: ~azure.servicefabric.models.NetworkRef
        :keyword destination_network: Required. Network that the Application is using.
        :paramtype destination_network: ~azure.servicefabric.models.NetworkRef
        :keyword tcp: Configuration for tcp connectivity for this gateway.
        :paramtype tcp: list[~azure.servicefabric.models.TcpConfig]
        :keyword http: Configuration for http connectivity for this gateway.
        :paramtype http: list[~azure.servicefabric.models.HttpConfig]
        """
        super(GatewayResourceDescription, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.description = kwargs.get('description', None)
        self.source_network = kwargs['source_network']
        self.destination_network = kwargs['destination_network']
        self.tcp = kwargs.get('tcp', None)
        self.http = kwargs.get('http', None)
        self.status = None
        self.status_details = None
        self.ip_address = None


class GetBackupByStorageQueryDescription(msrest.serialization.Model):
    """Describes additional filters to be applied, while listing backups, and backup storage details from where to fetch the backups.

    All required parameters must be populated in order to send to Azure.

    :ivar start_date_time_filter: Specifies the start date time in ISO8601 from which to enumerate
     backups. If not specified, backups are enumerated from the beginning.
    :vartype start_date_time_filter: ~datetime.datetime
    :ivar end_date_time_filter: Specifies the end date time in ISO8601 till which to enumerate
     backups. If not specified, backups are enumerated till the end.
    :vartype end_date_time_filter: ~datetime.datetime
    :ivar latest: If specified as true, gets the most recent backup (within the specified time
     range) for every partition under the specified backup entity.
    :vartype latest: bool
    :ivar storage: Required. Describes the parameters for the backup storage from where to
     enumerate backups. This is optional and by default backups are enumerated from the backup
     storage where this backup entity is currently being backed up (as specified in backup policy).
     This parameter is useful to be able to enumerate backups from another cluster where you may
     intend to restore.
    :vartype storage: ~azure.servicefabric.models.BackupStorageDescription
    :ivar backup_entity: Required. Indicates the entity for which to enumerate backups.
    :vartype backup_entity: ~azure.servicefabric.models.BackupEntity
    """

    _validation = {
        'storage': {'required': True},
        'backup_entity': {'required': True},
    }

    _attribute_map = {
        'start_date_time_filter': {'key': 'StartDateTimeFilter', 'type': 'iso-8601'},
        'end_date_time_filter': {'key': 'EndDateTimeFilter', 'type': 'iso-8601'},
        'latest': {'key': 'Latest', 'type': 'bool'},
        'storage': {'key': 'Storage', 'type': 'BackupStorageDescription'},
        'backup_entity': {'key': 'BackupEntity', 'type': 'BackupEntity'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword start_date_time_filter: Specifies the start date time in ISO8601 from which to
         enumerate backups. If not specified, backups are enumerated from the beginning.
        :paramtype start_date_time_filter: ~datetime.datetime
        :keyword end_date_time_filter: Specifies the end date time in ISO8601 till which to enumerate
         backups. If not specified, backups are enumerated till the end.
        :paramtype end_date_time_filter: ~datetime.datetime
        :keyword latest: If specified as true, gets the most recent backup (within the specified time
         range) for every partition under the specified backup entity.
        :paramtype latest: bool
        :keyword storage: Required. Describes the parameters for the backup storage from where to
         enumerate backups. This is optional and by default backups are enumerated from the backup
         storage where this backup entity is currently being backed up (as specified in backup policy).
         This parameter is useful to be able to enumerate backups from another cluster where you may
         intend to restore.
        :paramtype storage: ~azure.servicefabric.models.BackupStorageDescription
        :keyword backup_entity: Required. Indicates the entity for which to enumerate backups.
        :paramtype backup_entity: ~azure.servicefabric.models.BackupEntity
        """
        super(GetBackupByStorageQueryDescription, self).__init__(**kwargs)
        self.start_date_time_filter = kwargs.get('start_date_time_filter', None)
        self.end_date_time_filter = kwargs.get('end_date_time_filter', None)
        self.latest = kwargs.get('latest', False)
        self.storage = kwargs['storage']
        self.backup_entity = kwargs['backup_entity']


class GetPropertyBatchOperation(PropertyBatchOperation):
    """Represents a PropertyBatchOperation that gets the specified property if it exists.
Note that if one PropertyBatchOperation in a PropertyBatch fails,
the entire batch fails and cannot be committed in a transactional manner.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property batch operation, determined by the operation to be
     performed. The following are the possible values.Constant filled by server. Possible values
     include: "Invalid", "Put", "Get", "CheckExists", "CheckSequence", "Delete", "CheckValue".
    :vartype kind: str or ~azure.servicefabric.models.PropertyBatchOperationKind
    :ivar property_name: Required. The name of the Service Fabric property.
    :vartype property_name: str
    :ivar include_value: Whether or not to return the property value with the metadata.
     True if values should be returned with the metadata; False to return only property metadata.
    :vartype include_value: bool
    """

    _validation = {
        'kind': {'required': True},
        'property_name': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'property_name': {'key': 'PropertyName', 'type': 'str'},
        'include_value': {'key': 'IncludeValue', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword property_name: Required. The name of the Service Fabric property.
        :paramtype property_name: str
        :keyword include_value: Whether or not to return the property value with the metadata.
         True if values should be returned with the metadata; False to return only property metadata.
        :paramtype include_value: bool
        """
        super(GetPropertyBatchOperation, self).__init__(**kwargs)
        self.kind = 'Get'  # type: str
        self.include_value = kwargs.get('include_value', False)


class GuidPropertyValue(PropertyValue):
    """Describes a Service Fabric property value of type Guid.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property, determined by the type of data. Following are the
     possible values.Constant filled by server. Possible values include: "Invalid", "Binary",
     "Int64", "Double", "String", "Guid".
    :vartype kind: str or ~azure.servicefabric.models.PropertyValueKind
    :ivar data: Required. The data of the property value.
    :vartype data: str
    """

    _validation = {
        'kind': {'required': True},
        'data': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'data': {'key': 'Data', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword data: Required. The data of the property value.
        :paramtype data: str
        """
        super(GuidPropertyValue, self).__init__(**kwargs)
        self.kind = 'Guid'  # type: str
        self.data = kwargs['data']


class HealthEvaluationWrapper(msrest.serialization.Model):
    """Wrapper object for health evaluation.

    :ivar health_evaluation: Represents a health evaluation which describes the data and the
     algorithm used by health manager to evaluate the health of an entity.
    :vartype health_evaluation: ~azure.servicefabric.models.HealthEvaluation
    """

    _attribute_map = {
        'health_evaluation': {'key': 'HealthEvaluation', 'type': 'HealthEvaluation'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword health_evaluation: Represents a health evaluation which describes the data and the
         algorithm used by health manager to evaluate the health of an entity.
        :paramtype health_evaluation: ~azure.servicefabric.models.HealthEvaluation
        """
        super(HealthEvaluationWrapper, self).__init__(**kwargs)
        self.health_evaluation = kwargs.get('health_evaluation', None)


class HealthInformation(msrest.serialization.Model):
    """Represents common health report information. It is included in all health reports sent to health store and in all health events returned by health queries.

    All required parameters must be populated in order to send to Azure.

    :ivar source_id: Required. The source name that identifies the client/watchdog/system component
     that generated the health information.
    :vartype source_id: str
    :ivar property: Required. The property of the health information. An entity can have health
     reports for different properties.
     The property is a string and not a fixed enumeration to allow the reporter flexibility to
     categorize the state condition that triggers the report.
     For example, a reporter with SourceId "LocalWatchdog" can monitor the state of the available
     disk on a node,
     so it can report "AvailableDisk" property on that node.
     The same reporter can monitor the node connectivity, so it can report a property
     "Connectivity" on the same node.
     In the health store, these reports are treated as separate health events for the specified
     node.
    
     Together with the SourceId, the property uniquely identifies the health information.
    :vartype property: str
    :ivar health_state: Required. The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar time_to_live_in_milli_seconds: The duration for which this health report is valid. This
     field uses ISO8601 format for specifying the duration.
     When clients report periodically, they should send reports with higher frequency than time to
     live.
     If clients report on transition, they can set the time to live to infinite.
     When time to live expires, the health event that contains the health information
     is either removed from health store, if RemoveWhenExpired is true, or evaluated at error, if
     RemoveWhenExpired false.
    
     If not specified, time to live defaults to infinite value.
    :vartype time_to_live_in_milli_seconds: ~datetime.timedelta
    :ivar description: The description of the health information. It represents free text used to
     add human readable information about the report.
     The maximum string length for the description is 4096 characters.
     If the provided string is longer, it will be automatically truncated.
     When truncated, the last characters of the description contain a marker "[Truncated]", and
     total string size is 4096 characters.
     The presence of the marker indicates to users that truncation occurred.
     Note that when truncated, the description has less than 4096 characters from the original
     string.
    :vartype description: str
    :ivar sequence_number: The sequence number for this health report as a numeric string.
     The report sequence number is used by the health store to detect stale reports.
     If not specified, a sequence number is auto-generated by the health client when a report is
     added.
    :vartype sequence_number: str
    :ivar remove_when_expired: Value that indicates whether the report is removed from health store
     when it expires.
     If set to true, the report is removed from the health store after it expires.
     If set to false, the report is treated as an error when expired. The value of this property is
     false by default.
     When clients report periodically, they should set RemoveWhenExpired false (default).
     This way, if the reporter has issues (e.g. deadlock) and can't report, the entity is evaluated
     at error when the health report expires.
     This flags the entity as being in Error health state.
    :vartype remove_when_expired: bool
    :ivar health_report_id: A health report ID which identifies the health report and can be used
     to find more detailed information about a specific health event at
     aka.ms/sfhealthid.
    :vartype health_report_id: str
    """

    _validation = {
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
    }

    _attribute_map = {
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_in_milli_seconds': {'key': 'TimeToLiveInMilliSeconds', 'type': 'duration'},
        'description': {'key': 'Description', 'type': 'str'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'health_report_id': {'key': 'HealthReportId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword source_id: Required. The source name that identifies the client/watchdog/system
         component that generated the health information.
        :paramtype source_id: str
        :keyword property: Required. The property of the health information. An entity can have health
         reports for different properties.
         The property is a string and not a fixed enumeration to allow the reporter flexibility to
         categorize the state condition that triggers the report.
         For example, a reporter with SourceId "LocalWatchdog" can monitor the state of the available
         disk on a node,
         so it can report "AvailableDisk" property on that node.
         The same reporter can monitor the node connectivity, so it can report a property
         "Connectivity" on the same node.
         In the health store, these reports are treated as separate health events for the specified
         node.
        
         Together with the SourceId, the property uniquely identifies the health information.
        :paramtype property: str
        :keyword health_state: Required. The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword time_to_live_in_milli_seconds: The duration for which this health report is valid.
         This field uses ISO8601 format for specifying the duration.
         When clients report periodically, they should send reports with higher frequency than time to
         live.
         If clients report on transition, they can set the time to live to infinite.
         When time to live expires, the health event that contains the health information
         is either removed from health store, if RemoveWhenExpired is true, or evaluated at error, if
         RemoveWhenExpired false.
        
         If not specified, time to live defaults to infinite value.
        :paramtype time_to_live_in_milli_seconds: ~datetime.timedelta
        :keyword description: The description of the health information. It represents free text used
         to add human readable information about the report.
         The maximum string length for the description is 4096 characters.
         If the provided string is longer, it will be automatically truncated.
         When truncated, the last characters of the description contain a marker "[Truncated]", and
         total string size is 4096 characters.
         The presence of the marker indicates to users that truncation occurred.
         Note that when truncated, the description has less than 4096 characters from the original
         string.
        :paramtype description: str
        :keyword sequence_number: The sequence number for this health report as a numeric string.
         The report sequence number is used by the health store to detect stale reports.
         If not specified, a sequence number is auto-generated by the health client when a report is
         added.
        :paramtype sequence_number: str
        :keyword remove_when_expired: Value that indicates whether the report is removed from health
         store when it expires.
         If set to true, the report is removed from the health store after it expires.
         If set to false, the report is treated as an error when expired. The value of this property is
         false by default.
         When clients report periodically, they should set RemoveWhenExpired false (default).
         This way, if the reporter has issues (e.g. deadlock) and can't report, the entity is evaluated
         at error when the health report expires.
         This flags the entity as being in Error health state.
        :paramtype remove_when_expired: bool
        :keyword health_report_id: A health report ID which identifies the health report and can be
         used to find more detailed information about a specific health event at
         aka.ms/sfhealthid.
        :paramtype health_report_id: str
        """
        super(HealthInformation, self).__init__(**kwargs)
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_in_milli_seconds = kwargs.get('time_to_live_in_milli_seconds', None)
        self.description = kwargs.get('description', None)
        self.sequence_number = kwargs.get('sequence_number', None)
        self.remove_when_expired = kwargs.get('remove_when_expired', None)
        self.health_report_id = kwargs.get('health_report_id', None)


class HealthEvent(HealthInformation):
    """Represents health information reported on a health entity, such as cluster, application or node, with additional metadata added by the Health Manager.

    All required parameters must be populated in order to send to Azure.

    :ivar source_id: Required. The source name that identifies the client/watchdog/system component
     that generated the health information.
    :vartype source_id: str
    :ivar property: Required. The property of the health information. An entity can have health
     reports for different properties.
     The property is a string and not a fixed enumeration to allow the reporter flexibility to
     categorize the state condition that triggers the report.
     For example, a reporter with SourceId "LocalWatchdog" can monitor the state of the available
     disk on a node,
     so it can report "AvailableDisk" property on that node.
     The same reporter can monitor the node connectivity, so it can report a property
     "Connectivity" on the same node.
     In the health store, these reports are treated as separate health events for the specified
     node.
    
     Together with the SourceId, the property uniquely identifies the health information.
    :vartype property: str
    :ivar health_state: Required. The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar time_to_live_in_milli_seconds: The duration for which this health report is valid. This
     field uses ISO8601 format for specifying the duration.
     When clients report periodically, they should send reports with higher frequency than time to
     live.
     If clients report on transition, they can set the time to live to infinite.
     When time to live expires, the health event that contains the health information
     is either removed from health store, if RemoveWhenExpired is true, or evaluated at error, if
     RemoveWhenExpired false.
    
     If not specified, time to live defaults to infinite value.
    :vartype time_to_live_in_milli_seconds: ~datetime.timedelta
    :ivar description: The description of the health information. It represents free text used to
     add human readable information about the report.
     The maximum string length for the description is 4096 characters.
     If the provided string is longer, it will be automatically truncated.
     When truncated, the last characters of the description contain a marker "[Truncated]", and
     total string size is 4096 characters.
     The presence of the marker indicates to users that truncation occurred.
     Note that when truncated, the description has less than 4096 characters from the original
     string.
    :vartype description: str
    :ivar sequence_number: The sequence number for this health report as a numeric string.
     The report sequence number is used by the health store to detect stale reports.
     If not specified, a sequence number is auto-generated by the health client when a report is
     added.
    :vartype sequence_number: str
    :ivar remove_when_expired: Value that indicates whether the report is removed from health store
     when it expires.
     If set to true, the report is removed from the health store after it expires.
     If set to false, the report is treated as an error when expired. The value of this property is
     false by default.
     When clients report periodically, they should set RemoveWhenExpired false (default).
     This way, if the reporter has issues (e.g. deadlock) and can't report, the entity is evaluated
     at error when the health report expires.
     This flags the entity as being in Error health state.
    :vartype remove_when_expired: bool
    :ivar health_report_id: A health report ID which identifies the health report and can be used
     to find more detailed information about a specific health event at
     aka.ms/sfhealthid.
    :vartype health_report_id: str
    :ivar is_expired: Returns true if the health event is expired, otherwise false.
    :vartype is_expired: bool
    :ivar source_utc_timestamp: The date and time when the health report was sent by the source.
    :vartype source_utc_timestamp: ~datetime.datetime
    :ivar last_modified_utc_timestamp: The date and time when the health report was last modified
     by the health store.
    :vartype last_modified_utc_timestamp: ~datetime.datetime
    :ivar last_ok_transition_at: If the current health state is 'Ok', this property returns the
     time at which the health report was first reported with 'Ok'.
     For periodic reporting, many reports with the same state may have been generated.
     This property returns the date and time when the first 'Ok' health report was received.
    
     If the current health state is 'Error' or 'Warning', returns the date and time at which the
     health state was last in 'Ok', before transitioning to a different state.
    
     If the health state was never 'Ok', the value will be zero date-time.
    :vartype last_ok_transition_at: ~datetime.datetime
    :ivar last_warning_transition_at: If the current health state is 'Warning', this property
     returns the time at which the health report was first reported with 'Warning'. For periodic
     reporting, many reports with the same state may have been generated however, this property
     returns only the date and time at the first 'Warning' health report was received.
    
     If the current health state is 'Ok' or 'Error', returns the date and time at which the health
     state was last in 'Warning', before transitioning to a different state.
    
     If the health state was never 'Warning', the value will be zero date-time.
    :vartype last_warning_transition_at: ~datetime.datetime
    :ivar last_error_transition_at: If the current health state is 'Error', this property returns
     the time at which the health report was first reported with 'Error'. For periodic reporting,
     many reports with the same state may have been generated however, this property returns only
     the date and time at the first 'Error' health report was received.
    
     If the current health state is 'Ok' or 'Warning', returns the date and time at which the
     health state was last in 'Error', before transitioning to a different state.
    
     If the health state was never 'Error', the value will be zero date-time.
    :vartype last_error_transition_at: ~datetime.datetime
    """

    _validation = {
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
    }

    _attribute_map = {
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_in_milli_seconds': {'key': 'TimeToLiveInMilliSeconds', 'type': 'duration'},
        'description': {'key': 'Description', 'type': 'str'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'health_report_id': {'key': 'HealthReportId', 'type': 'str'},
        'is_expired': {'key': 'IsExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
        'last_modified_utc_timestamp': {'key': 'LastModifiedUtcTimestamp', 'type': 'iso-8601'},
        'last_ok_transition_at': {'key': 'LastOkTransitionAt', 'type': 'iso-8601'},
        'last_warning_transition_at': {'key': 'LastWarningTransitionAt', 'type': 'iso-8601'},
        'last_error_transition_at': {'key': 'LastErrorTransitionAt', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword source_id: Required. The source name that identifies the client/watchdog/system
         component that generated the health information.
        :paramtype source_id: str
        :keyword property: Required. The property of the health information. An entity can have health
         reports for different properties.
         The property is a string and not a fixed enumeration to allow the reporter flexibility to
         categorize the state condition that triggers the report.
         For example, a reporter with SourceId "LocalWatchdog" can monitor the state of the available
         disk on a node,
         so it can report "AvailableDisk" property on that node.
         The same reporter can monitor the node connectivity, so it can report a property
         "Connectivity" on the same node.
         In the health store, these reports are treated as separate health events for the specified
         node.
        
         Together with the SourceId, the property uniquely identifies the health information.
        :paramtype property: str
        :keyword health_state: Required. The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword time_to_live_in_milli_seconds: The duration for which this health report is valid.
         This field uses ISO8601 format for specifying the duration.
         When clients report periodically, they should send reports with higher frequency than time to
         live.
         If clients report on transition, they can set the time to live to infinite.
         When time to live expires, the health event that contains the health information
         is either removed from health store, if RemoveWhenExpired is true, or evaluated at error, if
         RemoveWhenExpired false.
        
         If not specified, time to live defaults to infinite value.
        :paramtype time_to_live_in_milli_seconds: ~datetime.timedelta
        :keyword description: The description of the health information. It represents free text used
         to add human readable information about the report.
         The maximum string length for the description is 4096 characters.
         If the provided string is longer, it will be automatically truncated.
         When truncated, the last characters of the description contain a marker "[Truncated]", and
         total string size is 4096 characters.
         The presence of the marker indicates to users that truncation occurred.
         Note that when truncated, the description has less than 4096 characters from the original
         string.
        :paramtype description: str
        :keyword sequence_number: The sequence number for this health report as a numeric string.
         The report sequence number is used by the health store to detect stale reports.
         If not specified, a sequence number is auto-generated by the health client when a report is
         added.
        :paramtype sequence_number: str
        :keyword remove_when_expired: Value that indicates whether the report is removed from health
         store when it expires.
         If set to true, the report is removed from the health store after it expires.
         If set to false, the report is treated as an error when expired. The value of this property is
         false by default.
         When clients report periodically, they should set RemoveWhenExpired false (default).
         This way, if the reporter has issues (e.g. deadlock) and can't report, the entity is evaluated
         at error when the health report expires.
         This flags the entity as being in Error health state.
        :paramtype remove_when_expired: bool
        :keyword health_report_id: A health report ID which identifies the health report and can be
         used to find more detailed information about a specific health event at
         aka.ms/sfhealthid.
        :paramtype health_report_id: str
        :keyword is_expired: Returns true if the health event is expired, otherwise false.
        :paramtype is_expired: bool
        :keyword source_utc_timestamp: The date and time when the health report was sent by the source.
        :paramtype source_utc_timestamp: ~datetime.datetime
        :keyword last_modified_utc_timestamp: The date and time when the health report was last
         modified by the health store.
        :paramtype last_modified_utc_timestamp: ~datetime.datetime
        :keyword last_ok_transition_at: If the current health state is 'Ok', this property returns the
         time at which the health report was first reported with 'Ok'.
         For periodic reporting, many reports with the same state may have been generated.
         This property returns the date and time when the first 'Ok' health report was received.
        
         If the current health state is 'Error' or 'Warning', returns the date and time at which the
         health state was last in 'Ok', before transitioning to a different state.
        
         If the health state was never 'Ok', the value will be zero date-time.
        :paramtype last_ok_transition_at: ~datetime.datetime
        :keyword last_warning_transition_at: If the current health state is 'Warning', this property
         returns the time at which the health report was first reported with 'Warning'. For periodic
         reporting, many reports with the same state may have been generated however, this property
         returns only the date and time at the first 'Warning' health report was received.
        
         If the current health state is 'Ok' or 'Error', returns the date and time at which the health
         state was last in 'Warning', before transitioning to a different state.
        
         If the health state was never 'Warning', the value will be zero date-time.
        :paramtype last_warning_transition_at: ~datetime.datetime
        :keyword last_error_transition_at: If the current health state is 'Error', this property
         returns the time at which the health report was first reported with 'Error'. For periodic
         reporting, many reports with the same state may have been generated however, this property
         returns only the date and time at the first 'Error' health report was received.
        
         If the current health state is 'Ok' or 'Warning', returns the date and time at which the
         health state was last in 'Error', before transitioning to a different state.
        
         If the health state was never 'Error', the value will be zero date-time.
        :paramtype last_error_transition_at: ~datetime.datetime
        """
        super(HealthEvent, self).__init__(**kwargs)
        self.is_expired = kwargs.get('is_expired', None)
        self.source_utc_timestamp = kwargs.get('source_utc_timestamp', None)
        self.last_modified_utc_timestamp = kwargs.get('last_modified_utc_timestamp', None)
        self.last_ok_transition_at = kwargs.get('last_ok_transition_at', None)
        self.last_warning_transition_at = kwargs.get('last_warning_transition_at', None)
        self.last_error_transition_at = kwargs.get('last_error_transition_at', None)


class HealthStateCount(msrest.serialization.Model):
    """Represents information about how many health entities are in Ok, Warning and Error health state.

    :ivar ok_count: The number of health entities with aggregated health state Ok.
    :vartype ok_count: long
    :ivar warning_count: The number of health entities with aggregated health state Warning.
    :vartype warning_count: long
    :ivar error_count: The number of health entities with aggregated health state Error.
    :vartype error_count: long
    """

    _validation = {
        'ok_count': {'minimum': 0},
        'warning_count': {'minimum': 0},
        'error_count': {'minimum': 0},
    }

    _attribute_map = {
        'ok_count': {'key': 'OkCount', 'type': 'long'},
        'warning_count': {'key': 'WarningCount', 'type': 'long'},
        'error_count': {'key': 'ErrorCount', 'type': 'long'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword ok_count: The number of health entities with aggregated health state Ok.
        :paramtype ok_count: long
        :keyword warning_count: The number of health entities with aggregated health state Warning.
        :paramtype warning_count: long
        :keyword error_count: The number of health entities with aggregated health state Error.
        :paramtype error_count: long
        """
        super(HealthStateCount, self).__init__(**kwargs)
        self.ok_count = kwargs.get('ok_count', None)
        self.warning_count = kwargs.get('warning_count', None)
        self.error_count = kwargs.get('error_count', None)


class HealthStatistics(msrest.serialization.Model):
    """The health statistics of an entity, returned as part of the health query result when the query description is configured to include statistics.
The statistics include health state counts for all children types of the current entity.
For example, for cluster, the health statistics include health state counts for nodes, applications, services, partitions, replicas, deployed applications and deployed service packages.
For partition, the health statistics include health counts for replicas.

    :ivar health_state_count_list: List of health state counts per entity kind, which keeps track
     of how many children of the queried entity are in Ok, Warning and Error state.
    :vartype health_state_count_list: list[~azure.servicefabric.models.EntityKindHealthStateCount]
    """

    _attribute_map = {
        'health_state_count_list': {'key': 'HealthStateCountList', 'type': '[EntityKindHealthStateCount]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword health_state_count_list: List of health state counts per entity kind, which keeps
         track of how many children of the queried entity are in Ok, Warning and Error state.
        :paramtype health_state_count_list:
         list[~azure.servicefabric.models.EntityKindHealthStateCount]
        """
        super(HealthStatistics, self).__init__(**kwargs)
        self.health_state_count_list = kwargs.get('health_state_count_list', None)


class HttpConfig(msrest.serialization.Model):
    """Describes the http configuration for external connectivity for this network.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. http gateway config name.
    :vartype name: str
    :ivar port: Required. Specifies the port at which the service endpoint below needs to be
     exposed.
    :vartype port: int
    :ivar hosts: Required. description for routing.
    :vartype hosts: list[~azure.servicefabric.models.HttpHostConfig]
    """

    _validation = {
        'name': {'required': True},
        'port': {'required': True},
        'hosts': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
        'hosts': {'key': 'hosts', 'type': '[HttpHostConfig]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. http gateway config name.
        :paramtype name: str
        :keyword port: Required. Specifies the port at which the service endpoint below needs to be
         exposed.
        :paramtype port: int
        :keyword hosts: Required. description for routing.
        :paramtype hosts: list[~azure.servicefabric.models.HttpHostConfig]
        """
        super(HttpConfig, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.port = kwargs['port']
        self.hosts = kwargs['hosts']


class HttpHostConfig(msrest.serialization.Model):
    """Describes the hostname properties for http routing.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. http hostname config name.
    :vartype name: str
    :ivar routes: Required. Route information to use for routing. Routes are processed in the order
     they are specified. Specify routes that are more specific before routes that can handle general
     cases.
    :vartype routes: list[~azure.servicefabric.models.HttpRouteConfig]
    """

    _validation = {
        'name': {'required': True},
        'routes': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'routes': {'key': 'routes', 'type': '[HttpRouteConfig]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. http hostname config name.
        :paramtype name: str
        :keyword routes: Required. Route information to use for routing. Routes are processed in the
         order they are specified. Specify routes that are more specific before routes that can handle
         general cases.
        :paramtype routes: list[~azure.servicefabric.models.HttpRouteConfig]
        """
        super(HttpHostConfig, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.routes = kwargs['routes']


class HttpRouteConfig(msrest.serialization.Model):
    """Describes the hostname properties for http routing.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. http route name.
    :vartype name: str
    :ivar match: Required. Describes a rule for http route matching.
    :vartype match: ~azure.servicefabric.models.HttpRouteMatchRule
    :ivar destination: Required. Describes destination endpoint for routing traffic.
    :vartype destination: ~azure.servicefabric.models.GatewayDestination
    """

    _validation = {
        'name': {'required': True},
        'match': {'required': True},
        'destination': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'match': {'key': 'match', 'type': 'HttpRouteMatchRule'},
        'destination': {'key': 'destination', 'type': 'GatewayDestination'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. http route name.
        :paramtype name: str
        :keyword match: Required. Describes a rule for http route matching.
        :paramtype match: ~azure.servicefabric.models.HttpRouteMatchRule
        :keyword destination: Required. Describes destination endpoint for routing traffic.
        :paramtype destination: ~azure.servicefabric.models.GatewayDestination
        """
        super(HttpRouteConfig, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.match = kwargs['match']
        self.destination = kwargs['destination']


class HttpRouteMatchHeader(msrest.serialization.Model):
    """Describes header information for http route matching.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. Name of header to match in request.
    :vartype name: str
    :ivar value: Value of header to match in request.
    :vartype value: str
    :ivar type: how to match header value. Possible values include: "exact".
    :vartype type: str or ~azure.servicefabric.models.HeaderMatchType
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. Name of header to match in request.
        :paramtype name: str
        :keyword value: Value of header to match in request.
        :paramtype value: str
        :keyword type: how to match header value. Possible values include: "exact".
        :paramtype type: str or ~azure.servicefabric.models.HeaderMatchType
        """
        super(HttpRouteMatchHeader, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.value = kwargs.get('value', None)
        self.type = kwargs.get('type', None)


class HttpRouteMatchPath(msrest.serialization.Model):
    """Path to match for routing.

    All required parameters must be populated in order to send to Azure.

    :ivar value: Required. Uri path to match for request.
    :vartype value: str
    :ivar rewrite: replacement string for matched part of the Uri.
    :vartype rewrite: str
    :ivar type: Required. how to match value in the Uri. Possible values include: "prefix".
    :vartype type: str or ~azure.servicefabric.models.PathMatchType
    """

    _validation = {
        'value': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': 'str'},
        'rewrite': {'key': 'rewrite', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword value: Required. Uri path to match for request.
        :paramtype value: str
        :keyword rewrite: replacement string for matched part of the Uri.
        :paramtype rewrite: str
        :keyword type: Required. how to match value in the Uri. Possible values include: "prefix".
        :paramtype type: str or ~azure.servicefabric.models.PathMatchType
        """
        super(HttpRouteMatchPath, self).__init__(**kwargs)
        self.value = kwargs['value']
        self.rewrite = kwargs.get('rewrite', None)
        self.type = kwargs['type']


class HttpRouteMatchRule(msrest.serialization.Model):
    """Describes a rule for http route matching.

    All required parameters must be populated in order to send to Azure.

    :ivar path: Required. Path to match for routing.
    :vartype path: ~azure.servicefabric.models.HttpRouteMatchPath
    :ivar headers: headers and their values to match in request.
    :vartype headers: list[~azure.servicefabric.models.HttpRouteMatchHeader]
    """

    _validation = {
        'path': {'required': True},
    }

    _attribute_map = {
        'path': {'key': 'path', 'type': 'HttpRouteMatchPath'},
        'headers': {'key': 'headers', 'type': '[HttpRouteMatchHeader]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword path: Required. Path to match for routing.
        :paramtype path: ~azure.servicefabric.models.HttpRouteMatchPath
        :keyword headers: headers and their values to match in request.
        :paramtype headers: list[~azure.servicefabric.models.HttpRouteMatchHeader]
        """
        super(HttpRouteMatchRule, self).__init__(**kwargs)
        self.path = kwargs['path']
        self.headers = kwargs.get('headers', None)


class IdentityDescription(msrest.serialization.Model):
    """Information describing the identities associated with this application.

    All required parameters must be populated in order to send to Azure.

    :ivar token_service_endpoint: the endpoint for the token service managing this identity.
    :vartype token_service_endpoint: str
    :ivar type: Required. the types of identities associated with this resource; currently
     restricted to 'SystemAssigned and UserAssigned'.
    :vartype type: str
    :ivar tenant_id: the identifier of the tenant containing the application's identity.
    :vartype tenant_id: str
    :ivar principal_id: the object identifier of the Service Principal of the identity associated
     with this resource.
    :vartype principal_id: str
    :ivar user_assigned_identities: represents user assigned identities map.
    :vartype user_assigned_identities: dict[str,
     ~azure.servicefabric.models.IdentityItemDescription]
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'token_service_endpoint': {'key': 'tokenServiceEndpoint', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tenant_id': {'key': 'tenantId', 'type': 'str'},
        'principal_id': {'key': 'principalId', 'type': 'str'},
        'user_assigned_identities': {'key': 'userAssignedIdentities', 'type': '{IdentityItemDescription}'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword token_service_endpoint: the endpoint for the token service managing this identity.
        :paramtype token_service_endpoint: str
        :keyword type: Required. the types of identities associated with this resource; currently
         restricted to 'SystemAssigned and UserAssigned'.
        :paramtype type: str
        :keyword tenant_id: the identifier of the tenant containing the application's identity.
        :paramtype tenant_id: str
        :keyword principal_id: the object identifier of the Service Principal of the identity
         associated with this resource.
        :paramtype principal_id: str
        :keyword user_assigned_identities: represents user assigned identities map.
        :paramtype user_assigned_identities: dict[str,
         ~azure.servicefabric.models.IdentityItemDescription]
        """
        super(IdentityDescription, self).__init__(**kwargs)
        self.token_service_endpoint = kwargs.get('token_service_endpoint', None)
        self.type = kwargs['type']
        self.tenant_id = kwargs.get('tenant_id', None)
        self.principal_id = kwargs.get('principal_id', None)
        self.user_assigned_identities = kwargs.get('user_assigned_identities', None)


class IdentityItemDescription(msrest.serialization.Model):
    """Describes a single user-assigned identity associated with the application.

    :ivar principal_id: the object identifier of the Service Principal which this identity
     represents.
    :vartype principal_id: str
    :ivar client_id: the client identifier of the Service Principal which this identity represents.
    :vartype client_id: str
    """

    _attribute_map = {
        'principal_id': {'key': 'principalId', 'type': 'str'},
        'client_id': {'key': 'clientId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword principal_id: the object identifier of the Service Principal which this identity
         represents.
        :paramtype principal_id: str
        :keyword client_id: the client identifier of the Service Principal which this identity
         represents.
        :paramtype client_id: str
        """
        super(IdentityItemDescription, self).__init__(**kwargs)
        self.principal_id = kwargs.get('principal_id', None)
        self.client_id = kwargs.get('client_id', None)


class ImageRegistryCredential(msrest.serialization.Model):
    """Image registry credential.

    All required parameters must be populated in order to send to Azure.

    :ivar server: Required. Docker image registry server, without protocol such as ``http`` and
     ``https``.
    :vartype server: str
    :ivar username: Required. The username for the private registry.
    :vartype username: str
    :ivar password_type: The type of the image registry password being given in password. Possible
     values include: "ClearText", "KeyVaultReference", "SecretValueReference". Default value:
     "ClearText".
    :vartype password_type: str or ~azure.servicefabric.models.ImageRegistryPasswordType
    :ivar password: The password for the private registry. The password is required for create or
     update operations, however it is not returned in the get or list operations. Will be processed
     based on the type provided.
    :vartype password: str
    """

    _validation = {
        'server': {'required': True},
        'username': {'required': True},
    }

    _attribute_map = {
        'server': {'key': 'server', 'type': 'str'},
        'username': {'key': 'username', 'type': 'str'},
        'password_type': {'key': 'passwordType', 'type': 'str'},
        'password': {'key': 'password', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword server: Required. Docker image registry server, without protocol such as ``http`` and
         ``https``.
        :paramtype server: str
        :keyword username: Required. The username for the private registry.
        :paramtype username: str
        :keyword password_type: The type of the image registry password being given in password.
         Possible values include: "ClearText", "KeyVaultReference", "SecretValueReference". Default
         value: "ClearText".
        :paramtype password_type: str or ~azure.servicefabric.models.ImageRegistryPasswordType
        :keyword password: The password for the private registry. The password is required for create
         or update operations, however it is not returned in the get or list operations. Will be
         processed based on the type provided.
        :paramtype password: str
        """
        super(ImageRegistryCredential, self).__init__(**kwargs)
        self.server = kwargs['server']
        self.username = kwargs['username']
        self.password_type = kwargs.get('password_type', "ClearText")
        self.password = kwargs.get('password', None)


class ImageStoreContent(msrest.serialization.Model):
    """Information about the image store content.

    :ivar store_files: The list of image store file info objects represents files found under the
     given image store relative path.
    :vartype store_files: list[~azure.servicefabric.models.FileInfo]
    :ivar store_folders: The list of image store folder info objects represents subfolders found
     under the given image store relative path.
    :vartype store_folders: list[~azure.servicefabric.models.FolderInfo]
    """

    _attribute_map = {
        'store_files': {'key': 'StoreFiles', 'type': '[FileInfo]'},
        'store_folders': {'key': 'StoreFolders', 'type': '[FolderInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword store_files: The list of image store file info objects represents files found under
         the given image store relative path.
        :paramtype store_files: list[~azure.servicefabric.models.FileInfo]
        :keyword store_folders: The list of image store folder info objects represents subfolders found
         under the given image store relative path.
        :paramtype store_folders: list[~azure.servicefabric.models.FolderInfo]
        """
        super(ImageStoreContent, self).__init__(**kwargs)
        self.store_files = kwargs.get('store_files', None)
        self.store_folders = kwargs.get('store_folders', None)


class ImageStoreCopyDescription(msrest.serialization.Model):
    """Information about how to copy image store content from one image store relative path to another image store relative path.

    All required parameters must be populated in order to send to Azure.

    :ivar remote_source: Required. The relative path of source image store content to be copied
     from.
    :vartype remote_source: str
    :ivar remote_destination: Required. The relative path of destination image store content to be
     copied to.
    :vartype remote_destination: str
    :ivar skip_files: The list of the file names to be skipped for copying.
    :vartype skip_files: list[str]
    :ivar check_mark_file: Indicates whether to check mark file during copying. The property is
     true if checking mark file is required, false otherwise. The mark file is used to check whether
     the folder is well constructed. If the property is true and mark file does not exist, the copy
     is skipped.
    :vartype check_mark_file: bool
    """

    _validation = {
        'remote_source': {'required': True},
        'remote_destination': {'required': True},
    }

    _attribute_map = {
        'remote_source': {'key': 'RemoteSource', 'type': 'str'},
        'remote_destination': {'key': 'RemoteDestination', 'type': 'str'},
        'skip_files': {'key': 'SkipFiles', 'type': '[str]'},
        'check_mark_file': {'key': 'CheckMarkFile', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword remote_source: Required. The relative path of source image store content to be copied
         from.
        :paramtype remote_source: str
        :keyword remote_destination: Required. The relative path of destination image store content to
         be copied to.
        :paramtype remote_destination: str
        :keyword skip_files: The list of the file names to be skipped for copying.
        :paramtype skip_files: list[str]
        :keyword check_mark_file: Indicates whether to check mark file during copying. The property is
         true if checking mark file is required, false otherwise. The mark file is used to check whether
         the folder is well constructed. If the property is true and mark file does not exist, the copy
         is skipped.
        :paramtype check_mark_file: bool
        """
        super(ImageStoreCopyDescription, self).__init__(**kwargs)
        self.remote_source = kwargs['remote_source']
        self.remote_destination = kwargs['remote_destination']
        self.skip_files = kwargs.get('skip_files', None)
        self.check_mark_file = kwargs.get('check_mark_file', None)


class ImageStoreInfo(msrest.serialization.Model):
    """Information about the ImageStore's resource usage.

    :ivar disk_info: disk capacity and available disk space on the node where the ImageStore
     primary is placed.
    :vartype disk_info: ~azure.servicefabric.models.DiskInfo
    :ivar used_by_metadata: the ImageStore's file system usage for metadata.
    :vartype used_by_metadata: ~azure.servicefabric.models.UsageInfo
    :ivar used_by_staging: The ImageStore's file system usage for staging files that are being
     uploaded.
    :vartype used_by_staging: ~azure.servicefabric.models.UsageInfo
    :ivar used_by_copy: the ImageStore's file system usage for copied application and cluster
     packages. `Removing application and cluster packages
     <https://docs.microsoft.com/rest/api/servicefabric/sfclient-api-deleteimagestorecontent>`_ will
     free up this space.
    :vartype used_by_copy: ~azure.servicefabric.models.UsageInfo
    :ivar used_by_register: the ImageStore's file system usage for registered and cluster packages.
     `Unregistering application
     <https://docs.microsoft.com/rest/api/servicefabric/sfclient-api-unprovisionapplicationtype>`_
     and `cluster packages
     <https://docs.microsoft.com/rest/api/servicefabric/sfclient-api-unprovisionapplicationtype>`_
     will free up this space.
    :vartype used_by_register: ~azure.servicefabric.models.UsageInfo
    """

    _attribute_map = {
        'disk_info': {'key': 'DiskInfo', 'type': 'DiskInfo'},
        'used_by_metadata': {'key': 'UsedByMetadata', 'type': 'UsageInfo'},
        'used_by_staging': {'key': 'UsedByStaging', 'type': 'UsageInfo'},
        'used_by_copy': {'key': 'UsedByCopy', 'type': 'UsageInfo'},
        'used_by_register': {'key': 'UsedByRegister', 'type': 'UsageInfo'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword disk_info: disk capacity and available disk space on the node where the ImageStore
         primary is placed.
        :paramtype disk_info: ~azure.servicefabric.models.DiskInfo
        :keyword used_by_metadata: the ImageStore's file system usage for metadata.
        :paramtype used_by_metadata: ~azure.servicefabric.models.UsageInfo
        :keyword used_by_staging: The ImageStore's file system usage for staging files that are being
         uploaded.
        :paramtype used_by_staging: ~azure.servicefabric.models.UsageInfo
        :keyword used_by_copy: the ImageStore's file system usage for copied application and cluster
         packages. `Removing application and cluster packages
         <https://docs.microsoft.com/rest/api/servicefabric/sfclient-api-deleteimagestorecontent>`_ will
         free up this space.
        :paramtype used_by_copy: ~azure.servicefabric.models.UsageInfo
        :keyword used_by_register: the ImageStore's file system usage for registered and cluster
         packages. `Unregistering application
         <https://docs.microsoft.com/rest/api/servicefabric/sfclient-api-unprovisionapplicationtype>`_
         and `cluster packages
         <https://docs.microsoft.com/rest/api/servicefabric/sfclient-api-unprovisionapplicationtype>`_
         will free up this space.
        :paramtype used_by_register: ~azure.servicefabric.models.UsageInfo
        """
        super(ImageStoreInfo, self).__init__(**kwargs)
        self.disk_info = kwargs.get('disk_info', None)
        self.used_by_metadata = kwargs.get('used_by_metadata', None)
        self.used_by_staging = kwargs.get('used_by_staging', None)
        self.used_by_copy = kwargs.get('used_by_copy', None)
        self.used_by_register = kwargs.get('used_by_register', None)


class SecretResourcePropertiesBase(msrest.serialization.Model):
    """This type describes the properties of a secret resource, including its kind.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: SecretResourceProperties.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. Describes the kind of secret.Constant filled by server. Possible values
     include: "inlinedValue", "keyVaultVersionedReference".
    :vartype kind: str or ~azure.servicefabric.models.SecretKind
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'SecretResourceProperties': 'SecretResourceProperties'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(SecretResourcePropertiesBase, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]


class SecretResourceProperties(SecretResourcePropertiesBase):
    """Describes the properties of a secret resource.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: InlinedValueSecretResourceProperties.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. Describes the kind of secret.Constant filled by server. Possible values
     include: "inlinedValue", "keyVaultVersionedReference".
    :vartype kind: str or ~azure.servicefabric.models.SecretKind
    :ivar description: User readable description of the secret.
    :vartype description: str
    :ivar status: Status of the resource. Possible values include: "Unknown", "Ready", "Upgrading",
     "Creating", "Deleting", "Failed".
    :vartype status: str or ~azure.servicefabric.models.ResourceStatus
    :ivar status_details: Gives additional information about the current status of the secret.
    :vartype status_details: str
    :ivar content_type: The type of the content stored in the secret value. The value of this
     property is opaque to Service Fabric. Once set, the value of this property cannot be changed.
    :vartype content_type: str
    """

    _validation = {
        'kind': {'required': True},
        'status': {'readonly': True},
        'status_details': {'readonly': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'status_details': {'key': 'statusDetails', 'type': 'str'},
        'content_type': {'key': 'contentType', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'inlinedValue': 'InlinedValueSecretResourceProperties'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword description: User readable description of the secret.
        :paramtype description: str
        :keyword content_type: The type of the content stored in the secret value. The value of this
         property is opaque to Service Fabric. Once set, the value of this property cannot be changed.
        :paramtype content_type: str
        """
        super(SecretResourceProperties, self).__init__(**kwargs)
        self.kind = 'SecretResourceProperties'  # type: str
        self.description = kwargs.get('description', None)
        self.status = None
        self.status_details = None
        self.content_type = kwargs.get('content_type', None)


class InlinedValueSecretResourceProperties(SecretResourceProperties):
    """Describes the properties of a secret resource whose value is provided explicitly as plaintext. The secret resource may have multiple values, each being uniquely versioned. The secret value of each version is stored encrypted, and delivered as plaintext into the context of applications referencing it.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. Describes the kind of secret.Constant filled by server. Possible values
     include: "inlinedValue", "keyVaultVersionedReference".
    :vartype kind: str or ~azure.servicefabric.models.SecretKind
    :ivar description: User readable description of the secret.
    :vartype description: str
    :ivar status: Status of the resource. Possible values include: "Unknown", "Ready", "Upgrading",
     "Creating", "Deleting", "Failed".
    :vartype status: str or ~azure.servicefabric.models.ResourceStatus
    :ivar status_details: Gives additional information about the current status of the secret.
    :vartype status_details: str
    :ivar content_type: The type of the content stored in the secret value. The value of this
     property is opaque to Service Fabric. Once set, the value of this property cannot be changed.
    :vartype content_type: str
    """

    _validation = {
        'kind': {'required': True},
        'status': {'readonly': True},
        'status_details': {'readonly': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'status_details': {'key': 'statusDetails', 'type': 'str'},
        'content_type': {'key': 'contentType', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword description: User readable description of the secret.
        :paramtype description: str
        :keyword content_type: The type of the content stored in the secret value. The value of this
         property is opaque to Service Fabric. Once set, the value of this property cannot be changed.
        :paramtype content_type: str
        """
        super(InlinedValueSecretResourceProperties, self).__init__(**kwargs)
        self.kind = 'inlinedValue'  # type: str


class InstanceLifecycleDescription(msrest.serialization.Model):
    """Describes how the instance will behave.

    :ivar restore_replica_location_after_upgrade: If set to true, move/swap replica to original
     location after upgrade.
    :vartype restore_replica_location_after_upgrade: bool
    """

    _attribute_map = {
        'restore_replica_location_after_upgrade': {'key': 'RestoreReplicaLocationAfterUpgrade', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword restore_replica_location_after_upgrade: If set to true, move/swap replica to original
         location after upgrade.
        :paramtype restore_replica_location_after_upgrade: bool
        """
        super(InstanceLifecycleDescription, self).__init__(**kwargs)
        self.restore_replica_location_after_upgrade = kwargs.get('restore_replica_location_after_upgrade', None)


class Int64PropertyValue(PropertyValue):
    """Describes a Service Fabric property value of type Int64.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property, determined by the type of data. Following are the
     possible values.Constant filled by server. Possible values include: "Invalid", "Binary",
     "Int64", "Double", "String", "Guid".
    :vartype kind: str or ~azure.servicefabric.models.PropertyValueKind
    :ivar data: Required. The data of the property value.
    :vartype data: str
    """

    _validation = {
        'kind': {'required': True},
        'data': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'data': {'key': 'Data', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword data: Required. The data of the property value.
        :paramtype data: str
        """
        super(Int64PropertyValue, self).__init__(**kwargs)
        self.kind = 'Int64'  # type: str
        self.data = kwargs['data']


class PartitionInformation(msrest.serialization.Model):
    """Information about the partition identity, partitioning scheme and keys supported by it.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: Int64RangePartitionInformation, NamedPartitionInformation, SingletonPartitionInformation.

    All required parameters must be populated in order to send to Azure.

    :ivar service_partition_kind: Required. The kind of partitioning scheme used to partition the
     service.Constant filled by server. Possible values include: "Invalid", "Singleton",
     "Int64Range", "Named".
    :vartype service_partition_kind: str or ~azure.servicefabric.models.ServicePartitionKind
    :ivar id: An internal ID used by Service Fabric to uniquely identify a partition. This is a
     randomly generated GUID when the service was created. The partition ID is unique and does not
     change for the lifetime of the service. If the same service was deleted and recreated the IDs
     of its partitions would be different.
    :vartype id: str
    """

    _validation = {
        'service_partition_kind': {'required': True},
    }

    _attribute_map = {
        'service_partition_kind': {'key': 'ServicePartitionKind', 'type': 'str'},
        'id': {'key': 'Id', 'type': 'str'},
    }

    _subtype_map = {
        'service_partition_kind': {'Int64Range': 'Int64RangePartitionInformation', 'Named': 'NamedPartitionInformation', 'Singleton': 'SingletonPartitionInformation'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword id: An internal ID used by Service Fabric to uniquely identify a partition. This is a
         randomly generated GUID when the service was created. The partition ID is unique and does not
         change for the lifetime of the service. If the same service was deleted and recreated the IDs
         of its partitions would be different.
        :paramtype id: str
        """
        super(PartitionInformation, self).__init__(**kwargs)
        self.service_partition_kind = None  # type: Optional[str]
        self.id = kwargs.get('id', None)


class Int64RangePartitionInformation(PartitionInformation):
    """Describes the partition information for the integer range that is based on partition schemes.

    All required parameters must be populated in order to send to Azure.

    :ivar service_partition_kind: Required. The kind of partitioning scheme used to partition the
     service.Constant filled by server. Possible values include: "Invalid", "Singleton",
     "Int64Range", "Named".
    :vartype service_partition_kind: str or ~azure.servicefabric.models.ServicePartitionKind
    :ivar id: An internal ID used by Service Fabric to uniquely identify a partition. This is a
     randomly generated GUID when the service was created. The partition ID is unique and does not
     change for the lifetime of the service. If the same service was deleted and recreated the IDs
     of its partitions would be different.
    :vartype id: str
    :ivar low_key: Specifies the minimum key value handled by this partition.
    :vartype low_key: str
    :ivar high_key: Specifies the maximum key value handled by this partition.
    :vartype high_key: str
    """

    _validation = {
        'service_partition_kind': {'required': True},
    }

    _attribute_map = {
        'service_partition_kind': {'key': 'ServicePartitionKind', 'type': 'str'},
        'id': {'key': 'Id', 'type': 'str'},
        'low_key': {'key': 'LowKey', 'type': 'str'},
        'high_key': {'key': 'HighKey', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword id: An internal ID used by Service Fabric to uniquely identify a partition. This is a
         randomly generated GUID when the service was created. The partition ID is unique and does not
         change for the lifetime of the service. If the same service was deleted and recreated the IDs
         of its partitions would be different.
        :paramtype id: str
        :keyword low_key: Specifies the minimum key value handled by this partition.
        :paramtype low_key: str
        :keyword high_key: Specifies the maximum key value handled by this partition.
        :paramtype high_key: str
        """
        super(Int64RangePartitionInformation, self).__init__(**kwargs)
        self.service_partition_kind = 'Int64Range'  # type: str
        self.low_key = kwargs.get('low_key', None)
        self.high_key = kwargs.get('high_key', None)


class InvokeDataLossResult(msrest.serialization.Model):
    """Represents information about an operation in a terminal state (Completed or Faulted).

    :ivar error_code: If OperationState is Completed, this is 0.  If OperationState is Faulted,
     this is an error code indicating the reason.
    :vartype error_code: int
    :ivar selected_partition: This class returns information about the partition that the
     user-induced operation acted upon.
    :vartype selected_partition: ~azure.servicefabric.models.SelectedPartition
    """

    _attribute_map = {
        'error_code': {'key': 'ErrorCode', 'type': 'int'},
        'selected_partition': {'key': 'SelectedPartition', 'type': 'SelectedPartition'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword error_code: If OperationState is Completed, this is 0.  If OperationState is Faulted,
         this is an error code indicating the reason.
        :paramtype error_code: int
        :keyword selected_partition: This class returns information about the partition that the
         user-induced operation acted upon.
        :paramtype selected_partition: ~azure.servicefabric.models.SelectedPartition
        """
        super(InvokeDataLossResult, self).__init__(**kwargs)
        self.error_code = kwargs.get('error_code', None)
        self.selected_partition = kwargs.get('selected_partition', None)


class InvokeQuorumLossResult(msrest.serialization.Model):
    """Represents information about an operation in a terminal state (Completed or Faulted).

    :ivar error_code: If OperationState is Completed, this is 0.  If OperationState is Faulted,
     this is an error code indicating the reason.
    :vartype error_code: int
    :ivar selected_partition: This class returns information about the partition that the
     user-induced operation acted upon.
    :vartype selected_partition: ~azure.servicefabric.models.SelectedPartition
    """

    _attribute_map = {
        'error_code': {'key': 'ErrorCode', 'type': 'int'},
        'selected_partition': {'key': 'SelectedPartition', 'type': 'SelectedPartition'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword error_code: If OperationState is Completed, this is 0.  If OperationState is Faulted,
         this is an error code indicating the reason.
        :paramtype error_code: int
        :keyword selected_partition: This class returns information about the partition that the
         user-induced operation acted upon.
        :paramtype selected_partition: ~azure.servicefabric.models.SelectedPartition
        """
        super(InvokeQuorumLossResult, self).__init__(**kwargs)
        self.error_code = kwargs.get('error_code', None)
        self.selected_partition = kwargs.get('selected_partition', None)


class ReplicaStatusBase(msrest.serialization.Model):
    """Information about the replica.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: KeyValueStoreReplicaStatus.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The role of a replica of a stateful service.Constant filled by server.
     Possible values include: "Invalid", "KeyValueStore".
    :vartype kind: str or ~azure.servicefabric.models.ReplicaKind
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'KeyValueStore': 'KeyValueStoreReplicaStatus'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(ReplicaStatusBase, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]


class KeyValueStoreReplicaStatus(ReplicaStatusBase):
    """Key value store related information for the replica.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The role of a replica of a stateful service.Constant filled by server.
     Possible values include: "Invalid", "KeyValueStore".
    :vartype kind: str or ~azure.servicefabric.models.ReplicaKind
    :ivar database_row_count_estimate: Value indicating the estimated number of rows in the
     underlying database.
    :vartype database_row_count_estimate: str
    :ivar database_logical_size_estimate: Value indicating the estimated size of the underlying
     database.
    :vartype database_logical_size_estimate: str
    :ivar copy_notification_current_key_filter: Value indicating the latest key-prefix filter
     applied to enumeration during the callback. Null if there is no pending callback.
    :vartype copy_notification_current_key_filter: str
    :ivar copy_notification_current_progress: Value indicating the latest number of keys enumerated
     during the callback. 0 if there is no pending callback.
    :vartype copy_notification_current_progress: str
    :ivar status_details: Value indicating the current status details of the replica.
    :vartype status_details: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'database_row_count_estimate': {'key': 'DatabaseRowCountEstimate', 'type': 'str'},
        'database_logical_size_estimate': {'key': 'DatabaseLogicalSizeEstimate', 'type': 'str'},
        'copy_notification_current_key_filter': {'key': 'CopyNotificationCurrentKeyFilter', 'type': 'str'},
        'copy_notification_current_progress': {'key': 'CopyNotificationCurrentProgress', 'type': 'str'},
        'status_details': {'key': 'StatusDetails', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword database_row_count_estimate: Value indicating the estimated number of rows in the
         underlying database.
        :paramtype database_row_count_estimate: str
        :keyword database_logical_size_estimate: Value indicating the estimated size of the underlying
         database.
        :paramtype database_logical_size_estimate: str
        :keyword copy_notification_current_key_filter: Value indicating the latest key-prefix filter
         applied to enumeration during the callback. Null if there is no pending callback.
        :paramtype copy_notification_current_key_filter: str
        :keyword copy_notification_current_progress: Value indicating the latest number of keys
         enumerated during the callback. 0 if there is no pending callback.
        :paramtype copy_notification_current_progress: str
        :keyword status_details: Value indicating the current status details of the replica.
        :paramtype status_details: str
        """
        super(KeyValueStoreReplicaStatus, self).__init__(**kwargs)
        self.kind = 'KeyValueStore'  # type: str
        self.database_row_count_estimate = kwargs.get('database_row_count_estimate', None)
        self.database_logical_size_estimate = kwargs.get('database_logical_size_estimate', None)
        self.copy_notification_current_key_filter = kwargs.get('copy_notification_current_key_filter', None)
        self.copy_notification_current_progress = kwargs.get('copy_notification_current_progress', None)
        self.status_details = kwargs.get('status_details', None)


class LoadedPartitionInformationQueryDescription(msrest.serialization.Model):
    """Represents data structure that contains query information.

    :ivar metric_name: Name of the metric for which this information is provided.
    :vartype metric_name: str
    :ivar service_name: Name of the service this partition belongs to.
    :vartype service_name: str
    :ivar ordering: Ordering of partitions' load. Possible values include: "Desc", "Asc".
    :vartype ordering: str or ~azure.servicefabric.models.Ordering
    :ivar max_results: The maximum number of results to be returned as part of the paged queries.
     This parameter defines the upper bound on the number of results returned. The results returned
     can be less than the specified maximum results if they do not fit in the message as per the max
     message size restrictions defined in the configuration. If this parameter is zero or not
     specified, the paged query includes as many results as possible that fit in the return message.
    :vartype max_results: long
    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    """

    _attribute_map = {
        'metric_name': {'key': 'MetricName', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'ordering': {'key': 'Ordering', 'type': 'str'},
        'max_results': {'key': 'MaxResults', 'type': 'long'},
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword metric_name: Name of the metric for which this information is provided.
        :paramtype metric_name: str
        :keyword service_name: Name of the service this partition belongs to.
        :paramtype service_name: str
        :keyword ordering: Ordering of partitions' load. Possible values include: "Desc", "Asc".
        :paramtype ordering: str or ~azure.servicefabric.models.Ordering
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message.
        :paramtype max_results: long
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        """
        super(LoadedPartitionInformationQueryDescription, self).__init__(**kwargs)
        self.metric_name = kwargs.get('metric_name', None)
        self.service_name = kwargs.get('service_name', None)
        self.ordering = kwargs.get('ordering', None)
        self.max_results = kwargs.get('max_results', None)
        self.continuation_token = kwargs.get('continuation_token', None)


class LoadedPartitionInformationResult(msrest.serialization.Model):
    """Represents partition information.

    All required parameters must be populated in order to send to Azure.

    :ivar service_name: Required. Name of the service this partition belongs to.
    :vartype service_name: str
    :ivar partition_id: Required. Id of the partition.
    :vartype partition_id: str
    :ivar metric_name: Required. Name of the metric for which this information is provided.
    :vartype metric_name: str
    :ivar load: Required. Load for metric.
    :vartype load: long
    """

    _validation = {
        'service_name': {'required': True},
        'partition_id': {'required': True},
        'metric_name': {'required': True},
        'load': {'required': True},
    }

    _attribute_map = {
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'metric_name': {'key': 'MetricName', 'type': 'str'},
        'load': {'key': 'Load', 'type': 'long'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_name: Required. Name of the service this partition belongs to.
        :paramtype service_name: str
        :keyword partition_id: Required. Id of the partition.
        :paramtype partition_id: str
        :keyword metric_name: Required. Name of the metric for which this information is provided.
        :paramtype metric_name: str
        :keyword load: Required. Load for metric.
        :paramtype load: long
        """
        super(LoadedPartitionInformationResult, self).__init__(**kwargs)
        self.service_name = kwargs['service_name']
        self.partition_id = kwargs['partition_id']
        self.metric_name = kwargs['metric_name']
        self.load = kwargs['load']


class LoadedPartitionInformationResultList(msrest.serialization.Model):
    """Represents data structure that contains top/least loaded partitions for a certain metric.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: List of application information.
    :vartype items: list[~azure.servicefabric.models.LoadedPartitionInformationResult]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[LoadedPartitionInformationResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: List of application information.
        :paramtype items: list[~azure.servicefabric.models.LoadedPartitionInformationResult]
        """
        super(LoadedPartitionInformationResultList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class LoadMetricInformation(msrest.serialization.Model):
    """Represents data structure that contains load information for a certain metric in a cluster.

    :ivar name: Name of the metric for which this load information is provided.
    :vartype name: str
    :ivar is_balanced_before: Value that indicates whether the metrics is balanced or not before
     resource balancer run.
    :vartype is_balanced_before: bool
    :ivar is_balanced_after: Value that indicates whether the metrics is balanced or not after
     resource balancer run.
    :vartype is_balanced_after: bool
    :ivar deviation_before: The standard average deviation of the metrics before resource balancer
     run.
    :vartype deviation_before: str
    :ivar deviation_after: The standard average deviation of the metrics after resource balancer
     run.
    :vartype deviation_after: str
    :ivar balancing_threshold: The balancing threshold for a certain metric.
    :vartype balancing_threshold: str
    :ivar action: The current action being taken with regard to this metric.
    :vartype action: str
    :ivar activity_threshold: The Activity Threshold specified for this metric in the system
     Cluster Manifest.
    :vartype activity_threshold: str
    :ivar cluster_capacity: The total cluster capacity for a given metric.
    :vartype cluster_capacity: str
    :ivar cluster_load: The total cluster load. In future releases of Service Fabric this parameter
     will be deprecated in favor of CurrentClusterLoad.
    :vartype cluster_load: str
    :ivar current_cluster_load: The total cluster load.
    :vartype current_cluster_load: str
    :ivar cluster_remaining_capacity: The remaining capacity for the metric in the cluster. In
     future releases of Service Fabric this parameter will be deprecated in favor of
     ClusterCapacityRemaining.
    :vartype cluster_remaining_capacity: str
    :ivar cluster_capacity_remaining: The remaining capacity for the metric in the cluster.
    :vartype cluster_capacity_remaining: str
    :ivar is_cluster_capacity_violation: Indicates that the metric is currently over capacity in
     the cluster.
    :vartype is_cluster_capacity_violation: bool
    :ivar node_buffer_percentage: The reserved percentage of total node capacity for this metric.
    :vartype node_buffer_percentage: str
    :ivar cluster_buffered_capacity: Remaining capacity in the cluster excluding the reserved
     space. In future releases of Service Fabric this parameter will be deprecated in favor of
     BufferedClusterCapacityRemaining.
    :vartype cluster_buffered_capacity: str
    :ivar buffered_cluster_capacity_remaining: Remaining capacity in the cluster excluding the
     reserved space.
    :vartype buffered_cluster_capacity_remaining: str
    :ivar cluster_remaining_buffered_capacity: The remaining percentage of cluster total capacity
     for this metric.
    :vartype cluster_remaining_buffered_capacity: str
    :ivar min_node_load_value: The minimum load on any node for this metric. In future releases of
     Service Fabric this parameter will be deprecated in favor of MinimumNodeLoad.
    :vartype min_node_load_value: str
    :ivar minimum_node_load: The minimum load on any node for this metric.
    :vartype minimum_node_load: str
    :ivar min_node_load_node_id: The node id of the node with the minimum load for this metric.
    :vartype min_node_load_node_id: ~azure.servicefabric.models.NodeId
    :ivar max_node_load_value: The maximum load on any node for this metric. In future releases of
     Service Fabric this parameter will be deprecated in favor of MaximumNodeLoad.
    :vartype max_node_load_value: str
    :ivar maximum_node_load: The maximum load on any node for this metric.
    :vartype maximum_node_load: str
    :ivar max_node_load_node_id: The node id of the node with the maximum load for this metric.
    :vartype max_node_load_node_id: ~azure.servicefabric.models.NodeId
    :ivar planned_load_removal: This value represents the load of the replicas that are planned to
     be removed in the future within the cluster.
     This kind of load is reported for replicas that are currently being moving to other nodes and
     for replicas that are currently being dropped but still use the load on the source node.
    :vartype planned_load_removal: str
    """

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'is_balanced_before': {'key': 'IsBalancedBefore', 'type': 'bool'},
        'is_balanced_after': {'key': 'IsBalancedAfter', 'type': 'bool'},
        'deviation_before': {'key': 'DeviationBefore', 'type': 'str'},
        'deviation_after': {'key': 'DeviationAfter', 'type': 'str'},
        'balancing_threshold': {'key': 'BalancingThreshold', 'type': 'str'},
        'action': {'key': 'Action', 'type': 'str'},
        'activity_threshold': {'key': 'ActivityThreshold', 'type': 'str'},
        'cluster_capacity': {'key': 'ClusterCapacity', 'type': 'str'},
        'cluster_load': {'key': 'ClusterLoad', 'type': 'str'},
        'current_cluster_load': {'key': 'CurrentClusterLoad', 'type': 'str'},
        'cluster_remaining_capacity': {'key': 'ClusterRemainingCapacity', 'type': 'str'},
        'cluster_capacity_remaining': {'key': 'ClusterCapacityRemaining', 'type': 'str'},
        'is_cluster_capacity_violation': {'key': 'IsClusterCapacityViolation', 'type': 'bool'},
        'node_buffer_percentage': {'key': 'NodeBufferPercentage', 'type': 'str'},
        'cluster_buffered_capacity': {'key': 'ClusterBufferedCapacity', 'type': 'str'},
        'buffered_cluster_capacity_remaining': {'key': 'BufferedClusterCapacityRemaining', 'type': 'str'},
        'cluster_remaining_buffered_capacity': {'key': 'ClusterRemainingBufferedCapacity', 'type': 'str'},
        'min_node_load_value': {'key': 'MinNodeLoadValue', 'type': 'str'},
        'minimum_node_load': {'key': 'MinimumNodeLoad', 'type': 'str'},
        'min_node_load_node_id': {'key': 'MinNodeLoadNodeId', 'type': 'NodeId'},
        'max_node_load_value': {'key': 'MaxNodeLoadValue', 'type': 'str'},
        'maximum_node_load': {'key': 'MaximumNodeLoad', 'type': 'str'},
        'max_node_load_node_id': {'key': 'MaxNodeLoadNodeId', 'type': 'NodeId'},
        'planned_load_removal': {'key': 'PlannedLoadRemoval', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Name of the metric for which this load information is provided.
        :paramtype name: str
        :keyword is_balanced_before: Value that indicates whether the metrics is balanced or not before
         resource balancer run.
        :paramtype is_balanced_before: bool
        :keyword is_balanced_after: Value that indicates whether the metrics is balanced or not after
         resource balancer run.
        :paramtype is_balanced_after: bool
        :keyword deviation_before: The standard average deviation of the metrics before resource
         balancer run.
        :paramtype deviation_before: str
        :keyword deviation_after: The standard average deviation of the metrics after resource balancer
         run.
        :paramtype deviation_after: str
        :keyword balancing_threshold: The balancing threshold for a certain metric.
        :paramtype balancing_threshold: str
        :keyword action: The current action being taken with regard to this metric.
        :paramtype action: str
        :keyword activity_threshold: The Activity Threshold specified for this metric in the system
         Cluster Manifest.
        :paramtype activity_threshold: str
        :keyword cluster_capacity: The total cluster capacity for a given metric.
        :paramtype cluster_capacity: str
        :keyword cluster_load: The total cluster load. In future releases of Service Fabric this
         parameter will be deprecated in favor of CurrentClusterLoad.
        :paramtype cluster_load: str
        :keyword current_cluster_load: The total cluster load.
        :paramtype current_cluster_load: str
        :keyword cluster_remaining_capacity: The remaining capacity for the metric in the cluster. In
         future releases of Service Fabric this parameter will be deprecated in favor of
         ClusterCapacityRemaining.
        :paramtype cluster_remaining_capacity: str
        :keyword cluster_capacity_remaining: The remaining capacity for the metric in the cluster.
        :paramtype cluster_capacity_remaining: str
        :keyword is_cluster_capacity_violation: Indicates that the metric is currently over capacity in
         the cluster.
        :paramtype is_cluster_capacity_violation: bool
        :keyword node_buffer_percentage: The reserved percentage of total node capacity for this
         metric.
        :paramtype node_buffer_percentage: str
        :keyword cluster_buffered_capacity: Remaining capacity in the cluster excluding the reserved
         space. In future releases of Service Fabric this parameter will be deprecated in favor of
         BufferedClusterCapacityRemaining.
        :paramtype cluster_buffered_capacity: str
        :keyword buffered_cluster_capacity_remaining: Remaining capacity in the cluster excluding the
         reserved space.
        :paramtype buffered_cluster_capacity_remaining: str
        :keyword cluster_remaining_buffered_capacity: The remaining percentage of cluster total
         capacity for this metric.
        :paramtype cluster_remaining_buffered_capacity: str
        :keyword min_node_load_value: The minimum load on any node for this metric. In future releases
         of Service Fabric this parameter will be deprecated in favor of MinimumNodeLoad.
        :paramtype min_node_load_value: str
        :keyword minimum_node_load: The minimum load on any node for this metric.
        :paramtype minimum_node_load: str
        :keyword min_node_load_node_id: The node id of the node with the minimum load for this metric.
        :paramtype min_node_load_node_id: ~azure.servicefabric.models.NodeId
        :keyword max_node_load_value: The maximum load on any node for this metric. In future releases
         of Service Fabric this parameter will be deprecated in favor of MaximumNodeLoad.
        :paramtype max_node_load_value: str
        :keyword maximum_node_load: The maximum load on any node for this metric.
        :paramtype maximum_node_load: str
        :keyword max_node_load_node_id: The node id of the node with the maximum load for this metric.
        :paramtype max_node_load_node_id: ~azure.servicefabric.models.NodeId
        :keyword planned_load_removal: This value represents the load of the replicas that are planned
         to be removed in the future within the cluster.
         This kind of load is reported for replicas that are currently being moving to other nodes and
         for replicas that are currently being dropped but still use the load on the source node.
        :paramtype planned_load_removal: str
        """
        super(LoadMetricInformation, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.is_balanced_before = kwargs.get('is_balanced_before', None)
        self.is_balanced_after = kwargs.get('is_balanced_after', None)
        self.deviation_before = kwargs.get('deviation_before', None)
        self.deviation_after = kwargs.get('deviation_after', None)
        self.balancing_threshold = kwargs.get('balancing_threshold', None)
        self.action = kwargs.get('action', None)
        self.activity_threshold = kwargs.get('activity_threshold', None)
        self.cluster_capacity = kwargs.get('cluster_capacity', None)
        self.cluster_load = kwargs.get('cluster_load', None)
        self.current_cluster_load = kwargs.get('current_cluster_load', None)
        self.cluster_remaining_capacity = kwargs.get('cluster_remaining_capacity', None)
        self.cluster_capacity_remaining = kwargs.get('cluster_capacity_remaining', None)
        self.is_cluster_capacity_violation = kwargs.get('is_cluster_capacity_violation', None)
        self.node_buffer_percentage = kwargs.get('node_buffer_percentage', None)
        self.cluster_buffered_capacity = kwargs.get('cluster_buffered_capacity', None)
        self.buffered_cluster_capacity_remaining = kwargs.get('buffered_cluster_capacity_remaining', None)
        self.cluster_remaining_buffered_capacity = kwargs.get('cluster_remaining_buffered_capacity', None)
        self.min_node_load_value = kwargs.get('min_node_load_value', None)
        self.minimum_node_load = kwargs.get('minimum_node_load', None)
        self.min_node_load_node_id = kwargs.get('min_node_load_node_id', None)
        self.max_node_load_value = kwargs.get('max_node_load_value', None)
        self.maximum_node_load = kwargs.get('maximum_node_load', None)
        self.max_node_load_node_id = kwargs.get('max_node_load_node_id', None)
        self.planned_load_removal = kwargs.get('planned_load_removal', None)


class LoadMetricReport(msrest.serialization.Model):
    """Represents the load metric report which contains the time metric was reported, its name and value.

    :ivar last_reported_utc: Gets the UTC time when the load was reported.
    :vartype last_reported_utc: ~datetime.datetime
    :ivar name: The name of the load metric.
    :vartype name: str
    :ivar value: The value of the load metric. In future releases of Service Fabric this parameter
     will be deprecated in favor of CurrentValue.
    :vartype value: str
    :ivar current_value: The value of the load metric.
    :vartype current_value: str
    """

    _attribute_map = {
        'last_reported_utc': {'key': 'LastReportedUtc', 'type': 'iso-8601'},
        'name': {'key': 'Name', 'type': 'str'},
        'value': {'key': 'Value', 'type': 'str'},
        'current_value': {'key': 'CurrentValue', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword last_reported_utc: Gets the UTC time when the load was reported.
        :paramtype last_reported_utc: ~datetime.datetime
        :keyword name: The name of the load metric.
        :paramtype name: str
        :keyword value: The value of the load metric. In future releases of Service Fabric this
         parameter will be deprecated in favor of CurrentValue.
        :paramtype value: str
        :keyword current_value: The value of the load metric.
        :paramtype current_value: str
        """
        super(LoadMetricReport, self).__init__(**kwargs)
        self.last_reported_utc = kwargs.get('last_reported_utc', None)
        self.name = kwargs.get('name', None)
        self.value = kwargs.get('value', None)
        self.current_value = kwargs.get('current_value', None)


class LoadMetricReportInfo(msrest.serialization.Model):
    """Information about load reported by replica.

    :ivar name: The name of the metric.
    :vartype name: str
    :ivar value: The value of the load for the metric. In future releases of Service Fabric this
     parameter will be deprecated in favor of CurrentValue.
    :vartype value: int
    :ivar current_value: The double value of the load for the metric.
    :vartype current_value: str
    :ivar last_reported_utc: The UTC time when the load is reported.
    :vartype last_reported_utc: ~datetime.datetime
    """

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'value': {'key': 'Value', 'type': 'int'},
        'current_value': {'key': 'CurrentValue', 'type': 'str'},
        'last_reported_utc': {'key': 'LastReportedUtc', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: The name of the metric.
        :paramtype name: str
        :keyword value: The value of the load for the metric. In future releases of Service Fabric this
         parameter will be deprecated in favor of CurrentValue.
        :paramtype value: int
        :keyword current_value: The double value of the load for the metric.
        :paramtype current_value: str
        :keyword last_reported_utc: The UTC time when the load is reported.
        :paramtype last_reported_utc: ~datetime.datetime
        """
        super(LoadMetricReportInfo, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.value = kwargs.get('value', None)
        self.current_value = kwargs.get('current_value', None)
        self.last_reported_utc = kwargs.get('last_reported_utc', None)


class NetworkResourcePropertiesBase(msrest.serialization.Model):
    """This type describes the properties of a network resource, including its kind.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: NetworkResourceProperties.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The type of a Service Fabric container network.Constant filled by server.
     Possible values include: "Local".
    :vartype kind: str or ~azure.servicefabric.models.NetworkKind
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'NetworkResourceProperties': 'NetworkResourceProperties'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(NetworkResourcePropertiesBase, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]


class NetworkResourceProperties(NetworkResourcePropertiesBase):
    """Describes properties of a network resource.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: LocalNetworkResourceProperties.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The type of a Service Fabric container network.Constant filled by server.
     Possible values include: "Local".
    :vartype kind: str or ~azure.servicefabric.models.NetworkKind
    :ivar description: User readable description of the network.
    :vartype description: str
    :ivar status: Status of the network. Possible values include: "Unknown", "Ready", "Upgrading",
     "Creating", "Deleting", "Failed".
    :vartype status: str or ~azure.servicefabric.models.ResourceStatus
    :ivar status_details: Gives additional information about the current status of the network.
    :vartype status_details: str
    """

    _validation = {
        'kind': {'required': True},
        'status': {'readonly': True},
        'status_details': {'readonly': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'status_details': {'key': 'statusDetails', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'Local': 'LocalNetworkResourceProperties'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword description: User readable description of the network.
        :paramtype description: str
        """
        super(NetworkResourceProperties, self).__init__(**kwargs)
        self.kind = 'NetworkResourceProperties'  # type: str
        self.description = kwargs.get('description', None)
        self.status = None
        self.status_details = None


class LocalNetworkResourceProperties(NetworkResourceProperties):
    """Information about a Service Fabric container network local to a single Service Fabric cluster.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The type of a Service Fabric container network.Constant filled by server.
     Possible values include: "Local".
    :vartype kind: str or ~azure.servicefabric.models.NetworkKind
    :ivar description: User readable description of the network.
    :vartype description: str
    :ivar status: Status of the network. Possible values include: "Unknown", "Ready", "Upgrading",
     "Creating", "Deleting", "Failed".
    :vartype status: str or ~azure.servicefabric.models.ResourceStatus
    :ivar status_details: Gives additional information about the current status of the network.
    :vartype status_details: str
    :ivar network_address_prefix: Address space for the local container network.
    :vartype network_address_prefix: str
    """

    _validation = {
        'kind': {'required': True},
        'status': {'readonly': True},
        'status_details': {'readonly': True},
    }

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'status_details': {'key': 'statusDetails', 'type': 'str'},
        'network_address_prefix': {'key': 'networkAddressPrefix', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword description: User readable description of the network.
        :paramtype description: str
        :keyword network_address_prefix: Address space for the local container network.
        :paramtype network_address_prefix: str
        """
        super(LocalNetworkResourceProperties, self).__init__(**kwargs)
        self.kind = 'Local'  # type: str
        self.network_address_prefix = kwargs.get('network_address_prefix', None)


class ManagedApplicationIdentity(msrest.serialization.Model):
    """Describes a managed application identity.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name of the identity.
    :vartype name: str
    :ivar principal_id: The identity's PrincipalId.
    :vartype principal_id: str
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'principal_id': {'key': 'PrincipalId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. The name of the identity.
        :paramtype name: str
        :keyword principal_id: The identity's PrincipalId.
        :paramtype principal_id: str
        """
        super(ManagedApplicationIdentity, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.principal_id = kwargs.get('principal_id', None)


class ManagedApplicationIdentityDescription(msrest.serialization.Model):
    """Managed application identity description.

    :ivar token_service_endpoint: Token service endpoint.
    :vartype token_service_endpoint: str
    :ivar managed_identities: A list of managed application identity objects.
    :vartype managed_identities: list[~azure.servicefabric.models.ManagedApplicationIdentity]
    """

    _attribute_map = {
        'token_service_endpoint': {'key': 'TokenServiceEndpoint', 'type': 'str'},
        'managed_identities': {'key': 'ManagedIdentities', 'type': '[ManagedApplicationIdentity]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword token_service_endpoint: Token service endpoint.
        :paramtype token_service_endpoint: str
        :keyword managed_identities: A list of managed application identity objects.
        :paramtype managed_identities: list[~azure.servicefabric.models.ManagedApplicationIdentity]
        """
        super(ManagedApplicationIdentityDescription, self).__init__(**kwargs)
        self.token_service_endpoint = kwargs.get('token_service_endpoint', None)
        self.managed_identities = kwargs.get('managed_identities', None)


class ManagedIdentityAzureBlobBackupStorageDescription(BackupStorageDescription):
    """Describes the parameters for Azure blob store (connected using managed identity) used for storing and enumerating backups.

    All required parameters must be populated in order to send to Azure.

    :ivar storage_kind: Required. The kind of backup storage, where backups are saved.Constant
     filled by server. Possible values include: "Invalid", "FileShare", "AzureBlobStore",
     "DsmsAzureBlobStore", "ManagedIdentityAzureBlobStore".
    :vartype storage_kind: str or ~azure.servicefabric.models.BackupStorageKind
    :ivar friendly_name: Friendly name for this backup storage.
    :vartype friendly_name: str
    :ivar managed_identity_type: Required. The type of managed identity to be used to connect to
     Azure Blob Store via Managed Identity. Possible values include: "Invalid", "VMSS", "Cluster".
    :vartype managed_identity_type: str or ~azure.servicefabric.models.ManagedIdentityType
    :ivar blob_service_uri: Required. The Blob Service Uri to connect to the Azure blob store..
    :vartype blob_service_uri: str
    :ivar container_name: Required. The name of the container in the blob store to store and
     enumerate backups from.
    :vartype container_name: str
    """

    _validation = {
        'storage_kind': {'required': True},
        'managed_identity_type': {'required': True},
        'blob_service_uri': {'required': True},
        'container_name': {'required': True},
    }

    _attribute_map = {
        'storage_kind': {'key': 'StorageKind', 'type': 'str'},
        'friendly_name': {'key': 'FriendlyName', 'type': 'str'},
        'managed_identity_type': {'key': 'ManagedIdentityType', 'type': 'str'},
        'blob_service_uri': {'key': 'BlobServiceUri', 'type': 'str'},
        'container_name': {'key': 'ContainerName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword friendly_name: Friendly name for this backup storage.
        :paramtype friendly_name: str
        :keyword managed_identity_type: Required. The type of managed identity to be used to connect to
         Azure Blob Store via Managed Identity. Possible values include: "Invalid", "VMSS", "Cluster".
        :paramtype managed_identity_type: str or ~azure.servicefabric.models.ManagedIdentityType
        :keyword blob_service_uri: Required. The Blob Service Uri to connect to the Azure blob store..
        :paramtype blob_service_uri: str
        :keyword container_name: Required. The name of the container in the blob store to store and
         enumerate backups from.
        :paramtype container_name: str
        """
        super(ManagedIdentityAzureBlobBackupStorageDescription, self).__init__(**kwargs)
        self.storage_kind = 'ManagedIdentityAzureBlobStore'  # type: str
        self.managed_identity_type = kwargs['managed_identity_type']
        self.blob_service_uri = kwargs['blob_service_uri']
        self.container_name = kwargs['container_name']


class MetricLoadDescription(msrest.serialization.Model):
    """Specifies metric load information.

    :ivar metric_name: The name of the reported metric.
    :vartype metric_name: str
    :ivar current_load: The current value of the metric load.
    :vartype current_load: long
    :ivar predicted_load: The predicted value of the metric load. Predicted metric load values is
     currently a preview feature. It allows predicted load values to be reported and used at the
     Service Fabric side, but that feature is currently not enabled.
    :vartype predicted_load: long
    """

    _attribute_map = {
        'metric_name': {'key': 'MetricName', 'type': 'str'},
        'current_load': {'key': 'CurrentLoad', 'type': 'long'},
        'predicted_load': {'key': 'PredictedLoad', 'type': 'long'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword metric_name: The name of the reported metric.
        :paramtype metric_name: str
        :keyword current_load: The current value of the metric load.
        :paramtype current_load: long
        :keyword predicted_load: The predicted value of the metric load. Predicted metric load values
         is currently a preview feature. It allows predicted load values to be reported and used at the
         Service Fabric side, but that feature is currently not enabled.
        :paramtype predicted_load: long
        """
        super(MetricLoadDescription, self).__init__(**kwargs)
        self.metric_name = kwargs.get('metric_name', None)
        self.current_load = kwargs.get('current_load', None)
        self.predicted_load = kwargs.get('predicted_load', None)


class MonitoringPolicyDescription(msrest.serialization.Model):
    """Describes the parameters for monitoring an upgrade in Monitored mode.

    :ivar failure_action: The compensating action to perform when a Monitored upgrade encounters
     monitoring policy or health policy violations.
     Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will
     start rolling back automatically.
     Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode. Possible
     values include: "Invalid", "Rollback", "Manual".
    :vartype failure_action: str or ~azure.servicefabric.models.FailureAction
    :ivar health_check_wait_duration_in_milliseconds: The amount of time to wait after completing
     an upgrade domain before applying health policies. It is first interpreted as a string
     representing an ISO 8601 duration. If that fails, then it is interpreted as a number
     representing the total number of milliseconds.
    :vartype health_check_wait_duration_in_milliseconds: str
    :ivar health_check_stable_duration_in_milliseconds: The amount of time that the application or
     cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is first
     interpreted as a string representing an ISO 8601 duration. If that fails, then it is
     interpreted as a number representing the total number of milliseconds.
    :vartype health_check_stable_duration_in_milliseconds: str
    :ivar health_check_retry_timeout_in_milliseconds: The amount of time to retry health evaluation
     when the application or cluster is unhealthy before FailureAction is executed. It is first
     interpreted as a string representing an ISO 8601 duration. If that fails, then it is
     interpreted as a number representing the total number of milliseconds.
    :vartype health_check_retry_timeout_in_milliseconds: str
    :ivar upgrade_timeout_in_milliseconds: The amount of time the overall upgrade has to complete
     before FailureAction is executed. It is first interpreted as a string representing an ISO 8601
     duration. If that fails, then it is interpreted as a number representing the total number of
     milliseconds.
    :vartype upgrade_timeout_in_milliseconds: str
    :ivar upgrade_domain_timeout_in_milliseconds: The amount of time each upgrade domain has to
     complete before FailureAction is executed. It is first interpreted as a string representing an
     ISO 8601 duration. If that fails, then it is interpreted as a number representing the total
     number of milliseconds.
    :vartype upgrade_domain_timeout_in_milliseconds: str
    """

    _attribute_map = {
        'failure_action': {'key': 'FailureAction', 'type': 'str'},
        'health_check_wait_duration_in_milliseconds': {'key': 'HealthCheckWaitDurationInMilliseconds', 'type': 'str'},
        'health_check_stable_duration_in_milliseconds': {'key': 'HealthCheckStableDurationInMilliseconds', 'type': 'str'},
        'health_check_retry_timeout_in_milliseconds': {'key': 'HealthCheckRetryTimeoutInMilliseconds', 'type': 'str'},
        'upgrade_timeout_in_milliseconds': {'key': 'UpgradeTimeoutInMilliseconds', 'type': 'str'},
        'upgrade_domain_timeout_in_milliseconds': {'key': 'UpgradeDomainTimeoutInMilliseconds', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword failure_action: The compensating action to perform when a Monitored upgrade encounters
         monitoring policy or health policy violations.
         Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will
         start rolling back automatically.
         Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode. Possible
         values include: "Invalid", "Rollback", "Manual".
        :paramtype failure_action: str or ~azure.servicefabric.models.FailureAction
        :keyword health_check_wait_duration_in_milliseconds: The amount of time to wait after
         completing an upgrade domain before applying health policies. It is first interpreted as a
         string representing an ISO 8601 duration. If that fails, then it is interpreted as a number
         representing the total number of milliseconds.
        :paramtype health_check_wait_duration_in_milliseconds: str
        :keyword health_check_stable_duration_in_milliseconds: The amount of time that the application
         or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is
         first interpreted as a string representing an ISO 8601 duration. If that fails, then it is
         interpreted as a number representing the total number of milliseconds.
        :paramtype health_check_stable_duration_in_milliseconds: str
        :keyword health_check_retry_timeout_in_milliseconds: The amount of time to retry health
         evaluation when the application or cluster is unhealthy before FailureAction is executed. It is
         first interpreted as a string representing an ISO 8601 duration. If that fails, then it is
         interpreted as a number representing the total number of milliseconds.
        :paramtype health_check_retry_timeout_in_milliseconds: str
        :keyword upgrade_timeout_in_milliseconds: The amount of time the overall upgrade has to
         complete before FailureAction is executed. It is first interpreted as a string representing an
         ISO 8601 duration. If that fails, then it is interpreted as a number representing the total
         number of milliseconds.
        :paramtype upgrade_timeout_in_milliseconds: str
        :keyword upgrade_domain_timeout_in_milliseconds: The amount of time each upgrade domain has to
         complete before FailureAction is executed. It is first interpreted as a string representing an
         ISO 8601 duration. If that fails, then it is interpreted as a number representing the total
         number of milliseconds.
        :paramtype upgrade_domain_timeout_in_milliseconds: str
        """
        super(MonitoringPolicyDescription, self).__init__(**kwargs)
        self.failure_action = kwargs.get('failure_action', None)
        self.health_check_wait_duration_in_milliseconds = kwargs.get('health_check_wait_duration_in_milliseconds', "0")
        self.health_check_stable_duration_in_milliseconds = kwargs.get('health_check_stable_duration_in_milliseconds', "PT0H2M0S")
        self.health_check_retry_timeout_in_milliseconds = kwargs.get('health_check_retry_timeout_in_milliseconds', "PT0H10M0S")
        self.upgrade_timeout_in_milliseconds = kwargs.get('upgrade_timeout_in_milliseconds', "P10675199DT02H48M05.4775807S")
        self.upgrade_domain_timeout_in_milliseconds = kwargs.get('upgrade_domain_timeout_in_milliseconds', "P10675199DT02H48M05.4775807S")


class NameDescription(msrest.serialization.Model):
    """Describes a Service Fabric name.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The Service Fabric name, including the 'fabric:' URI scheme.
    :vartype name: str
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. The Service Fabric name, including the 'fabric:' URI scheme.
        :paramtype name: str
        """
        super(NameDescription, self).__init__(**kwargs)
        self.name = kwargs['name']


class NamedPartitionInformation(PartitionInformation):
    """Describes the partition information for the name as a string that is based on partition schemes.

    All required parameters must be populated in order to send to Azure.

    :ivar service_partition_kind: Required. The kind of partitioning scheme used to partition the
     service.Constant filled by server. Possible values include: "Invalid", "Singleton",
     "Int64Range", "Named".
    :vartype service_partition_kind: str or ~azure.servicefabric.models.ServicePartitionKind
    :ivar id: An internal ID used by Service Fabric to uniquely identify a partition. This is a
     randomly generated GUID when the service was created. The partition ID is unique and does not
     change for the lifetime of the service. If the same service was deleted and recreated the IDs
     of its partitions would be different.
    :vartype id: str
    :ivar name: Name of the partition.
    :vartype name: str
    """

    _validation = {
        'service_partition_kind': {'required': True},
    }

    _attribute_map = {
        'service_partition_kind': {'key': 'ServicePartitionKind', 'type': 'str'},
        'id': {'key': 'Id', 'type': 'str'},
        'name': {'key': 'Name', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword id: An internal ID used by Service Fabric to uniquely identify a partition. This is a
         randomly generated GUID when the service was created. The partition ID is unique and does not
         change for the lifetime of the service. If the same service was deleted and recreated the IDs
         of its partitions would be different.
        :paramtype id: str
        :keyword name: Name of the partition.
        :paramtype name: str
        """
        super(NamedPartitionInformation, self).__init__(**kwargs)
        self.service_partition_kind = 'Named'  # type: str
        self.name = kwargs.get('name', None)


class PartitionSchemeDescription(msrest.serialization.Model):
    """Describes how the service is partitioned.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: NamedPartitionSchemeDescription, SingletonPartitionSchemeDescription, UniformInt64RangePartitionSchemeDescription.

    All required parameters must be populated in order to send to Azure.

    :ivar partition_scheme: Required. Specifies how the service is partitioned.Constant filled by
     server. Possible values include: "Invalid", "Singleton", "UniformInt64Range", "Named".
    :vartype partition_scheme: str or ~azure.servicefabric.models.PartitionScheme
    """

    _validation = {
        'partition_scheme': {'required': True},
    }

    _attribute_map = {
        'partition_scheme': {'key': 'PartitionScheme', 'type': 'str'},
    }

    _subtype_map = {
        'partition_scheme': {'Named': 'NamedPartitionSchemeDescription', 'Singleton': 'SingletonPartitionSchemeDescription', 'UniformInt64Range': 'UniformInt64RangePartitionSchemeDescription'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(PartitionSchemeDescription, self).__init__(**kwargs)
        self.partition_scheme = None  # type: Optional[str]


class NamedPartitionSchemeDescription(PartitionSchemeDescription):
    """Describes the named partition scheme of the service.

    All required parameters must be populated in order to send to Azure.

    :ivar partition_scheme: Required. Specifies how the service is partitioned.Constant filled by
     server. Possible values include: "Invalid", "Singleton", "UniformInt64Range", "Named".
    :vartype partition_scheme: str or ~azure.servicefabric.models.PartitionScheme
    :ivar count: Required. The number of partitions.
    :vartype count: int
    :ivar names: Required. Array of size specified by the ‘Count’ parameter, for the names of the
     partitions.
    :vartype names: list[str]
    """

    _validation = {
        'partition_scheme': {'required': True},
        'count': {'required': True},
        'names': {'required': True},
    }

    _attribute_map = {
        'partition_scheme': {'key': 'PartitionScheme', 'type': 'str'},
        'count': {'key': 'Count', 'type': 'int'},
        'names': {'key': 'Names', 'type': '[str]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword count: Required. The number of partitions.
        :paramtype count: int
        :keyword names: Required. Array of size specified by the ‘Count’ parameter, for the names of
         the partitions.
        :paramtype names: list[str]
        """
        super(NamedPartitionSchemeDescription, self).__init__(**kwargs)
        self.partition_scheme = 'Named'  # type: str
        self.count = kwargs['count']
        self.names = kwargs['names']


class NetworkRef(msrest.serialization.Model):
    """Describes a network reference in a service.

    :ivar name: Name of the network.
    :vartype name: str
    :ivar endpoint_refs: A list of endpoints that are exposed on this network.
    :vartype endpoint_refs: list[~azure.servicefabric.models.EndpointRef]
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'endpoint_refs': {'key': 'endpointRefs', 'type': '[EndpointRef]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Name of the network.
        :paramtype name: str
        :keyword endpoint_refs: A list of endpoints that are exposed on this network.
        :paramtype endpoint_refs: list[~azure.servicefabric.models.EndpointRef]
        """
        super(NetworkRef, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.endpoint_refs = kwargs.get('endpoint_refs', None)


class NetworkResourceDescription(msrest.serialization.Model):
    """This type describes a network resource.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. Name of the Network resource.
    :vartype name: str
    :ivar properties: Required. Describes properties of a network resource.
    :vartype properties: ~azure.servicefabric.models.NetworkResourceProperties
    """

    _validation = {
        'name': {'required': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'properties': {'key': 'properties', 'type': 'NetworkResourceProperties'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. Name of the Network resource.
        :paramtype name: str
        :keyword properties: Required. Describes properties of a network resource.
        :paramtype properties: ~azure.servicefabric.models.NetworkResourceProperties
        """
        super(NetworkResourceDescription, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.properties = kwargs['properties']


class NodeAbortedEvent(NodeEvent):
    """Node Aborted event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar node_instance: Required. Id of Node instance.
    :vartype node_instance: long
    :ivar node_id: Required. Id of Node.
    :vartype node_id: str
    :ivar upgrade_domain: Required. Upgrade domain of Node.
    :vartype upgrade_domain: str
    :ivar fault_domain: Required. Fault domain of Node.
    :vartype fault_domain: str
    :ivar ip_address_or_fqdn: Required. IP address or FQDN.
    :vartype ip_address_or_fqdn: str
    :ivar hostname: Required. Name of Host.
    :vartype hostname: str
    :ivar is_seed_node: Required. Indicates if it is seed node.
    :vartype is_seed_node: bool
    :ivar node_version: Required. Version of Node.
    :vartype node_version: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'node_name': {'required': True},
        'node_instance': {'required': True},
        'node_id': {'required': True},
        'upgrade_domain': {'required': True},
        'fault_domain': {'required': True},
        'ip_address_or_fqdn': {'required': True},
        'hostname': {'required': True},
        'is_seed_node': {'required': True},
        'node_version': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_instance': {'key': 'NodeInstance', 'type': 'long'},
        'node_id': {'key': 'NodeId', 'type': 'str'},
        'upgrade_domain': {'key': 'UpgradeDomain', 'type': 'str'},
        'fault_domain': {'key': 'FaultDomain', 'type': 'str'},
        'ip_address_or_fqdn': {'key': 'IpAddressOrFQDN', 'type': 'str'},
        'hostname': {'key': 'Hostname', 'type': 'str'},
        'is_seed_node': {'key': 'IsSeedNode', 'type': 'bool'},
        'node_version': {'key': 'NodeVersion', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword node_instance: Required. Id of Node instance.
        :paramtype node_instance: long
        :keyword node_id: Required. Id of Node.
        :paramtype node_id: str
        :keyword upgrade_domain: Required. Upgrade domain of Node.
        :paramtype upgrade_domain: str
        :keyword fault_domain: Required. Fault domain of Node.
        :paramtype fault_domain: str
        :keyword ip_address_or_fqdn: Required. IP address or FQDN.
        :paramtype ip_address_or_fqdn: str
        :keyword hostname: Required. Name of Host.
        :paramtype hostname: str
        :keyword is_seed_node: Required. Indicates if it is seed node.
        :paramtype is_seed_node: bool
        :keyword node_version: Required. Version of Node.
        :paramtype node_version: str
        """
        super(NodeAbortedEvent, self).__init__(**kwargs)
        self.kind = 'NodeAborted'  # type: str
        self.node_instance = kwargs['node_instance']
        self.node_id = kwargs['node_id']
        self.upgrade_domain = kwargs['upgrade_domain']
        self.fault_domain = kwargs['fault_domain']
        self.ip_address_or_fqdn = kwargs['ip_address_or_fqdn']
        self.hostname = kwargs['hostname']
        self.is_seed_node = kwargs['is_seed_node']
        self.node_version = kwargs['node_version']


class NodeAddedToClusterEvent(NodeEvent):
    """Node Added event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar node_id: Required. Id of Node.
    :vartype node_id: str
    :ivar node_instance: Required. Id of Node instance.
    :vartype node_instance: long
    :ivar node_type: Required. Type of Node.
    :vartype node_type: str
    :ivar fabric_version: Required. Fabric version.
    :vartype fabric_version: str
    :ivar ip_address_or_fqdn: Required. IP address or FQDN.
    :vartype ip_address_or_fqdn: str
    :ivar node_capacities: Required. Capacities.
    :vartype node_capacities: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'node_name': {'required': True},
        'node_id': {'required': True},
        'node_instance': {'required': True},
        'node_type': {'required': True},
        'fabric_version': {'required': True},
        'ip_address_or_fqdn': {'required': True},
        'node_capacities': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_id': {'key': 'NodeId', 'type': 'str'},
        'node_instance': {'key': 'NodeInstance', 'type': 'long'},
        'node_type': {'key': 'NodeType', 'type': 'str'},
        'fabric_version': {'key': 'FabricVersion', 'type': 'str'},
        'ip_address_or_fqdn': {'key': 'IpAddressOrFQDN', 'type': 'str'},
        'node_capacities': {'key': 'NodeCapacities', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword node_id: Required. Id of Node.
        :paramtype node_id: str
        :keyword node_instance: Required. Id of Node instance.
        :paramtype node_instance: long
        :keyword node_type: Required. Type of Node.
        :paramtype node_type: str
        :keyword fabric_version: Required. Fabric version.
        :paramtype fabric_version: str
        :keyword ip_address_or_fqdn: Required. IP address or FQDN.
        :paramtype ip_address_or_fqdn: str
        :keyword node_capacities: Required. Capacities.
        :paramtype node_capacities: str
        """
        super(NodeAddedToClusterEvent, self).__init__(**kwargs)
        self.kind = 'NodeAddedToCluster'  # type: str
        self.node_id = kwargs['node_id']
        self.node_instance = kwargs['node_instance']
        self.node_type = kwargs['node_type']
        self.fabric_version = kwargs['fabric_version']
        self.ip_address_or_fqdn = kwargs['ip_address_or_fqdn']
        self.node_capacities = kwargs['node_capacities']


class NodeClosedEvent(NodeEvent):
    """Node Closed event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar node_id: Required. Id of Node.
    :vartype node_id: str
    :ivar node_instance: Required. Id of Node instance.
    :vartype node_instance: long
    :ivar error: Required. Describes error.
    :vartype error: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'node_name': {'required': True},
        'node_id': {'required': True},
        'node_instance': {'required': True},
        'error': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_id': {'key': 'NodeId', 'type': 'str'},
        'node_instance': {'key': 'NodeInstance', 'type': 'long'},
        'error': {'key': 'Error', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword node_id: Required. Id of Node.
        :paramtype node_id: str
        :keyword node_instance: Required. Id of Node instance.
        :paramtype node_instance: long
        :keyword error: Required. Describes error.
        :paramtype error: str
        """
        super(NodeClosedEvent, self).__init__(**kwargs)
        self.kind = 'NodeClosed'  # type: str
        self.node_id = kwargs['node_id']
        self.node_instance = kwargs['node_instance']
        self.error = kwargs['error']


class NodeDeactivateCompletedEvent(NodeEvent):
    """Node Deactivate Completed event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar node_instance: Required. Id of Node instance.
    :vartype node_instance: long
    :ivar effective_deactivate_intent: Required. Describes deactivate intent.
    :vartype effective_deactivate_intent: str
    :ivar batch_ids_with_deactivate_intent: Required. Batch Ids.
    :vartype batch_ids_with_deactivate_intent: str
    :ivar start_time: Required. Start time.
    :vartype start_time: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'node_name': {'required': True},
        'node_instance': {'required': True},
        'effective_deactivate_intent': {'required': True},
        'batch_ids_with_deactivate_intent': {'required': True},
        'start_time': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_instance': {'key': 'NodeInstance', 'type': 'long'},
        'effective_deactivate_intent': {'key': 'EffectiveDeactivateIntent', 'type': 'str'},
        'batch_ids_with_deactivate_intent': {'key': 'BatchIdsWithDeactivateIntent', 'type': 'str'},
        'start_time': {'key': 'StartTime', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword node_instance: Required. Id of Node instance.
        :paramtype node_instance: long
        :keyword effective_deactivate_intent: Required. Describes deactivate intent.
        :paramtype effective_deactivate_intent: str
        :keyword batch_ids_with_deactivate_intent: Required. Batch Ids.
        :paramtype batch_ids_with_deactivate_intent: str
        :keyword start_time: Required. Start time.
        :paramtype start_time: ~datetime.datetime
        """
        super(NodeDeactivateCompletedEvent, self).__init__(**kwargs)
        self.kind = 'NodeDeactivateCompleted'  # type: str
        self.node_instance = kwargs['node_instance']
        self.effective_deactivate_intent = kwargs['effective_deactivate_intent']
        self.batch_ids_with_deactivate_intent = kwargs['batch_ids_with_deactivate_intent']
        self.start_time = kwargs['start_time']


class NodeDeactivateStartedEvent(NodeEvent):
    """Node Deactivate Started event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar node_instance: Required. Id of Node instance.
    :vartype node_instance: long
    :ivar batch_id: Required. Batch Id.
    :vartype batch_id: str
    :ivar deactivate_intent: Required. Describes deactivate intent.
    :vartype deactivate_intent: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'node_name': {'required': True},
        'node_instance': {'required': True},
        'batch_id': {'required': True},
        'deactivate_intent': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_instance': {'key': 'NodeInstance', 'type': 'long'},
        'batch_id': {'key': 'BatchId', 'type': 'str'},
        'deactivate_intent': {'key': 'DeactivateIntent', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword node_instance: Required. Id of Node instance.
        :paramtype node_instance: long
        :keyword batch_id: Required. Batch Id.
        :paramtype batch_id: str
        :keyword deactivate_intent: Required. Describes deactivate intent.
        :paramtype deactivate_intent: str
        """
        super(NodeDeactivateStartedEvent, self).__init__(**kwargs)
        self.kind = 'NodeDeactivateStarted'  # type: str
        self.node_instance = kwargs['node_instance']
        self.batch_id = kwargs['batch_id']
        self.deactivate_intent = kwargs['deactivate_intent']


class NodeDeactivationInfo(msrest.serialization.Model):
    """Information about the node deactivation. This information is valid for a node that is undergoing deactivation or has already been deactivated.

    :ivar node_deactivation_intent: The intent or the reason for deactivating the node. Following
     are the possible values for it. Possible values include: "Invalid", "Pause", "Restart",
     "RemoveData", "RemoveNode".
    :vartype node_deactivation_intent: str or ~azure.servicefabric.models.NodeDeactivationIntent
    :ivar node_deactivation_status: The status of node deactivation operation. Following are the
     possible values. Possible values include: "None", "SafetyCheckInProgress",
     "SafetyCheckComplete", "Completed".
    :vartype node_deactivation_status: str or ~azure.servicefabric.models.NodeDeactivationStatus
    :ivar node_deactivation_task: List of tasks representing the deactivation operation on the
     node.
    :vartype node_deactivation_task: list[~azure.servicefabric.models.NodeDeactivationTask]
    :ivar pending_safety_checks: List of pending safety checks.
    :vartype pending_safety_checks: list[~azure.servicefabric.models.SafetyCheckWrapper]
    """

    _attribute_map = {
        'node_deactivation_intent': {'key': 'NodeDeactivationIntent', 'type': 'str'},
        'node_deactivation_status': {'key': 'NodeDeactivationStatus', 'type': 'str'},
        'node_deactivation_task': {'key': 'NodeDeactivationTask', 'type': '[NodeDeactivationTask]'},
        'pending_safety_checks': {'key': 'PendingSafetyChecks', 'type': '[SafetyCheckWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword node_deactivation_intent: The intent or the reason for deactivating the node.
         Following are the possible values for it. Possible values include: "Invalid", "Pause",
         "Restart", "RemoveData", "RemoveNode".
        :paramtype node_deactivation_intent: str or ~azure.servicefabric.models.NodeDeactivationIntent
        :keyword node_deactivation_status: The status of node deactivation operation. Following are the
         possible values. Possible values include: "None", "SafetyCheckInProgress",
         "SafetyCheckComplete", "Completed".
        :paramtype node_deactivation_status: str or ~azure.servicefabric.models.NodeDeactivationStatus
        :keyword node_deactivation_task: List of tasks representing the deactivation operation on the
         node.
        :paramtype node_deactivation_task: list[~azure.servicefabric.models.NodeDeactivationTask]
        :keyword pending_safety_checks: List of pending safety checks.
        :paramtype pending_safety_checks: list[~azure.servicefabric.models.SafetyCheckWrapper]
        """
        super(NodeDeactivationInfo, self).__init__(**kwargs)
        self.node_deactivation_intent = kwargs.get('node_deactivation_intent', None)
        self.node_deactivation_status = kwargs.get('node_deactivation_status', None)
        self.node_deactivation_task = kwargs.get('node_deactivation_task', None)
        self.pending_safety_checks = kwargs.get('pending_safety_checks', None)


class NodeDeactivationTask(msrest.serialization.Model):
    """The task representing the deactivation operation on the node.

    :ivar node_deactivation_task_id: Identity of the task related to deactivation operation on the
     node.
    :vartype node_deactivation_task_id: ~azure.servicefabric.models.NodeDeactivationTaskId
    :ivar node_deactivation_intent: The intent or the reason for deactivating the node. Following
     are the possible values for it. Possible values include: "Invalid", "Pause", "Restart",
     "RemoveData", "RemoveNode".
    :vartype node_deactivation_intent: str or ~azure.servicefabric.models.NodeDeactivationIntent
    """

    _attribute_map = {
        'node_deactivation_task_id': {'key': 'NodeDeactivationTaskId', 'type': 'NodeDeactivationTaskId'},
        'node_deactivation_intent': {'key': 'NodeDeactivationIntent', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword node_deactivation_task_id: Identity of the task related to deactivation operation on
         the node.
        :paramtype node_deactivation_task_id: ~azure.servicefabric.models.NodeDeactivationTaskId
        :keyword node_deactivation_intent: The intent or the reason for deactivating the node.
         Following are the possible values for it. Possible values include: "Invalid", "Pause",
         "Restart", "RemoveData", "RemoveNode".
        :paramtype node_deactivation_intent: str or ~azure.servicefabric.models.NodeDeactivationIntent
        """
        super(NodeDeactivationTask, self).__init__(**kwargs)
        self.node_deactivation_task_id = kwargs.get('node_deactivation_task_id', None)
        self.node_deactivation_intent = kwargs.get('node_deactivation_intent', None)


class NodeDeactivationTaskId(msrest.serialization.Model):
    """Identity of the task related to deactivation operation on the node.

    :ivar id: Value of the task id.
    :vartype id: str
    :ivar node_deactivation_task_type: The type of the task that performed the node deactivation.
     Following are the possible values. Possible values include: "Invalid", "Infrastructure",
     "Repair", "Client".
    :vartype node_deactivation_task_type: str or
     ~azure.servicefabric.models.NodeDeactivationTaskType
    """

    _attribute_map = {
        'id': {'key': 'Id', 'type': 'str'},
        'node_deactivation_task_type': {'key': 'NodeDeactivationTaskType', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword id: Value of the task id.
        :paramtype id: str
        :keyword node_deactivation_task_type: The type of the task that performed the node
         deactivation. Following are the possible values. Possible values include: "Invalid",
         "Infrastructure", "Repair", "Client".
        :paramtype node_deactivation_task_type: str or
         ~azure.servicefabric.models.NodeDeactivationTaskType
        """
        super(NodeDeactivationTaskId, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.node_deactivation_task_type = kwargs.get('node_deactivation_task_type', None)


class NodeDownEvent(NodeEvent):
    """Node Down event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar node_instance: Required. Id of Node instance.
    :vartype node_instance: long
    :ivar last_node_up_at: Required. Time when Node was last up.
    :vartype last_node_up_at: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'node_name': {'required': True},
        'node_instance': {'required': True},
        'last_node_up_at': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_instance': {'key': 'NodeInstance', 'type': 'long'},
        'last_node_up_at': {'key': 'LastNodeUpAt', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword node_instance: Required. Id of Node instance.
        :paramtype node_instance: long
        :keyword last_node_up_at: Required. Time when Node was last up.
        :paramtype last_node_up_at: ~datetime.datetime
        """
        super(NodeDownEvent, self).__init__(**kwargs)
        self.kind = 'NodeDown'  # type: str
        self.node_instance = kwargs['node_instance']
        self.last_node_up_at = kwargs['last_node_up_at']


class NodeHealth(EntityHealth):
    """Information about the health of a Service Fabric node.

    :ivar aggregated_health_state: The HealthState representing the aggregated health state of the
     entity computed by Health Manager.
     The health evaluation of the entity reflects all events reported on the entity and its
     children (if any).
     The aggregation is done by applying the desired health policy. Possible values include:
     "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar health_events: The list of health events reported on the entity.
    :vartype health_events: list[~azure.servicefabric.models.HealthEvent]
    :ivar unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
     health state was returned by Health Manager.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    :ivar health_statistics: Shows the health statistics for all children types of the queried
     entity.
    :vartype health_statistics: ~azure.servicefabric.models.HealthStatistics
    :ivar name: Name of the node whose health information is described by this object.
    :vartype name: str
    """

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'health_events': {'key': 'HealthEvents', 'type': '[HealthEvent]'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
        'health_statistics': {'key': 'HealthStatistics', 'type': 'HealthStatistics'},
        'name': {'key': 'Name', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The HealthState representing the aggregated health state of
         the entity computed by Health Manager.
         The health evaluation of the entity reflects all events reported on the entity and its
         children (if any).
         The aggregation is done by applying the desired health policy. Possible values include:
         "Invalid", "Ok", "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword health_events: The list of health events reported on the entity.
        :paramtype health_events: list[~azure.servicefabric.models.HealthEvent]
        :keyword unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
         health state was returned by Health Manager.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        :keyword health_statistics: Shows the health statistics for all children types of the queried
         entity.
        :paramtype health_statistics: ~azure.servicefabric.models.HealthStatistics
        :keyword name: Name of the node whose health information is described by this object.
        :paramtype name: str
        """
        super(NodeHealth, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)


class NodeHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for a node, containing information about the data and the algorithm used by health store to evaluate health. The evaluation is returned only when the aggregated health state is either Error or Warning.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar node_name: The name of a Service Fabric node.
    :vartype node_name: str
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the current aggregated
     health state of the node. The types of the unhealthy evaluations can be EventHealthEvaluation.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword node_name: The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the current
         aggregated health state of the node. The types of the unhealthy evaluations can be
         EventHealthEvaluation.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(NodeHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'Node'  # type: str
        self.node_name = kwargs.get('node_name', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class NodeHealthReportExpiredEvent(NodeEvent):
    """Node Health Report Expired event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar node_instance_id: Required. Id of Node instance.
    :vartype node_instance_id: long
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'node_name': {'required': True},
        'node_instance_id': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_instance_id': {'key': 'NodeInstanceId', 'type': 'long'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword node_instance_id: Required. Id of Node instance.
        :paramtype node_instance_id: long
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(NodeHealthReportExpiredEvent, self).__init__(**kwargs)
        self.kind = 'NodeHealthReportExpired'  # type: str
        self.node_instance_id = kwargs['node_instance_id']
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class NodeHealthState(EntityHealthState):
    """Represents the health state of a node, which contains the node identifier and its aggregated health state.

    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar name: The name of a Service Fabric node.
    :vartype name: str
    :ivar id: An internal ID used by Service Fabric to uniquely identify a node. Node Id is
     deterministically generated from node name.
    :vartype id: ~azure.servicefabric.models.NodeId
    """

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'name': {'key': 'Name', 'type': 'str'},
        'id': {'key': 'Id', 'type': 'NodeId'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword name: The name of a Service Fabric node.
        :paramtype name: str
        :keyword id: An internal ID used by Service Fabric to uniquely identify a node. Node Id is
         deterministically generated from node name.
        :paramtype id: ~azure.servicefabric.models.NodeId
        """
        super(NodeHealthState, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.id = kwargs.get('id', None)


class NodeHealthStateChunk(EntityHealthStateChunk):
    """Represents the health state chunk of a node, which contains the node name and its aggregated health state.

    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar node_name: The name of a Service Fabric node.
    :vartype node_name: str
    """

    _attribute_map = {
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword node_name: The name of a Service Fabric node.
        :paramtype node_name: str
        """
        super(NodeHealthStateChunk, self).__init__(**kwargs)
        self.node_name = kwargs.get('node_name', None)


class NodeHealthStateChunkList(EntityHealthStateChunkList):
    """The list of node health state chunks in the cluster that respect the input filters in the chunk query. Returned by get cluster health state chunks query.

    :ivar total_count: Total number of entity health state objects that match the specified filters
     from the cluster health chunk query description.
    :vartype total_count: long
    :ivar items: The list of node health state chunks that respect the input filters in the chunk
     query.
    :vartype items: list[~azure.servicefabric.models.NodeHealthStateChunk]
    """

    _attribute_map = {
        'total_count': {'key': 'TotalCount', 'type': 'long'},
        'items': {'key': 'Items', 'type': '[NodeHealthStateChunk]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword total_count: Total number of entity health state objects that match the specified
         filters from the cluster health chunk query description.
        :paramtype total_count: long
        :keyword items: The list of node health state chunks that respect the input filters in the
         chunk query.
        :paramtype items: list[~azure.servicefabric.models.NodeHealthStateChunk]
        """
        super(NodeHealthStateChunkList, self).__init__(**kwargs)
        self.items = kwargs.get('items', None)


class NodeHealthStateFilter(msrest.serialization.Model):
    """Defines matching criteria to determine whether a node should be included in the returned cluster health chunk.
One filter can match zero, one or multiple nodes, depending on its properties.
Can be specified in the cluster health chunk query description.

    :ivar node_name_filter: Name of the node that matches the filter. The filter is applied only to
     the specified node, if it exists.
     If the node doesn't exist, no node is returned in the cluster health chunk based on this
     filter.
     If the node exists, it is included in the cluster health chunk if the health state matches the
     other filter properties.
     If not specified, all nodes that match the parent filters (if any) are taken into
     consideration and matched against the other filter members, like health state filter.
    :vartype node_name_filter: str
    :ivar health_state_filter: The filter for the health state of the nodes. It allows selecting
     nodes if they match the desired health states.
     The possible values are integer value of one of the following health states. Only nodes that
     match the filter are returned. All nodes are used to evaluate the cluster aggregated health
     state.
     If not specified, default value is None, unless the node name is specified. If the filter has
     default value and node name is specified, the matching node is returned.
     The state values are flag-based enumeration, so the value could be a combination of these
     values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6, it matches nodes with HealthState value of OK (2) and
     Warning (4).
    
    
     * Default - Default value. Matches any HealthState. The value is zero.
     * None - Filter that doesn't match any HealthState value. Used in order to return no results
     on a given collection of states. The value is 1.
     * Ok - Filter that matches input with HealthState value Ok. The value is 2.
     * Warning - Filter that matches input with HealthState value Warning. The value is 4.
     * Error - Filter that matches input with HealthState value Error. The value is 8.
     * All - Filter that matches input with any HealthState value. The value is 65535.
    :vartype health_state_filter: int
    """

    _attribute_map = {
        'node_name_filter': {'key': 'NodeNameFilter', 'type': 'str'},
        'health_state_filter': {'key': 'HealthStateFilter', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword node_name_filter: Name of the node that matches the filter. The filter is applied only
         to the specified node, if it exists.
         If the node doesn't exist, no node is returned in the cluster health chunk based on this
         filter.
         If the node exists, it is included in the cluster health chunk if the health state matches the
         other filter properties.
         If not specified, all nodes that match the parent filters (if any) are taken into
         consideration and matched against the other filter members, like health state filter.
        :paramtype node_name_filter: str
        :keyword health_state_filter: The filter for the health state of the nodes. It allows selecting
         nodes if they match the desired health states.
         The possible values are integer value of one of the following health states. Only nodes that
         match the filter are returned. All nodes are used to evaluate the cluster aggregated health
         state.
         If not specified, default value is None, unless the node name is specified. If the filter has
         default value and node name is specified, the matching node is returned.
         The state values are flag-based enumeration, so the value could be a combination of these
         values obtained using bitwise 'OR' operator.
         For example, if the provided value is 6, it matches nodes with HealthState value of OK (2) and
         Warning (4).
        
        
         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535.
        :paramtype health_state_filter: int
        """
        super(NodeHealthStateFilter, self).__init__(**kwargs)
        self.node_name_filter = kwargs.get('node_name_filter', None)
        self.health_state_filter = kwargs.get('health_state_filter', 0)


class NodeId(msrest.serialization.Model):
    """An internal ID used by Service Fabric to uniquely identify a node. Node Id is deterministically generated from node name.

    :ivar id: Value of the node Id. This is a 128 bit integer.
    :vartype id: str
    """

    _attribute_map = {
        'id': {'key': 'Id', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword id: Value of the node Id. This is a 128 bit integer.
        :paramtype id: str
        """
        super(NodeId, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)


class NodeImpact(msrest.serialization.Model):
    """Describes the expected impact of a repair to a particular node.

This type supports the Service Fabric platform; it is not meant to be used directly from your code.

    All required parameters must be populated in order to send to Azure.

    :ivar node_name: Required. The name of the impacted node.
    :vartype node_name: str
    :ivar impact_level: The level of impact expected. Possible values include: "Invalid", "None",
     "Restart", "RemoveData", "RemoveNode".
    :vartype impact_level: str or ~azure.servicefabric.models.ImpactLevel
    """

    _validation = {
        'node_name': {'required': True},
    }

    _attribute_map = {
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'impact_level': {'key': 'ImpactLevel', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword node_name: Required. The name of the impacted node.
        :paramtype node_name: str
        :keyword impact_level: The level of impact expected. Possible values include: "Invalid",
         "None", "Restart", "RemoveData", "RemoveNode".
        :paramtype impact_level: str or ~azure.servicefabric.models.ImpactLevel
        """
        super(NodeImpact, self).__init__(**kwargs)
        self.node_name = kwargs['node_name']
        self.impact_level = kwargs.get('impact_level', None)


class NodeInfo(msrest.serialization.Model):
    """Information about a node in Service Fabric cluster.

    :ivar name: The name of a Service Fabric node.
    :vartype name: str
    :ivar ip_address_or_fqdn: The IP address or fully qualified domain name of the node.
    :vartype ip_address_or_fqdn: str
    :ivar type: The type of the node.
    :vartype type: str
    :ivar code_version: The version of Service Fabric binaries that the node is running.
    :vartype code_version: str
    :ivar config_version: The version of Service Fabric cluster manifest that the node is using.
    :vartype config_version: str
    :ivar node_status: The status of the node. Possible values include: "Invalid", "Up", "Down",
     "Enabling", "Disabling", "Disabled", "Unknown", "Removed".
    :vartype node_status: str or ~azure.servicefabric.models.NodeStatus
    :ivar node_up_time_in_seconds: Time in seconds since the node has been in NodeStatus Up. Value
     zero indicates that the node is not Up.
    :vartype node_up_time_in_seconds: str
    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar is_seed_node: Indicates if the node is a seed node or not. Returns true if the node is a
     seed node, otherwise false. A quorum of seed nodes are required for proper operation of Service
     Fabric cluster.
    :vartype is_seed_node: bool
    :ivar upgrade_domain: The upgrade domain of the node.
    :vartype upgrade_domain: str
    :ivar fault_domain: The fault domain of the node.
    :vartype fault_domain: str
    :ivar id: An internal ID used by Service Fabric to uniquely identify a node. Node Id is
     deterministically generated from node name.
    :vartype id: ~azure.servicefabric.models.NodeId
    :ivar instance_id: The ID representing the node instance. While the ID of the node is
     deterministically generated from the node name and remains same across restarts, the InstanceId
     changes every time node restarts.
    :vartype instance_id: str
    :ivar node_deactivation_info: Information about the node deactivation. This information is
     valid for a node that is undergoing deactivation or has already been deactivated.
    :vartype node_deactivation_info: ~azure.servicefabric.models.NodeDeactivationInfo
    :ivar is_stopped: Indicates if the node is stopped by calling stop node API or not. Returns
     true if the node is stopped, otherwise false.
    :vartype is_stopped: bool
    :ivar node_down_time_in_seconds: Time in seconds since the node has been in NodeStatus Down.
     Value zero indicates node is not NodeStatus Down.
    :vartype node_down_time_in_seconds: str
    :ivar node_up_at: Date time in UTC when the node came up. If the node has never been up then
     this value will be zero date time.
    :vartype node_up_at: ~datetime.datetime
    :ivar node_down_at: Date time in UTC when the node went down. If node has never been down then
     this value will be zero date time.
    :vartype node_down_at: ~datetime.datetime
    :ivar node_tags: List that contains tags, which will be applied to the nodes.
    :vartype node_tags: list[str]
    :ivar is_node_by_node_upgrade_in_progress: Indicates if a node-by-node upgrade is currently
     being performed on this node.
    :vartype is_node_by_node_upgrade_in_progress: bool
    :ivar infrastructure_placement_id: PlacementID used by the InfrastructureService.
    :vartype infrastructure_placement_id: str
    """

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'ip_address_or_fqdn': {'key': 'IpAddressOrFQDN', 'type': 'str'},
        'type': {'key': 'Type', 'type': 'str'},
        'code_version': {'key': 'CodeVersion', 'type': 'str'},
        'config_version': {'key': 'ConfigVersion', 'type': 'str'},
        'node_status': {'key': 'NodeStatus', 'type': 'str'},
        'node_up_time_in_seconds': {'key': 'NodeUpTimeInSeconds', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'is_seed_node': {'key': 'IsSeedNode', 'type': 'bool'},
        'upgrade_domain': {'key': 'UpgradeDomain', 'type': 'str'},
        'fault_domain': {'key': 'FaultDomain', 'type': 'str'},
        'id': {'key': 'Id', 'type': 'NodeId'},
        'instance_id': {'key': 'InstanceId', 'type': 'str'},
        'node_deactivation_info': {'key': 'NodeDeactivationInfo', 'type': 'NodeDeactivationInfo'},
        'is_stopped': {'key': 'IsStopped', 'type': 'bool'},
        'node_down_time_in_seconds': {'key': 'NodeDownTimeInSeconds', 'type': 'str'},
        'node_up_at': {'key': 'NodeUpAt', 'type': 'iso-8601'},
        'node_down_at': {'key': 'NodeDownAt', 'type': 'iso-8601'},
        'node_tags': {'key': 'NodeTags', 'type': '[str]'},
        'is_node_by_node_upgrade_in_progress': {'key': 'IsNodeByNodeUpgradeInProgress', 'type': 'bool'},
        'infrastructure_placement_id': {'key': 'InfrastructurePlacementID', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: The name of a Service Fabric node.
        :paramtype name: str
        :keyword ip_address_or_fqdn: The IP address or fully qualified domain name of the node.
        :paramtype ip_address_or_fqdn: str
        :keyword type: The type of the node.
        :paramtype type: str
        :keyword code_version: The version of Service Fabric binaries that the node is running.
        :paramtype code_version: str
        :keyword config_version: The version of Service Fabric cluster manifest that the node is using.
        :paramtype config_version: str
        :keyword node_status: The status of the node. Possible values include: "Invalid", "Up", "Down",
         "Enabling", "Disabling", "Disabled", "Unknown", "Removed".
        :paramtype node_status: str or ~azure.servicefabric.models.NodeStatus
        :keyword node_up_time_in_seconds: Time in seconds since the node has been in NodeStatus Up.
         Value zero indicates that the node is not Up.
        :paramtype node_up_time_in_seconds: str
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword is_seed_node: Indicates if the node is a seed node or not. Returns true if the node is
         a seed node, otherwise false. A quorum of seed nodes are required for proper operation of
         Service Fabric cluster.
        :paramtype is_seed_node: bool
        :keyword upgrade_domain: The upgrade domain of the node.
        :paramtype upgrade_domain: str
        :keyword fault_domain: The fault domain of the node.
        :paramtype fault_domain: str
        :keyword id: An internal ID used by Service Fabric to uniquely identify a node. Node Id is
         deterministically generated from node name.
        :paramtype id: ~azure.servicefabric.models.NodeId
        :keyword instance_id: The ID representing the node instance. While the ID of the node is
         deterministically generated from the node name and remains same across restarts, the InstanceId
         changes every time node restarts.
        :paramtype instance_id: str
        :keyword node_deactivation_info: Information about the node deactivation. This information is
         valid for a node that is undergoing deactivation or has already been deactivated.
        :paramtype node_deactivation_info: ~azure.servicefabric.models.NodeDeactivationInfo
        :keyword is_stopped: Indicates if the node is stopped by calling stop node API or not. Returns
         true if the node is stopped, otherwise false.
        :paramtype is_stopped: bool
        :keyword node_down_time_in_seconds: Time in seconds since the node has been in NodeStatus Down.
         Value zero indicates node is not NodeStatus Down.
        :paramtype node_down_time_in_seconds: str
        :keyword node_up_at: Date time in UTC when the node came up. If the node has never been up then
         this value will be zero date time.
        :paramtype node_up_at: ~datetime.datetime
        :keyword node_down_at: Date time in UTC when the node went down. If node has never been down
         then this value will be zero date time.
        :paramtype node_down_at: ~datetime.datetime
        :keyword node_tags: List that contains tags, which will be applied to the nodes.
        :paramtype node_tags: list[str]
        :keyword is_node_by_node_upgrade_in_progress: Indicates if a node-by-node upgrade is currently
         being performed on this node.
        :paramtype is_node_by_node_upgrade_in_progress: bool
        :keyword infrastructure_placement_id: PlacementID used by the InfrastructureService.
        :paramtype infrastructure_placement_id: str
        """
        super(NodeInfo, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.ip_address_or_fqdn = kwargs.get('ip_address_or_fqdn', None)
        self.type = kwargs.get('type', None)
        self.code_version = kwargs.get('code_version', None)
        self.config_version = kwargs.get('config_version', None)
        self.node_status = kwargs.get('node_status', None)
        self.node_up_time_in_seconds = kwargs.get('node_up_time_in_seconds', None)
        self.health_state = kwargs.get('health_state', None)
        self.is_seed_node = kwargs.get('is_seed_node', None)
        self.upgrade_domain = kwargs.get('upgrade_domain', None)
        self.fault_domain = kwargs.get('fault_domain', None)
        self.id = kwargs.get('id', None)
        self.instance_id = kwargs.get('instance_id', None)
        self.node_deactivation_info = kwargs.get('node_deactivation_info', None)
        self.is_stopped = kwargs.get('is_stopped', None)
        self.node_down_time_in_seconds = kwargs.get('node_down_time_in_seconds', None)
        self.node_up_at = kwargs.get('node_up_at', None)
        self.node_down_at = kwargs.get('node_down_at', None)
        self.node_tags = kwargs.get('node_tags', None)
        self.is_node_by_node_upgrade_in_progress = kwargs.get('is_node_by_node_upgrade_in_progress', None)
        self.infrastructure_placement_id = kwargs.get('infrastructure_placement_id', None)


class NodeLoadInfo(msrest.serialization.Model):
    """Information about load on a Service Fabric node. It holds a summary of all metrics and their load on a node.

    :ivar node_name: Name of the node for which the load information is provided by this object.
    :vartype node_name: str
    :ivar node_load_metric_information: List that contains metrics and their load information on
     this node.
    :vartype node_load_metric_information:
     list[~azure.servicefabric.models.NodeLoadMetricInformation]
    """

    _attribute_map = {
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_load_metric_information': {'key': 'NodeLoadMetricInformation', 'type': '[NodeLoadMetricInformation]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword node_name: Name of the node for which the load information is provided by this object.
        :paramtype node_name: str
        :keyword node_load_metric_information: List that contains metrics and their load information on
         this node.
        :paramtype node_load_metric_information:
         list[~azure.servicefabric.models.NodeLoadMetricInformation]
        """
        super(NodeLoadInfo, self).__init__(**kwargs)
        self.node_name = kwargs.get('node_name', None)
        self.node_load_metric_information = kwargs.get('node_load_metric_information', None)


class NodeLoadMetricInformation(msrest.serialization.Model):
    """Represents data structure that contains load information for a certain metric on a node.

    :ivar name: Name of the metric for which this load information is provided.
    :vartype name: str
    :ivar node_capacity: Total capacity on the node for this metric.
    :vartype node_capacity: str
    :ivar node_load: Current load on the node for this metric. In future releases of Service Fabric
     this parameter will be deprecated in favor of CurrentNodeLoad.
    :vartype node_load: str
    :ivar node_remaining_capacity: The remaining capacity on the node for this metric. In future
     releases of Service Fabric this parameter will be deprecated in favor of NodeCapacityRemaining.
    :vartype node_remaining_capacity: str
    :ivar is_capacity_violation: Indicates if there is a capacity violation for this metric on the
     node.
    :vartype is_capacity_violation: bool
    :ivar node_buffered_capacity: The value that indicates the reserved capacity for this metric on
     the node.
    :vartype node_buffered_capacity: str
    :ivar node_remaining_buffered_capacity: The remaining reserved capacity for this metric on the
     node. In future releases of Service Fabric this parameter will be deprecated in favor of
     BufferedNodeCapacityRemaining.
    :vartype node_remaining_buffered_capacity: str
    :ivar current_node_load: Current load on the node for this metric.
    :vartype current_node_load: str
    :ivar node_capacity_remaining: The remaining capacity on the node for the metric.
    :vartype node_capacity_remaining: str
    :ivar buffered_node_capacity_remaining: The remaining capacity which is not reserved by
     NodeBufferPercentage for this metric on the node.
    :vartype buffered_node_capacity_remaining: str
    :ivar planned_node_load_removal: This value represents the load of the replicas that are
     planned to be removed in the future.
     This kind of load is reported for replicas that are currently being moving to other nodes and
     for replicas that are currently being dropped but still use the load on the source node.
    :vartype planned_node_load_removal: str
    """

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'node_capacity': {'key': 'NodeCapacity', 'type': 'str'},
        'node_load': {'key': 'NodeLoad', 'type': 'str'},
        'node_remaining_capacity': {'key': 'NodeRemainingCapacity', 'type': 'str'},
        'is_capacity_violation': {'key': 'IsCapacityViolation', 'type': 'bool'},
        'node_buffered_capacity': {'key': 'NodeBufferedCapacity', 'type': 'str'},
        'node_remaining_buffered_capacity': {'key': 'NodeRemainingBufferedCapacity', 'type': 'str'},
        'current_node_load': {'key': 'CurrentNodeLoad', 'type': 'str'},
        'node_capacity_remaining': {'key': 'NodeCapacityRemaining', 'type': 'str'},
        'buffered_node_capacity_remaining': {'key': 'BufferedNodeCapacityRemaining', 'type': 'str'},
        'planned_node_load_removal': {'key': 'PlannedNodeLoadRemoval', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Name of the metric for which this load information is provided.
        :paramtype name: str
        :keyword node_capacity: Total capacity on the node for this metric.
        :paramtype node_capacity: str
        :keyword node_load: Current load on the node for this metric. In future releases of Service
         Fabric this parameter will be deprecated in favor of CurrentNodeLoad.
        :paramtype node_load: str
        :keyword node_remaining_capacity: The remaining capacity on the node for this metric. In future
         releases of Service Fabric this parameter will be deprecated in favor of NodeCapacityRemaining.
        :paramtype node_remaining_capacity: str
        :keyword is_capacity_violation: Indicates if there is a capacity violation for this metric on
         the node.
        :paramtype is_capacity_violation: bool
        :keyword node_buffered_capacity: The value that indicates the reserved capacity for this metric
         on the node.
        :paramtype node_buffered_capacity: str
        :keyword node_remaining_buffered_capacity: The remaining reserved capacity for this metric on
         the node. In future releases of Service Fabric this parameter will be deprecated in favor of
         BufferedNodeCapacityRemaining.
        :paramtype node_remaining_buffered_capacity: str
        :keyword current_node_load: Current load on the node for this metric.
        :paramtype current_node_load: str
        :keyword node_capacity_remaining: The remaining capacity on the node for the metric.
        :paramtype node_capacity_remaining: str
        :keyword buffered_node_capacity_remaining: The remaining capacity which is not reserved by
         NodeBufferPercentage for this metric on the node.
        :paramtype buffered_node_capacity_remaining: str
        :keyword planned_node_load_removal: This value represents the load of the replicas that are
         planned to be removed in the future.
         This kind of load is reported for replicas that are currently being moving to other nodes and
         for replicas that are currently being dropped but still use the load on the source node.
        :paramtype planned_node_load_removal: str
        """
        super(NodeLoadMetricInformation, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.node_capacity = kwargs.get('node_capacity', None)
        self.node_load = kwargs.get('node_load', None)
        self.node_remaining_capacity = kwargs.get('node_remaining_capacity', None)
        self.is_capacity_violation = kwargs.get('is_capacity_violation', None)
        self.node_buffered_capacity = kwargs.get('node_buffered_capacity', None)
        self.node_remaining_buffered_capacity = kwargs.get('node_remaining_buffered_capacity', None)
        self.current_node_load = kwargs.get('current_node_load', None)
        self.node_capacity_remaining = kwargs.get('node_capacity_remaining', None)
        self.buffered_node_capacity_remaining = kwargs.get('buffered_node_capacity_remaining', None)
        self.planned_node_load_removal = kwargs.get('planned_node_load_removal', None)


class NodeNewHealthReportEvent(NodeEvent):
    """Node Health Report Created event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar node_instance_id: Required. Id of Node instance.
    :vartype node_instance_id: long
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'node_name': {'required': True},
        'node_instance_id': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_instance_id': {'key': 'NodeInstanceId', 'type': 'long'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword node_instance_id: Required. Id of Node instance.
        :paramtype node_instance_id: long
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(NodeNewHealthReportEvent, self).__init__(**kwargs)
        self.kind = 'NodeNewHealthReport'  # type: str
        self.node_instance_id = kwargs['node_instance_id']
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class NodeOpenFailedEvent(NodeEvent):
    """Node Open Failed event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar node_instance: Required. Id of Node instance.
    :vartype node_instance: long
    :ivar node_id: Required. Id of Node.
    :vartype node_id: str
    :ivar upgrade_domain: Required. Upgrade domain of Node.
    :vartype upgrade_domain: str
    :ivar fault_domain: Required. Fault domain of Node.
    :vartype fault_domain: str
    :ivar ip_address_or_fqdn: Required. IP address or FQDN.
    :vartype ip_address_or_fqdn: str
    :ivar hostname: Required. Name of Host.
    :vartype hostname: str
    :ivar is_seed_node: Required. Indicates if it is seed node.
    :vartype is_seed_node: bool
    :ivar node_version: Required. Version of Node.
    :vartype node_version: str
    :ivar error: Required. Describes the error.
    :vartype error: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'node_name': {'required': True},
        'node_instance': {'required': True},
        'node_id': {'required': True},
        'upgrade_domain': {'required': True},
        'fault_domain': {'required': True},
        'ip_address_or_fqdn': {'required': True},
        'hostname': {'required': True},
        'is_seed_node': {'required': True},
        'node_version': {'required': True},
        'error': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_instance': {'key': 'NodeInstance', 'type': 'long'},
        'node_id': {'key': 'NodeId', 'type': 'str'},
        'upgrade_domain': {'key': 'UpgradeDomain', 'type': 'str'},
        'fault_domain': {'key': 'FaultDomain', 'type': 'str'},
        'ip_address_or_fqdn': {'key': 'IpAddressOrFQDN', 'type': 'str'},
        'hostname': {'key': 'Hostname', 'type': 'str'},
        'is_seed_node': {'key': 'IsSeedNode', 'type': 'bool'},
        'node_version': {'key': 'NodeVersion', 'type': 'str'},
        'error': {'key': 'Error', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword node_instance: Required. Id of Node instance.
        :paramtype node_instance: long
        :keyword node_id: Required. Id of Node.
        :paramtype node_id: str
        :keyword upgrade_domain: Required. Upgrade domain of Node.
        :paramtype upgrade_domain: str
        :keyword fault_domain: Required. Fault domain of Node.
        :paramtype fault_domain: str
        :keyword ip_address_or_fqdn: Required. IP address or FQDN.
        :paramtype ip_address_or_fqdn: str
        :keyword hostname: Required. Name of Host.
        :paramtype hostname: str
        :keyword is_seed_node: Required. Indicates if it is seed node.
        :paramtype is_seed_node: bool
        :keyword node_version: Required. Version of Node.
        :paramtype node_version: str
        :keyword error: Required. Describes the error.
        :paramtype error: str
        """
        super(NodeOpenFailedEvent, self).__init__(**kwargs)
        self.kind = 'NodeOpenFailed'  # type: str
        self.node_instance = kwargs['node_instance']
        self.node_id = kwargs['node_id']
        self.upgrade_domain = kwargs['upgrade_domain']
        self.fault_domain = kwargs['fault_domain']
        self.ip_address_or_fqdn = kwargs['ip_address_or_fqdn']
        self.hostname = kwargs['hostname']
        self.is_seed_node = kwargs['is_seed_node']
        self.node_version = kwargs['node_version']
        self.error = kwargs['error']


class NodeOpenSucceededEvent(NodeEvent):
    """Node Opened Succeeded event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar node_instance: Required. Id of Node instance.
    :vartype node_instance: long
    :ivar node_id: Required. Id of Node.
    :vartype node_id: str
    :ivar upgrade_domain: Required. Upgrade domain of Node.
    :vartype upgrade_domain: str
    :ivar fault_domain: Required. Fault domain of Node.
    :vartype fault_domain: str
    :ivar ip_address_or_fqdn: Required. IP address or FQDN.
    :vartype ip_address_or_fqdn: str
    :ivar hostname: Required. Name of Host.
    :vartype hostname: str
    :ivar is_seed_node: Required. Indicates if it is seed node.
    :vartype is_seed_node: bool
    :ivar node_version: Required. Version of Node.
    :vartype node_version: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'node_name': {'required': True},
        'node_instance': {'required': True},
        'node_id': {'required': True},
        'upgrade_domain': {'required': True},
        'fault_domain': {'required': True},
        'ip_address_or_fqdn': {'required': True},
        'hostname': {'required': True},
        'is_seed_node': {'required': True},
        'node_version': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_instance': {'key': 'NodeInstance', 'type': 'long'},
        'node_id': {'key': 'NodeId', 'type': 'str'},
        'upgrade_domain': {'key': 'UpgradeDomain', 'type': 'str'},
        'fault_domain': {'key': 'FaultDomain', 'type': 'str'},
        'ip_address_or_fqdn': {'key': 'IpAddressOrFQDN', 'type': 'str'},
        'hostname': {'key': 'Hostname', 'type': 'str'},
        'is_seed_node': {'key': 'IsSeedNode', 'type': 'bool'},
        'node_version': {'key': 'NodeVersion', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword node_instance: Required. Id of Node instance.
        :paramtype node_instance: long
        :keyword node_id: Required. Id of Node.
        :paramtype node_id: str
        :keyword upgrade_domain: Required. Upgrade domain of Node.
        :paramtype upgrade_domain: str
        :keyword fault_domain: Required. Fault domain of Node.
        :paramtype fault_domain: str
        :keyword ip_address_or_fqdn: Required. IP address or FQDN.
        :paramtype ip_address_or_fqdn: str
        :keyword hostname: Required. Name of Host.
        :paramtype hostname: str
        :keyword is_seed_node: Required. Indicates if it is seed node.
        :paramtype is_seed_node: bool
        :keyword node_version: Required. Version of Node.
        :paramtype node_version: str
        """
        super(NodeOpenSucceededEvent, self).__init__(**kwargs)
        self.kind = 'NodeOpenSucceeded'  # type: str
        self.node_instance = kwargs['node_instance']
        self.node_id = kwargs['node_id']
        self.upgrade_domain = kwargs['upgrade_domain']
        self.fault_domain = kwargs['fault_domain']
        self.ip_address_or_fqdn = kwargs['ip_address_or_fqdn']
        self.hostname = kwargs['hostname']
        self.is_seed_node = kwargs['is_seed_node']
        self.node_version = kwargs['node_version']


class NodeRemovedFromClusterEvent(NodeEvent):
    """Node Removed event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar node_id: Required. Id of Node.
    :vartype node_id: str
    :ivar node_instance: Required. Id of Node instance.
    :vartype node_instance: long
    :ivar node_type: Required. Type of Node.
    :vartype node_type: str
    :ivar fabric_version: Required. Fabric version.
    :vartype fabric_version: str
    :ivar ip_address_or_fqdn: Required. IP address or FQDN.
    :vartype ip_address_or_fqdn: str
    :ivar node_capacities: Required. Capacities.
    :vartype node_capacities: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'node_name': {'required': True},
        'node_id': {'required': True},
        'node_instance': {'required': True},
        'node_type': {'required': True},
        'fabric_version': {'required': True},
        'ip_address_or_fqdn': {'required': True},
        'node_capacities': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_id': {'key': 'NodeId', 'type': 'str'},
        'node_instance': {'key': 'NodeInstance', 'type': 'long'},
        'node_type': {'key': 'NodeType', 'type': 'str'},
        'fabric_version': {'key': 'FabricVersion', 'type': 'str'},
        'ip_address_or_fqdn': {'key': 'IpAddressOrFQDN', 'type': 'str'},
        'node_capacities': {'key': 'NodeCapacities', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword node_id: Required. Id of Node.
        :paramtype node_id: str
        :keyword node_instance: Required. Id of Node instance.
        :paramtype node_instance: long
        :keyword node_type: Required. Type of Node.
        :paramtype node_type: str
        :keyword fabric_version: Required. Fabric version.
        :paramtype fabric_version: str
        :keyword ip_address_or_fqdn: Required. IP address or FQDN.
        :paramtype ip_address_or_fqdn: str
        :keyword node_capacities: Required. Capacities.
        :paramtype node_capacities: str
        """
        super(NodeRemovedFromClusterEvent, self).__init__(**kwargs)
        self.kind = 'NodeRemovedFromCluster'  # type: str
        self.node_id = kwargs['node_id']
        self.node_instance = kwargs['node_instance']
        self.node_type = kwargs['node_type']
        self.fabric_version = kwargs['fabric_version']
        self.ip_address_or_fqdn = kwargs['ip_address_or_fqdn']
        self.node_capacities = kwargs['node_capacities']


class RepairImpactDescriptionBase(msrest.serialization.Model):
    """Describes the expected impact of executing a repair task.

This type supports the Service Fabric platform; it is not meant to be used directly from your code.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: NodeRepairImpactDescription.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of repair impact represented by the current object.Constant
     filled by server. Possible values include: "Invalid", "Node".
    :vartype kind: str or ~azure.servicefabric.models.RepairImpactKind
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'Node': 'NodeRepairImpactDescription'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(RepairImpactDescriptionBase, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]


class NodeRepairImpactDescription(RepairImpactDescriptionBase):
    """Describes the expected impact of a repair on a set of nodes.

This type supports the Service Fabric platform; it is not meant to be used directly from your code.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of repair impact represented by the current object.Constant
     filled by server. Possible values include: "Invalid", "Node".
    :vartype kind: str or ~azure.servicefabric.models.RepairImpactKind
    :ivar node_impact_list: The list of nodes impacted by a repair action and their respective
     expected impact.
    :vartype node_impact_list: list[~azure.servicefabric.models.NodeImpact]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'node_impact_list': {'key': 'NodeImpactList', 'type': '[NodeImpact]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword node_impact_list: The list of nodes impacted by a repair action and their respective
         expected impact.
        :paramtype node_impact_list: list[~azure.servicefabric.models.NodeImpact]
        """
        super(NodeRepairImpactDescription, self).__init__(**kwargs)
        self.kind = 'Node'  # type: str
        self.node_impact_list = kwargs.get('node_impact_list', None)


class RepairTargetDescriptionBase(msrest.serialization.Model):
    """Describes the entities targeted by a repair action.

This type supports the Service Fabric platform; it is not meant to be used directly from your code.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: NodeRepairTargetDescription.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of repair target described by the current object.Constant filled
     by server. Possible values include: "Invalid", "Node".
    :vartype kind: str or ~azure.servicefabric.models.RepairTargetKind
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'Node': 'NodeRepairTargetDescription'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(RepairTargetDescriptionBase, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]


class NodeRepairTargetDescription(RepairTargetDescriptionBase):
    """Describes the list of nodes targeted by a repair action.

This type supports the Service Fabric platform; it is not meant to be used directly from your code.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of repair target described by the current object.Constant filled
     by server. Possible values include: "Invalid", "Node".
    :vartype kind: str or ~azure.servicefabric.models.RepairTargetKind
    :ivar node_names: The list of nodes targeted by a repair action.
    :vartype node_names: list[str]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'node_names': {'key': 'NodeNames', 'type': '[str]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword node_names: The list of nodes targeted by a repair action.
        :paramtype node_names: list[str]
        """
        super(NodeRepairTargetDescription, self).__init__(**kwargs)
        self.kind = 'Node'  # type: str
        self.node_names = kwargs.get('node_names', None)


class NodeResult(msrest.serialization.Model):
    """Contains information about a node that was targeted by a user-induced operation.

    :ivar node_name: The name of a Service Fabric node.
    :vartype node_name: str
    :ivar node_instance_id: The node instance id.
    :vartype node_instance_id: str
    """

    _attribute_map = {
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_instance_id': {'key': 'NodeInstanceId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword node_name: The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword node_instance_id: The node instance id.
        :paramtype node_instance_id: str
        """
        super(NodeResult, self).__init__(**kwargs)
        self.node_name = kwargs.get('node_name', None)
        self.node_instance_id = kwargs.get('node_instance_id', None)


class NodesHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for nodes, containing health evaluations for each unhealthy node that impacted current aggregated health state. Can be returned when evaluating cluster health and the aggregated health state is either Error or Warning.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar max_percent_unhealthy_nodes: Maximum allowed percentage of unhealthy nodes from the
     ClusterHealthPolicy.
    :vartype max_percent_unhealthy_nodes: int
    :ivar total_count: Total number of nodes found in the health store.
    :vartype total_count: long
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
     state. Includes all the unhealthy NodeHealthEvaluation that impacted the aggregated health.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'max_percent_unhealthy_nodes': {'key': 'MaxPercentUnhealthyNodes', 'type': 'int'},
        'total_count': {'key': 'TotalCount', 'type': 'long'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword max_percent_unhealthy_nodes: Maximum allowed percentage of unhealthy nodes from the
         ClusterHealthPolicy.
        :paramtype max_percent_unhealthy_nodes: int
        :keyword total_count: Total number of nodes found in the health store.
        :paramtype total_count: long
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
         state. Includes all the unhealthy NodeHealthEvaluation that impacted the aggregated health.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(NodesHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'Nodes'  # type: str
        self.max_percent_unhealthy_nodes = kwargs.get('max_percent_unhealthy_nodes', None)
        self.total_count = kwargs.get('total_count', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class NodeTagsDescription(msrest.serialization.Model):
    """Describes the tags required for placement or running of the service.

    All required parameters must be populated in order to send to Azure.

    :ivar count: Required. The number of tags.
    :vartype count: int
    :ivar tags: Required. A set of tags. Array of size specified by the ‘Count’ parameter, for the
     placement tags of the service.
    :vartype tags: list[str]
    """

    _validation = {
        'count': {'required': True},
        'tags': {'required': True},
    }

    _attribute_map = {
        'count': {'key': 'Count', 'type': 'int'},
        'tags': {'key': 'Tags', 'type': '[str]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword count: Required. The number of tags.
        :paramtype count: int
        :keyword tags: Required. A set of tags. Array of size specified by the ‘Count’ parameter, for
         the placement tags of the service.
        :paramtype tags: list[str]
        """
        super(NodeTagsDescription, self).__init__(**kwargs)
        self.count = kwargs['count']
        self.tags = kwargs['tags']


class NodeTransitionProgress(msrest.serialization.Model):
    """Information about an NodeTransition operation.  This class contains an OperationState and a NodeTransitionResult.  The NodeTransitionResult is not valid until OperationState
is Completed or Faulted.

    :ivar state: The state of the operation. Possible values include: "Invalid", "Running",
     "RollingBack", "Completed", "Faulted", "Cancelled", "ForceCancelled".
    :vartype state: str or ~azure.servicefabric.models.OperationState
    :ivar node_transition_result: Represents information about an operation in a terminal state
     (Completed or Faulted).
    :vartype node_transition_result: ~azure.servicefabric.models.NodeTransitionResult
    """

    _attribute_map = {
        'state': {'key': 'State', 'type': 'str'},
        'node_transition_result': {'key': 'NodeTransitionResult', 'type': 'NodeTransitionResult'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword state: The state of the operation. Possible values include: "Invalid", "Running",
         "RollingBack", "Completed", "Faulted", "Cancelled", "ForceCancelled".
        :paramtype state: str or ~azure.servicefabric.models.OperationState
        :keyword node_transition_result: Represents information about an operation in a terminal state
         (Completed or Faulted).
        :paramtype node_transition_result: ~azure.servicefabric.models.NodeTransitionResult
        """
        super(NodeTransitionProgress, self).__init__(**kwargs)
        self.state = kwargs.get('state', None)
        self.node_transition_result = kwargs.get('node_transition_result', None)


class NodeTransitionResult(msrest.serialization.Model):
    """Represents information about an operation in a terminal state (Completed or Faulted).

    :ivar error_code: If OperationState is Completed, this is 0.  If OperationState is Faulted,
     this is an error code indicating the reason.
    :vartype error_code: int
    :ivar node_result: Contains information about a node that was targeted by a user-induced
     operation.
    :vartype node_result: ~azure.servicefabric.models.NodeResult
    """

    _attribute_map = {
        'error_code': {'key': 'ErrorCode', 'type': 'int'},
        'node_result': {'key': 'NodeResult', 'type': 'NodeResult'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword error_code: If OperationState is Completed, this is 0.  If OperationState is Faulted,
         this is an error code indicating the reason.
        :paramtype error_code: int
        :keyword node_result: Contains information about a node that was targeted by a user-induced
         operation.
        :paramtype node_result: ~azure.servicefabric.models.NodeResult
        """
        super(NodeTransitionResult, self).__init__(**kwargs)
        self.error_code = kwargs.get('error_code', None)
        self.node_result = kwargs.get('node_result', None)


class NodeTypeHealthPolicyMapItem(msrest.serialization.Model):
    """Defines an item in NodeTypeHealthPolicyMap.

    All required parameters must be populated in order to send to Azure.

    :ivar key: Required. The key of the node type health policy map item. This is the name of the
     node type.
    :vartype key: str
    :ivar value: Required. The value of the node type health policy map item.
     If the percentage is respected but there is at least one unhealthy node in the node type, the
     health is evaluated as Warning.
     The percentage is calculated by dividing the number of unhealthy nodes over the total number
     of nodes in the node type.
     The computation rounds up to tolerate one failure on small numbers of nodes.
     The max percent unhealthy nodes allowed for the node type. Must be between zero and 100.
    :vartype value: int
    """

    _validation = {
        'key': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'key': {'key': 'Key', 'type': 'str'},
        'value': {'key': 'Value', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword key: Required. The key of the node type health policy map item. This is the name of
         the node type.
        :paramtype key: str
        :keyword value: Required. The value of the node type health policy map item.
         If the percentage is respected but there is at least one unhealthy node in the node type, the
         health is evaluated as Warning.
         The percentage is calculated by dividing the number of unhealthy nodes over the total number
         of nodes in the node type.
         The computation rounds up to tolerate one failure on small numbers of nodes.
         The max percent unhealthy nodes allowed for the node type. Must be between zero and 100.
        :paramtype value: int
        """
        super(NodeTypeHealthPolicyMapItem, self).__init__(**kwargs)
        self.key = kwargs['key']
        self.value = kwargs['value']


class NodeTypeNodesHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for nodes of a particular node type. The node type nodes evaluation can be returned when cluster health evaluation returns unhealthy aggregated health state, either Error or Warning. It contains health evaluations for each unhealthy node of the included node type that impacted current aggregated health state.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar node_type_name: The node type name as defined in the cluster manifest.
    :vartype node_type_name: str
    :ivar max_percent_unhealthy_nodes: Maximum allowed percentage of unhealthy nodes for the node
     type, specified as an entry in NodeTypeHealthPolicyMap.
    :vartype max_percent_unhealthy_nodes: int
    :ivar total_count: Total number of nodes of the node type found in the health store.
    :vartype total_count: long
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
     state. Includes all the unhealthy NodeHealthEvaluation of this node type that impacted the
     aggregated health.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'node_type_name': {'key': 'NodeTypeName', 'type': 'str'},
        'max_percent_unhealthy_nodes': {'key': 'MaxPercentUnhealthyNodes', 'type': 'int'},
        'total_count': {'key': 'TotalCount', 'type': 'long'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword node_type_name: The node type name as defined in the cluster manifest.
        :paramtype node_type_name: str
        :keyword max_percent_unhealthy_nodes: Maximum allowed percentage of unhealthy nodes for the
         node type, specified as an entry in NodeTypeHealthPolicyMap.
        :paramtype max_percent_unhealthy_nodes: int
        :keyword total_count: Total number of nodes of the node type found in the health store.
        :paramtype total_count: long
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
         state. Includes all the unhealthy NodeHealthEvaluation of this node type that impacted the
         aggregated health.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(NodeTypeNodesHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'NodeTypeNodes'  # type: str
        self.node_type_name = kwargs.get('node_type_name', None)
        self.max_percent_unhealthy_nodes = kwargs.get('max_percent_unhealthy_nodes', None)
        self.total_count = kwargs.get('total_count', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class NodeUpEvent(NodeEvent):
    """Node Up event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar node_instance: Required. Id of Node instance.
    :vartype node_instance: long
    :ivar last_node_down_at: Required. Time when Node was last down.
    :vartype last_node_down_at: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'node_name': {'required': True},
        'node_instance': {'required': True},
        'last_node_down_at': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_instance': {'key': 'NodeInstance', 'type': 'long'},
        'last_node_down_at': {'key': 'LastNodeDownAt', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword node_instance: Required. Id of Node instance.
        :paramtype node_instance: long
        :keyword last_node_down_at: Required. Time when Node was last down.
        :paramtype last_node_down_at: ~datetime.datetime
        """
        super(NodeUpEvent, self).__init__(**kwargs)
        self.kind = 'NodeUp'  # type: str
        self.node_instance = kwargs['node_instance']
        self.last_node_down_at = kwargs['last_node_down_at']


class NodeUpgradeProgressInfo(msrest.serialization.Model):
    """Information about the upgrading node and its status.

    :ivar node_name: The name of a Service Fabric node.
    :vartype node_name: str
    :ivar upgrade_phase: The state of the upgrading node. Possible values include: "Invalid",
     "PreUpgradeSafetyCheck", "Upgrading", "PostUpgradeSafetyCheck".
    :vartype upgrade_phase: str or ~azure.servicefabric.models.NodeUpgradePhase
    :ivar pending_safety_checks: List of pending safety checks.
    :vartype pending_safety_checks: list[~azure.servicefabric.models.SafetyCheckWrapper]
    :ivar upgrade_duration: The estimated time spent processing the node since it was deactivated
     during a node-by-node upgrade.
    :vartype upgrade_duration: str
    """

    _attribute_map = {
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'upgrade_phase': {'key': 'UpgradePhase', 'type': 'str'},
        'pending_safety_checks': {'key': 'PendingSafetyChecks', 'type': '[SafetyCheckWrapper]'},
        'upgrade_duration': {'key': 'UpgradeDuration', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword node_name: The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword upgrade_phase: The state of the upgrading node. Possible values include: "Invalid",
         "PreUpgradeSafetyCheck", "Upgrading", "PostUpgradeSafetyCheck".
        :paramtype upgrade_phase: str or ~azure.servicefabric.models.NodeUpgradePhase
        :keyword pending_safety_checks: List of pending safety checks.
        :paramtype pending_safety_checks: list[~azure.servicefabric.models.SafetyCheckWrapper]
        :keyword upgrade_duration: The estimated time spent processing the node since it was
         deactivated during a node-by-node upgrade.
        :paramtype upgrade_duration: str
        """
        super(NodeUpgradeProgressInfo, self).__init__(**kwargs)
        self.node_name = kwargs.get('node_name', None)
        self.upgrade_phase = kwargs.get('upgrade_phase', None)
        self.pending_safety_checks = kwargs.get('pending_safety_checks', None)
        self.upgrade_duration = kwargs.get('upgrade_duration', None)


class OperationStatus(msrest.serialization.Model):
    """Contains the OperationId, OperationState, and OperationType for user-induced operations.

    :ivar operation_id: A GUID that identifies a call to this API.  This is also passed into the
     corresponding GetProgress API.
    :vartype operation_id: str
    :ivar state: The state of the operation. Possible values include: "Invalid", "Running",
     "RollingBack", "Completed", "Faulted", "Cancelled", "ForceCancelled".
    :vartype state: str or ~azure.servicefabric.models.OperationState
    :ivar type: The type of the operation. Possible values include: "Invalid", "PartitionDataLoss",
     "PartitionQuorumLoss", "PartitionRestart", "NodeTransition".
    :vartype type: str or ~azure.servicefabric.models.OperationType
    """

    _attribute_map = {
        'operation_id': {'key': 'OperationId', 'type': 'str'},
        'state': {'key': 'State', 'type': 'str'},
        'type': {'key': 'Type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword operation_id: A GUID that identifies a call to this API.  This is also passed into the
         corresponding GetProgress API.
        :paramtype operation_id: str
        :keyword state: The state of the operation. Possible values include: "Invalid", "Running",
         "RollingBack", "Completed", "Faulted", "Cancelled", "ForceCancelled".
        :paramtype state: str or ~azure.servicefabric.models.OperationState
        :keyword type: The type of the operation. Possible values include: "Invalid",
         "PartitionDataLoss", "PartitionQuorumLoss", "PartitionRestart", "NodeTransition".
        :paramtype type: str or ~azure.servicefabric.models.OperationType
        """
        super(OperationStatus, self).__init__(**kwargs)
        self.operation_id = kwargs.get('operation_id', None)
        self.state = kwargs.get('state', None)
        self.type = kwargs.get('type', None)


class PackageSharingPolicyInfo(msrest.serialization.Model):
    """Represents a policy for the package sharing.

    :ivar shared_package_name: The name of code, configuration or data package that should be
     shared.
    :vartype shared_package_name: str
    :ivar package_sharing_scope: Represents the scope for PackageSharingPolicy. This is specified
     during DeployServicePackageToNode operation. Possible values include: "None", "All", "Code",
     "Config", "Data".
    :vartype package_sharing_scope: str or ~azure.servicefabric.models.PackageSharingPolicyScope
    """

    _attribute_map = {
        'shared_package_name': {'key': 'SharedPackageName', 'type': 'str'},
        'package_sharing_scope': {'key': 'PackageSharingScope', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword shared_package_name: The name of code, configuration or data package that should be
         shared.
        :paramtype shared_package_name: str
        :keyword package_sharing_scope: Represents the scope for PackageSharingPolicy. This is
         specified during DeployServicePackageToNode operation. Possible values include: "None", "All",
         "Code", "Config", "Data".
        :paramtype package_sharing_scope: str or ~azure.servicefabric.models.PackageSharingPolicyScope
        """
        super(PackageSharingPolicyInfo, self).__init__(**kwargs)
        self.shared_package_name = kwargs.get('shared_package_name', None)
        self.package_sharing_scope = kwargs.get('package_sharing_scope', None)


class PagedApplicationInfoList(msrest.serialization.Model):
    """The list of applications in the cluster. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: List of application information.
    :vartype items: list[~azure.servicefabric.models.ApplicationInfo]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[ApplicationInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: List of application information.
        :paramtype items: list[~azure.servicefabric.models.ApplicationInfo]
        """
        super(PagedApplicationInfoList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedApplicationResourceDescriptionList(msrest.serialization.Model):
    """The list of application resources. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: One page of the list.
    :vartype items: list[~azure.servicefabric.models.ApplicationResourceDescription]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[ApplicationResourceDescription]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: One page of the list.
        :paramtype items: list[~azure.servicefabric.models.ApplicationResourceDescription]
        """
        super(PagedApplicationResourceDescriptionList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedApplicationTypeInfoList(msrest.serialization.Model):
    """The list of application types that are provisioned or being provisioned in the cluster. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: List of application type information.
    :vartype items: list[~azure.servicefabric.models.ApplicationTypeInfo]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[ApplicationTypeInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: List of application type information.
        :paramtype items: list[~azure.servicefabric.models.ApplicationTypeInfo]
        """
        super(PagedApplicationTypeInfoList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedBackupConfigurationInfoList(msrest.serialization.Model):
    """The list of backup configuration information. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: List of backup configuration information.
    :vartype items: list[~azure.servicefabric.models.BackupConfigurationInfo]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[BackupConfigurationInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: List of backup configuration information.
        :paramtype items: list[~azure.servicefabric.models.BackupConfigurationInfo]
        """
        super(PagedBackupConfigurationInfoList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedBackupEntityList(msrest.serialization.Model):
    """The list of backup entities that are being periodically backed. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: List of backup entity information.
    :vartype items: list[~azure.servicefabric.models.BackupEntity]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[BackupEntity]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: List of backup entity information.
        :paramtype items: list[~azure.servicefabric.models.BackupEntity]
        """
        super(PagedBackupEntityList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedBackupInfoList(msrest.serialization.Model):
    """The list of backups. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: List of backup information.
    :vartype items: list[~azure.servicefabric.models.BackupInfo]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[BackupInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: List of backup information.
        :paramtype items: list[~azure.servicefabric.models.BackupInfo]
        """
        super(PagedBackupInfoList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedBackupPolicyDescriptionList(msrest.serialization.Model):
    """The list of backup policies configured in the cluster. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: The list of backup policies information.
    :vartype items: list[~azure.servicefabric.models.BackupPolicyDescription]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[BackupPolicyDescription]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: The list of backup policies information.
        :paramtype items: list[~azure.servicefabric.models.BackupPolicyDescription]
        """
        super(PagedBackupPolicyDescriptionList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedComposeDeploymentStatusInfoList(msrest.serialization.Model):
    """The list of compose deployments in the cluster. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: List of compose deployment status information.
    :vartype items: list[~azure.servicefabric.models.ComposeDeploymentStatusInfo]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[ComposeDeploymentStatusInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: List of compose deployment status information.
        :paramtype items: list[~azure.servicefabric.models.ComposeDeploymentStatusInfo]
        """
        super(PagedComposeDeploymentStatusInfoList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedDeployedApplicationInfoList(msrest.serialization.Model):
    """The list of deployed applications in activating, downloading, or active states on a node.
The list is paged when all of the results cannot fit in a single message.
The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: List of deployed application information.
    :vartype items: list[~azure.servicefabric.models.DeployedApplicationInfo]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[DeployedApplicationInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: List of deployed application information.
        :paramtype items: list[~azure.servicefabric.models.DeployedApplicationInfo]
        """
        super(PagedDeployedApplicationInfoList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedGatewayResourceDescriptionList(msrest.serialization.Model):
    """The list of gateway resources. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: One page of the list.
    :vartype items: list[~azure.servicefabric.models.GatewayResourceDescription]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[GatewayResourceDescription]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: One page of the list.
        :paramtype items: list[~azure.servicefabric.models.GatewayResourceDescription]
        """
        super(PagedGatewayResourceDescriptionList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedNetworkResourceDescriptionList(msrest.serialization.Model):
    """The list of network resources. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: One page of the list.
    :vartype items: list[~azure.servicefabric.models.NetworkResourceDescription]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[NetworkResourceDescription]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: One page of the list.
        :paramtype items: list[~azure.servicefabric.models.NetworkResourceDescription]
        """
        super(PagedNetworkResourceDescriptionList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedNodeInfoList(msrest.serialization.Model):
    """The list of nodes in the cluster. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: List of node information.
    :vartype items: list[~azure.servicefabric.models.NodeInfo]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[NodeInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: List of node information.
        :paramtype items: list[~azure.servicefabric.models.NodeInfo]
        """
        super(PagedNodeInfoList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedPropertyInfoList(msrest.serialization.Model):
    """The paged list of Service Fabric properties under a given name. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar is_consistent: Indicates whether any property under the given name has been modified
     during the enumeration. If there was a modification, this property value is false.
    :vartype is_consistent: bool
    :ivar properties: List of property information.
    :vartype properties: list[~azure.servicefabric.models.PropertyInfo]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'is_consistent': {'key': 'IsConsistent', 'type': 'bool'},
        'properties': {'key': 'Properties', 'type': '[PropertyInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword is_consistent: Indicates whether any property under the given name has been modified
         during the enumeration. If there was a modification, this property value is false.
        :paramtype is_consistent: bool
        :keyword properties: List of property information.
        :paramtype properties: list[~azure.servicefabric.models.PropertyInfo]
        """
        super(PagedPropertyInfoList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.is_consistent = kwargs.get('is_consistent', None)
        self.properties = kwargs.get('properties', None)


class PagedReplicaInfoList(msrest.serialization.Model):
    """The list of replicas in the cluster for a given partition. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: List of replica information.
    :vartype items: list[~azure.servicefabric.models.ReplicaInfo]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[ReplicaInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: List of replica information.
        :paramtype items: list[~azure.servicefabric.models.ReplicaInfo]
        """
        super(PagedReplicaInfoList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedSecretResourceDescriptionList(msrest.serialization.Model):
    """The list of secret resources. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: One page of the list.
    :vartype items: list[~azure.servicefabric.models.SecretResourceDescription]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[SecretResourceDescription]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: One page of the list.
        :paramtype items: list[~azure.servicefabric.models.SecretResourceDescription]
        """
        super(PagedSecretResourceDescriptionList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedSecretValueResourceDescriptionList(msrest.serialization.Model):
    """The list of values of a secret resource, paged if the number of results exceeds the limits of a single message. The next set of results can be obtained by executing the same query with the continuation token provided in the previous page.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: One page of the list.
    :vartype items: list[~azure.servicefabric.models.SecretValueResourceDescription]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[SecretValueResourceDescription]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: One page of the list.
        :paramtype items: list[~azure.servicefabric.models.SecretValueResourceDescription]
        """
        super(PagedSecretValueResourceDescriptionList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedServiceInfoList(msrest.serialization.Model):
    """The list of services in the cluster for an application. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: List of service information.
    :vartype items: list[~azure.servicefabric.models.ServiceInfo]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[ServiceInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: List of service information.
        :paramtype items: list[~azure.servicefabric.models.ServiceInfo]
        """
        super(PagedServiceInfoList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedServicePartitionInfoList(msrest.serialization.Model):
    """The list of partition in the cluster for a service. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: List of service partition information.
    :vartype items: list[~azure.servicefabric.models.ServicePartitionInfo]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[ServicePartitionInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: List of service partition information.
        :paramtype items: list[~azure.servicefabric.models.ServicePartitionInfo]
        """
        super(PagedServicePartitionInfoList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedServiceReplicaDescriptionList(msrest.serialization.Model):
    """The list of service resource replicas in the cluster. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: List of service resource replica description.
    :vartype items: list[~azure.servicefabric.models.ServiceReplicaDescription]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[ServiceReplicaDescription]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: List of service resource replica description.
        :paramtype items: list[~azure.servicefabric.models.ServiceReplicaDescription]
        """
        super(PagedServiceReplicaDescriptionList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedServiceResourceDescriptionList(msrest.serialization.Model):
    """The list of service resources. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: One page of the list.
    :vartype items: list[~azure.servicefabric.models.ServiceResourceDescription]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[ServiceResourceDescription]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: One page of the list.
        :paramtype items: list[~azure.servicefabric.models.ServiceResourceDescription]
        """
        super(PagedServiceResourceDescriptionList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedSubNameInfoList(msrest.serialization.Model):
    """A paged list of Service Fabric names. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar is_consistent: Indicates whether any name under the given name has been modified during
     the enumeration. If there was a modification, this property value is false.
    :vartype is_consistent: bool
    :ivar sub_names: List of the child names.
    :vartype sub_names: list[str]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'is_consistent': {'key': 'IsConsistent', 'type': 'bool'},
        'sub_names': {'key': 'SubNames', 'type': '[str]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword is_consistent: Indicates whether any name under the given name has been modified
         during the enumeration. If there was a modification, this property value is false.
        :paramtype is_consistent: bool
        :keyword sub_names: List of the child names.
        :paramtype sub_names: list[str]
        """
        super(PagedSubNameInfoList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.is_consistent = kwargs.get('is_consistent', None)
        self.sub_names = kwargs.get('sub_names', None)


class PagedUpdatePartitionLoadResultList(msrest.serialization.Model):
    """The list of results of the call UpdatePartitionLoad. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: List of partition load update information.
    :vartype items: list[~azure.servicefabric.models.UpdatePartitionLoadResult]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[UpdatePartitionLoadResult]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: List of partition load update information.
        :paramtype items: list[~azure.servicefabric.models.UpdatePartitionLoadResult]
        """
        super(PagedUpdatePartitionLoadResultList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PagedVolumeResourceDescriptionList(msrest.serialization.Model):
    """The list of volume resources. The list is paged when all of the results cannot fit in a single message. The next set of results can be obtained by executing the same query with the continuation token provided in this list.

    :ivar continuation_token: The continuation token parameter is used to obtain next set of
     results. The continuation token is included in the response of the API when the results from
     the system do not fit in a single response. When this value is passed to the next API call, the
     API returns next set of results. If there are no further results, then the continuation token
     is not included in the response.
    :vartype continuation_token: str
    :ivar items: One page of the list.
    :vartype items: list[~azure.servicefabric.models.VolumeResourceDescription]
    """

    _attribute_map = {
        'continuation_token': {'key': 'ContinuationToken', 'type': 'str'},
        'items': {'key': 'Items', 'type': '[VolumeResourceDescription]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword continuation_token: The continuation token parameter is used to obtain next set of
         results. The continuation token is included in the response of the API when the results from
         the system do not fit in a single response. When this value is passed to the next API call, the
         API returns next set of results. If there are no further results, then the continuation token
         is not included in the response.
        :paramtype continuation_token: str
        :keyword items: One page of the list.
        :paramtype items: list[~azure.servicefabric.models.VolumeResourceDescription]
        """
        super(PagedVolumeResourceDescriptionList, self).__init__(**kwargs)
        self.continuation_token = kwargs.get('continuation_token', None)
        self.items = kwargs.get('items', None)


class PartitionAnalysisEvent(PartitionEvent):
    """Represents the base for all Partition Analysis Events.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: PartitionPrimaryMoveAnalysisEvent.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar metadata: Required. Metadata about an Analysis Event.
    :vartype metadata: ~azure.servicefabric.models.AnalysisEventMetadata
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'partition_id': {'required': True},
        'metadata': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'metadata': {'key': 'Metadata', 'type': 'AnalysisEventMetadata'},
    }

    _subtype_map = {
        'kind': {'PartitionPrimaryMoveAnalysis': 'PartitionPrimaryMoveAnalysisEvent'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword metadata: Required. Metadata about an Analysis Event.
        :paramtype metadata: ~azure.servicefabric.models.AnalysisEventMetadata
        """
        super(PartitionAnalysisEvent, self).__init__(**kwargs)
        self.kind = 'PartitionAnalysisEvent'  # type: str
        self.metadata = kwargs['metadata']


class PartitionBackupConfigurationInfo(BackupConfigurationInfo):
    """Backup configuration information, for a specific partition, specifying what backup policy is being applied and suspend description, if any.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The entity type of a Service Fabric entity such as Application, Service
     or a Partition where periodic backups can be enabled.Constant filled by server. Possible values
     include: "Invalid", "Partition", "Service", "Application".
    :vartype kind: str or ~azure.servicefabric.models.BackupEntityKind
    :ivar policy_name: The name of the backup policy which is applicable to this Service Fabric
     application or service or partition.
    :vartype policy_name: str
    :ivar policy_inherited_from: Specifies the scope at which the backup policy is applied.
     Possible values include: "Invalid", "Partition", "Service", "Application".
    :vartype policy_inherited_from: str or ~azure.servicefabric.models.BackupPolicyScope
    :ivar suspension_info: Describes the backup suspension details.
    :vartype suspension_info: ~azure.servicefabric.models.BackupSuspensionInfo
    :ivar service_name: The full name of the service with 'fabric:' URI scheme.
    :vartype service_name: str
    :ivar partition_id: The partition ID identifying the partition.
    :vartype partition_id: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'policy_name': {'key': 'PolicyName', 'type': 'str'},
        'policy_inherited_from': {'key': 'PolicyInheritedFrom', 'type': 'str'},
        'suspension_info': {'key': 'SuspensionInfo', 'type': 'BackupSuspensionInfo'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword policy_name: The name of the backup policy which is applicable to this Service Fabric
         application or service or partition.
        :paramtype policy_name: str
        :keyword policy_inherited_from: Specifies the scope at which the backup policy is applied.
         Possible values include: "Invalid", "Partition", "Service", "Application".
        :paramtype policy_inherited_from: str or ~azure.servicefabric.models.BackupPolicyScope
        :keyword suspension_info: Describes the backup suspension details.
        :paramtype suspension_info: ~azure.servicefabric.models.BackupSuspensionInfo
        :keyword service_name: The full name of the service with 'fabric:' URI scheme.
        :paramtype service_name: str
        :keyword partition_id: The partition ID identifying the partition.
        :paramtype partition_id: str
        """
        super(PartitionBackupConfigurationInfo, self).__init__(**kwargs)
        self.kind = 'Partition'  # type: str
        self.service_name = kwargs.get('service_name', None)
        self.partition_id = kwargs.get('partition_id', None)


class PartitionBackupEntity(BackupEntity):
    """Identifies the Service Fabric stateful partition which is being backed up.

    All required parameters must be populated in order to send to Azure.

    :ivar entity_kind: Required. The entity type of a Service Fabric entity such as Application,
     Service or a Partition where periodic backups can be enabled.Constant filled by server.
     Possible values include: "Invalid", "Partition", "Service", "Application".
    :vartype entity_kind: str or ~azure.servicefabric.models.BackupEntityKind
    :ivar service_name: The full name of the service with 'fabric:' URI scheme.
    :vartype service_name: str
    :ivar partition_id: The partition ID identifying the partition.
    :vartype partition_id: str
    """

    _validation = {
        'entity_kind': {'required': True},
    }

    _attribute_map = {
        'entity_kind': {'key': 'EntityKind', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_name: The full name of the service with 'fabric:' URI scheme.
        :paramtype service_name: str
        :keyword partition_id: The partition ID identifying the partition.
        :paramtype partition_id: str
        """
        super(PartitionBackupEntity, self).__init__(**kwargs)
        self.entity_kind = 'Partition'  # type: str
        self.service_name = kwargs.get('service_name', None)
        self.partition_id = kwargs.get('partition_id', None)


class PartitionDataLossProgress(msrest.serialization.Model):
    """Information about a partition data loss user-induced operation.

    :ivar state: The state of the operation. Possible values include: "Invalid", "Running",
     "RollingBack", "Completed", "Faulted", "Cancelled", "ForceCancelled".
    :vartype state: str or ~azure.servicefabric.models.OperationState
    :ivar invoke_data_loss_result: Represents information about an operation in a terminal state
     (Completed or Faulted).
    :vartype invoke_data_loss_result: ~azure.servicefabric.models.InvokeDataLossResult
    """

    _attribute_map = {
        'state': {'key': 'State', 'type': 'str'},
        'invoke_data_loss_result': {'key': 'InvokeDataLossResult', 'type': 'InvokeDataLossResult'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword state: The state of the operation. Possible values include: "Invalid", "Running",
         "RollingBack", "Completed", "Faulted", "Cancelled", "ForceCancelled".
        :paramtype state: str or ~azure.servicefabric.models.OperationState
        :keyword invoke_data_loss_result: Represents information about an operation in a terminal state
         (Completed or Faulted).
        :paramtype invoke_data_loss_result: ~azure.servicefabric.models.InvokeDataLossResult
        """
        super(PartitionDataLossProgress, self).__init__(**kwargs)
        self.state = kwargs.get('state', None)
        self.invoke_data_loss_result = kwargs.get('invoke_data_loss_result', None)


class PartitionHealth(EntityHealth):
    """Information about the health of a Service Fabric partition.

    :ivar aggregated_health_state: The HealthState representing the aggregated health state of the
     entity computed by Health Manager.
     The health evaluation of the entity reflects all events reported on the entity and its
     children (if any).
     The aggregation is done by applying the desired health policy. Possible values include:
     "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar health_events: The list of health events reported on the entity.
    :vartype health_events: list[~azure.servicefabric.models.HealthEvent]
    :ivar unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
     health state was returned by Health Manager.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    :ivar health_statistics: Shows the health statistics for all children types of the queried
     entity.
    :vartype health_statistics: ~azure.servicefabric.models.HealthStatistics
    :ivar partition_id: ID of the partition whose health information is described by this object.
    :vartype partition_id: str
    :ivar replica_health_states: The list of replica health states associated with the partition.
    :vartype replica_health_states: list[~azure.servicefabric.models.ReplicaHealthState]
    """

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'health_events': {'key': 'HealthEvents', 'type': '[HealthEvent]'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
        'health_statistics': {'key': 'HealthStatistics', 'type': 'HealthStatistics'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_health_states': {'key': 'ReplicaHealthStates', 'type': '[ReplicaHealthState]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The HealthState representing the aggregated health state of
         the entity computed by Health Manager.
         The health evaluation of the entity reflects all events reported on the entity and its
         children (if any).
         The aggregation is done by applying the desired health policy. Possible values include:
         "Invalid", "Ok", "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword health_events: The list of health events reported on the entity.
        :paramtype health_events: list[~azure.servicefabric.models.HealthEvent]
        :keyword unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
         health state was returned by Health Manager.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        :keyword health_statistics: Shows the health statistics for all children types of the queried
         entity.
        :paramtype health_statistics: ~azure.servicefabric.models.HealthStatistics
        :keyword partition_id: ID of the partition whose health information is described by this
         object.
        :paramtype partition_id: str
        :keyword replica_health_states: The list of replica health states associated with the
         partition.
        :paramtype replica_health_states: list[~azure.servicefabric.models.ReplicaHealthState]
        """
        super(PartitionHealth, self).__init__(**kwargs)
        self.partition_id = kwargs.get('partition_id', None)
        self.replica_health_states = kwargs.get('replica_health_states', None)


class PartitionHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for a partition, containing information about the data and the algorithm used by health store to evaluate health. The evaluation is returned only when the aggregated health state is either Error or Warning.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar partition_id: Id of the partition whose health evaluation is described by this object.
    :vartype partition_id: str
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the current aggregated
     health state of the partition. The types of the unhealthy evaluations can be
     ReplicasHealthEvaluation or EventHealthEvaluation.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword partition_id: Id of the partition whose health evaluation is described by this object.
        :paramtype partition_id: str
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the current
         aggregated health state of the partition. The types of the unhealthy evaluations can be
         ReplicasHealthEvaluation or EventHealthEvaluation.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(PartitionHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'Partition'  # type: str
        self.partition_id = kwargs.get('partition_id', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class PartitionHealthReportExpiredEvent(PartitionEvent):
    """Partition Health Report Expired event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'partition_id': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(PartitionHealthReportExpiredEvent, self).__init__(**kwargs)
        self.kind = 'PartitionHealthReportExpired'  # type: str
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class PartitionHealthState(EntityHealthState):
    """Represents the health state of a partition, which contains the partition identifier and its aggregated health state.

    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar partition_id: Id of the partition whose health state is described by this object.
    :vartype partition_id: str
    """

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword partition_id: Id of the partition whose health state is described by this object.
        :paramtype partition_id: str
        """
        super(PartitionHealthState, self).__init__(**kwargs)
        self.partition_id = kwargs.get('partition_id', None)


class PartitionHealthStateChunk(EntityHealthStateChunk):
    """Represents the health state chunk of a partition, which contains the partition ID, its aggregated health state and any replicas that respect the filters in the cluster health chunk query description.

    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar partition_id: The Id of the partition.
    :vartype partition_id: str
    :ivar replica_health_state_chunks: The list of replica health state chunks belonging to the
     partition that respect the filters in the cluster health chunk query description.
    :vartype replica_health_state_chunks: ~azure.servicefabric.models.ReplicaHealthStateChunkList
    """

    _attribute_map = {
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_health_state_chunks': {'key': 'ReplicaHealthStateChunks', 'type': 'ReplicaHealthStateChunkList'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword partition_id: The Id of the partition.
        :paramtype partition_id: str
        :keyword replica_health_state_chunks: The list of replica health state chunks belonging to the
         partition that respect the filters in the cluster health chunk query description.
        :paramtype replica_health_state_chunks: ~azure.servicefabric.models.ReplicaHealthStateChunkList
        """
        super(PartitionHealthStateChunk, self).__init__(**kwargs)
        self.partition_id = kwargs.get('partition_id', None)
        self.replica_health_state_chunks = kwargs.get('replica_health_state_chunks', None)


class PartitionHealthStateChunkList(msrest.serialization.Model):
    """The list of partition health state chunks that respect the input filters in the chunk query description.
Returned by get cluster health state chunks query as part of the parent application hierarchy.

    :ivar items: The list of partition health state chunks that respect the input filters in the
     chunk query.
    :vartype items: list[~azure.servicefabric.models.PartitionHealthStateChunk]
    """

    _attribute_map = {
        'items': {'key': 'Items', 'type': '[PartitionHealthStateChunk]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword items: The list of partition health state chunks that respect the input filters in the
         chunk query.
        :paramtype items: list[~azure.servicefabric.models.PartitionHealthStateChunk]
        """
        super(PartitionHealthStateChunkList, self).__init__(**kwargs)
        self.items = kwargs.get('items', None)


class PartitionHealthStateFilter(msrest.serialization.Model):
    """Defines matching criteria to determine whether a partition should be included as a child of a service in the cluster health chunk.
The partitions are only returned if the parent entities match a filter specified in the cluster health chunk query description. The parent service and application must be included in the cluster health chunk.
One filter can match zero, one or multiple partitions, depending on its properties.

    :ivar partition_id_filter: ID of the partition that matches the filter. The filter is applied
     only to the specified partition, if it exists.
     If the partition doesn't exist, no partition is returned in the cluster health chunk based on
     this filter.
     If the partition exists, it is included in the cluster health chunk if it respects the other
     filter properties.
     If not specified, all partitions that match the parent filters (if any) are taken into
     consideration and matched against the other filter members, like health state filter.
    :vartype partition_id_filter: str
    :ivar health_state_filter: The filter for the health state of the partitions. It allows
     selecting partitions if they match the desired health states.
     The possible values are integer value of one of the following health states. Only partitions
     that match the filter are returned. All partitions are used to evaluate the cluster aggregated
     health state.
     If not specified, default value is None, unless the partition ID is specified. If the filter
     has default value and partition ID is specified, the matching partition is returned.
     The state values are flag-based enumeration, so the value could be a combination of these
     values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6, it matches partitions with HealthState value of OK
     (2) and Warning (4).
    
    
     * Default - Default value. Matches any HealthState. The value is zero.
     * None - Filter that doesn't match any HealthState value. Used in order to return no results
     on a given collection of states. The value is 1.
     * Ok - Filter that matches input with HealthState value Ok. The value is 2.
     * Warning - Filter that matches input with HealthState value Warning. The value is 4.
     * Error - Filter that matches input with HealthState value Error. The value is 8.
     * All - Filter that matches input with any HealthState value. The value is 65535.
    :vartype health_state_filter: int
    :ivar replica_filters: Defines a list of filters that specify which replicas to be included in
     the returned cluster health chunk as children of the parent partition. The replicas are
     returned only if the parent partition matches a filter.
     If the list is empty, no replicas are returned. All the replicas are used to evaluate the
     parent partition aggregated health state, regardless of the input filters.
     The partition filter may specify multiple replica filters.
     For example, it can specify a filter to return all replicas with health state Error and
     another filter to always include a replica identified by its replica id.
    :vartype replica_filters: list[~azure.servicefabric.models.ReplicaHealthStateFilter]
    """

    _attribute_map = {
        'partition_id_filter': {'key': 'PartitionIdFilter', 'type': 'str'},
        'health_state_filter': {'key': 'HealthStateFilter', 'type': 'int'},
        'replica_filters': {'key': 'ReplicaFilters', 'type': '[ReplicaHealthStateFilter]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword partition_id_filter: ID of the partition that matches the filter. The filter is
         applied only to the specified partition, if it exists.
         If the partition doesn't exist, no partition is returned in the cluster health chunk based on
         this filter.
         If the partition exists, it is included in the cluster health chunk if it respects the other
         filter properties.
         If not specified, all partitions that match the parent filters (if any) are taken into
         consideration and matched against the other filter members, like health state filter.
        :paramtype partition_id_filter: str
        :keyword health_state_filter: The filter for the health state of the partitions. It allows
         selecting partitions if they match the desired health states.
         The possible values are integer value of one of the following health states. Only partitions
         that match the filter are returned. All partitions are used to evaluate the cluster aggregated
         health state.
         If not specified, default value is None, unless the partition ID is specified. If the filter
         has default value and partition ID is specified, the matching partition is returned.
         The state values are flag-based enumeration, so the value could be a combination of these
         values obtained using bitwise 'OR' operator.
         For example, if the provided value is 6, it matches partitions with HealthState value of OK
         (2) and Warning (4).
        
        
         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535.
        :paramtype health_state_filter: int
        :keyword replica_filters: Defines a list of filters that specify which replicas to be included
         in the returned cluster health chunk as children of the parent partition. The replicas are
         returned only if the parent partition matches a filter.
         If the list is empty, no replicas are returned. All the replicas are used to evaluate the
         parent partition aggregated health state, regardless of the input filters.
         The partition filter may specify multiple replica filters.
         For example, it can specify a filter to return all replicas with health state Error and
         another filter to always include a replica identified by its replica id.
        :paramtype replica_filters: list[~azure.servicefabric.models.ReplicaHealthStateFilter]
        """
        super(PartitionHealthStateFilter, self).__init__(**kwargs)
        self.partition_id_filter = kwargs.get('partition_id_filter', None)
        self.health_state_filter = kwargs.get('health_state_filter', 0)
        self.replica_filters = kwargs.get('replica_filters', None)


class PartitionInstanceCountScaleMechanism(ScalingMechanismDescription):
    """Represents a scaling mechanism for adding or removing instances of stateless service partition.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. Specifies the kind of scaling mechanism.Constant filled by server.
     Possible values include: "Invalid", "PartitionInstanceCount",
     "AddRemoveIncrementalNamedPartition".
    :vartype kind: str or ~azure.servicefabric.models.ScalingMechanismKind
    :ivar min_instance_count: Required. Minimum number of instances of the partition.
    :vartype min_instance_count: int
    :ivar max_instance_count: Required. Maximum number of instances of the partition.
    :vartype max_instance_count: int
    :ivar scale_increment: Required. The number of instances to add or remove during a scaling
     operation.
    :vartype scale_increment: int
    """

    _validation = {
        'kind': {'required': True},
        'min_instance_count': {'required': True},
        'max_instance_count': {'required': True},
        'scale_increment': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'min_instance_count': {'key': 'MinInstanceCount', 'type': 'int'},
        'max_instance_count': {'key': 'MaxInstanceCount', 'type': 'int'},
        'scale_increment': {'key': 'ScaleIncrement', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword min_instance_count: Required. Minimum number of instances of the partition.
        :paramtype min_instance_count: int
        :keyword max_instance_count: Required. Maximum number of instances of the partition.
        :paramtype max_instance_count: int
        :keyword scale_increment: Required. The number of instances to add or remove during a scaling
         operation.
        :paramtype scale_increment: int
        """
        super(PartitionInstanceCountScaleMechanism, self).__init__(**kwargs)
        self.kind = 'PartitionInstanceCount'  # type: str
        self.min_instance_count = kwargs['min_instance_count']
        self.max_instance_count = kwargs['max_instance_count']
        self.scale_increment = kwargs['scale_increment']


class PartitionLoadInformation(msrest.serialization.Model):
    """Represents load information for a partition, which contains the primary, secondary and auxiliary reported load metrics.
In case there is no load reported, PartitionLoadInformation will contain the default load for the service of the partition.
For default loads, LoadMetricReport's LastReportedUtc is set to 0.

    :ivar partition_id: Id of the partition.
    :vartype partition_id: str
    :ivar primary_load_metric_reports: Array of load reports from the primary replica for this
     partition.
    :vartype primary_load_metric_reports: list[~azure.servicefabric.models.LoadMetricReport]
    :ivar secondary_load_metric_reports: Array of aggregated load reports from all secondary
     replicas for this partition.
     Array only contains the latest reported load for each metric.
    :vartype secondary_load_metric_reports: list[~azure.servicefabric.models.LoadMetricReport]
    :ivar auxiliary_load_metric_reports: Array of aggregated load reports from all auxiliary
     replicas for this partition.
     Array only contains the latest reported load for each metric.
    :vartype auxiliary_load_metric_reports: list[~azure.servicefabric.models.LoadMetricReport]
    """

    _attribute_map = {
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'primary_load_metric_reports': {'key': 'PrimaryLoadMetricReports', 'type': '[LoadMetricReport]'},
        'secondary_load_metric_reports': {'key': 'SecondaryLoadMetricReports', 'type': '[LoadMetricReport]'},
        'auxiliary_load_metric_reports': {'key': 'AuxiliaryLoadMetricReports', 'type': '[LoadMetricReport]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword partition_id: Id of the partition.
        :paramtype partition_id: str
        :keyword primary_load_metric_reports: Array of load reports from the primary replica for this
         partition.
        :paramtype primary_load_metric_reports: list[~azure.servicefabric.models.LoadMetricReport]
        :keyword secondary_load_metric_reports: Array of aggregated load reports from all secondary
         replicas for this partition.
         Array only contains the latest reported load for each metric.
        :paramtype secondary_load_metric_reports: list[~azure.servicefabric.models.LoadMetricReport]
        :keyword auxiliary_load_metric_reports: Array of aggregated load reports from all auxiliary
         replicas for this partition.
         Array only contains the latest reported load for each metric.
        :paramtype auxiliary_load_metric_reports: list[~azure.servicefabric.models.LoadMetricReport]
        """
        super(PartitionLoadInformation, self).__init__(**kwargs)
        self.partition_id = kwargs.get('partition_id', None)
        self.primary_load_metric_reports = kwargs.get('primary_load_metric_reports', None)
        self.secondary_load_metric_reports = kwargs.get('secondary_load_metric_reports', None)
        self.auxiliary_load_metric_reports = kwargs.get('auxiliary_load_metric_reports', None)


class PartitionMetricLoadDescription(msrest.serialization.Model):
    """Represents load information for a partition, which contains the metrics load information about primary, all secondary replicas/instances or a specific secondary replica/instance on a specific node , all auxiliary replicas or a specific auxiliary replica on a specific node.

    :ivar partition_id: Id of the partition.
    :vartype partition_id: str
    :ivar primary_replica_load_entries: Partition's load information for primary replica, in case
     partition is from a stateful service.
    :vartype primary_replica_load_entries: list[~azure.servicefabric.models.MetricLoadDescription]
    :ivar secondary_replicas_or_instances_load_entries: Partition's load information for all
     secondary replicas or instances.
    :vartype secondary_replicas_or_instances_load_entries:
     list[~azure.servicefabric.models.MetricLoadDescription]
    :ivar secondary_replica_or_instance_load_entries_per_node: Partition's load information for a
     specific secondary replica or instance located on a specific node.
    :vartype secondary_replica_or_instance_load_entries_per_node:
     list[~azure.servicefabric.models.ReplicaMetricLoadDescription]
    :ivar auxiliary_replicas_load_entries: Partition's load information for all auxiliary replicas.
    :vartype auxiliary_replicas_load_entries:
     list[~azure.servicefabric.models.MetricLoadDescription]
    :ivar auxiliary_replica_load_entries_per_node: Partition's load information for a specific
     auxiliary replica located on a specific node.
    :vartype auxiliary_replica_load_entries_per_node:
     list[~azure.servicefabric.models.ReplicaMetricLoadDescription]
    """

    _attribute_map = {
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'primary_replica_load_entries': {'key': 'PrimaryReplicaLoadEntries', 'type': '[MetricLoadDescription]'},
        'secondary_replicas_or_instances_load_entries': {'key': 'SecondaryReplicasOrInstancesLoadEntries', 'type': '[MetricLoadDescription]'},
        'secondary_replica_or_instance_load_entries_per_node': {'key': 'SecondaryReplicaOrInstanceLoadEntriesPerNode', 'type': '[ReplicaMetricLoadDescription]'},
        'auxiliary_replicas_load_entries': {'key': 'AuxiliaryReplicasLoadEntries', 'type': '[MetricLoadDescription]'},
        'auxiliary_replica_load_entries_per_node': {'key': 'AuxiliaryReplicaLoadEntriesPerNode', 'type': '[ReplicaMetricLoadDescription]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword partition_id: Id of the partition.
        :paramtype partition_id: str
        :keyword primary_replica_load_entries: Partition's load information for primary replica, in
         case partition is from a stateful service.
        :paramtype primary_replica_load_entries:
         list[~azure.servicefabric.models.MetricLoadDescription]
        :keyword secondary_replicas_or_instances_load_entries: Partition's load information for all
         secondary replicas or instances.
        :paramtype secondary_replicas_or_instances_load_entries:
         list[~azure.servicefabric.models.MetricLoadDescription]
        :keyword secondary_replica_or_instance_load_entries_per_node: Partition's load information for
         a specific secondary replica or instance located on a specific node.
        :paramtype secondary_replica_or_instance_load_entries_per_node:
         list[~azure.servicefabric.models.ReplicaMetricLoadDescription]
        :keyword auxiliary_replicas_load_entries: Partition's load information for all auxiliary
         replicas.
        :paramtype auxiliary_replicas_load_entries:
         list[~azure.servicefabric.models.MetricLoadDescription]
        :keyword auxiliary_replica_load_entries_per_node: Partition's load information for a specific
         auxiliary replica located on a specific node.
        :paramtype auxiliary_replica_load_entries_per_node:
         list[~azure.servicefabric.models.ReplicaMetricLoadDescription]
        """
        super(PartitionMetricLoadDescription, self).__init__(**kwargs)
        self.partition_id = kwargs.get('partition_id', None)
        self.primary_replica_load_entries = kwargs.get('primary_replica_load_entries', None)
        self.secondary_replicas_or_instances_load_entries = kwargs.get('secondary_replicas_or_instances_load_entries', None)
        self.secondary_replica_or_instance_load_entries_per_node = kwargs.get('secondary_replica_or_instance_load_entries_per_node', None)
        self.auxiliary_replicas_load_entries = kwargs.get('auxiliary_replicas_load_entries', None)
        self.auxiliary_replica_load_entries_per_node = kwargs.get('auxiliary_replica_load_entries_per_node', None)


class PartitionNewHealthReportEvent(PartitionEvent):
    """Partition Health Report Created event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'partition_id': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(PartitionNewHealthReportEvent, self).__init__(**kwargs)
        self.kind = 'PartitionNewHealthReport'  # type: str
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class PartitionPrimaryMoveAnalysisEvent(PartitionAnalysisEvent):
    """Partition Primary Move Analysis event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar metadata: Required. Metadata about an Analysis Event.
    :vartype metadata: ~azure.servicefabric.models.AnalysisEventMetadata
    :ivar when_move_completed: Required. Time when the move was completed.
    :vartype when_move_completed: ~datetime.datetime
    :ivar previous_node: Required. The name of a Service Fabric node.
    :vartype previous_node: str
    :ivar current_node: Required. The name of a Service Fabric node.
    :vartype current_node: str
    :ivar move_reason: Required. Move reason.
    :vartype move_reason: str
    :ivar relevant_traces: Required. Relevant traces.
    :vartype relevant_traces: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'partition_id': {'required': True},
        'metadata': {'required': True},
        'when_move_completed': {'required': True},
        'previous_node': {'required': True},
        'current_node': {'required': True},
        'move_reason': {'required': True},
        'relevant_traces': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'metadata': {'key': 'Metadata', 'type': 'AnalysisEventMetadata'},
        'when_move_completed': {'key': 'WhenMoveCompleted', 'type': 'iso-8601'},
        'previous_node': {'key': 'PreviousNode', 'type': 'str'},
        'current_node': {'key': 'CurrentNode', 'type': 'str'},
        'move_reason': {'key': 'MoveReason', 'type': 'str'},
        'relevant_traces': {'key': 'RelevantTraces', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword metadata: Required. Metadata about an Analysis Event.
        :paramtype metadata: ~azure.servicefabric.models.AnalysisEventMetadata
        :keyword when_move_completed: Required. Time when the move was completed.
        :paramtype when_move_completed: ~datetime.datetime
        :keyword previous_node: Required. The name of a Service Fabric node.
        :paramtype previous_node: str
        :keyword current_node: Required. The name of a Service Fabric node.
        :paramtype current_node: str
        :keyword move_reason: Required. Move reason.
        :paramtype move_reason: str
        :keyword relevant_traces: Required. Relevant traces.
        :paramtype relevant_traces: str
        """
        super(PartitionPrimaryMoveAnalysisEvent, self).__init__(**kwargs)
        self.kind = 'PartitionPrimaryMoveAnalysis'  # type: str
        self.when_move_completed = kwargs['when_move_completed']
        self.previous_node = kwargs['previous_node']
        self.current_node = kwargs['current_node']
        self.move_reason = kwargs['move_reason']
        self.relevant_traces = kwargs['relevant_traces']


class PartitionQuorumLossProgress(msrest.serialization.Model):
    """Information about a partition quorum loss user-induced operation.

    :ivar state: The state of the operation. Possible values include: "Invalid", "Running",
     "RollingBack", "Completed", "Faulted", "Cancelled", "ForceCancelled".
    :vartype state: str or ~azure.servicefabric.models.OperationState
    :ivar invoke_quorum_loss_result: Represents information about an operation in a terminal state
     (Completed or Faulted).
    :vartype invoke_quorum_loss_result: ~azure.servicefabric.models.InvokeQuorumLossResult
    """

    _attribute_map = {
        'state': {'key': 'State', 'type': 'str'},
        'invoke_quorum_loss_result': {'key': 'InvokeQuorumLossResult', 'type': 'InvokeQuorumLossResult'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword state: The state of the operation. Possible values include: "Invalid", "Running",
         "RollingBack", "Completed", "Faulted", "Cancelled", "ForceCancelled".
        :paramtype state: str or ~azure.servicefabric.models.OperationState
        :keyword invoke_quorum_loss_result: Represents information about an operation in a terminal
         state (Completed or Faulted).
        :paramtype invoke_quorum_loss_result: ~azure.servicefabric.models.InvokeQuorumLossResult
        """
        super(PartitionQuorumLossProgress, self).__init__(**kwargs)
        self.state = kwargs.get('state', None)
        self.invoke_quorum_loss_result = kwargs.get('invoke_quorum_loss_result', None)


class PartitionReconfiguredEvent(PartitionEvent):
    """Partition Reconfiguration event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar node_name: Required. The name of a Service Fabric node.
    :vartype node_name: str
    :ivar node_instance_id: Required. Id of Node instance.
    :vartype node_instance_id: str
    :ivar service_type: Required. Type of Service.
    :vartype service_type: str
    :ivar cc_epoch_data_loss_version: Required. CcEpochDataLoss version.
    :vartype cc_epoch_data_loss_version: long
    :ivar cc_epoch_config_version: Required. CcEpochConfig version.
    :vartype cc_epoch_config_version: long
    :ivar reconfig_type: Required. Type of reconfiguration.
    :vartype reconfig_type: str
    :ivar result: Required. Describes reconfiguration result.
    :vartype result: str
    :ivar phase0_duration_ms: Required. Duration of Phase0 in milli-seconds.
    :vartype phase0_duration_ms: float
    :ivar phase1_duration_ms: Required. Duration of Phase1 in milli-seconds.
    :vartype phase1_duration_ms: float
    :ivar phase2_duration_ms: Required. Duration of Phase2 in milli-seconds.
    :vartype phase2_duration_ms: float
    :ivar phase3_duration_ms: Required. Duration of Phase3 in milli-seconds.
    :vartype phase3_duration_ms: float
    :ivar phase4_duration_ms: Required. Duration of Phase4 in milli-seconds.
    :vartype phase4_duration_ms: float
    :ivar total_duration_ms: Required. Total duration in milli-seconds.
    :vartype total_duration_ms: float
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'partition_id': {'required': True},
        'node_name': {'required': True},
        'node_instance_id': {'required': True},
        'service_type': {'required': True},
        'cc_epoch_data_loss_version': {'required': True},
        'cc_epoch_config_version': {'required': True},
        'reconfig_type': {'required': True},
        'result': {'required': True},
        'phase0_duration_ms': {'required': True},
        'phase1_duration_ms': {'required': True},
        'phase2_duration_ms': {'required': True},
        'phase3_duration_ms': {'required': True},
        'phase4_duration_ms': {'required': True},
        'total_duration_ms': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'node_instance_id': {'key': 'NodeInstanceId', 'type': 'str'},
        'service_type': {'key': 'ServiceType', 'type': 'str'},
        'cc_epoch_data_loss_version': {'key': 'CcEpochDataLossVersion', 'type': 'long'},
        'cc_epoch_config_version': {'key': 'CcEpochConfigVersion', 'type': 'long'},
        'reconfig_type': {'key': 'ReconfigType', 'type': 'str'},
        'result': {'key': 'Result', 'type': 'str'},
        'phase0_duration_ms': {'key': 'Phase0DurationMs', 'type': 'float'},
        'phase1_duration_ms': {'key': 'Phase1DurationMs', 'type': 'float'},
        'phase2_duration_ms': {'key': 'Phase2DurationMs', 'type': 'float'},
        'phase3_duration_ms': {'key': 'Phase3DurationMs', 'type': 'float'},
        'phase4_duration_ms': {'key': 'Phase4DurationMs', 'type': 'float'},
        'total_duration_ms': {'key': 'TotalDurationMs', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword node_name: Required. The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword node_instance_id: Required. Id of Node instance.
        :paramtype node_instance_id: str
        :keyword service_type: Required. Type of Service.
        :paramtype service_type: str
        :keyword cc_epoch_data_loss_version: Required. CcEpochDataLoss version.
        :paramtype cc_epoch_data_loss_version: long
        :keyword cc_epoch_config_version: Required. CcEpochConfig version.
        :paramtype cc_epoch_config_version: long
        :keyword reconfig_type: Required. Type of reconfiguration.
        :paramtype reconfig_type: str
        :keyword result: Required. Describes reconfiguration result.
        :paramtype result: str
        :keyword phase0_duration_ms: Required. Duration of Phase0 in milli-seconds.
        :paramtype phase0_duration_ms: float
        :keyword phase1_duration_ms: Required. Duration of Phase1 in milli-seconds.
        :paramtype phase1_duration_ms: float
        :keyword phase2_duration_ms: Required. Duration of Phase2 in milli-seconds.
        :paramtype phase2_duration_ms: float
        :keyword phase3_duration_ms: Required. Duration of Phase3 in milli-seconds.
        :paramtype phase3_duration_ms: float
        :keyword phase4_duration_ms: Required. Duration of Phase4 in milli-seconds.
        :paramtype phase4_duration_ms: float
        :keyword total_duration_ms: Required. Total duration in milli-seconds.
        :paramtype total_duration_ms: float
        """
        super(PartitionReconfiguredEvent, self).__init__(**kwargs)
        self.kind = 'PartitionReconfigured'  # type: str
        self.node_name = kwargs['node_name']
        self.node_instance_id = kwargs['node_instance_id']
        self.service_type = kwargs['service_type']
        self.cc_epoch_data_loss_version = kwargs['cc_epoch_data_loss_version']
        self.cc_epoch_config_version = kwargs['cc_epoch_config_version']
        self.reconfig_type = kwargs['reconfig_type']
        self.result = kwargs['result']
        self.phase0_duration_ms = kwargs['phase0_duration_ms']
        self.phase1_duration_ms = kwargs['phase1_duration_ms']
        self.phase2_duration_ms = kwargs['phase2_duration_ms']
        self.phase3_duration_ms = kwargs['phase3_duration_ms']
        self.phase4_duration_ms = kwargs['phase4_duration_ms']
        self.total_duration_ms = kwargs['total_duration_ms']


class PartitionRestartProgress(msrest.serialization.Model):
    """Information about a partition restart user-induced operation.

    :ivar state: The state of the operation. Possible values include: "Invalid", "Running",
     "RollingBack", "Completed", "Faulted", "Cancelled", "ForceCancelled".
    :vartype state: str or ~azure.servicefabric.models.OperationState
    :ivar restart_partition_result: Represents information about an operation in a terminal state
     (Completed or Faulted).
    :vartype restart_partition_result: ~azure.servicefabric.models.RestartPartitionResult
    """

    _attribute_map = {
        'state': {'key': 'State', 'type': 'str'},
        'restart_partition_result': {'key': 'RestartPartitionResult', 'type': 'RestartPartitionResult'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword state: The state of the operation. Possible values include: "Invalid", "Running",
         "RollingBack", "Completed", "Faulted", "Cancelled", "ForceCancelled".
        :paramtype state: str or ~azure.servicefabric.models.OperationState
        :keyword restart_partition_result: Represents information about an operation in a terminal
         state (Completed or Faulted).
        :paramtype restart_partition_result: ~azure.servicefabric.models.RestartPartitionResult
        """
        super(PartitionRestartProgress, self).__init__(**kwargs)
        self.state = kwargs.get('state', None)
        self.restart_partition_result = kwargs.get('restart_partition_result', None)


class PartitionsHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for the partitions of a service, containing health evaluations for each unhealthy partition that impacts current aggregated health state. Can be returned when evaluating service health and the aggregated health state is either Error or Warning.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar max_percent_unhealthy_partitions_per_service: Maximum allowed percentage of unhealthy
     partitions per service from the ServiceTypeHealthPolicy.
    :vartype max_percent_unhealthy_partitions_per_service: int
    :ivar total_count: Total number of partitions of the service from the health store.
    :vartype total_count: long
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
     state. Includes all the unhealthy PartitionHealthEvaluation that impacted the aggregated
     health.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'max_percent_unhealthy_partitions_per_service': {'key': 'MaxPercentUnhealthyPartitionsPerService', 'type': 'int'},
        'total_count': {'key': 'TotalCount', 'type': 'long'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword max_percent_unhealthy_partitions_per_service: Maximum allowed percentage of unhealthy
         partitions per service from the ServiceTypeHealthPolicy.
        :paramtype max_percent_unhealthy_partitions_per_service: int
        :keyword total_count: Total number of partitions of the service from the health store.
        :paramtype total_count: long
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
         state. Includes all the unhealthy PartitionHealthEvaluation that impacted the aggregated
         health.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(PartitionsHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'Partitions'  # type: str
        self.max_percent_unhealthy_partitions_per_service = kwargs.get('max_percent_unhealthy_partitions_per_service', None)
        self.total_count = kwargs.get('total_count', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class ReplicatorStatus(msrest.serialization.Model):
    """Represents a base class for primary or secondary replicator status.
Contains information about the service fabric replicator like the replication/copy queue utilization, last acknowledgement received timestamp, etc.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: PrimaryReplicatorStatus, SecondaryReplicatorStatus.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The role of a replica of a stateful service.Constant filled by server.
     Possible values include: "Unknown", "None", "Primary", "IdleSecondary", "ActiveSecondary",
     "IdleAuxiliary", "ActiveAuxiliary", "PrimaryAuxiliary".
    :vartype kind: str or ~azure.servicefabric.models.ReplicaRole
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'Primary': 'PrimaryReplicatorStatus', 'SecondaryReplicatorStatus': 'SecondaryReplicatorStatus'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(ReplicatorStatus, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]


class PrimaryReplicatorStatus(ReplicatorStatus):
    """Provides statistics about the Service Fabric Replicator, when it is functioning in a Primary role.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The role of a replica of a stateful service.Constant filled by server.
     Possible values include: "Unknown", "None", "Primary", "IdleSecondary", "ActiveSecondary",
     "IdleAuxiliary", "ActiveAuxiliary", "PrimaryAuxiliary".
    :vartype kind: str or ~azure.servicefabric.models.ReplicaRole
    :ivar replication_queue_status: Details about the replication queue on the primary replicator.
    :vartype replication_queue_status: ~azure.servicefabric.models.ReplicatorQueueStatus
    :ivar remote_replicators: The status of all the active and idle secondary replicators that the
     primary is aware of.
    :vartype remote_replicators: list[~azure.servicefabric.models.RemoteReplicatorStatus]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'replication_queue_status': {'key': 'ReplicationQueueStatus', 'type': 'ReplicatorQueueStatus'},
        'remote_replicators': {'key': 'RemoteReplicators', 'type': '[RemoteReplicatorStatus]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword replication_queue_status: Details about the replication queue on the primary
         replicator.
        :paramtype replication_queue_status: ~azure.servicefabric.models.ReplicatorQueueStatus
        :keyword remote_replicators: The status of all the active and idle secondary replicators that
         the primary is aware of.
        :paramtype remote_replicators: list[~azure.servicefabric.models.RemoteReplicatorStatus]
        """
        super(PrimaryReplicatorStatus, self).__init__(**kwargs)
        self.kind = 'Primary'  # type: str
        self.replication_queue_status = kwargs.get('replication_queue_status', None)
        self.remote_replicators = kwargs.get('remote_replicators', None)


class Probe(msrest.serialization.Model):
    """Probes have a number of fields that you can use to control their behavior.

    :ivar initial_delay_seconds: The initial delay in seconds to start executing probe once
     codepackage has started.
    :vartype initial_delay_seconds: int
    :ivar period_seconds: Periodic seconds to execute probe.
    :vartype period_seconds: int
    :ivar timeout_seconds: Period after which probe is considered as failed if it hasn't completed
     successfully.
    :vartype timeout_seconds: int
    :ivar success_threshold: The count of successful probe executions after which probe is
     considered success.
    :vartype success_threshold: int
    :ivar failure_threshold: The count of failures after which probe is considered failed.
    :vartype failure_threshold: int
    :ivar exec_property: Exec command to run inside the container.
    :vartype exec_property: ~azure.servicefabric.models.ProbeExec
    :ivar http_get: Http probe for the container.
    :vartype http_get: ~azure.servicefabric.models.ProbeHttpGet
    :ivar tcp_socket: Tcp port to probe inside the container.
    :vartype tcp_socket: ~azure.servicefabric.models.ProbeTcpSocket
    """

    _attribute_map = {
        'initial_delay_seconds': {'key': 'initialDelaySeconds', 'type': 'int'},
        'period_seconds': {'key': 'periodSeconds', 'type': 'int'},
        'timeout_seconds': {'key': 'timeoutSeconds', 'type': 'int'},
        'success_threshold': {'key': 'successThreshold', 'type': 'int'},
        'failure_threshold': {'key': 'failureThreshold', 'type': 'int'},
        'exec_property': {'key': 'exec', 'type': 'ProbeExec'},
        'http_get': {'key': 'httpGet', 'type': 'ProbeHttpGet'},
        'tcp_socket': {'key': 'tcpSocket', 'type': 'ProbeTcpSocket'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword initial_delay_seconds: The initial delay in seconds to start executing probe once
         codepackage has started.
        :paramtype initial_delay_seconds: int
        :keyword period_seconds: Periodic seconds to execute probe.
        :paramtype period_seconds: int
        :keyword timeout_seconds: Period after which probe is considered as failed if it hasn't
         completed successfully.
        :paramtype timeout_seconds: int
        :keyword success_threshold: The count of successful probe executions after which probe is
         considered success.
        :paramtype success_threshold: int
        :keyword failure_threshold: The count of failures after which probe is considered failed.
        :paramtype failure_threshold: int
        :keyword exec_property: Exec command to run inside the container.
        :paramtype exec_property: ~azure.servicefabric.models.ProbeExec
        :keyword http_get: Http probe for the container.
        :paramtype http_get: ~azure.servicefabric.models.ProbeHttpGet
        :keyword tcp_socket: Tcp port to probe inside the container.
        :paramtype tcp_socket: ~azure.servicefabric.models.ProbeTcpSocket
        """
        super(Probe, self).__init__(**kwargs)
        self.initial_delay_seconds = kwargs.get('initial_delay_seconds', 0)
        self.period_seconds = kwargs.get('period_seconds', 10)
        self.timeout_seconds = kwargs.get('timeout_seconds', 1)
        self.success_threshold = kwargs.get('success_threshold', 1)
        self.failure_threshold = kwargs.get('failure_threshold', 3)
        self.exec_property = kwargs.get('exec_property', None)
        self.http_get = kwargs.get('http_get', None)
        self.tcp_socket = kwargs.get('tcp_socket', None)


class ProbeExec(msrest.serialization.Model):
    """Exec command to run inside the container.

    All required parameters must be populated in order to send to Azure.

    :ivar command: Required. Comma separated command to run inside the container for example "sh,
     -c, echo hello world".
    :vartype command: str
    """

    _validation = {
        'command': {'required': True},
    }

    _attribute_map = {
        'command': {'key': 'command', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword command: Required. Comma separated command to run inside the container for example
         "sh, -c, echo hello world".
        :paramtype command: str
        """
        super(ProbeExec, self).__init__(**kwargs)
        self.command = kwargs['command']


class ProbeHttpGet(msrest.serialization.Model):
    """Http probe for the container.

    All required parameters must be populated in order to send to Azure.

    :ivar port: Required. Port to access for probe.
    :vartype port: int
    :ivar path: Path to access on the HTTP request.
    :vartype path: str
    :ivar host: Host IP to connect to.
    :vartype host: str
    :ivar http_headers: Headers to set in the request.
    :vartype http_headers: list[~azure.servicefabric.models.ProbeHttpGetHeaders]
    :ivar scheme: Scheme for the http probe. Can be Http or Https. Possible values include: "http",
     "https".
    :vartype scheme: str or ~azure.servicefabric.models.Scheme
    """

    _validation = {
        'port': {'required': True},
    }

    _attribute_map = {
        'port': {'key': 'port', 'type': 'int'},
        'path': {'key': 'path', 'type': 'str'},
        'host': {'key': 'host', 'type': 'str'},
        'http_headers': {'key': 'httpHeaders', 'type': '[ProbeHttpGetHeaders]'},
        'scheme': {'key': 'scheme', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword port: Required. Port to access for probe.
        :paramtype port: int
        :keyword path: Path to access on the HTTP request.
        :paramtype path: str
        :keyword host: Host IP to connect to.
        :paramtype host: str
        :keyword http_headers: Headers to set in the request.
        :paramtype http_headers: list[~azure.servicefabric.models.ProbeHttpGetHeaders]
        :keyword scheme: Scheme for the http probe. Can be Http or Https. Possible values include:
         "http", "https".
        :paramtype scheme: str or ~azure.servicefabric.models.Scheme
        """
        super(ProbeHttpGet, self).__init__(**kwargs)
        self.port = kwargs['port']
        self.path = kwargs.get('path', None)
        self.host = kwargs.get('host', None)
        self.http_headers = kwargs.get('http_headers', None)
        self.scheme = kwargs.get('scheme', None)


class ProbeHttpGetHeaders(msrest.serialization.Model):
    """Http headers.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name of the header.
    :vartype name: str
    :ivar value: Required. The value of the header.
    :vartype value: str
    """

    _validation = {
        'name': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. The name of the header.
        :paramtype name: str
        :keyword value: Required. The value of the header.
        :paramtype value: str
        """
        super(ProbeHttpGetHeaders, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.value = kwargs['value']


class ProbeTcpSocket(msrest.serialization.Model):
    """Tcp port to probe inside the container.

    All required parameters must be populated in order to send to Azure.

    :ivar port: Required. Port to access for probe.
    :vartype port: int
    """

    _validation = {
        'port': {'required': True},
    }

    _attribute_map = {
        'port': {'key': 'port', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword port: Required. Port to access for probe.
        :paramtype port: int
        """
        super(ProbeTcpSocket, self).__init__(**kwargs)
        self.port = kwargs['port']


class PropertyBatchDescriptionList(msrest.serialization.Model):
    """Describes a list of property batch operations to be executed. Either all or none of the operations will be committed.

    :ivar operations: A list of the property batch operations to be executed.
    :vartype operations: list[~azure.servicefabric.models.PropertyBatchOperation]
    """

    _attribute_map = {
        'operations': {'key': 'Operations', 'type': '[PropertyBatchOperation]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword operations: A list of the property batch operations to be executed.
        :paramtype operations: list[~azure.servicefabric.models.PropertyBatchOperation]
        """
        super(PropertyBatchDescriptionList, self).__init__(**kwargs)
        self.operations = kwargs.get('operations', None)


class PropertyDescription(msrest.serialization.Model):
    """Description of a Service Fabric property.

    All required parameters must be populated in order to send to Azure.

    :ivar property_name: Required. The name of the Service Fabric property.
    :vartype property_name: str
    :ivar custom_type_id: The property's custom type ID. Using this property, the user is able to
     tag the type of the value of the property.
    :vartype custom_type_id: str
    :ivar value: Required. Describes a Service Fabric property value.
    :vartype value: ~azure.servicefabric.models.PropertyValue
    """

    _validation = {
        'property_name': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'property_name': {'key': 'PropertyName', 'type': 'str'},
        'custom_type_id': {'key': 'CustomTypeId', 'type': 'str'},
        'value': {'key': 'Value', 'type': 'PropertyValue'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword property_name: Required. The name of the Service Fabric property.
        :paramtype property_name: str
        :keyword custom_type_id: The property's custom type ID. Using this property, the user is able
         to tag the type of the value of the property.
        :paramtype custom_type_id: str
        :keyword value: Required. Describes a Service Fabric property value.
        :paramtype value: ~azure.servicefabric.models.PropertyValue
        """
        super(PropertyDescription, self).__init__(**kwargs)
        self.property_name = kwargs['property_name']
        self.custom_type_id = kwargs.get('custom_type_id', None)
        self.value = kwargs['value']


class PropertyInfo(msrest.serialization.Model):
    """Information about a Service Fabric property.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name of the Service Fabric property.
    :vartype name: str
    :ivar value: Describes a Service Fabric property value.
    :vartype value: ~azure.servicefabric.models.PropertyValue
    :ivar metadata: Required. The metadata associated with a property, including the property's
     name.
    :vartype metadata: ~azure.servicefabric.models.PropertyMetadata
    """

    _validation = {
        'name': {'required': True},
        'metadata': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'value': {'key': 'Value', 'type': 'PropertyValue'},
        'metadata': {'key': 'Metadata', 'type': 'PropertyMetadata'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. The name of the Service Fabric property.
        :paramtype name: str
        :keyword value: Describes a Service Fabric property value.
        :paramtype value: ~azure.servicefabric.models.PropertyValue
        :keyword metadata: Required. The metadata associated with a property, including the property's
         name.
        :paramtype metadata: ~azure.servicefabric.models.PropertyMetadata
        """
        super(PropertyInfo, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.value = kwargs.get('value', None)
        self.metadata = kwargs['metadata']


class PropertyMetadata(msrest.serialization.Model):
    """The metadata associated with a property, including the property's name.

    :ivar type_id: The kind of property, determined by the type of data. Following are the possible
     values. Possible values include: "Invalid", "Binary", "Int64", "Double", "String", "Guid".
    :vartype type_id: str or ~azure.servicefabric.models.PropertyValueKind
    :ivar custom_type_id: The property's custom type ID.
    :vartype custom_type_id: str
    :ivar parent: The name of the parent Service Fabric Name for the property. It could be thought
     of as the name-space/table under which the property exists.
    :vartype parent: str
    :ivar size_in_bytes: The length of the serialized property value.
    :vartype size_in_bytes: int
    :ivar last_modified_utc_timestamp: Represents when the Property was last modified. Only write
     operations will cause this field to be updated.
    :vartype last_modified_utc_timestamp: ~datetime.datetime
    :ivar sequence_number: The version of the property. Every time a property is modified, its
     sequence number is increased.
    :vartype sequence_number: str
    """

    _attribute_map = {
        'type_id': {'key': 'TypeId', 'type': 'str'},
        'custom_type_id': {'key': 'CustomTypeId', 'type': 'str'},
        'parent': {'key': 'Parent', 'type': 'str'},
        'size_in_bytes': {'key': 'SizeInBytes', 'type': 'int'},
        'last_modified_utc_timestamp': {'key': 'LastModifiedUtcTimestamp', 'type': 'iso-8601'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword type_id: The kind of property, determined by the type of data. Following are the
         possible values. Possible values include: "Invalid", "Binary", "Int64", "Double", "String",
         "Guid".
        :paramtype type_id: str or ~azure.servicefabric.models.PropertyValueKind
        :keyword custom_type_id: The property's custom type ID.
        :paramtype custom_type_id: str
        :keyword parent: The name of the parent Service Fabric Name for the property. It could be
         thought of as the name-space/table under which the property exists.
        :paramtype parent: str
        :keyword size_in_bytes: The length of the serialized property value.
        :paramtype size_in_bytes: int
        :keyword last_modified_utc_timestamp: Represents when the Property was last modified. Only
         write operations will cause this field to be updated.
        :paramtype last_modified_utc_timestamp: ~datetime.datetime
        :keyword sequence_number: The version of the property. Every time a property is modified, its
         sequence number is increased.
        :paramtype sequence_number: str
        """
        super(PropertyMetadata, self).__init__(**kwargs)
        self.type_id = kwargs.get('type_id', None)
        self.custom_type_id = kwargs.get('custom_type_id', None)
        self.parent = kwargs.get('parent', None)
        self.size_in_bytes = kwargs.get('size_in_bytes', None)
        self.last_modified_utc_timestamp = kwargs.get('last_modified_utc_timestamp', None)
        self.sequence_number = kwargs.get('sequence_number', None)


class ProvisionApplicationTypeDescription(ProvisionApplicationTypeDescriptionBase):
    """Describes the operation to register or provision an application type using an application package uploaded to the Service Fabric image store.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of application type registration or provision requested. The
     application package can be registered or provisioned either from the image store or from an
     external store. Following are the kinds of the application type provision.Constant filled by
     server. Possible values include: "Invalid", "ImageStorePath", "ExternalStore".
    :vartype kind: str or ~azure.servicefabric.models.ProvisionApplicationTypeKind
    :ivar async_property: Required. Indicates whether or not provisioning should occur
     asynchronously. When set to true, the provision operation returns when the request is accepted
     by the system, and the provision operation continues without any timeout limit. The default
     value is false. For large application packages, we recommend setting the value to true.
    :vartype async_property: bool
    :ivar application_type_build_path: Required. The relative path for the application package in
     the image store specified during the prior upload operation.
    :vartype application_type_build_path: str
    :ivar application_package_cleanup_policy: The kind of action that needs to be taken for
     cleaning up the application package after successful provision. Possible values include:
     "Invalid", "Default", "Automatic", "Manual".
    :vartype application_package_cleanup_policy: str or
     ~azure.servicefabric.models.ApplicationPackageCleanupPolicy
    """

    _validation = {
        'kind': {'required': True},
        'async_property': {'required': True},
        'application_type_build_path': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'async_property': {'key': 'Async', 'type': 'bool'},
        'application_type_build_path': {'key': 'ApplicationTypeBuildPath', 'type': 'str'},
        'application_package_cleanup_policy': {'key': 'ApplicationPackageCleanupPolicy', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword async_property: Required. Indicates whether or not provisioning should occur
         asynchronously. When set to true, the provision operation returns when the request is accepted
         by the system, and the provision operation continues without any timeout limit. The default
         value is false. For large application packages, we recommend setting the value to true.
        :paramtype async_property: bool
        :keyword application_type_build_path: Required. The relative path for the application package
         in the image store specified during the prior upload operation.
        :paramtype application_type_build_path: str
        :keyword application_package_cleanup_policy: The kind of action that needs to be taken for
         cleaning up the application package after successful provision. Possible values include:
         "Invalid", "Default", "Automatic", "Manual".
        :paramtype application_package_cleanup_policy: str or
         ~azure.servicefabric.models.ApplicationPackageCleanupPolicy
        """
        super(ProvisionApplicationTypeDescription, self).__init__(**kwargs)
        self.kind = 'ImageStorePath'  # type: str
        self.application_type_build_path = kwargs['application_type_build_path']
        self.application_package_cleanup_policy = kwargs.get('application_package_cleanup_policy', None)


class ProvisionFabricDescription(msrest.serialization.Model):
    """Describes the parameters for provisioning a cluster.

    :ivar code_file_path: The cluster code package file path.
    :vartype code_file_path: str
    :ivar cluster_manifest_file_path: The cluster manifest file path.
    :vartype cluster_manifest_file_path: str
    """

    _attribute_map = {
        'code_file_path': {'key': 'CodeFilePath', 'type': 'str'},
        'cluster_manifest_file_path': {'key': 'ClusterManifestFilePath', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword code_file_path: The cluster code package file path.
        :paramtype code_file_path: str
        :keyword cluster_manifest_file_path: The cluster manifest file path.
        :paramtype cluster_manifest_file_path: str
        """
        super(ProvisionFabricDescription, self).__init__(**kwargs)
        self.code_file_path = kwargs.get('code_file_path', None)
        self.cluster_manifest_file_path = kwargs.get('cluster_manifest_file_path', None)


class PutPropertyBatchOperation(PropertyBatchOperation):
    """Puts the specified property under the specified name.
Note that if one PropertyBatchOperation in a PropertyBatch fails,
the entire batch fails and cannot be committed in a transactional manner.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property batch operation, determined by the operation to be
     performed. The following are the possible values.Constant filled by server. Possible values
     include: "Invalid", "Put", "Get", "CheckExists", "CheckSequence", "Delete", "CheckValue".
    :vartype kind: str or ~azure.servicefabric.models.PropertyBatchOperationKind
    :ivar property_name: Required. The name of the Service Fabric property.
    :vartype property_name: str
    :ivar value: Required. Describes a Service Fabric property value.
    :vartype value: ~azure.servicefabric.models.PropertyValue
    :ivar custom_type_id: The property's custom type ID. Using this property, the user is able to
     tag the type of the value of the property.
    :vartype custom_type_id: str
    """

    _validation = {
        'kind': {'required': True},
        'property_name': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'property_name': {'key': 'PropertyName', 'type': 'str'},
        'value': {'key': 'Value', 'type': 'PropertyValue'},
        'custom_type_id': {'key': 'CustomTypeId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword property_name: Required. The name of the Service Fabric property.
        :paramtype property_name: str
        :keyword value: Required. Describes a Service Fabric property value.
        :paramtype value: ~azure.servicefabric.models.PropertyValue
        :keyword custom_type_id: The property's custom type ID. Using this property, the user is able
         to tag the type of the value of the property.
        :paramtype custom_type_id: str
        """
        super(PutPropertyBatchOperation, self).__init__(**kwargs)
        self.kind = 'Put'  # type: str
        self.value = kwargs['value']
        self.custom_type_id = kwargs.get('custom_type_id', None)


class ReconfigurationInformation(msrest.serialization.Model):
    """Information about current reconfiguration like phase, type, previous configuration role of replica and reconfiguration start date time.

    :ivar previous_configuration_role: Replica role before reconfiguration started. Possible values
     include: "Unknown", "None", "Primary", "IdleSecondary", "ActiveSecondary", "IdleAuxiliary",
     "ActiveAuxiliary", "PrimaryAuxiliary".
    :vartype previous_configuration_role: str or ~azure.servicefabric.models.ReplicaRole
    :ivar reconfiguration_phase: Current phase of ongoing reconfiguration. If no reconfiguration is
     taking place then this value will be "None". Possible values include: "Unknown", "None",
     "Phase0", "Phase1", "Phase2", "Phase3", "Phase4", "AbortPhaseZero".
    :vartype reconfiguration_phase: str or ~azure.servicefabric.models.ReconfigurationPhase
    :ivar reconfiguration_type: Type of current ongoing reconfiguration. If no reconfiguration is
     taking place then this value will be "None". Possible values include: "Unknown", "SwapPrimary",
     "Failover", "Other".
    :vartype reconfiguration_type: str or ~azure.servicefabric.models.ReconfigurationType
    :ivar reconfiguration_start_time_utc: Start time (in UTC) of the ongoing reconfiguration. If no
     reconfiguration is taking place then this value will be zero date-time.
    :vartype reconfiguration_start_time_utc: ~datetime.datetime
    """

    _attribute_map = {
        'previous_configuration_role': {'key': 'PreviousConfigurationRole', 'type': 'str'},
        'reconfiguration_phase': {'key': 'ReconfigurationPhase', 'type': 'str'},
        'reconfiguration_type': {'key': 'ReconfigurationType', 'type': 'str'},
        'reconfiguration_start_time_utc': {'key': 'ReconfigurationStartTimeUtc', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword previous_configuration_role: Replica role before reconfiguration started. Possible
         values include: "Unknown", "None", "Primary", "IdleSecondary", "ActiveSecondary",
         "IdleAuxiliary", "ActiveAuxiliary", "PrimaryAuxiliary".
        :paramtype previous_configuration_role: str or ~azure.servicefabric.models.ReplicaRole
        :keyword reconfiguration_phase: Current phase of ongoing reconfiguration. If no reconfiguration
         is taking place then this value will be "None". Possible values include: "Unknown", "None",
         "Phase0", "Phase1", "Phase2", "Phase3", "Phase4", "AbortPhaseZero".
        :paramtype reconfiguration_phase: str or ~azure.servicefabric.models.ReconfigurationPhase
        :keyword reconfiguration_type: Type of current ongoing reconfiguration. If no reconfiguration
         is taking place then this value will be "None". Possible values include: "Unknown",
         "SwapPrimary", "Failover", "Other".
        :paramtype reconfiguration_type: str or ~azure.servicefabric.models.ReconfigurationType
        :keyword reconfiguration_start_time_utc: Start time (in UTC) of the ongoing reconfiguration. If
         no reconfiguration is taking place then this value will be zero date-time.
        :paramtype reconfiguration_start_time_utc: ~datetime.datetime
        """
        super(ReconfigurationInformation, self).__init__(**kwargs)
        self.previous_configuration_role = kwargs.get('previous_configuration_role', None)
        self.reconfiguration_phase = kwargs.get('reconfiguration_phase', None)
        self.reconfiguration_type = kwargs.get('reconfiguration_type', None)
        self.reconfiguration_start_time_utc = kwargs.get('reconfiguration_start_time_utc', None)


class RegistryCredential(msrest.serialization.Model):
    """Credential information to connect to container registry.

    :ivar registry_user_name: The user name to connect to container registry.
    :vartype registry_user_name: str
    :ivar registry_password: The password for supplied username to connect to container registry.
    :vartype registry_password: str
    :ivar password_encrypted: Indicates that supplied container registry password is encrypted.
    :vartype password_encrypted: bool
    """

    _attribute_map = {
        'registry_user_name': {'key': 'RegistryUserName', 'type': 'str'},
        'registry_password': {'key': 'RegistryPassword', 'type': 'str'},
        'password_encrypted': {'key': 'PasswordEncrypted', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword registry_user_name: The user name to connect to container registry.
        :paramtype registry_user_name: str
        :keyword registry_password: The password for supplied username to connect to container
         registry.
        :paramtype registry_password: str
        :keyword password_encrypted: Indicates that supplied container registry password is encrypted.
        :paramtype password_encrypted: bool
        """
        super(RegistryCredential, self).__init__(**kwargs)
        self.registry_user_name = kwargs.get('registry_user_name', None)
        self.registry_password = kwargs.get('registry_password', None)
        self.password_encrypted = kwargs.get('password_encrypted', None)


class ReliableCollectionsRef(msrest.serialization.Model):
    """Specifying this parameter adds support for reliable collections.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. Name of ReliableCollection resource. Right now it's not used and you can
     use any string.
    :vartype name: str
    :ivar do_not_persist_state: False (the default) if ReliableCollections state is persisted to
     disk as usual. True if you do not want to persist state, in which case replication is still
     enabled and you can use ReliableCollections as distributed cache.
    :vartype do_not_persist_state: bool
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'do_not_persist_state': {'key': 'doNotPersistState', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. Name of ReliableCollection resource. Right now it's not used and you
         can use any string.
        :paramtype name: str
        :keyword do_not_persist_state: False (the default) if ReliableCollections state is persisted to
         disk as usual. True if you do not want to persist state, in which case replication is still
         enabled and you can use ReliableCollections as distributed cache.
        :paramtype do_not_persist_state: bool
        """
        super(ReliableCollectionsRef, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.do_not_persist_state = kwargs.get('do_not_persist_state', None)


class RemoteReplicatorAcknowledgementDetail(msrest.serialization.Model):
    """Provides various statistics of the acknowledgements that are being received from the remote replicator.

    :ivar average_receive_duration: Represents the average duration it takes for the remote
     replicator to receive an operation.
    :vartype average_receive_duration: str
    :ivar average_apply_duration: Represents the average duration it takes for the remote
     replicator to apply an operation. This usually entails writing the operation to disk.
    :vartype average_apply_duration: str
    :ivar not_received_count: Represents the number of operations not yet received by a remote
     replicator.
    :vartype not_received_count: str
    :ivar received_and_not_applied_count: Represents the number of operations received and not yet
     applied by a remote replicator.
    :vartype received_and_not_applied_count: str
    """

    _attribute_map = {
        'average_receive_duration': {'key': 'AverageReceiveDuration', 'type': 'str'},
        'average_apply_duration': {'key': 'AverageApplyDuration', 'type': 'str'},
        'not_received_count': {'key': 'NotReceivedCount', 'type': 'str'},
        'received_and_not_applied_count': {'key': 'ReceivedAndNotAppliedCount', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword average_receive_duration: Represents the average duration it takes for the remote
         replicator to receive an operation.
        :paramtype average_receive_duration: str
        :keyword average_apply_duration: Represents the average duration it takes for the remote
         replicator to apply an operation. This usually entails writing the operation to disk.
        :paramtype average_apply_duration: str
        :keyword not_received_count: Represents the number of operations not yet received by a remote
         replicator.
        :paramtype not_received_count: str
        :keyword received_and_not_applied_count: Represents the number of operations received and not
         yet applied by a remote replicator.
        :paramtype received_and_not_applied_count: str
        """
        super(RemoteReplicatorAcknowledgementDetail, self).__init__(**kwargs)
        self.average_receive_duration = kwargs.get('average_receive_duration', None)
        self.average_apply_duration = kwargs.get('average_apply_duration', None)
        self.not_received_count = kwargs.get('not_received_count', None)
        self.received_and_not_applied_count = kwargs.get('received_and_not_applied_count', None)


class RemoteReplicatorAcknowledgementStatus(msrest.serialization.Model):
    """Provides details about the remote replicators from the primary replicator's point of view.

    :ivar replication_stream_acknowledgement_detail: Details about the acknowledgements for
     operations that are part of the replication stream data.
    :vartype replication_stream_acknowledgement_detail:
     ~azure.servicefabric.models.RemoteReplicatorAcknowledgementDetail
    :ivar copy_stream_acknowledgement_detail: Details about the acknowledgements for operations
     that are part of the copy stream data.
    :vartype copy_stream_acknowledgement_detail:
     ~azure.servicefabric.models.RemoteReplicatorAcknowledgementDetail
    """

    _attribute_map = {
        'replication_stream_acknowledgement_detail': {'key': 'ReplicationStreamAcknowledgementDetail', 'type': 'RemoteReplicatorAcknowledgementDetail'},
        'copy_stream_acknowledgement_detail': {'key': 'CopyStreamAcknowledgementDetail', 'type': 'RemoteReplicatorAcknowledgementDetail'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword replication_stream_acknowledgement_detail: Details about the acknowledgements for
         operations that are part of the replication stream data.
        :paramtype replication_stream_acknowledgement_detail:
         ~azure.servicefabric.models.RemoteReplicatorAcknowledgementDetail
        :keyword copy_stream_acknowledgement_detail: Details about the acknowledgements for operations
         that are part of the copy stream data.
        :paramtype copy_stream_acknowledgement_detail:
         ~azure.servicefabric.models.RemoteReplicatorAcknowledgementDetail
        """
        super(RemoteReplicatorAcknowledgementStatus, self).__init__(**kwargs)
        self.replication_stream_acknowledgement_detail = kwargs.get('replication_stream_acknowledgement_detail', None)
        self.copy_stream_acknowledgement_detail = kwargs.get('copy_stream_acknowledgement_detail', None)


class RemoteReplicatorStatus(msrest.serialization.Model):
    """Represents the state of the secondary replicator from the primary replicator’s point of view.

    :ivar replica_id: Represents the replica ID of the remote secondary replicator.
    :vartype replica_id: str
    :ivar last_acknowledgement_processed_time_utc: The last timestamp (in UTC) when an
     acknowledgement from the secondary replicator was processed on the primary.
     UTC 0 represents an invalid value, indicating that no acknowledgement messages were ever
     processed.
    :vartype last_acknowledgement_processed_time_utc: ~datetime.datetime
    :ivar last_received_replication_sequence_number: The highest replication operation sequence
     number that the secondary has received from the primary.
    :vartype last_received_replication_sequence_number: str
    :ivar last_applied_replication_sequence_number: The highest replication operation sequence
     number that the secondary has applied to its state.
    :vartype last_applied_replication_sequence_number: str
    :ivar is_in_build: A value that indicates whether the secondary replica is in the process of
     being built.
    :vartype is_in_build: bool
    :ivar last_received_copy_sequence_number: The highest copy operation sequence number that the
     secondary has received from the primary.
     A value of -1 implies that the secondary has received all copy operations.
    :vartype last_received_copy_sequence_number: str
    :ivar last_applied_copy_sequence_number: The highest copy operation sequence number that the
     secondary has applied to its state.
     A value of -1 implies that the secondary has applied all copy operations and the copy process
     is complete.
    :vartype last_applied_copy_sequence_number: str
    :ivar remote_replicator_acknowledgement_status: Represents the acknowledgment status for the
     remote secondary replicator.
    :vartype remote_replicator_acknowledgement_status:
     ~azure.servicefabric.models.RemoteReplicatorAcknowledgementStatus
    """

    _attribute_map = {
        'replica_id': {'key': 'ReplicaId', 'type': 'str'},
        'last_acknowledgement_processed_time_utc': {'key': 'LastAcknowledgementProcessedTimeUtc', 'type': 'iso-8601'},
        'last_received_replication_sequence_number': {'key': 'LastReceivedReplicationSequenceNumber', 'type': 'str'},
        'last_applied_replication_sequence_number': {'key': 'LastAppliedReplicationSequenceNumber', 'type': 'str'},
        'is_in_build': {'key': 'IsInBuild', 'type': 'bool'},
        'last_received_copy_sequence_number': {'key': 'LastReceivedCopySequenceNumber', 'type': 'str'},
        'last_applied_copy_sequence_number': {'key': 'LastAppliedCopySequenceNumber', 'type': 'str'},
        'remote_replicator_acknowledgement_status': {'key': 'RemoteReplicatorAcknowledgementStatus', 'type': 'RemoteReplicatorAcknowledgementStatus'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword replica_id: Represents the replica ID of the remote secondary replicator.
        :paramtype replica_id: str
        :keyword last_acknowledgement_processed_time_utc: The last timestamp (in UTC) when an
         acknowledgement from the secondary replicator was processed on the primary.
         UTC 0 represents an invalid value, indicating that no acknowledgement messages were ever
         processed.
        :paramtype last_acknowledgement_processed_time_utc: ~datetime.datetime
        :keyword last_received_replication_sequence_number: The highest replication operation sequence
         number that the secondary has received from the primary.
        :paramtype last_received_replication_sequence_number: str
        :keyword last_applied_replication_sequence_number: The highest replication operation sequence
         number that the secondary has applied to its state.
        :paramtype last_applied_replication_sequence_number: str
        :keyword is_in_build: A value that indicates whether the secondary replica is in the process of
         being built.
        :paramtype is_in_build: bool
        :keyword last_received_copy_sequence_number: The highest copy operation sequence number that
         the secondary has received from the primary.
         A value of -1 implies that the secondary has received all copy operations.
        :paramtype last_received_copy_sequence_number: str
        :keyword last_applied_copy_sequence_number: The highest copy operation sequence number that the
         secondary has applied to its state.
         A value of -1 implies that the secondary has applied all copy operations and the copy process
         is complete.
        :paramtype last_applied_copy_sequence_number: str
        :keyword remote_replicator_acknowledgement_status: Represents the acknowledgment status for the
         remote secondary replicator.
        :paramtype remote_replicator_acknowledgement_status:
         ~azure.servicefabric.models.RemoteReplicatorAcknowledgementStatus
        """
        super(RemoteReplicatorStatus, self).__init__(**kwargs)
        self.replica_id = kwargs.get('replica_id', None)
        self.last_acknowledgement_processed_time_utc = kwargs.get('last_acknowledgement_processed_time_utc', None)
        self.last_received_replication_sequence_number = kwargs.get('last_received_replication_sequence_number', None)
        self.last_applied_replication_sequence_number = kwargs.get('last_applied_replication_sequence_number', None)
        self.is_in_build = kwargs.get('is_in_build', None)
        self.last_received_copy_sequence_number = kwargs.get('last_received_copy_sequence_number', None)
        self.last_applied_copy_sequence_number = kwargs.get('last_applied_copy_sequence_number', None)
        self.remote_replicator_acknowledgement_status = kwargs.get('remote_replicator_acknowledgement_status', None)


class RepairTask(msrest.serialization.Model):
    """Represents a repair task, which includes information about what kind of repair was requested, what its progress is, and what its final result was.

This type supports the Service Fabric platform; it is not meant to be used directly from your code.

    All required parameters must be populated in order to send to Azure.

    :ivar task_id: Required. The ID of the repair task.
    :vartype task_id: str
    :ivar version: The version of the repair task.
     When creating a new repair task, the version must be set to zero.  When updating a repair
     task,
     the version is used for optimistic concurrency checks.  If the version is
     set to zero, the update will not check for write conflicts.  If the version is set to a
     non-zero value, then the
     update will only succeed if the actual current version of the repair task matches this value.
    :vartype version: str
    :ivar description: A description of the purpose of the repair task, or other informational
     details.
     May be set when the repair task is created, and is immutable once set.
    :vartype description: str
    :ivar state: Required. The workflow state of the repair task. Valid initial states are Created,
     Claimed, and Preparing. Possible values include: "Invalid", "Created", "Claimed", "Preparing",
     "Approved", "Executing", "Restoring", "Completed".
    :vartype state: str or ~azure.servicefabric.models.State
    :ivar flags: A bitwise-OR of the following values, which gives additional details about the
     status of the repair task.
    
    
     * 1 - Cancellation of the repair has been requested
     * 2 - Abort of the repair has been requested
     * 4 - Approval of the repair was forced via client request.
    :vartype flags: int
    :ivar action: Required. The requested repair action. Must be specified when the repair task is
     created, and is immutable once set.
    :vartype action: str
    :ivar target: The target object determines what actions the system will take to prepare for the
     impact of the repair, prior to approving execution of the repair.
     May be set when the repair task is created, and is immutable once set.
    :vartype target: ~azure.servicefabric.models.RepairTargetDescriptionBase
    :ivar executor: The name of the repair executor. Must be specified in Claimed and later states,
     and is immutable once set.
    :vartype executor: str
    :ivar executor_data: A data string that the repair executor can use to store its internal
     state.
    :vartype executor_data: str
    :ivar impact: The impact object determines what actions the system will take to prepare for the
     impact of the repair, prior to approving execution of the repair.
     Impact must be specified by the repair executor when transitioning to the Preparing state, and
     is immutable once set.
    :vartype impact: ~azure.servicefabric.models.RepairImpactDescriptionBase
    :ivar result_status: A value describing the overall result of the repair task execution. Must
     be specified in the Restoring and later states, and is immutable once set. Possible values
     include: "Invalid", "Succeeded", "Cancelled", "Interrupted", "Failed", "Pending".
    :vartype result_status: str or ~azure.servicefabric.models.ResultStatus
    :ivar result_code: A numeric value providing additional details about the result of the repair
     task execution.
     May be specified in the Restoring and later states, and is immutable once set.
    :vartype result_code: int
    :ivar result_details: A string providing additional details about the result of the repair task
     execution.
     May be specified in the Restoring and later states, and is immutable once set.
    :vartype result_details: str
    :ivar history: An object that contains timestamps of the repair task's state transitions.
     These timestamps are updated by the system, and cannot be directly modified.
    :vartype history: ~azure.servicefabric.models.RepairTaskHistory
    :ivar preparing_health_check_state: The workflow state of the health check when the repair task
     is in the Preparing state. Possible values include: "NotStarted", "InProgress", "Succeeded",
     "Skipped", "TimedOut".
    :vartype preparing_health_check_state: str or
     ~azure.servicefabric.models.RepairTaskHealthCheckState
    :ivar restoring_health_check_state: The workflow state of the health check when the repair task
     is in the Restoring state. Possible values include: "NotStarted", "InProgress", "Succeeded",
     "Skipped", "TimedOut".
    :vartype restoring_health_check_state: str or
     ~azure.servicefabric.models.RepairTaskHealthCheckState
    :ivar perform_preparing_health_check: A value to determine if health checks will be performed
     when the repair task enters the Preparing state.
    :vartype perform_preparing_health_check: bool
    :ivar perform_restoring_health_check: A value to determine if health checks will be performed
     when the repair task enters the Restoring state.
    :vartype perform_restoring_health_check: bool
    """

    _validation = {
        'task_id': {'required': True},
        'state': {'required': True},
        'action': {'required': True},
    }

    _attribute_map = {
        'task_id': {'key': 'TaskId', 'type': 'str'},
        'version': {'key': 'Version', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'state': {'key': 'State', 'type': 'str'},
        'flags': {'key': 'Flags', 'type': 'int'},
        'action': {'key': 'Action', 'type': 'str'},
        'target': {'key': 'Target', 'type': 'RepairTargetDescriptionBase'},
        'executor': {'key': 'Executor', 'type': 'str'},
        'executor_data': {'key': 'ExecutorData', 'type': 'str'},
        'impact': {'key': 'Impact', 'type': 'RepairImpactDescriptionBase'},
        'result_status': {'key': 'ResultStatus', 'type': 'str'},
        'result_code': {'key': 'ResultCode', 'type': 'int'},
        'result_details': {'key': 'ResultDetails', 'type': 'str'},
        'history': {'key': 'History', 'type': 'RepairTaskHistory'},
        'preparing_health_check_state': {'key': 'PreparingHealthCheckState', 'type': 'str'},
        'restoring_health_check_state': {'key': 'RestoringHealthCheckState', 'type': 'str'},
        'perform_preparing_health_check': {'key': 'PerformPreparingHealthCheck', 'type': 'bool'},
        'perform_restoring_health_check': {'key': 'PerformRestoringHealthCheck', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword task_id: Required. The ID of the repair task.
        :paramtype task_id: str
        :keyword version: The version of the repair task.
         When creating a new repair task, the version must be set to zero.  When updating a repair
         task,
         the version is used for optimistic concurrency checks.  If the version is
         set to zero, the update will not check for write conflicts.  If the version is set to a
         non-zero value, then the
         update will only succeed if the actual current version of the repair task matches this value.
        :paramtype version: str
        :keyword description: A description of the purpose of the repair task, or other informational
         details.
         May be set when the repair task is created, and is immutable once set.
        :paramtype description: str
        :keyword state: Required. The workflow state of the repair task. Valid initial states are
         Created, Claimed, and Preparing. Possible values include: "Invalid", "Created", "Claimed",
         "Preparing", "Approved", "Executing", "Restoring", "Completed".
        :paramtype state: str or ~azure.servicefabric.models.State
        :keyword flags: A bitwise-OR of the following values, which gives additional details about the
         status of the repair task.
        
        
         * 1 - Cancellation of the repair has been requested
         * 2 - Abort of the repair has been requested
         * 4 - Approval of the repair was forced via client request.
        :paramtype flags: int
        :keyword action: Required. The requested repair action. Must be specified when the repair task
         is created, and is immutable once set.
        :paramtype action: str
        :keyword target: The target object determines what actions the system will take to prepare for
         the impact of the repair, prior to approving execution of the repair.
         May be set when the repair task is created, and is immutable once set.
        :paramtype target: ~azure.servicefabric.models.RepairTargetDescriptionBase
        :keyword executor: The name of the repair executor. Must be specified in Claimed and later
         states, and is immutable once set.
        :paramtype executor: str
        :keyword executor_data: A data string that the repair executor can use to store its internal
         state.
        :paramtype executor_data: str
        :keyword impact: The impact object determines what actions the system will take to prepare for
         the impact of the repair, prior to approving execution of the repair.
         Impact must be specified by the repair executor when transitioning to the Preparing state, and
         is immutable once set.
        :paramtype impact: ~azure.servicefabric.models.RepairImpactDescriptionBase
        :keyword result_status: A value describing the overall result of the repair task execution.
         Must be specified in the Restoring and later states, and is immutable once set. Possible values
         include: "Invalid", "Succeeded", "Cancelled", "Interrupted", "Failed", "Pending".
        :paramtype result_status: str or ~azure.servicefabric.models.ResultStatus
        :keyword result_code: A numeric value providing additional details about the result of the
         repair task execution.
         May be specified in the Restoring and later states, and is immutable once set.
        :paramtype result_code: int
        :keyword result_details: A string providing additional details about the result of the repair
         task execution.
         May be specified in the Restoring and later states, and is immutable once set.
        :paramtype result_details: str
        :keyword history: An object that contains timestamps of the repair task's state transitions.
         These timestamps are updated by the system, and cannot be directly modified.
        :paramtype history: ~azure.servicefabric.models.RepairTaskHistory
        :keyword preparing_health_check_state: The workflow state of the health check when the repair
         task is in the Preparing state. Possible values include: "NotStarted", "InProgress",
         "Succeeded", "Skipped", "TimedOut".
        :paramtype preparing_health_check_state: str or
         ~azure.servicefabric.models.RepairTaskHealthCheckState
        :keyword restoring_health_check_state: The workflow state of the health check when the repair
         task is in the Restoring state. Possible values include: "NotStarted", "InProgress",
         "Succeeded", "Skipped", "TimedOut".
        :paramtype restoring_health_check_state: str or
         ~azure.servicefabric.models.RepairTaskHealthCheckState
        :keyword perform_preparing_health_check: A value to determine if health checks will be
         performed when the repair task enters the Preparing state.
        :paramtype perform_preparing_health_check: bool
        :keyword perform_restoring_health_check: A value to determine if health checks will be
         performed when the repair task enters the Restoring state.
        :paramtype perform_restoring_health_check: bool
        """
        super(RepairTask, self).__init__(**kwargs)
        self.task_id = kwargs['task_id']
        self.version = kwargs.get('version', None)
        self.description = kwargs.get('description', None)
        self.state = kwargs['state']
        self.flags = kwargs.get('flags', None)
        self.action = kwargs['action']
        self.target = kwargs.get('target', None)
        self.executor = kwargs.get('executor', None)
        self.executor_data = kwargs.get('executor_data', None)
        self.impact = kwargs.get('impact', None)
        self.result_status = kwargs.get('result_status', None)
        self.result_code = kwargs.get('result_code', None)
        self.result_details = kwargs.get('result_details', None)
        self.history = kwargs.get('history', None)
        self.preparing_health_check_state = kwargs.get('preparing_health_check_state', None)
        self.restoring_health_check_state = kwargs.get('restoring_health_check_state', None)
        self.perform_preparing_health_check = kwargs.get('perform_preparing_health_check', None)
        self.perform_restoring_health_check = kwargs.get('perform_restoring_health_check', None)


class RepairTaskApproveDescription(msrest.serialization.Model):
    """Describes a request for forced approval of a repair task.

This type supports the Service Fabric platform; it is not meant to be used directly from your code.

    All required parameters must be populated in order to send to Azure.

    :ivar task_id: Required. The ID of the repair task.
    :vartype task_id: str
    :ivar version: The current version number of the repair task. If non-zero, then the request
     will only succeed if this value matches the actual current version of the repair task. If zero,
     then no version check is performed.
    :vartype version: str
    """

    _validation = {
        'task_id': {'required': True},
    }

    _attribute_map = {
        'task_id': {'key': 'TaskId', 'type': 'str'},
        'version': {'key': 'Version', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword task_id: Required. The ID of the repair task.
        :paramtype task_id: str
        :keyword version: The current version number of the repair task. If non-zero, then the request
         will only succeed if this value matches the actual current version of the repair task. If zero,
         then no version check is performed.
        :paramtype version: str
        """
        super(RepairTaskApproveDescription, self).__init__(**kwargs)
        self.task_id = kwargs['task_id']
        self.version = kwargs.get('version', None)


class RepairTaskCancelDescription(msrest.serialization.Model):
    """Describes a request to cancel a repair task.

This type supports the Service Fabric platform; it is not meant to be used directly from your code.

    All required parameters must be populated in order to send to Azure.

    :ivar task_id: Required. The ID of the repair task.
    :vartype task_id: str
    :ivar version: The current version number of the repair task. If non-zero, then the request
     will only succeed if this value matches the actual current version of the repair task. If zero,
     then no version check is performed.
    :vartype version: str
    :ivar request_abort: *True* if the repair should be stopped as soon as possible even if it has
     already started executing. *False* if the repair should be cancelled only if execution has not
     yet started.
    :vartype request_abort: bool
    """

    _validation = {
        'task_id': {'required': True},
    }

    _attribute_map = {
        'task_id': {'key': 'TaskId', 'type': 'str'},
        'version': {'key': 'Version', 'type': 'str'},
        'request_abort': {'key': 'RequestAbort', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword task_id: Required. The ID of the repair task.
        :paramtype task_id: str
        :keyword version: The current version number of the repair task. If non-zero, then the request
         will only succeed if this value matches the actual current version of the repair task. If zero,
         then no version check is performed.
        :paramtype version: str
        :keyword request_abort: *True* if the repair should be stopped as soon as possible even if it
         has already started executing. *False* if the repair should be cancelled only if execution has
         not yet started.
        :paramtype request_abort: bool
        """
        super(RepairTaskCancelDescription, self).__init__(**kwargs)
        self.task_id = kwargs['task_id']
        self.version = kwargs.get('version', None)
        self.request_abort = kwargs.get('request_abort', None)


class RepairTaskDeleteDescription(msrest.serialization.Model):
    """Describes a request to delete a completed repair task.

This type supports the Service Fabric platform; it is not meant to be used directly from your code.

    All required parameters must be populated in order to send to Azure.

    :ivar task_id: Required. The ID of the completed repair task to be deleted.
    :vartype task_id: str
    :ivar version: The current version number of the repair task. If non-zero, then the request
     will only succeed if this value matches the actual current version of the repair task. If zero,
     then no version check is performed.
    :vartype version: str
    """

    _validation = {
        'task_id': {'required': True},
    }

    _attribute_map = {
        'task_id': {'key': 'TaskId', 'type': 'str'},
        'version': {'key': 'Version', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword task_id: Required. The ID of the completed repair task to be deleted.
        :paramtype task_id: str
        :keyword version: The current version number of the repair task. If non-zero, then the request
         will only succeed if this value matches the actual current version of the repair task. If zero,
         then no version check is performed.
        :paramtype version: str
        """
        super(RepairTaskDeleteDescription, self).__init__(**kwargs)
        self.task_id = kwargs['task_id']
        self.version = kwargs.get('version', None)


class RepairTaskHistory(msrest.serialization.Model):
    """A record of the times when the repair task entered each state.

This type supports the Service Fabric platform; it is not meant to be used directly from your code.

    :ivar created_utc_timestamp: The time when the repair task entered the Created state.
    :vartype created_utc_timestamp: ~datetime.datetime
    :ivar claimed_utc_timestamp: The time when the repair task entered the Claimed state.
    :vartype claimed_utc_timestamp: ~datetime.datetime
    :ivar preparing_utc_timestamp: The time when the repair task entered the Preparing state.
    :vartype preparing_utc_timestamp: ~datetime.datetime
    :ivar approved_utc_timestamp: The time when the repair task entered the Approved state.
    :vartype approved_utc_timestamp: ~datetime.datetime
    :ivar executing_utc_timestamp: The time when the repair task entered the Executing state.
    :vartype executing_utc_timestamp: ~datetime.datetime
    :ivar restoring_utc_timestamp: The time when the repair task entered the Restoring state.
    :vartype restoring_utc_timestamp: ~datetime.datetime
    :ivar completed_utc_timestamp: The time when the repair task entered the Completed state.
    :vartype completed_utc_timestamp: ~datetime.datetime
    :ivar preparing_health_check_start_utc_timestamp: The time when the repair task started the
     health check in the Preparing state.
    :vartype preparing_health_check_start_utc_timestamp: ~datetime.datetime
    :ivar preparing_health_check_end_utc_timestamp: The time when the repair task completed the
     health check in the Preparing state.
    :vartype preparing_health_check_end_utc_timestamp: ~datetime.datetime
    :ivar restoring_health_check_start_utc_timestamp: The time when the repair task started the
     health check in the Restoring state.
    :vartype restoring_health_check_start_utc_timestamp: ~datetime.datetime
    :ivar restoring_health_check_end_utc_timestamp: The time when the repair task completed the
     health check in the Restoring state.
    :vartype restoring_health_check_end_utc_timestamp: ~datetime.datetime
    """

    _attribute_map = {
        'created_utc_timestamp': {'key': 'CreatedUtcTimestamp', 'type': 'iso-8601'},
        'claimed_utc_timestamp': {'key': 'ClaimedUtcTimestamp', 'type': 'iso-8601'},
        'preparing_utc_timestamp': {'key': 'PreparingUtcTimestamp', 'type': 'iso-8601'},
        'approved_utc_timestamp': {'key': 'ApprovedUtcTimestamp', 'type': 'iso-8601'},
        'executing_utc_timestamp': {'key': 'ExecutingUtcTimestamp', 'type': 'iso-8601'},
        'restoring_utc_timestamp': {'key': 'RestoringUtcTimestamp', 'type': 'iso-8601'},
        'completed_utc_timestamp': {'key': 'CompletedUtcTimestamp', 'type': 'iso-8601'},
        'preparing_health_check_start_utc_timestamp': {'key': 'PreparingHealthCheckStartUtcTimestamp', 'type': 'iso-8601'},
        'preparing_health_check_end_utc_timestamp': {'key': 'PreparingHealthCheckEndUtcTimestamp', 'type': 'iso-8601'},
        'restoring_health_check_start_utc_timestamp': {'key': 'RestoringHealthCheckStartUtcTimestamp', 'type': 'iso-8601'},
        'restoring_health_check_end_utc_timestamp': {'key': 'RestoringHealthCheckEndUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword created_utc_timestamp: The time when the repair task entered the Created state.
        :paramtype created_utc_timestamp: ~datetime.datetime
        :keyword claimed_utc_timestamp: The time when the repair task entered the Claimed state.
        :paramtype claimed_utc_timestamp: ~datetime.datetime
        :keyword preparing_utc_timestamp: The time when the repair task entered the Preparing state.
        :paramtype preparing_utc_timestamp: ~datetime.datetime
        :keyword approved_utc_timestamp: The time when the repair task entered the Approved state.
        :paramtype approved_utc_timestamp: ~datetime.datetime
        :keyword executing_utc_timestamp: The time when the repair task entered the Executing state.
        :paramtype executing_utc_timestamp: ~datetime.datetime
        :keyword restoring_utc_timestamp: The time when the repair task entered the Restoring state.
        :paramtype restoring_utc_timestamp: ~datetime.datetime
        :keyword completed_utc_timestamp: The time when the repair task entered the Completed state.
        :paramtype completed_utc_timestamp: ~datetime.datetime
        :keyword preparing_health_check_start_utc_timestamp: The time when the repair task started the
         health check in the Preparing state.
        :paramtype preparing_health_check_start_utc_timestamp: ~datetime.datetime
        :keyword preparing_health_check_end_utc_timestamp: The time when the repair task completed the
         health check in the Preparing state.
        :paramtype preparing_health_check_end_utc_timestamp: ~datetime.datetime
        :keyword restoring_health_check_start_utc_timestamp: The time when the repair task started the
         health check in the Restoring state.
        :paramtype restoring_health_check_start_utc_timestamp: ~datetime.datetime
        :keyword restoring_health_check_end_utc_timestamp: The time when the repair task completed the
         health check in the Restoring state.
        :paramtype restoring_health_check_end_utc_timestamp: ~datetime.datetime
        """
        super(RepairTaskHistory, self).__init__(**kwargs)
        self.created_utc_timestamp = kwargs.get('created_utc_timestamp', None)
        self.claimed_utc_timestamp = kwargs.get('claimed_utc_timestamp', None)
        self.preparing_utc_timestamp = kwargs.get('preparing_utc_timestamp', None)
        self.approved_utc_timestamp = kwargs.get('approved_utc_timestamp', None)
        self.executing_utc_timestamp = kwargs.get('executing_utc_timestamp', None)
        self.restoring_utc_timestamp = kwargs.get('restoring_utc_timestamp', None)
        self.completed_utc_timestamp = kwargs.get('completed_utc_timestamp', None)
        self.preparing_health_check_start_utc_timestamp = kwargs.get('preparing_health_check_start_utc_timestamp', None)
        self.preparing_health_check_end_utc_timestamp = kwargs.get('preparing_health_check_end_utc_timestamp', None)
        self.restoring_health_check_start_utc_timestamp = kwargs.get('restoring_health_check_start_utc_timestamp', None)
        self.restoring_health_check_end_utc_timestamp = kwargs.get('restoring_health_check_end_utc_timestamp', None)


class RepairTaskUpdateHealthPolicyDescription(msrest.serialization.Model):
    """Describes a request to update the health policy of a repair task.

This type supports the Service Fabric platform; it is not meant to be used directly from your code.

    All required parameters must be populated in order to send to Azure.

    :ivar task_id: Required. The ID of the repair task to be updated.
    :vartype task_id: str
    :ivar version: The current version number of the repair task. If non-zero, then the request
     will only succeed if this value matches the actual current value of the repair task. If zero,
     then no version check is performed.
    :vartype version: str
    :ivar perform_preparing_health_check: A boolean indicating if health check is to be performed
     in the Preparing stage of the repair task. If not specified the existing value should not be
     altered. Otherwise, specify the desired new value.
    :vartype perform_preparing_health_check: bool
    :ivar perform_restoring_health_check: A boolean indicating if health check is to be performed
     in the Restoring stage of the repair task. If not specified the existing value should not be
     altered. Otherwise, specify the desired new value.
    :vartype perform_restoring_health_check: bool
    """

    _validation = {
        'task_id': {'required': True},
    }

    _attribute_map = {
        'task_id': {'key': 'TaskId', 'type': 'str'},
        'version': {'key': 'Version', 'type': 'str'},
        'perform_preparing_health_check': {'key': 'PerformPreparingHealthCheck', 'type': 'bool'},
        'perform_restoring_health_check': {'key': 'PerformRestoringHealthCheck', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword task_id: Required. The ID of the repair task to be updated.
        :paramtype task_id: str
        :keyword version: The current version number of the repair task. If non-zero, then the request
         will only succeed if this value matches the actual current value of the repair task. If zero,
         then no version check is performed.
        :paramtype version: str
        :keyword perform_preparing_health_check: A boolean indicating if health check is to be
         performed in the Preparing stage of the repair task. If not specified the existing value should
         not be altered. Otherwise, specify the desired new value.
        :paramtype perform_preparing_health_check: bool
        :keyword perform_restoring_health_check: A boolean indicating if health check is to be
         performed in the Restoring stage of the repair task. If not specified the existing value should
         not be altered. Otherwise, specify the desired new value.
        :paramtype perform_restoring_health_check: bool
        """
        super(RepairTaskUpdateHealthPolicyDescription, self).__init__(**kwargs)
        self.task_id = kwargs['task_id']
        self.version = kwargs.get('version', None)
        self.perform_preparing_health_check = kwargs.get('perform_preparing_health_check', None)
        self.perform_restoring_health_check = kwargs.get('perform_restoring_health_check', None)


class RepairTaskUpdateInfo(msrest.serialization.Model):
    """Describes the result of an operation that created or updated a repair task.

This type supports the Service Fabric platform; it is not meant to be used directly from your code.

    All required parameters must be populated in order to send to Azure.

    :ivar version: Required. The new version of the repair task.
    :vartype version: str
    """

    _validation = {
        'version': {'required': True},
    }

    _attribute_map = {
        'version': {'key': 'Version', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword version: Required. The new version of the repair task.
        :paramtype version: str
        """
        super(RepairTaskUpdateInfo, self).__init__(**kwargs)
        self.version = kwargs['version']


class ReplicaHealth(EntityHealth):
    """Represents a base class for stateful service replica or stateless service instance health.
Contains the replica aggregated health state, the health events and the unhealthy evaluations.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: StatefulServiceReplicaHealth, StatelessServiceInstanceHealth.

    All required parameters must be populated in order to send to Azure.

    :ivar aggregated_health_state: The HealthState representing the aggregated health state of the
     entity computed by Health Manager.
     The health evaluation of the entity reflects all events reported on the entity and its
     children (if any).
     The aggregation is done by applying the desired health policy. Possible values include:
     "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar health_events: The list of health events reported on the entity.
    :vartype health_events: list[~azure.servicefabric.models.HealthEvent]
    :ivar unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
     health state was returned by Health Manager.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    :ivar health_statistics: Shows the health statistics for all children types of the queried
     entity.
    :vartype health_statistics: ~azure.servicefabric.models.HealthStatistics
    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar partition_id: Id of the partition to which this replica belongs.
    :vartype partition_id: str
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'health_events': {'key': 'HealthEvents', 'type': '[HealthEvent]'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
        'health_statistics': {'key': 'HealthStatistics', 'type': 'HealthStatistics'},
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
    }

    _subtype_map = {
        'service_kind': {'Stateful': 'StatefulServiceReplicaHealth', 'Stateless': 'StatelessServiceInstanceHealth'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The HealthState representing the aggregated health state of
         the entity computed by Health Manager.
         The health evaluation of the entity reflects all events reported on the entity and its
         children (if any).
         The aggregation is done by applying the desired health policy. Possible values include:
         "Invalid", "Ok", "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword health_events: The list of health events reported on the entity.
        :paramtype health_events: list[~azure.servicefabric.models.HealthEvent]
        :keyword unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
         health state was returned by Health Manager.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        :keyword health_statistics: Shows the health statistics for all children types of the queried
         entity.
        :paramtype health_statistics: ~azure.servicefabric.models.HealthStatistics
        :keyword partition_id: Id of the partition to which this replica belongs.
        :paramtype partition_id: str
        """
        super(ReplicaHealth, self).__init__(**kwargs)
        self.service_kind = 'ReplicaHealth'  # type: str
        self.partition_id = kwargs.get('partition_id', None)


class ReplicaHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for a replica, containing information about the data and the algorithm used by health store to evaluate health. The evaluation is returned only when the aggregated health state is either Error or Warning.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar partition_id: Id of the partition to which the replica belongs.
    :vartype partition_id: str
    :ivar replica_or_instance_id: Id of a stateful service replica or a stateless service instance.
     This ID is used in the queries that apply to both stateful and stateless services. It is used
     by Service Fabric to uniquely identify a replica of a partition of a stateful service or an
     instance of a stateless service partition. It is unique within a partition and does not change
     for the lifetime of the replica or the instance. If a stateful replica gets dropped and another
     replica gets created on the same node for the same partition, it will get a different value for
     the ID. If a stateless instance is failed over on the same or different node it will get a
     different value for the ID.
    :vartype replica_or_instance_id: str
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the current aggregated
     health state of the replica. The types of the unhealthy evaluations can be
     EventHealthEvaluation.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_or_instance_id': {'key': 'ReplicaOrInstanceId', 'type': 'str'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword partition_id: Id of the partition to which the replica belongs.
        :paramtype partition_id: str
        :keyword replica_or_instance_id: Id of a stateful service replica or a stateless service
         instance. This ID is used in the queries that apply to both stateful and stateless services. It
         is used by Service Fabric to uniquely identify a replica of a partition of a stateful service
         or an instance of a stateless service partition. It is unique within a partition and does not
         change for the lifetime of the replica or the instance. If a stateful replica gets dropped and
         another replica gets created on the same node for the same partition, it will get a different
         value for the ID. If a stateless instance is failed over on the same or different node it will
         get a different value for the ID.
        :paramtype replica_or_instance_id: str
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the current
         aggregated health state of the replica. The types of the unhealthy evaluations can be
         EventHealthEvaluation.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(ReplicaHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'Replica'  # type: str
        self.partition_id = kwargs.get('partition_id', None)
        self.replica_or_instance_id = kwargs.get('replica_or_instance_id', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class ReplicaHealthState(EntityHealthState):
    """Represents a base class for stateful service replica or stateless service instance health state.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: StatefulServiceReplicaHealthState, StatelessServiceInstanceHealthState.

    All required parameters must be populated in order to send to Azure.

    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar partition_id: The ID of the partition to which this replica belongs.
    :vartype partition_id: str
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
    }

    _subtype_map = {
        'service_kind': {'Stateful': 'StatefulServiceReplicaHealthState', 'Stateless': 'StatelessServiceInstanceHealthState'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword partition_id: The ID of the partition to which this replica belongs.
        :paramtype partition_id: str
        """
        super(ReplicaHealthState, self).__init__(**kwargs)
        self.service_kind = 'ReplicaHealthState'  # type: str
        self.partition_id = kwargs.get('partition_id', None)


class ReplicaHealthStateChunk(EntityHealthStateChunk):
    """Represents the health state chunk of a stateful service replica or a stateless service instance.
The replica health state contains the replica ID and its aggregated health state.

    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar replica_or_instance_id: Id of a stateful service replica or a stateless service instance.
     This ID is used in the queries that apply to both stateful and stateless services. It is used
     by Service Fabric to uniquely identify a replica of a partition of a stateful service or an
     instance of a stateless service partition. It is unique within a partition and does not change
     for the lifetime of the replica or the instance. If a stateful replica gets dropped and another
     replica gets created on the same node for the same partition, it will get a different value for
     the ID. If a stateless instance is failed over on the same or different node it will get a
     different value for the ID.
    :vartype replica_or_instance_id: str
    """

    _attribute_map = {
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'replica_or_instance_id': {'key': 'ReplicaOrInstanceId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword replica_or_instance_id: Id of a stateful service replica or a stateless service
         instance. This ID is used in the queries that apply to both stateful and stateless services. It
         is used by Service Fabric to uniquely identify a replica of a partition of a stateful service
         or an instance of a stateless service partition. It is unique within a partition and does not
         change for the lifetime of the replica or the instance. If a stateful replica gets dropped and
         another replica gets created on the same node for the same partition, it will get a different
         value for the ID. If a stateless instance is failed over on the same or different node it will
         get a different value for the ID.
        :paramtype replica_or_instance_id: str
        """
        super(ReplicaHealthStateChunk, self).__init__(**kwargs)
        self.replica_or_instance_id = kwargs.get('replica_or_instance_id', None)


class ReplicaHealthStateChunkList(msrest.serialization.Model):
    """The list of replica health state chunks that respect the input filters in the chunk query. Returned by get cluster health state chunks query.

    :ivar items: The list of replica health state chunks that respect the input filters in the
     chunk query.
    :vartype items: list[~azure.servicefabric.models.ReplicaHealthStateChunk]
    """

    _attribute_map = {
        'items': {'key': 'Items', 'type': '[ReplicaHealthStateChunk]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword items: The list of replica health state chunks that respect the input filters in the
         chunk query.
        :paramtype items: list[~azure.servicefabric.models.ReplicaHealthStateChunk]
        """
        super(ReplicaHealthStateChunkList, self).__init__(**kwargs)
        self.items = kwargs.get('items', None)


class ReplicaHealthStateFilter(msrest.serialization.Model):
    """Defines matching criteria to determine whether a replica should be included as a child of a partition in the cluster health chunk.
The replicas are only returned if the parent entities match a filter specified in the cluster health chunk query description. The parent partition, service and application must be included in the cluster health chunk.
One filter can match zero, one or multiple replicas, depending on its properties.

    :ivar replica_or_instance_id_filter: Id of the stateful service replica or stateless service
     instance that matches the filter. The filter is applied only to the specified replica, if it
     exists.
     If the replica doesn't exist, no replica is returned in the cluster health chunk based on this
     filter.
     If the replica exists, it is included in the cluster health chunk if it respects the other
     filter properties.
     If not specified, all replicas that match the parent filters (if any) are taken into
     consideration and matched against the other filter members, like health state filter.
    :vartype replica_or_instance_id_filter: str
    :ivar health_state_filter: The filter for the health state of the replicas. It allows selecting
     replicas if they match the desired health states.
     The possible values are integer value of one of the following health states. Only replicas
     that match the filter are returned. All replicas are used to evaluate the parent partition
     aggregated health state.
     If not specified, default value is None, unless the replica ID is specified. If the filter has
     default value and replica ID is specified, the matching replica is returned.
     The state values are flag-based enumeration, so the value could be a combination of these
     values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6, it matches replicas with HealthState value of OK (2)
     and Warning (4).
    
    
     * Default - Default value. Matches any HealthState. The value is zero.
     * None - Filter that doesn't match any HealthState value. Used in order to return no results
     on a given collection of states. The value is 1.
     * Ok - Filter that matches input with HealthState value Ok. The value is 2.
     * Warning - Filter that matches input with HealthState value Warning. The value is 4.
     * Error - Filter that matches input with HealthState value Error. The value is 8.
     * All - Filter that matches input with any HealthState value. The value is 65535.
    :vartype health_state_filter: int
    """

    _attribute_map = {
        'replica_or_instance_id_filter': {'key': 'ReplicaOrInstanceIdFilter', 'type': 'str'},
        'health_state_filter': {'key': 'HealthStateFilter', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword replica_or_instance_id_filter: Id of the stateful service replica or stateless service
         instance that matches the filter. The filter is applied only to the specified replica, if it
         exists.
         If the replica doesn't exist, no replica is returned in the cluster health chunk based on this
         filter.
         If the replica exists, it is included in the cluster health chunk if it respects the other
         filter properties.
         If not specified, all replicas that match the parent filters (if any) are taken into
         consideration and matched against the other filter members, like health state filter.
        :paramtype replica_or_instance_id_filter: str
        :keyword health_state_filter: The filter for the health state of the replicas. It allows
         selecting replicas if they match the desired health states.
         The possible values are integer value of one of the following health states. Only replicas
         that match the filter are returned. All replicas are used to evaluate the parent partition
         aggregated health state.
         If not specified, default value is None, unless the replica ID is specified. If the filter has
         default value and replica ID is specified, the matching replica is returned.
         The state values are flag-based enumeration, so the value could be a combination of these
         values obtained using bitwise 'OR' operator.
         For example, if the provided value is 6, it matches replicas with HealthState value of OK (2)
         and Warning (4).
        
        
         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535.
        :paramtype health_state_filter: int
        """
        super(ReplicaHealthStateFilter, self).__init__(**kwargs)
        self.replica_or_instance_id_filter = kwargs.get('replica_or_instance_id_filter', None)
        self.health_state_filter = kwargs.get('health_state_filter', 0)


class ReplicaInfo(msrest.serialization.Model):
    """Information about the identity, status, health, node name, uptime, and other details about the replica.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: StatefulServiceReplicaInfo, StatelessServiceInstanceInfo.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar replica_status: The status of a replica of a service. Possible values include: "Invalid",
     "InBuild", "Standby", "Ready", "Down", "Dropped".
    :vartype replica_status: str or ~azure.servicefabric.models.ReplicaStatus
    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar node_name: The name of a Service Fabric node.
    :vartype node_name: str
    :ivar address: The address the replica is listening on.
    :vartype address: str
    :ivar last_in_build_duration_in_seconds: The last in build duration of the replica in seconds.
    :vartype last_in_build_duration_in_seconds: str
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'replica_status': {'key': 'ReplicaStatus', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'address': {'key': 'Address', 'type': 'str'},
        'last_in_build_duration_in_seconds': {'key': 'LastInBuildDurationInSeconds', 'type': 'str'},
    }

    _subtype_map = {
        'service_kind': {'Stateful': 'StatefulServiceReplicaInfo', 'Stateless': 'StatelessServiceInstanceInfo'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword replica_status: The status of a replica of a service. Possible values include:
         "Invalid", "InBuild", "Standby", "Ready", "Down", "Dropped".
        :paramtype replica_status: str or ~azure.servicefabric.models.ReplicaStatus
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword node_name: The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword address: The address the replica is listening on.
        :paramtype address: str
        :keyword last_in_build_duration_in_seconds: The last in build duration of the replica in
         seconds.
        :paramtype last_in_build_duration_in_seconds: str
        """
        super(ReplicaInfo, self).__init__(**kwargs)
        self.service_kind = None  # type: Optional[str]
        self.replica_status = kwargs.get('replica_status', None)
        self.health_state = kwargs.get('health_state', None)
        self.node_name = kwargs.get('node_name', None)
        self.address = kwargs.get('address', None)
        self.last_in_build_duration_in_seconds = kwargs.get('last_in_build_duration_in_seconds', None)


class ReplicaLifecycleDescription(msrest.serialization.Model):
    """Describes how the replica will behave.

    :ivar is_singleton_replica_move_allowed_during_upgrade: If set to true, replicas with a target
     replica set size of 1 will be permitted to move during upgrade.
    :vartype is_singleton_replica_move_allowed_during_upgrade: bool
    :ivar restore_replica_location_after_upgrade: If set to true, move/swap replica to original
     location after upgrade.
    :vartype restore_replica_location_after_upgrade: bool
    """

    _attribute_map = {
        'is_singleton_replica_move_allowed_during_upgrade': {'key': 'IsSingletonReplicaMoveAllowedDuringUpgrade', 'type': 'bool'},
        'restore_replica_location_after_upgrade': {'key': 'RestoreReplicaLocationAfterUpgrade', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword is_singleton_replica_move_allowed_during_upgrade: If set to true, replicas with a
         target replica set size of 1 will be permitted to move during upgrade.
        :paramtype is_singleton_replica_move_allowed_during_upgrade: bool
        :keyword restore_replica_location_after_upgrade: If set to true, move/swap replica to original
         location after upgrade.
        :paramtype restore_replica_location_after_upgrade: bool
        """
        super(ReplicaLifecycleDescription, self).__init__(**kwargs)
        self.is_singleton_replica_move_allowed_during_upgrade = kwargs.get('is_singleton_replica_move_allowed_during_upgrade', None)
        self.restore_replica_location_after_upgrade = kwargs.get('restore_replica_location_after_upgrade', None)


class ReplicaMetricLoadDescription(msrest.serialization.Model):
    """Specifies metric loads of a partition's specific secondary replica or instance.

    :ivar node_name: Node name of a specific secondary replica or instance.
    :vartype node_name: str
    :ivar replica_or_instance_load_entries: Loads of a different metrics for a partition's
     secondary replica or instance.
    :vartype replica_or_instance_load_entries:
     list[~azure.servicefabric.models.MetricLoadDescription]
    """

    _attribute_map = {
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'replica_or_instance_load_entries': {'key': 'ReplicaOrInstanceLoadEntries', 'type': '[MetricLoadDescription]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword node_name: Node name of a specific secondary replica or instance.
        :paramtype node_name: str
        :keyword replica_or_instance_load_entries: Loads of a different metrics for a partition's
         secondary replica or instance.
        :paramtype replica_or_instance_load_entries:
         list[~azure.servicefabric.models.MetricLoadDescription]
        """
        super(ReplicaMetricLoadDescription, self).__init__(**kwargs)
        self.node_name = kwargs.get('node_name', None)
        self.replica_or_instance_load_entries = kwargs.get('replica_or_instance_load_entries', None)


class ReplicasHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for replicas, containing health evaluations for each unhealthy replica that impacted current aggregated health state. Can be returned when evaluating partition health and the aggregated health state is either Error or Warning.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar max_percent_unhealthy_replicas_per_partition: Maximum allowed percentage of unhealthy
     replicas per partition from the ApplicationHealthPolicy.
    :vartype max_percent_unhealthy_replicas_per_partition: int
    :ivar total_count: Total number of replicas in the partition from the health store.
    :vartype total_count: long
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
     state. Includes all the unhealthy ReplicaHealthEvaluation that impacted the aggregated health.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'max_percent_unhealthy_replicas_per_partition': {'key': 'MaxPercentUnhealthyReplicasPerPartition', 'type': 'int'},
        'total_count': {'key': 'TotalCount', 'type': 'long'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword max_percent_unhealthy_replicas_per_partition: Maximum allowed percentage of unhealthy
         replicas per partition from the ApplicationHealthPolicy.
        :paramtype max_percent_unhealthy_replicas_per_partition: int
        :keyword total_count: Total number of replicas in the partition from the health store.
        :paramtype total_count: long
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
         state. Includes all the unhealthy ReplicaHealthEvaluation that impacted the aggregated health.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(ReplicasHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'Replicas'  # type: str
        self.max_percent_unhealthy_replicas_per_partition = kwargs.get('max_percent_unhealthy_replicas_per_partition', None)
        self.total_count = kwargs.get('total_count', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class ReplicatorQueueStatus(msrest.serialization.Model):
    """Provides various statistics of the queue used in the service fabric replicator.
Contains information about the service fabric replicator like the replication/copy queue utilization, last acknowledgement received timestamp, etc.
Depending on the role of the replicator, the properties in this type imply different meanings.

    :ivar queue_utilization_percentage: Represents the utilization of the queue. A value of 0
     indicates that the queue is empty and a value of 100 indicates the queue is full.
    :vartype queue_utilization_percentage: int
    :ivar queue_memory_size: Represents the virtual memory consumed by the queue in bytes.
    :vartype queue_memory_size: str
    :ivar first_sequence_number: On a primary replicator, this is semantically the sequence number
     of the operation for which all the secondary replicas have sent an acknowledgement.
     On a secondary replicator, this is the smallest sequence number of the operation that is
     present in the queue.
    :vartype first_sequence_number: str
    :ivar completed_sequence_number: On a primary replicator, this is semantically the highest
     sequence number of the operation for which all the secondary replicas have sent an
     acknowledgement.
     On a secondary replicator, this is semantically the highest sequence number that has been
     applied to the persistent state.
    :vartype completed_sequence_number: str
    :ivar committed_sequence_number: On a primary replicator, this is semantically the highest
     sequence number of the operation for which a write quorum of the secondary replicas have sent
     an acknowledgement.
     On a secondary replicator, this is semantically the highest sequence number of the in-order
     operation received from the primary.
    :vartype committed_sequence_number: str
    :ivar last_sequence_number: Represents the latest sequence number of the operation that is
     available in the queue.
    :vartype last_sequence_number: str
    """

    _attribute_map = {
        'queue_utilization_percentage': {'key': 'QueueUtilizationPercentage', 'type': 'int'},
        'queue_memory_size': {'key': 'QueueMemorySize', 'type': 'str'},
        'first_sequence_number': {'key': 'FirstSequenceNumber', 'type': 'str'},
        'completed_sequence_number': {'key': 'CompletedSequenceNumber', 'type': 'str'},
        'committed_sequence_number': {'key': 'CommittedSequenceNumber', 'type': 'str'},
        'last_sequence_number': {'key': 'LastSequenceNumber', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword queue_utilization_percentage: Represents the utilization of the queue. A value of 0
         indicates that the queue is empty and a value of 100 indicates the queue is full.
        :paramtype queue_utilization_percentage: int
        :keyword queue_memory_size: Represents the virtual memory consumed by the queue in bytes.
        :paramtype queue_memory_size: str
        :keyword first_sequence_number: On a primary replicator, this is semantically the sequence
         number of the operation for which all the secondary replicas have sent an acknowledgement.
         On a secondary replicator, this is the smallest sequence number of the operation that is
         present in the queue.
        :paramtype first_sequence_number: str
        :keyword completed_sequence_number: On a primary replicator, this is semantically the highest
         sequence number of the operation for which all the secondary replicas have sent an
         acknowledgement.
         On a secondary replicator, this is semantically the highest sequence number that has been
         applied to the persistent state.
        :paramtype completed_sequence_number: str
        :keyword committed_sequence_number: On a primary replicator, this is semantically the highest
         sequence number of the operation for which a write quorum of the secondary replicas have sent
         an acknowledgement.
         On a secondary replicator, this is semantically the highest sequence number of the in-order
         operation received from the primary.
        :paramtype committed_sequence_number: str
        :keyword last_sequence_number: Represents the latest sequence number of the operation that is
         available in the queue.
        :paramtype last_sequence_number: str
        """
        super(ReplicatorQueueStatus, self).__init__(**kwargs)
        self.queue_utilization_percentage = kwargs.get('queue_utilization_percentage', None)
        self.queue_memory_size = kwargs.get('queue_memory_size', None)
        self.first_sequence_number = kwargs.get('first_sequence_number', None)
        self.completed_sequence_number = kwargs.get('completed_sequence_number', None)
        self.committed_sequence_number = kwargs.get('committed_sequence_number', None)
        self.last_sequence_number = kwargs.get('last_sequence_number', None)


class ResolvedServiceEndpoint(msrest.serialization.Model):
    """Endpoint of a resolved service partition.

    :ivar kind: The role of the replica where the endpoint is reported. Possible values include:
     "Invalid", "Stateless", "StatefulPrimary", "StatefulSecondary".
    :vartype kind: str or ~azure.servicefabric.models.ServiceEndpointRole
    :ivar address: The address of the endpoint. If the endpoint has multiple listeners the address
     is a JSON object with one property per listener with the value as the address of that listener.
    :vartype address: str
    """

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'address': {'key': 'Address', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword kind: The role of the replica where the endpoint is reported. Possible values include:
         "Invalid", "Stateless", "StatefulPrimary", "StatefulSecondary".
        :paramtype kind: str or ~azure.servicefabric.models.ServiceEndpointRole
        :keyword address: The address of the endpoint. If the endpoint has multiple listeners the
         address is a JSON object with one property per listener with the value as the address of that
         listener.
        :paramtype address: str
        """
        super(ResolvedServiceEndpoint, self).__init__(**kwargs)
        self.kind = kwargs.get('kind', None)
        self.address = kwargs.get('address', None)


class ResolvedServicePartition(msrest.serialization.Model):
    """Information about a service partition and its associated endpoints.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The full name of the service with 'fabric:' URI scheme.
    :vartype name: str
    :ivar partition_information: Required. A representation of the resolved partition.
    :vartype partition_information: ~azure.servicefabric.models.PartitionInformation
    :ivar endpoints: Required. List of resolved service endpoints of a service partition.
    :vartype endpoints: list[~azure.servicefabric.models.ResolvedServiceEndpoint]
    :ivar version: Required. The version of this resolved service partition result. This version
     should be passed in the next time the ResolveService call is made via the PreviousRspVersion
     query parameter.
    :vartype version: str
    """

    _validation = {
        'name': {'required': True},
        'partition_information': {'required': True},
        'endpoints': {'required': True},
        'version': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'partition_information': {'key': 'PartitionInformation', 'type': 'PartitionInformation'},
        'endpoints': {'key': 'Endpoints', 'type': '[ResolvedServiceEndpoint]'},
        'version': {'key': 'Version', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. The full name of the service with 'fabric:' URI scheme.
        :paramtype name: str
        :keyword partition_information: Required. A representation of the resolved partition.
        :paramtype partition_information: ~azure.servicefabric.models.PartitionInformation
        :keyword endpoints: Required. List of resolved service endpoints of a service partition.
        :paramtype endpoints: list[~azure.servicefabric.models.ResolvedServiceEndpoint]
        :keyword version: Required. The version of this resolved service partition result. This version
         should be passed in the next time the ResolveService call is made via the PreviousRspVersion
         query parameter.
        :paramtype version: str
        """
        super(ResolvedServicePartition, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.partition_information = kwargs['partition_information']
        self.endpoints = kwargs['endpoints']
        self.version = kwargs['version']


class ResourceLimits(msrest.serialization.Model):
    """This type describes the resource limits for a given container. It describes the most amount of resources a container is allowed to use before being restarted.

    :ivar memory_in_gb: The memory limit in GB.
    :vartype memory_in_gb: float
    :ivar cpu: CPU limits in cores. At present, only full cores are supported.
    :vartype cpu: float
    """

    _attribute_map = {
        'memory_in_gb': {'key': 'memoryInGB', 'type': 'float'},
        'cpu': {'key': 'cpu', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword memory_in_gb: The memory limit in GB.
        :paramtype memory_in_gb: float
        :keyword cpu: CPU limits in cores. At present, only full cores are supported.
        :paramtype cpu: float
        """
        super(ResourceLimits, self).__init__(**kwargs)
        self.memory_in_gb = kwargs.get('memory_in_gb', None)
        self.cpu = kwargs.get('cpu', None)


class ResourceRequests(msrest.serialization.Model):
    """This type describes the requested resources for a given container. It describes the least amount of resources required for the container. A container can consume more than requested resources up to the specified limits before being restarted. Currently, the requested resources are treated as limits.

    All required parameters must be populated in order to send to Azure.

    :ivar memory_in_gb: Required. The memory request in GB for this container.
    :vartype memory_in_gb: float
    :ivar cpu: Required. Requested number of CPU cores. At present, only full cores are supported.
    :vartype cpu: float
    """

    _validation = {
        'memory_in_gb': {'required': True},
        'cpu': {'required': True},
    }

    _attribute_map = {
        'memory_in_gb': {'key': 'memoryInGB', 'type': 'float'},
        'cpu': {'key': 'cpu', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword memory_in_gb: Required. The memory request in GB for this container.
        :paramtype memory_in_gb: float
        :keyword cpu: Required. Requested number of CPU cores. At present, only full cores are
         supported.
        :paramtype cpu: float
        """
        super(ResourceRequests, self).__init__(**kwargs)
        self.memory_in_gb = kwargs['memory_in_gb']
        self.cpu = kwargs['cpu']


class ResourceRequirements(msrest.serialization.Model):
    """This type describes the resource requirements for a container or a service.

    All required parameters must be populated in order to send to Azure.

    :ivar requests: Required. Describes the requested resources for a given container.
    :vartype requests: ~azure.servicefabric.models.ResourceRequests
    :ivar limits: Describes the maximum limits on the resources for a given container.
    :vartype limits: ~azure.servicefabric.models.ResourceLimits
    """

    _validation = {
        'requests': {'required': True},
    }

    _attribute_map = {
        'requests': {'key': 'requests', 'type': 'ResourceRequests'},
        'limits': {'key': 'limits', 'type': 'ResourceLimits'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword requests: Required. Describes the requested resources for a given container.
        :paramtype requests: ~azure.servicefabric.models.ResourceRequests
        :keyword limits: Describes the maximum limits on the resources for a given container.
        :paramtype limits: ~azure.servicefabric.models.ResourceLimits
        """
        super(ResourceRequirements, self).__init__(**kwargs)
        self.requests = kwargs['requests']
        self.limits = kwargs.get('limits', None)


class RestartDeployedCodePackageDescription(msrest.serialization.Model):
    """Defines description for restarting a deployed code package on Service Fabric node.

    All required parameters must be populated in order to send to Azure.

    :ivar service_manifest_name: Required. The name of service manifest that specified this code
     package.
    :vartype service_manifest_name: str
    :ivar service_package_activation_id: The ActivationId of a deployed service package. If
     ServicePackageActivationMode specified at the time of creating the service
     is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
     then value of ServicePackageActivationId
     is always an empty string.
    :vartype service_package_activation_id: str
    :ivar code_package_name: Required. The name of the code package defined in the service
     manifest.
    :vartype code_package_name: str
    :ivar code_package_instance_id: Required. The instance ID for currently running entry point.
     For a code package setup entry point (if specified) runs first and after it finishes main entry
     point is started.
     Each time entry point executable is run, its instance ID will change. If 0 is passed in as the
     code package instance ID, the API will restart the code package with whatever instance ID it is
     currently running.
     If an instance ID other than 0 is passed in, the API will restart the code package only if the
     current Instance ID matches the passed in instance ID.
     Note, passing in the exact instance ID (not 0) in the API is safer, because if ensures at most
     one restart of the code package.
    :vartype code_package_instance_id: str
    """

    _validation = {
        'service_manifest_name': {'required': True},
        'code_package_name': {'required': True},
        'code_package_instance_id': {'required': True},
    }

    _attribute_map = {
        'service_manifest_name': {'key': 'ServiceManifestName', 'type': 'str'},
        'service_package_activation_id': {'key': 'ServicePackageActivationId', 'type': 'str'},
        'code_package_name': {'key': 'CodePackageName', 'type': 'str'},
        'code_package_instance_id': {'key': 'CodePackageInstanceId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_manifest_name: Required. The name of service manifest that specified this code
         package.
        :paramtype service_manifest_name: str
        :keyword service_package_activation_id: The ActivationId of a deployed service package. If
         ServicePackageActivationMode specified at the time of creating the service
         is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
         then value of ServicePackageActivationId
         is always an empty string.
        :paramtype service_package_activation_id: str
        :keyword code_package_name: Required. The name of the code package defined in the service
         manifest.
        :paramtype code_package_name: str
        :keyword code_package_instance_id: Required. The instance ID for currently running entry point.
         For a code package setup entry point (if specified) runs first and after it finishes main entry
         point is started.
         Each time entry point executable is run, its instance ID will change. If 0 is passed in as the
         code package instance ID, the API will restart the code package with whatever instance ID it is
         currently running.
         If an instance ID other than 0 is passed in, the API will restart the code package only if the
         current Instance ID matches the passed in instance ID.
         Note, passing in the exact instance ID (not 0) in the API is safer, because if ensures at most
         one restart of the code package.
        :paramtype code_package_instance_id: str
        """
        super(RestartDeployedCodePackageDescription, self).__init__(**kwargs)
        self.service_manifest_name = kwargs['service_manifest_name']
        self.service_package_activation_id = kwargs.get('service_package_activation_id', None)
        self.code_package_name = kwargs['code_package_name']
        self.code_package_instance_id = kwargs['code_package_instance_id']


class RestartNodeDescription(msrest.serialization.Model):
    """Describes the parameters to restart a Service Fabric node.

    All required parameters must be populated in order to send to Azure.

    :ivar node_instance_id: Required. The instance ID of the target node. If instance ID is
     specified the node is restarted only if it matches with the current instance of the node. A
     default value of "0" would match any instance ID. The instance ID can be obtained using get
     node query.
    :vartype node_instance_id: str
    :ivar create_fabric_dump: Specify True to create a dump of the fabric node process. This is
     case-sensitive. Possible values include: "False", "True". Default value: "False".
    :vartype create_fabric_dump: str or ~azure.servicefabric.models.CreateFabricDump
    """

    _validation = {
        'node_instance_id': {'required': True},
    }

    _attribute_map = {
        'node_instance_id': {'key': 'NodeInstanceId', 'type': 'str'},
        'create_fabric_dump': {'key': 'CreateFabricDump', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword node_instance_id: Required. The instance ID of the target node. If instance ID is
         specified the node is restarted only if it matches with the current instance of the node. A
         default value of "0" would match any instance ID. The instance ID can be obtained using get
         node query.
        :paramtype node_instance_id: str
        :keyword create_fabric_dump: Specify True to create a dump of the fabric node process. This is
         case-sensitive. Possible values include: "False", "True". Default value: "False".
        :paramtype create_fabric_dump: str or ~azure.servicefabric.models.CreateFabricDump
        """
        super(RestartNodeDescription, self).__init__(**kwargs)
        self.node_instance_id = kwargs.get('node_instance_id', "0")
        self.create_fabric_dump = kwargs.get('create_fabric_dump', "False")


class RestartPartitionResult(msrest.serialization.Model):
    """Represents information about an operation in a terminal state (Completed or Faulted).

    :ivar error_code: If OperationState is Completed, this is 0.  If OperationState is Faulted,
     this is an error code indicating the reason.
    :vartype error_code: int
    :ivar selected_partition: This class returns information about the partition that the
     user-induced operation acted upon.
    :vartype selected_partition: ~azure.servicefabric.models.SelectedPartition
    """

    _attribute_map = {
        'error_code': {'key': 'ErrorCode', 'type': 'int'},
        'selected_partition': {'key': 'SelectedPartition', 'type': 'SelectedPartition'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword error_code: If OperationState is Completed, this is 0.  If OperationState is Faulted,
         this is an error code indicating the reason.
        :paramtype error_code: int
        :keyword selected_partition: This class returns information about the partition that the
         user-induced operation acted upon.
        :paramtype selected_partition: ~azure.servicefabric.models.SelectedPartition
        """
        super(RestartPartitionResult, self).__init__(**kwargs)
        self.error_code = kwargs.get('error_code', None)
        self.selected_partition = kwargs.get('selected_partition', None)


class RestorePartitionDescription(msrest.serialization.Model):
    """Specifies the parameters needed to trigger a restore of a specific partition.

    All required parameters must be populated in order to send to Azure.

    :ivar backup_id: Required. Unique backup ID.
    :vartype backup_id: str
    :ivar backup_location: Required. Location of the backup relative to the backup storage
     specified/ configured.
    :vartype backup_location: str
    :ivar backup_storage: Location of the backup from where the partition will be restored.
    :vartype backup_storage: ~azure.servicefabric.models.BackupStorageDescription
    """

    _validation = {
        'backup_id': {'required': True},
        'backup_location': {'required': True},
    }

    _attribute_map = {
        'backup_id': {'key': 'BackupId', 'type': 'str'},
        'backup_location': {'key': 'BackupLocation', 'type': 'str'},
        'backup_storage': {'key': 'BackupStorage', 'type': 'BackupStorageDescription'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword backup_id: Required. Unique backup ID.
        :paramtype backup_id: str
        :keyword backup_location: Required. Location of the backup relative to the backup storage
         specified/ configured.
        :paramtype backup_location: str
        :keyword backup_storage: Location of the backup from where the partition will be restored.
        :paramtype backup_storage: ~azure.servicefabric.models.BackupStorageDescription
        """
        super(RestorePartitionDescription, self).__init__(**kwargs)
        self.backup_id = kwargs['backup_id']
        self.backup_location = kwargs['backup_location']
        self.backup_storage = kwargs.get('backup_storage', None)


class RestoreProgressInfo(msrest.serialization.Model):
    """Describes the progress of a restore operation on a partition.

    :ivar restore_state: Represents the current state of the partition restore operation. Possible
     values include: "Invalid", "Accepted", "RestoreInProgress", "Success", "Failure", "Timeout".
    :vartype restore_state: str or ~azure.servicefabric.models.RestoreState
    :ivar time_stamp_utc: Timestamp when operation succeeded or failed.
    :vartype time_stamp_utc: ~datetime.datetime
    :ivar restored_epoch: Describes the epoch at which the partition is restored.
    :vartype restored_epoch: ~azure.servicefabric.models.Epoch
    :ivar restored_lsn: Restored LSN.
    :vartype restored_lsn: str
    :ivar failure_error: Denotes the failure encountered in performing restore operation.
    :vartype failure_error: ~azure.servicefabric.models.FabricErrorError
    """

    _attribute_map = {
        'restore_state': {'key': 'RestoreState', 'type': 'str'},
        'time_stamp_utc': {'key': 'TimeStampUtc', 'type': 'iso-8601'},
        'restored_epoch': {'key': 'RestoredEpoch', 'type': 'Epoch'},
        'restored_lsn': {'key': 'RestoredLsn', 'type': 'str'},
        'failure_error': {'key': 'FailureError', 'type': 'FabricErrorError'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword restore_state: Represents the current state of the partition restore operation.
         Possible values include: "Invalid", "Accepted", "RestoreInProgress", "Success", "Failure",
         "Timeout".
        :paramtype restore_state: str or ~azure.servicefabric.models.RestoreState
        :keyword time_stamp_utc: Timestamp when operation succeeded or failed.
        :paramtype time_stamp_utc: ~datetime.datetime
        :keyword restored_epoch: Describes the epoch at which the partition is restored.
        :paramtype restored_epoch: ~azure.servicefabric.models.Epoch
        :keyword restored_lsn: Restored LSN.
        :paramtype restored_lsn: str
        :keyword failure_error: Denotes the failure encountered in performing restore operation.
        :paramtype failure_error: ~azure.servicefabric.models.FabricErrorError
        """
        super(RestoreProgressInfo, self).__init__(**kwargs)
        self.restore_state = kwargs.get('restore_state', None)
        self.time_stamp_utc = kwargs.get('time_stamp_utc', None)
        self.restored_epoch = kwargs.get('restored_epoch', None)
        self.restored_lsn = kwargs.get('restored_lsn', None)
        self.failure_error = kwargs.get('failure_error', None)


class ResumeApplicationUpgradeDescription(msrest.serialization.Model):
    """Describes the parameters for resuming an unmonitored manual Service Fabric application upgrade.

    All required parameters must be populated in order to send to Azure.

    :ivar upgrade_domain_name: Required. The name of the upgrade domain in which to resume the
     upgrade.
    :vartype upgrade_domain_name: str
    """

    _validation = {
        'upgrade_domain_name': {'required': True},
    }

    _attribute_map = {
        'upgrade_domain_name': {'key': 'UpgradeDomainName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword upgrade_domain_name: Required. The name of the upgrade domain in which to resume the
         upgrade.
        :paramtype upgrade_domain_name: str
        """
        super(ResumeApplicationUpgradeDescription, self).__init__(**kwargs)
        self.upgrade_domain_name = kwargs['upgrade_domain_name']


class ResumeClusterUpgradeDescription(msrest.serialization.Model):
    """Describes the parameters for resuming a cluster upgrade.

    All required parameters must be populated in order to send to Azure.

    :ivar upgrade_domain: Required. The next upgrade domain for this cluster upgrade.
    :vartype upgrade_domain: str
    """

    _validation = {
        'upgrade_domain': {'required': True},
    }

    _attribute_map = {
        'upgrade_domain': {'key': 'UpgradeDomain', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword upgrade_domain: Required. The next upgrade domain for this cluster upgrade.
        :paramtype upgrade_domain: str
        """
        super(ResumeClusterUpgradeDescription, self).__init__(**kwargs)
        self.upgrade_domain = kwargs['upgrade_domain']


class RollingUpgradeUpdateDescription(msrest.serialization.Model):
    """Describes the parameters for updating a rolling upgrade of application or cluster.

    All required parameters must be populated in order to send to Azure.

    :ivar rolling_upgrade_mode: Required. The mode used to monitor health during a rolling upgrade.
     The values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred. Possible
     values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
     "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
    :vartype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
    :ivar force_restart: If true, then processes are forcefully restarted during upgrade even when
     the code version has not changed (the upgrade only changes configuration or data).
    :vartype force_restart: bool
    :ivar replica_set_check_timeout_in_milliseconds: The maximum amount of time to block processing
     of an upgrade domain and prevent loss of availability when there are unexpected issues. When
     this timeout expires, processing of the upgrade domain will proceed regardless of availability
     loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between
     0 and 42949672925 inclusive. (unsigned 32-bit integer).
    :vartype replica_set_check_timeout_in_milliseconds: long
    :ivar failure_action: The compensating action to perform when a Monitored upgrade encounters
     monitoring policy or health policy violations.
     Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will
     start rolling back automatically.
     Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode. Possible
     values include: "Invalid", "Rollback", "Manual".
    :vartype failure_action: str or ~azure.servicefabric.models.FailureAction
    :ivar health_check_wait_duration_in_milliseconds: The amount of time to wait after completing
     an upgrade domain before applying health policies. It is first interpreted as a string
     representing an ISO 8601 duration. If that fails, then it is interpreted as a number
     representing the total number of milliseconds.
    :vartype health_check_wait_duration_in_milliseconds: str
    :ivar health_check_stable_duration_in_milliseconds: The amount of time that the application or
     cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is first
     interpreted as a string representing an ISO 8601 duration. If that fails, then it is
     interpreted as a number representing the total number of milliseconds.
    :vartype health_check_stable_duration_in_milliseconds: str
    :ivar health_check_retry_timeout_in_milliseconds: The amount of time to retry health evaluation
     when the application or cluster is unhealthy before FailureAction is executed. It is first
     interpreted as a string representing an ISO 8601 duration. If that fails, then it is
     interpreted as a number representing the total number of milliseconds.
    :vartype health_check_retry_timeout_in_milliseconds: str
    :ivar upgrade_timeout_in_milliseconds: The amount of time the overall upgrade has to complete
     before FailureAction is executed. It is first interpreted as a string representing an ISO 8601
     duration. If that fails, then it is interpreted as a number representing the total number of
     milliseconds.
    :vartype upgrade_timeout_in_milliseconds: str
    :ivar upgrade_domain_timeout_in_milliseconds: The amount of time each upgrade domain has to
     complete before FailureAction is executed. It is first interpreted as a string representing an
     ISO 8601 duration. If that fails, then it is interpreted as a number representing the total
     number of milliseconds.
    :vartype upgrade_domain_timeout_in_milliseconds: str
    :ivar instance_close_delay_duration_in_seconds: Duration in seconds, to wait before a stateless
     instance is closed, to allow the active requests to drain gracefully. This would be effective
     when the instance is closing during the application/cluster
     upgrade, only for those instances which have a non-zero delay duration configured in the
     service description. See InstanceCloseDelayDurationSeconds property in $ref:
     "#/definitions/StatelessServiceDescription.yaml" for details.
     Note, the default value of InstanceCloseDelayDurationInSeconds is 4294967295, which indicates
     that the behavior will entirely depend on the delay configured in the stateless service
     description.
    :vartype instance_close_delay_duration_in_seconds: long
    """

    _validation = {
        'rolling_upgrade_mode': {'required': True},
    }

    _attribute_map = {
        'rolling_upgrade_mode': {'key': 'RollingUpgradeMode', 'type': 'str'},
        'force_restart': {'key': 'ForceRestart', 'type': 'bool'},
        'replica_set_check_timeout_in_milliseconds': {'key': 'ReplicaSetCheckTimeoutInMilliseconds', 'type': 'long'},
        'failure_action': {'key': 'FailureAction', 'type': 'str'},
        'health_check_wait_duration_in_milliseconds': {'key': 'HealthCheckWaitDurationInMilliseconds', 'type': 'str'},
        'health_check_stable_duration_in_milliseconds': {'key': 'HealthCheckStableDurationInMilliseconds', 'type': 'str'},
        'health_check_retry_timeout_in_milliseconds': {'key': 'HealthCheckRetryTimeoutInMilliseconds', 'type': 'str'},
        'upgrade_timeout_in_milliseconds': {'key': 'UpgradeTimeoutInMilliseconds', 'type': 'str'},
        'upgrade_domain_timeout_in_milliseconds': {'key': 'UpgradeDomainTimeoutInMilliseconds', 'type': 'str'},
        'instance_close_delay_duration_in_seconds': {'key': 'InstanceCloseDelayDurationInSeconds', 'type': 'long'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword rolling_upgrade_mode: Required. The mode used to monitor health during a rolling
         upgrade. The values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred.
         Possible values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
         "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
        :paramtype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
        :keyword force_restart: If true, then processes are forcefully restarted during upgrade even
         when the code version has not changed (the upgrade only changes configuration or data).
        :paramtype force_restart: bool
        :keyword replica_set_check_timeout_in_milliseconds: The maximum amount of time to block
         processing of an upgrade domain and prevent loss of availability when there are unexpected
         issues. When this timeout expires, processing of the upgrade domain will proceed regardless of
         availability loss issues. The timeout is reset at the start of each upgrade domain. Valid
         values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
        :paramtype replica_set_check_timeout_in_milliseconds: long
        :keyword failure_action: The compensating action to perform when a Monitored upgrade encounters
         monitoring policy or health policy violations.
         Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will
         start rolling back automatically.
         Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode. Possible
         values include: "Invalid", "Rollback", "Manual".
        :paramtype failure_action: str or ~azure.servicefabric.models.FailureAction
        :keyword health_check_wait_duration_in_milliseconds: The amount of time to wait after
         completing an upgrade domain before applying health policies. It is first interpreted as a
         string representing an ISO 8601 duration. If that fails, then it is interpreted as a number
         representing the total number of milliseconds.
        :paramtype health_check_wait_duration_in_milliseconds: str
        :keyword health_check_stable_duration_in_milliseconds: The amount of time that the application
         or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is
         first interpreted as a string representing an ISO 8601 duration. If that fails, then it is
         interpreted as a number representing the total number of milliseconds.
        :paramtype health_check_stable_duration_in_milliseconds: str
        :keyword health_check_retry_timeout_in_milliseconds: The amount of time to retry health
         evaluation when the application or cluster is unhealthy before FailureAction is executed. It is
         first interpreted as a string representing an ISO 8601 duration. If that fails, then it is
         interpreted as a number representing the total number of milliseconds.
        :paramtype health_check_retry_timeout_in_milliseconds: str
        :keyword upgrade_timeout_in_milliseconds: The amount of time the overall upgrade has to
         complete before FailureAction is executed. It is first interpreted as a string representing an
         ISO 8601 duration. If that fails, then it is interpreted as a number representing the total
         number of milliseconds.
        :paramtype upgrade_timeout_in_milliseconds: str
        :keyword upgrade_domain_timeout_in_milliseconds: The amount of time each upgrade domain has to
         complete before FailureAction is executed. It is first interpreted as a string representing an
         ISO 8601 duration. If that fails, then it is interpreted as a number representing the total
         number of milliseconds.
        :paramtype upgrade_domain_timeout_in_milliseconds: str
        :keyword instance_close_delay_duration_in_seconds: Duration in seconds, to wait before a
         stateless instance is closed, to allow the active requests to drain gracefully. This would be
         effective when the instance is closing during the application/cluster
         upgrade, only for those instances which have a non-zero delay duration configured in the
         service description. See InstanceCloseDelayDurationSeconds property in $ref:
         "#/definitions/StatelessServiceDescription.yaml" for details.
         Note, the default value of InstanceCloseDelayDurationInSeconds is 4294967295, which indicates
         that the behavior will entirely depend on the delay configured in the stateless service
         description.
        :paramtype instance_close_delay_duration_in_seconds: long
        """
        super(RollingUpgradeUpdateDescription, self).__init__(**kwargs)
        self.rolling_upgrade_mode = kwargs.get('rolling_upgrade_mode', "UnmonitoredAuto")
        self.force_restart = kwargs.get('force_restart', False)
        self.replica_set_check_timeout_in_milliseconds = kwargs.get('replica_set_check_timeout_in_milliseconds', 42949672925)
        self.failure_action = kwargs.get('failure_action', None)
        self.health_check_wait_duration_in_milliseconds = kwargs.get('health_check_wait_duration_in_milliseconds', "0")
        self.health_check_stable_duration_in_milliseconds = kwargs.get('health_check_stable_duration_in_milliseconds', "PT0H2M0S")
        self.health_check_retry_timeout_in_milliseconds = kwargs.get('health_check_retry_timeout_in_milliseconds', "PT0H10M0S")
        self.upgrade_timeout_in_milliseconds = kwargs.get('upgrade_timeout_in_milliseconds', "P10675199DT02H48M05.4775807S")
        self.upgrade_domain_timeout_in_milliseconds = kwargs.get('upgrade_domain_timeout_in_milliseconds', "P10675199DT02H48M05.4775807S")
        self.instance_close_delay_duration_in_seconds = kwargs.get('instance_close_delay_duration_in_seconds', 4294967295)


class RunToCompletionExecutionPolicy(ExecutionPolicy):
    """The run to completion execution policy, the service will perform its desired operation and complete successfully. If the service encounters failure, it will restarted based on restart policy specified. If the service completes its operation successfully, it will not be restarted again.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. Enumerates the execution policy types for services.Constant filled by
     server. Possible values include: "Default", "RunToCompletion".
    :vartype type: str or ~azure.servicefabric.models.ExecutionPolicyType
    :ivar restart: Required. Enumerates the restart policy for RunToCompletionExecutionPolicy.
     Possible values include: "OnFailure", "Never".
    :vartype restart: str or ~azure.servicefabric.models.RestartPolicy
    """

    _validation = {
        'type': {'required': True},
        'restart': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'restart': {'key': 'restart', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword restart: Required. Enumerates the restart policy for RunToCompletionExecutionPolicy.
         Possible values include: "OnFailure", "Never".
        :paramtype restart: str or ~azure.servicefabric.models.RestartPolicy
        """
        super(RunToCompletionExecutionPolicy, self).__init__(**kwargs)
        self.type = 'RunToCompletion'  # type: str
        self.restart = kwargs['restart']


class SafetyCheckWrapper(msrest.serialization.Model):
    """A wrapper for the safety check object. Safety checks are performed by service fabric before continuing with the operations. These checks ensure the availability of the service and the reliability of the state.

    :ivar safety_check: Represents a safety check performed by service fabric before continuing
     with the operations. These checks ensure the availability of the service and the reliability of
     the state.
    :vartype safety_check: ~azure.servicefabric.models.SafetyCheck
    """

    _attribute_map = {
        'safety_check': {'key': 'SafetyCheck', 'type': 'SafetyCheck'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword safety_check: Represents a safety check performed by service fabric before continuing
         with the operations. These checks ensure the availability of the service and the reliability of
         the state.
        :paramtype safety_check: ~azure.servicefabric.models.SafetyCheck
        """
        super(SafetyCheckWrapper, self).__init__(**kwargs)
        self.safety_check = kwargs.get('safety_check', None)


class ScalingPolicyDescription(msrest.serialization.Model):
    """Describes how the scaling should be performed.

    All required parameters must be populated in order to send to Azure.

    :ivar scaling_trigger: Required. Specifies the trigger associated with this scaling policy.
    :vartype scaling_trigger: ~azure.servicefabric.models.ScalingTriggerDescription
    :ivar scaling_mechanism: Required. Specifies the mechanism associated with this scaling policy.
    :vartype scaling_mechanism: ~azure.servicefabric.models.ScalingMechanismDescription
    """

    _validation = {
        'scaling_trigger': {'required': True},
        'scaling_mechanism': {'required': True},
    }

    _attribute_map = {
        'scaling_trigger': {'key': 'ScalingTrigger', 'type': 'ScalingTriggerDescription'},
        'scaling_mechanism': {'key': 'ScalingMechanism', 'type': 'ScalingMechanismDescription'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword scaling_trigger: Required. Specifies the trigger associated with this scaling policy.
        :paramtype scaling_trigger: ~azure.servicefabric.models.ScalingTriggerDescription
        :keyword scaling_mechanism: Required. Specifies the mechanism associated with this scaling
         policy.
        :paramtype scaling_mechanism: ~azure.servicefabric.models.ScalingMechanismDescription
        """
        super(ScalingPolicyDescription, self).__init__(**kwargs)
        self.scaling_trigger = kwargs['scaling_trigger']
        self.scaling_mechanism = kwargs['scaling_mechanism']


class SecondaryReplicatorStatus(ReplicatorStatus):
    """Provides statistics about the Service Fabric Replicator, when it is functioning in a ActiveSecondary role.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: SecondaryActiveReplicatorStatus, SecondaryIdleReplicatorStatus.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The role of a replica of a stateful service.Constant filled by server.
     Possible values include: "Unknown", "None", "Primary", "IdleSecondary", "ActiveSecondary",
     "IdleAuxiliary", "ActiveAuxiliary", "PrimaryAuxiliary".
    :vartype kind: str or ~azure.servicefabric.models.ReplicaRole
    :ivar replication_queue_status: Details about the replication queue on the secondary
     replicator.
    :vartype replication_queue_status: ~azure.servicefabric.models.ReplicatorQueueStatus
    :ivar last_replication_operation_received_time_utc: The last time-stamp (UTC) at which a
     replication operation was received from the primary.
     UTC 0 represents an invalid value, indicating that a replication operation message was never
     received.
    :vartype last_replication_operation_received_time_utc: ~datetime.datetime
    :ivar is_in_build: Value that indicates whether the replica is currently being built.
    :vartype is_in_build: bool
    :ivar copy_queue_status: Details about the copy queue on the secondary replicator.
    :vartype copy_queue_status: ~azure.servicefabric.models.ReplicatorQueueStatus
    :ivar last_copy_operation_received_time_utc: The last time-stamp (UTC) at which a copy
     operation was received from the primary.
     UTC 0 represents an invalid value, indicating that a copy operation message was never
     received.
    :vartype last_copy_operation_received_time_utc: ~datetime.datetime
    :ivar last_acknowledgement_sent_time_utc: The last time-stamp (UTC) at which an acknowledgment
     was sent to the primary replicator.
     UTC 0 represents an invalid value, indicating that an acknowledgment message was never sent.
    :vartype last_acknowledgement_sent_time_utc: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'replication_queue_status': {'key': 'ReplicationQueueStatus', 'type': 'ReplicatorQueueStatus'},
        'last_replication_operation_received_time_utc': {'key': 'LastReplicationOperationReceivedTimeUtc', 'type': 'iso-8601'},
        'is_in_build': {'key': 'IsInBuild', 'type': 'bool'},
        'copy_queue_status': {'key': 'CopyQueueStatus', 'type': 'ReplicatorQueueStatus'},
        'last_copy_operation_received_time_utc': {'key': 'LastCopyOperationReceivedTimeUtc', 'type': 'iso-8601'},
        'last_acknowledgement_sent_time_utc': {'key': 'LastAcknowledgementSentTimeUtc', 'type': 'iso-8601'},
    }

    _subtype_map = {
        'kind': {'ActiveSecondary': 'SecondaryActiveReplicatorStatus', 'IdleSecondary': 'SecondaryIdleReplicatorStatus'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword replication_queue_status: Details about the replication queue on the secondary
         replicator.
        :paramtype replication_queue_status: ~azure.servicefabric.models.ReplicatorQueueStatus
        :keyword last_replication_operation_received_time_utc: The last time-stamp (UTC) at which a
         replication operation was received from the primary.
         UTC 0 represents an invalid value, indicating that a replication operation message was never
         received.
        :paramtype last_replication_operation_received_time_utc: ~datetime.datetime
        :keyword is_in_build: Value that indicates whether the replica is currently being built.
        :paramtype is_in_build: bool
        :keyword copy_queue_status: Details about the copy queue on the secondary replicator.
        :paramtype copy_queue_status: ~azure.servicefabric.models.ReplicatorQueueStatus
        :keyword last_copy_operation_received_time_utc: The last time-stamp (UTC) at which a copy
         operation was received from the primary.
         UTC 0 represents an invalid value, indicating that a copy operation message was never
         received.
        :paramtype last_copy_operation_received_time_utc: ~datetime.datetime
        :keyword last_acknowledgement_sent_time_utc: The last time-stamp (UTC) at which an
         acknowledgment was sent to the primary replicator.
         UTC 0 represents an invalid value, indicating that an acknowledgment message was never sent.
        :paramtype last_acknowledgement_sent_time_utc: ~datetime.datetime
        """
        super(SecondaryReplicatorStatus, self).__init__(**kwargs)
        self.kind = 'SecondaryReplicatorStatus'  # type: str
        self.replication_queue_status = kwargs.get('replication_queue_status', None)
        self.last_replication_operation_received_time_utc = kwargs.get('last_replication_operation_received_time_utc', None)
        self.is_in_build = kwargs.get('is_in_build', None)
        self.copy_queue_status = kwargs.get('copy_queue_status', None)
        self.last_copy_operation_received_time_utc = kwargs.get('last_copy_operation_received_time_utc', None)
        self.last_acknowledgement_sent_time_utc = kwargs.get('last_acknowledgement_sent_time_utc', None)


class SecondaryActiveReplicatorStatus(SecondaryReplicatorStatus):
    """Status of the secondary replicator when it is in active mode and is part of the replica set.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The role of a replica of a stateful service.Constant filled by server.
     Possible values include: "Unknown", "None", "Primary", "IdleSecondary", "ActiveSecondary",
     "IdleAuxiliary", "ActiveAuxiliary", "PrimaryAuxiliary".
    :vartype kind: str or ~azure.servicefabric.models.ReplicaRole
    :ivar replication_queue_status: Details about the replication queue on the secondary
     replicator.
    :vartype replication_queue_status: ~azure.servicefabric.models.ReplicatorQueueStatus
    :ivar last_replication_operation_received_time_utc: The last time-stamp (UTC) at which a
     replication operation was received from the primary.
     UTC 0 represents an invalid value, indicating that a replication operation message was never
     received.
    :vartype last_replication_operation_received_time_utc: ~datetime.datetime
    :ivar is_in_build: Value that indicates whether the replica is currently being built.
    :vartype is_in_build: bool
    :ivar copy_queue_status: Details about the copy queue on the secondary replicator.
    :vartype copy_queue_status: ~azure.servicefabric.models.ReplicatorQueueStatus
    :ivar last_copy_operation_received_time_utc: The last time-stamp (UTC) at which a copy
     operation was received from the primary.
     UTC 0 represents an invalid value, indicating that a copy operation message was never
     received.
    :vartype last_copy_operation_received_time_utc: ~datetime.datetime
    :ivar last_acknowledgement_sent_time_utc: The last time-stamp (UTC) at which an acknowledgment
     was sent to the primary replicator.
     UTC 0 represents an invalid value, indicating that an acknowledgment message was never sent.
    :vartype last_acknowledgement_sent_time_utc: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'replication_queue_status': {'key': 'ReplicationQueueStatus', 'type': 'ReplicatorQueueStatus'},
        'last_replication_operation_received_time_utc': {'key': 'LastReplicationOperationReceivedTimeUtc', 'type': 'iso-8601'},
        'is_in_build': {'key': 'IsInBuild', 'type': 'bool'},
        'copy_queue_status': {'key': 'CopyQueueStatus', 'type': 'ReplicatorQueueStatus'},
        'last_copy_operation_received_time_utc': {'key': 'LastCopyOperationReceivedTimeUtc', 'type': 'iso-8601'},
        'last_acknowledgement_sent_time_utc': {'key': 'LastAcknowledgementSentTimeUtc', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword replication_queue_status: Details about the replication queue on the secondary
         replicator.
        :paramtype replication_queue_status: ~azure.servicefabric.models.ReplicatorQueueStatus
        :keyword last_replication_operation_received_time_utc: The last time-stamp (UTC) at which a
         replication operation was received from the primary.
         UTC 0 represents an invalid value, indicating that a replication operation message was never
         received.
        :paramtype last_replication_operation_received_time_utc: ~datetime.datetime
        :keyword is_in_build: Value that indicates whether the replica is currently being built.
        :paramtype is_in_build: bool
        :keyword copy_queue_status: Details about the copy queue on the secondary replicator.
        :paramtype copy_queue_status: ~azure.servicefabric.models.ReplicatorQueueStatus
        :keyword last_copy_operation_received_time_utc: The last time-stamp (UTC) at which a copy
         operation was received from the primary.
         UTC 0 represents an invalid value, indicating that a copy operation message was never
         received.
        :paramtype last_copy_operation_received_time_utc: ~datetime.datetime
        :keyword last_acknowledgement_sent_time_utc: The last time-stamp (UTC) at which an
         acknowledgment was sent to the primary replicator.
         UTC 0 represents an invalid value, indicating that an acknowledgment message was never sent.
        :paramtype last_acknowledgement_sent_time_utc: ~datetime.datetime
        """
        super(SecondaryActiveReplicatorStatus, self).__init__(**kwargs)
        self.kind = 'ActiveSecondary'  # type: str


class SecondaryIdleReplicatorStatus(SecondaryReplicatorStatus):
    """Status of the secondary replicator when it is in idle mode and is being built by the primary.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The role of a replica of a stateful service.Constant filled by server.
     Possible values include: "Unknown", "None", "Primary", "IdleSecondary", "ActiveSecondary",
     "IdleAuxiliary", "ActiveAuxiliary", "PrimaryAuxiliary".
    :vartype kind: str or ~azure.servicefabric.models.ReplicaRole
    :ivar replication_queue_status: Details about the replication queue on the secondary
     replicator.
    :vartype replication_queue_status: ~azure.servicefabric.models.ReplicatorQueueStatus
    :ivar last_replication_operation_received_time_utc: The last time-stamp (UTC) at which a
     replication operation was received from the primary.
     UTC 0 represents an invalid value, indicating that a replication operation message was never
     received.
    :vartype last_replication_operation_received_time_utc: ~datetime.datetime
    :ivar is_in_build: Value that indicates whether the replica is currently being built.
    :vartype is_in_build: bool
    :ivar copy_queue_status: Details about the copy queue on the secondary replicator.
    :vartype copy_queue_status: ~azure.servicefabric.models.ReplicatorQueueStatus
    :ivar last_copy_operation_received_time_utc: The last time-stamp (UTC) at which a copy
     operation was received from the primary.
     UTC 0 represents an invalid value, indicating that a copy operation message was never
     received.
    :vartype last_copy_operation_received_time_utc: ~datetime.datetime
    :ivar last_acknowledgement_sent_time_utc: The last time-stamp (UTC) at which an acknowledgment
     was sent to the primary replicator.
     UTC 0 represents an invalid value, indicating that an acknowledgment message was never sent.
    :vartype last_acknowledgement_sent_time_utc: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'replication_queue_status': {'key': 'ReplicationQueueStatus', 'type': 'ReplicatorQueueStatus'},
        'last_replication_operation_received_time_utc': {'key': 'LastReplicationOperationReceivedTimeUtc', 'type': 'iso-8601'},
        'is_in_build': {'key': 'IsInBuild', 'type': 'bool'},
        'copy_queue_status': {'key': 'CopyQueueStatus', 'type': 'ReplicatorQueueStatus'},
        'last_copy_operation_received_time_utc': {'key': 'LastCopyOperationReceivedTimeUtc', 'type': 'iso-8601'},
        'last_acknowledgement_sent_time_utc': {'key': 'LastAcknowledgementSentTimeUtc', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword replication_queue_status: Details about the replication queue on the secondary
         replicator.
        :paramtype replication_queue_status: ~azure.servicefabric.models.ReplicatorQueueStatus
        :keyword last_replication_operation_received_time_utc: The last time-stamp (UTC) at which a
         replication operation was received from the primary.
         UTC 0 represents an invalid value, indicating that a replication operation message was never
         received.
        :paramtype last_replication_operation_received_time_utc: ~datetime.datetime
        :keyword is_in_build: Value that indicates whether the replica is currently being built.
        :paramtype is_in_build: bool
        :keyword copy_queue_status: Details about the copy queue on the secondary replicator.
        :paramtype copy_queue_status: ~azure.servicefabric.models.ReplicatorQueueStatus
        :keyword last_copy_operation_received_time_utc: The last time-stamp (UTC) at which a copy
         operation was received from the primary.
         UTC 0 represents an invalid value, indicating that a copy operation message was never
         received.
        :paramtype last_copy_operation_received_time_utc: ~datetime.datetime
        :keyword last_acknowledgement_sent_time_utc: The last time-stamp (UTC) at which an
         acknowledgment was sent to the primary replicator.
         UTC 0 represents an invalid value, indicating that an acknowledgment message was never sent.
        :paramtype last_acknowledgement_sent_time_utc: ~datetime.datetime
        """
        super(SecondaryIdleReplicatorStatus, self).__init__(**kwargs)
        self.kind = 'IdleSecondary'  # type: str


class SecretResourceDescription(msrest.serialization.Model):
    """This type describes a secret resource.

    All required parameters must be populated in order to send to Azure.

    :ivar properties: Required. Describes the properties of a secret resource.
    :vartype properties: ~azure.servicefabric.models.SecretResourceProperties
    :ivar name: Required. Name of the Secret resource.
    :vartype name: str
    """

    _validation = {
        'properties': {'required': True},
        'name': {'required': True},
    }

    _attribute_map = {
        'properties': {'key': 'properties', 'type': 'SecretResourceProperties'},
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword properties: Required. Describes the properties of a secret resource.
        :paramtype properties: ~azure.servicefabric.models.SecretResourceProperties
        :keyword name: Required. Name of the Secret resource.
        :paramtype name: str
        """
        super(SecretResourceDescription, self).__init__(**kwargs)
        self.properties = kwargs['properties']
        self.name = kwargs['name']


class SecretValue(msrest.serialization.Model):
    """This type represents the unencrypted value of the secret.

    :ivar value: The actual value of the secret.
    :vartype value: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword value: The actual value of the secret.
        :paramtype value: str
        """
        super(SecretValue, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)


class SecretValueProperties(msrest.serialization.Model):
    """This type describes properties of secret value resource.

    :ivar value: The actual value of the secret.
    :vartype value: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword value: The actual value of the secret.
        :paramtype value: str
        """
        super(SecretValueProperties, self).__init__(**kwargs)
        self.value = kwargs.get('value', None)


class SecretValueResourceDescription(msrest.serialization.Model):
    """This type describes a value of a secret resource. The name of this resource is the version identifier corresponding to this secret value.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. Version identifier of the secret value.
    :vartype name: str
    :ivar value: The actual value of the secret.
    :vartype value: str
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'properties.value', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. Version identifier of the secret value.
        :paramtype name: str
        :keyword value: The actual value of the secret.
        :paramtype value: str
        """
        super(SecretValueResourceDescription, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.value = kwargs.get('value', None)


class SecretValueResourceProperties(SecretValueProperties):
    """This type describes properties of a secret value resource.

    :ivar value: The actual value of the secret.
    :vartype value: str
    """

    _attribute_map = {
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword value: The actual value of the secret.
        :paramtype value: str
        """
        super(SecretValueResourceProperties, self).__init__(**kwargs)


class SeedNodeSafetyCheck(SafetyCheck):
    """Represents a safety check for the seed nodes being performed by service fabric before continuing with node level operations.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of safety check performed by service fabric before continuing
     with the operations. These checks ensure the availability of the service and the reliability of
     the state. Following are the kinds of safety checks.Constant filled by server. Possible values
     include: "Invalid", "EnsureSeedNodeQuorum", "EnsurePartitionQuorum", "WaitForPrimaryPlacement",
     "WaitForPrimarySwap", "WaitForReconfiguration", "WaitForInbuildReplica", "EnsureAvailability".
    :vartype kind: str or ~azure.servicefabric.models.SafetyCheckKind
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(SeedNodeSafetyCheck, self).__init__(**kwargs)
        self.kind = 'EnsureSeedNodeQuorum'  # type: str


class SelectedPartition(msrest.serialization.Model):
    """This class returns information about the partition that the user-induced operation acted upon.

    :ivar service_name: The name of the service the partition belongs to.
    :vartype service_name: str
    :ivar partition_id: An internal ID used by Service Fabric to uniquely identify a partition.
     This is a randomly generated GUID when the service was created. The partition ID is unique and
     does not change for the lifetime of the service. If the same service was deleted and recreated
     the IDs of its partitions would be different.
    :vartype partition_id: str
    """

    _attribute_map = {
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_name: The name of the service the partition belongs to.
        :paramtype service_name: str
        :keyword partition_id: An internal ID used by Service Fabric to uniquely identify a partition.
         This is a randomly generated GUID when the service was created. The partition ID is unique and
         does not change for the lifetime of the service. If the same service was deleted and recreated
         the IDs of its partitions would be different.
        :paramtype partition_id: str
        """
        super(SelectedPartition, self).__init__(**kwargs)
        self.service_name = kwargs.get('service_name', None)
        self.partition_id = kwargs.get('partition_id', None)


class ServiceBackupConfigurationInfo(BackupConfigurationInfo):
    """Backup configuration information for a specific Service Fabric service specifying what backup policy is being applied and suspend description, if any.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The entity type of a Service Fabric entity such as Application, Service
     or a Partition where periodic backups can be enabled.Constant filled by server. Possible values
     include: "Invalid", "Partition", "Service", "Application".
    :vartype kind: str or ~azure.servicefabric.models.BackupEntityKind
    :ivar policy_name: The name of the backup policy which is applicable to this Service Fabric
     application or service or partition.
    :vartype policy_name: str
    :ivar policy_inherited_from: Specifies the scope at which the backup policy is applied.
     Possible values include: "Invalid", "Partition", "Service", "Application".
    :vartype policy_inherited_from: str or ~azure.servicefabric.models.BackupPolicyScope
    :ivar suspension_info: Describes the backup suspension details.
    :vartype suspension_info: ~azure.servicefabric.models.BackupSuspensionInfo
    :ivar service_name: The full name of the service with 'fabric:' URI scheme.
    :vartype service_name: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'policy_name': {'key': 'PolicyName', 'type': 'str'},
        'policy_inherited_from': {'key': 'PolicyInheritedFrom', 'type': 'str'},
        'suspension_info': {'key': 'SuspensionInfo', 'type': 'BackupSuspensionInfo'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword policy_name: The name of the backup policy which is applicable to this Service Fabric
         application or service or partition.
        :paramtype policy_name: str
        :keyword policy_inherited_from: Specifies the scope at which the backup policy is applied.
         Possible values include: "Invalid", "Partition", "Service", "Application".
        :paramtype policy_inherited_from: str or ~azure.servicefabric.models.BackupPolicyScope
        :keyword suspension_info: Describes the backup suspension details.
        :paramtype suspension_info: ~azure.servicefabric.models.BackupSuspensionInfo
        :keyword service_name: The full name of the service with 'fabric:' URI scheme.
        :paramtype service_name: str
        """
        super(ServiceBackupConfigurationInfo, self).__init__(**kwargs)
        self.kind = 'Service'  # type: str
        self.service_name = kwargs.get('service_name', None)


class ServiceBackupEntity(BackupEntity):
    """Identifies the Service Fabric stateful service which is being backed up.

    All required parameters must be populated in order to send to Azure.

    :ivar entity_kind: Required. The entity type of a Service Fabric entity such as Application,
     Service or a Partition where periodic backups can be enabled.Constant filled by server.
     Possible values include: "Invalid", "Partition", "Service", "Application".
    :vartype entity_kind: str or ~azure.servicefabric.models.BackupEntityKind
    :ivar service_name: The full name of the service with 'fabric:' URI scheme.
    :vartype service_name: str
    """

    _validation = {
        'entity_kind': {'required': True},
    }

    _attribute_map = {
        'entity_kind': {'key': 'EntityKind', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_name: The full name of the service with 'fabric:' URI scheme.
        :paramtype service_name: str
        """
        super(ServiceBackupEntity, self).__init__(**kwargs)
        self.entity_kind = 'Service'  # type: str
        self.service_name = kwargs.get('service_name', None)


class ServiceCorrelationDescription(msrest.serialization.Model):
    """Creates a particular correlation between services.

    All required parameters must be populated in order to send to Azure.

    :ivar scheme: Required. The ServiceCorrelationScheme which describes the relationship between
     this service and the service specified via ServiceName. Possible values include: "Invalid",
     "Affinity", "AlignedAffinity", "NonAlignedAffinity".
    :vartype scheme: str or ~azure.servicefabric.models.ServiceCorrelationScheme
    :ivar service_name: Required. The name of the service that the correlation relationship is
     established with.
    :vartype service_name: str
    """

    _validation = {
        'scheme': {'required': True},
        'service_name': {'required': True},
    }

    _attribute_map = {
        'scheme': {'key': 'Scheme', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword scheme: Required. The ServiceCorrelationScheme which describes the relationship
         between this service and the service specified via ServiceName. Possible values include:
         "Invalid", "Affinity", "AlignedAffinity", "NonAlignedAffinity".
        :paramtype scheme: str or ~azure.servicefabric.models.ServiceCorrelationScheme
        :keyword service_name: Required. The name of the service that the correlation relationship is
         established with.
        :paramtype service_name: str
        """
        super(ServiceCorrelationDescription, self).__init__(**kwargs)
        self.scheme = kwargs['scheme']
        self.service_name = kwargs['service_name']


class ServiceEvent(FabricEvent):
    """Represents the base for all Service Events.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ServiceCreatedEvent, ServiceDeletedEvent, ServiceHealthReportExpiredEvent, ServiceNewHealthReportEvent.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar service_id: Required. The identity of the service. This ID is an encoded representation
     of the service name. This is used in the REST APIs to identify the service resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the service name is "fabric:/myapp/app1/svc1",
     the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
     versions.
    :vartype service_id: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'service_id': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'service_id': {'key': 'ServiceId', 'type': 'str'},
    }

    _subtype_map = {
        'kind': {'ServiceCreated': 'ServiceCreatedEvent', 'ServiceDeleted': 'ServiceDeletedEvent', 'ServiceHealthReportExpired': 'ServiceHealthReportExpiredEvent', 'ServiceNewHealthReport': 'ServiceNewHealthReportEvent'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword service_id: Required. The identity of the service. This ID is an encoded
         representation of the service name. This is used in the REST APIs to identify the service
         resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the service name is "fabric:/myapp/app1/svc1",
         the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
         versions.
        :paramtype service_id: str
        """
        super(ServiceEvent, self).__init__(**kwargs)
        self.kind = 'ServiceEvent'  # type: str
        self.service_id = kwargs['service_id']


class ServiceCreatedEvent(ServiceEvent):
    """Service Created event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar service_id: Required. The identity of the service. This ID is an encoded representation
     of the service name. This is used in the REST APIs to identify the service resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the service name is "fabric:/myapp/app1/svc1",
     the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
     versions.
    :vartype service_id: str
    :ivar service_type_name: Required. Service type name.
    :vartype service_type_name: str
    :ivar application_name: Required. Application name.
    :vartype application_name: str
    :ivar application_type_name: Required. Application type name.
    :vartype application_type_name: str
    :ivar service_instance: Required. Id of Service instance.
    :vartype service_instance: long
    :ivar is_stateful: Required. Indicates if Service is stateful.
    :vartype is_stateful: bool
    :ivar partition_count: Required. Number of partitions.
    :vartype partition_count: int
    :ivar target_replica_set_size: Required. Size of target replicas set.
    :vartype target_replica_set_size: int
    :ivar min_replica_set_size: Required. Minimum size of replicas set.
    :vartype min_replica_set_size: int
    :ivar service_package_version: Required. Version of Service package.
    :vartype service_package_version: str
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'service_id': {'required': True},
        'service_type_name': {'required': True},
        'application_name': {'required': True},
        'application_type_name': {'required': True},
        'service_instance': {'required': True},
        'is_stateful': {'required': True},
        'partition_count': {'required': True},
        'target_replica_set_size': {'required': True},
        'min_replica_set_size': {'required': True},
        'service_package_version': {'required': True},
        'partition_id': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'service_id': {'key': 'ServiceId', 'type': 'str'},
        'service_type_name': {'key': 'ServiceTypeName', 'type': 'str'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
        'application_type_name': {'key': 'ApplicationTypeName', 'type': 'str'},
        'service_instance': {'key': 'ServiceInstance', 'type': 'long'},
        'is_stateful': {'key': 'IsStateful', 'type': 'bool'},
        'partition_count': {'key': 'PartitionCount', 'type': 'int'},
        'target_replica_set_size': {'key': 'TargetReplicaSetSize', 'type': 'int'},
        'min_replica_set_size': {'key': 'MinReplicaSetSize', 'type': 'int'},
        'service_package_version': {'key': 'ServicePackageVersion', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword service_id: Required. The identity of the service. This ID is an encoded
         representation of the service name. This is used in the REST APIs to identify the service
         resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the service name is "fabric:/myapp/app1/svc1",
         the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
         versions.
        :paramtype service_id: str
        :keyword service_type_name: Required. Service type name.
        :paramtype service_type_name: str
        :keyword application_name: Required. Application name.
        :paramtype application_name: str
        :keyword application_type_name: Required. Application type name.
        :paramtype application_type_name: str
        :keyword service_instance: Required. Id of Service instance.
        :paramtype service_instance: long
        :keyword is_stateful: Required. Indicates if Service is stateful.
        :paramtype is_stateful: bool
        :keyword partition_count: Required. Number of partitions.
        :paramtype partition_count: int
        :keyword target_replica_set_size: Required. Size of target replicas set.
        :paramtype target_replica_set_size: int
        :keyword min_replica_set_size: Required. Minimum size of replicas set.
        :paramtype min_replica_set_size: int
        :keyword service_package_version: Required. Version of Service package.
        :paramtype service_package_version: str
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        """
        super(ServiceCreatedEvent, self).__init__(**kwargs)
        self.kind = 'ServiceCreated'  # type: str
        self.service_type_name = kwargs['service_type_name']
        self.application_name = kwargs['application_name']
        self.application_type_name = kwargs['application_type_name']
        self.service_instance = kwargs['service_instance']
        self.is_stateful = kwargs['is_stateful']
        self.partition_count = kwargs['partition_count']
        self.target_replica_set_size = kwargs['target_replica_set_size']
        self.min_replica_set_size = kwargs['min_replica_set_size']
        self.service_package_version = kwargs['service_package_version']
        self.partition_id = kwargs['partition_id']


class ServiceDeletedEvent(ServiceEvent):
    """Service Deleted event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar service_id: Required. The identity of the service. This ID is an encoded representation
     of the service name. This is used in the REST APIs to identify the service resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the service name is "fabric:/myapp/app1/svc1",
     the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
     versions.
    :vartype service_id: str
    :ivar service_type_name: Required. Service type name.
    :vartype service_type_name: str
    :ivar application_name: Required. Application name.
    :vartype application_name: str
    :ivar application_type_name: Required. Application type name.
    :vartype application_type_name: str
    :ivar service_instance: Required. Id of Service instance.
    :vartype service_instance: long
    :ivar is_stateful: Required. Indicates if Service is stateful.
    :vartype is_stateful: bool
    :ivar partition_count: Required. Number of partitions.
    :vartype partition_count: int
    :ivar target_replica_set_size: Required. Size of target replicas set.
    :vartype target_replica_set_size: int
    :ivar min_replica_set_size: Required. Minimum size of replicas set.
    :vartype min_replica_set_size: int
    :ivar service_package_version: Required. Version of Service package.
    :vartype service_package_version: str
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'service_id': {'required': True},
        'service_type_name': {'required': True},
        'application_name': {'required': True},
        'application_type_name': {'required': True},
        'service_instance': {'required': True},
        'is_stateful': {'required': True},
        'partition_count': {'required': True},
        'target_replica_set_size': {'required': True},
        'min_replica_set_size': {'required': True},
        'service_package_version': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'service_id': {'key': 'ServiceId', 'type': 'str'},
        'service_type_name': {'key': 'ServiceTypeName', 'type': 'str'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
        'application_type_name': {'key': 'ApplicationTypeName', 'type': 'str'},
        'service_instance': {'key': 'ServiceInstance', 'type': 'long'},
        'is_stateful': {'key': 'IsStateful', 'type': 'bool'},
        'partition_count': {'key': 'PartitionCount', 'type': 'int'},
        'target_replica_set_size': {'key': 'TargetReplicaSetSize', 'type': 'int'},
        'min_replica_set_size': {'key': 'MinReplicaSetSize', 'type': 'int'},
        'service_package_version': {'key': 'ServicePackageVersion', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword service_id: Required. The identity of the service. This ID is an encoded
         representation of the service name. This is used in the REST APIs to identify the service
         resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the service name is "fabric:/myapp/app1/svc1",
         the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
         versions.
        :paramtype service_id: str
        :keyword service_type_name: Required. Service type name.
        :paramtype service_type_name: str
        :keyword application_name: Required. Application name.
        :paramtype application_name: str
        :keyword application_type_name: Required. Application type name.
        :paramtype application_type_name: str
        :keyword service_instance: Required. Id of Service instance.
        :paramtype service_instance: long
        :keyword is_stateful: Required. Indicates if Service is stateful.
        :paramtype is_stateful: bool
        :keyword partition_count: Required. Number of partitions.
        :paramtype partition_count: int
        :keyword target_replica_set_size: Required. Size of target replicas set.
        :paramtype target_replica_set_size: int
        :keyword min_replica_set_size: Required. Minimum size of replicas set.
        :paramtype min_replica_set_size: int
        :keyword service_package_version: Required. Version of Service package.
        :paramtype service_package_version: str
        """
        super(ServiceDeletedEvent, self).__init__(**kwargs)
        self.kind = 'ServiceDeleted'  # type: str
        self.service_type_name = kwargs['service_type_name']
        self.application_name = kwargs['application_name']
        self.application_type_name = kwargs['application_type_name']
        self.service_instance = kwargs['service_instance']
        self.is_stateful = kwargs['is_stateful']
        self.partition_count = kwargs['partition_count']
        self.target_replica_set_size = kwargs['target_replica_set_size']
        self.min_replica_set_size = kwargs['min_replica_set_size']
        self.service_package_version = kwargs['service_package_version']


class ServiceDescription(msrest.serialization.Model):
    """A ServiceDescription contains all of the information necessary to create a service.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: StatefulServiceDescription, StatelessServiceDescription.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The service kind.Constant filled by server. Possible values
     include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar application_name: The name of the application, including the 'fabric:' URI scheme.
    :vartype application_name: str
    :ivar service_name: Required. The full name of the service with 'fabric:' URI scheme.
    :vartype service_name: str
    :ivar service_type_name: Required. Name of the service type as specified in the service
     manifest.
    :vartype service_type_name: str
    :ivar initialization_data: The initialization data as an array of bytes. Initialization data is
     passed to service instances or replicas when they are created.
    :vartype initialization_data: list[int]
    :ivar partition_description: Required. The partition description as an object.
    :vartype partition_description: ~azure.servicefabric.models.PartitionSchemeDescription
    :ivar placement_constraints: The placement constraints as a string. Placement constraints are
     boolean expressions on node properties and allow for restricting a service to particular nodes
     based on the service requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :vartype placement_constraints: str
    :ivar correlation_scheme: The correlation scheme.
    :vartype correlation_scheme: list[~azure.servicefabric.models.ServiceCorrelationDescription]
    :ivar service_load_metrics: The service load metrics.
    :vartype service_load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: The service placement policies.
    :vartype service_placement_policies:
     list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar default_move_cost: The move cost for the service. Possible values include: "Zero", "Low",
     "Medium", "High", "VeryHigh".
    :vartype default_move_cost: str or ~azure.servicefabric.models.MoveCost
    :ivar is_default_move_cost_specified: Indicates if the DefaultMoveCost property is specified.
    :vartype is_default_move_cost_specified: bool
    :ivar service_package_activation_mode: The activation mode of service package to be used for a
     service. Possible values include: "SharedProcess", "ExclusiveProcess".
    :vartype service_package_activation_mode: str or
     ~azure.servicefabric.models.ServicePackageActivationMode
    :ivar service_dns_name: The DNS name of the service. It requires the DNS system service to be
     enabled in Service Fabric cluster.
    :vartype service_dns_name: str
    :ivar scaling_policies: Scaling policies for this service.
    :vartype scaling_policies: list[~azure.servicefabric.models.ScalingPolicyDescription]
    :ivar tags_required_to_place: Tags for placement of this service.
    :vartype tags_required_to_place: ~azure.servicefabric.models.NodeTagsDescription
    :ivar tags_required_to_run: Tags for running of this service.
    :vartype tags_required_to_run: ~azure.servicefabric.models.NodeTagsDescription
    """

    _validation = {
        'service_kind': {'required': True},
        'service_name': {'required': True},
        'service_type_name': {'required': True},
        'partition_description': {'required': True},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'service_type_name': {'key': 'ServiceTypeName', 'type': 'str'},
        'initialization_data': {'key': 'InitializationData', 'type': '[int]'},
        'partition_description': {'key': 'PartitionDescription', 'type': 'PartitionSchemeDescription'},
        'placement_constraints': {'key': 'PlacementConstraints', 'type': 'str'},
        'correlation_scheme': {'key': 'CorrelationScheme', 'type': '[ServiceCorrelationDescription]'},
        'service_load_metrics': {'key': 'ServiceLoadMetrics', 'type': '[ServiceLoadMetricDescription]'},
        'service_placement_policies': {'key': 'ServicePlacementPolicies', 'type': '[ServicePlacementPolicyDescription]'},
        'default_move_cost': {'key': 'DefaultMoveCost', 'type': 'str'},
        'is_default_move_cost_specified': {'key': 'IsDefaultMoveCostSpecified', 'type': 'bool'},
        'service_package_activation_mode': {'key': 'ServicePackageActivationMode', 'type': 'str'},
        'service_dns_name': {'key': 'ServiceDnsName', 'type': 'str'},
        'scaling_policies': {'key': 'ScalingPolicies', 'type': '[ScalingPolicyDescription]'},
        'tags_required_to_place': {'key': 'TagsRequiredToPlace', 'type': 'NodeTagsDescription'},
        'tags_required_to_run': {'key': 'TagsRequiredToRun', 'type': 'NodeTagsDescription'},
    }

    _subtype_map = {
        'service_kind': {'Stateful': 'StatefulServiceDescription', 'Stateless': 'StatelessServiceDescription'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword application_name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype application_name: str
        :keyword service_name: Required. The full name of the service with 'fabric:' URI scheme.
        :paramtype service_name: str
        :keyword service_type_name: Required. Name of the service type as specified in the service
         manifest.
        :paramtype service_type_name: str
        :keyword initialization_data: The initialization data as an array of bytes. Initialization data
         is passed to service instances or replicas when they are created.
        :paramtype initialization_data: list[int]
        :keyword partition_description: Required. The partition description as an object.
        :paramtype partition_description: ~azure.servicefabric.models.PartitionSchemeDescription
        :keyword placement_constraints: The placement constraints as a string. Placement constraints
         are boolean expressions on node properties and allow for restricting a service to particular
         nodes based on the service requirements. For example, to place a service on nodes where
         NodeType is blue specify the following: "NodeColor == blue)".
        :paramtype placement_constraints: str
        :keyword correlation_scheme: The correlation scheme.
        :paramtype correlation_scheme: list[~azure.servicefabric.models.ServiceCorrelationDescription]
        :keyword service_load_metrics: The service load metrics.
        :paramtype service_load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
        :keyword service_placement_policies: The service placement policies.
        :paramtype service_placement_policies:
         list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
        :keyword default_move_cost: The move cost for the service. Possible values include: "Zero",
         "Low", "Medium", "High", "VeryHigh".
        :paramtype default_move_cost: str or ~azure.servicefabric.models.MoveCost
        :keyword is_default_move_cost_specified: Indicates if the DefaultMoveCost property is
         specified.
        :paramtype is_default_move_cost_specified: bool
        :keyword service_package_activation_mode: The activation mode of service package to be used for
         a service. Possible values include: "SharedProcess", "ExclusiveProcess".
        :paramtype service_package_activation_mode: str or
         ~azure.servicefabric.models.ServicePackageActivationMode
        :keyword service_dns_name: The DNS name of the service. It requires the DNS system service to
         be enabled in Service Fabric cluster.
        :paramtype service_dns_name: str
        :keyword scaling_policies: Scaling policies for this service.
        :paramtype scaling_policies: list[~azure.servicefabric.models.ScalingPolicyDescription]
        :keyword tags_required_to_place: Tags for placement of this service.
        :paramtype tags_required_to_place: ~azure.servicefabric.models.NodeTagsDescription
        :keyword tags_required_to_run: Tags for running of this service.
        :paramtype tags_required_to_run: ~azure.servicefabric.models.NodeTagsDescription
        """
        super(ServiceDescription, self).__init__(**kwargs)
        self.service_kind = None  # type: Optional[str]
        self.application_name = kwargs.get('application_name', None)
        self.service_name = kwargs['service_name']
        self.service_type_name = kwargs['service_type_name']
        self.initialization_data = kwargs.get('initialization_data', None)
        self.partition_description = kwargs['partition_description']
        self.placement_constraints = kwargs.get('placement_constraints', None)
        self.correlation_scheme = kwargs.get('correlation_scheme', None)
        self.service_load_metrics = kwargs.get('service_load_metrics', None)
        self.service_placement_policies = kwargs.get('service_placement_policies', None)
        self.default_move_cost = kwargs.get('default_move_cost', None)
        self.is_default_move_cost_specified = kwargs.get('is_default_move_cost_specified', None)
        self.service_package_activation_mode = kwargs.get('service_package_activation_mode', None)
        self.service_dns_name = kwargs.get('service_dns_name', None)
        self.scaling_policies = kwargs.get('scaling_policies', None)
        self.tags_required_to_place = kwargs.get('tags_required_to_place', None)
        self.tags_required_to_run = kwargs.get('tags_required_to_run', None)


class ServiceFromTemplateDescription(msrest.serialization.Model):
    """Defines description for creating a Service Fabric service from a template defined in the application manifest.

    All required parameters must be populated in order to send to Azure.

    :ivar application_name: Required. The name of the application, including the 'fabric:' URI
     scheme.
    :vartype application_name: str
    :ivar service_name: Required. The full name of the service with 'fabric:' URI scheme.
    :vartype service_name: str
    :ivar service_type_name: Required. Name of the service type as specified in the service
     manifest.
    :vartype service_type_name: str
    :ivar initialization_data: The initialization data for the newly created service instance.
    :vartype initialization_data: list[int]
    :ivar service_package_activation_mode: The activation mode of service package to be used for a
     service. Possible values include: "SharedProcess", "ExclusiveProcess".
    :vartype service_package_activation_mode: str or
     ~azure.servicefabric.models.ServicePackageActivationMode
    :ivar service_dns_name: The DNS name of the service. It requires the DNS system service to be
     enabled in Service Fabric cluster.
    :vartype service_dns_name: str
    """

    _validation = {
        'application_name': {'required': True},
        'service_name': {'required': True},
        'service_type_name': {'required': True},
    }

    _attribute_map = {
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'service_type_name': {'key': 'ServiceTypeName', 'type': 'str'},
        'initialization_data': {'key': 'InitializationData', 'type': '[int]'},
        'service_package_activation_mode': {'key': 'ServicePackageActivationMode', 'type': 'str'},
        'service_dns_name': {'key': 'ServiceDnsName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword application_name: Required. The name of the application, including the 'fabric:' URI
         scheme.
        :paramtype application_name: str
        :keyword service_name: Required. The full name of the service with 'fabric:' URI scheme.
        :paramtype service_name: str
        :keyword service_type_name: Required. Name of the service type as specified in the service
         manifest.
        :paramtype service_type_name: str
        :keyword initialization_data: The initialization data for the newly created service instance.
        :paramtype initialization_data: list[int]
        :keyword service_package_activation_mode: The activation mode of service package to be used for
         a service. Possible values include: "SharedProcess", "ExclusiveProcess".
        :paramtype service_package_activation_mode: str or
         ~azure.servicefabric.models.ServicePackageActivationMode
        :keyword service_dns_name: The DNS name of the service. It requires the DNS system service to
         be enabled in Service Fabric cluster.
        :paramtype service_dns_name: str
        """
        super(ServiceFromTemplateDescription, self).__init__(**kwargs)
        self.application_name = kwargs['application_name']
        self.service_name = kwargs['service_name']
        self.service_type_name = kwargs['service_type_name']
        self.initialization_data = kwargs.get('initialization_data', None)
        self.service_package_activation_mode = kwargs.get('service_package_activation_mode', None)
        self.service_dns_name = kwargs.get('service_dns_name', None)


class ServiceHealth(EntityHealth):
    """Information about the health of a Service Fabric service.

    :ivar aggregated_health_state: The HealthState representing the aggregated health state of the
     entity computed by Health Manager.
     The health evaluation of the entity reflects all events reported on the entity and its
     children (if any).
     The aggregation is done by applying the desired health policy. Possible values include:
     "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar health_events: The list of health events reported on the entity.
    :vartype health_events: list[~azure.servicefabric.models.HealthEvent]
    :ivar unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
     health state was returned by Health Manager.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    :ivar health_statistics: Shows the health statistics for all children types of the queried
     entity.
    :vartype health_statistics: ~azure.servicefabric.models.HealthStatistics
    :ivar name: The name of the service whose health information is described by this object.
    :vartype name: str
    :ivar partition_health_states: The list of partition health states associated with the service.
    :vartype partition_health_states: list[~azure.servicefabric.models.PartitionHealthState]
    """

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'health_events': {'key': 'HealthEvents', 'type': '[HealthEvent]'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
        'health_statistics': {'key': 'HealthStatistics', 'type': 'HealthStatistics'},
        'name': {'key': 'Name', 'type': 'str'},
        'partition_health_states': {'key': 'PartitionHealthStates', 'type': '[PartitionHealthState]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The HealthState representing the aggregated health state of
         the entity computed by Health Manager.
         The health evaluation of the entity reflects all events reported on the entity and its
         children (if any).
         The aggregation is done by applying the desired health policy. Possible values include:
         "Invalid", "Ok", "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword health_events: The list of health events reported on the entity.
        :paramtype health_events: list[~azure.servicefabric.models.HealthEvent]
        :keyword unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
         health state was returned by Health Manager.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        :keyword health_statistics: Shows the health statistics for all children types of the queried
         entity.
        :paramtype health_statistics: ~azure.servicefabric.models.HealthStatistics
        :keyword name: The name of the service whose health information is described by this object.
        :paramtype name: str
        :keyword partition_health_states: The list of partition health states associated with the
         service.
        :paramtype partition_health_states: list[~azure.servicefabric.models.PartitionHealthState]
        """
        super(ServiceHealth, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.partition_health_states = kwargs.get('partition_health_states', None)


class ServiceHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for a service, containing information about the data and the algorithm used by health store to evaluate health. The evaluation is returned only when the aggregated health state is either Error or Warning.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar service_name: Name of the service whose health evaluation is described by this object.
    :vartype service_name: str
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the current aggregated
     health state of the service. The types of the unhealthy evaluations can be
     PartitionsHealthEvaluation or EventHealthEvaluation.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword service_name: Name of the service whose health evaluation is described by this object.
        :paramtype service_name: str
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the current
         aggregated health state of the service. The types of the unhealthy evaluations can be
         PartitionsHealthEvaluation or EventHealthEvaluation.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(ServiceHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'Service'  # type: str
        self.service_name = kwargs.get('service_name', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class ServiceHealthReportExpiredEvent(ServiceEvent):
    """Service Health Report Expired event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar service_id: Required. The identity of the service. This ID is an encoded representation
     of the service name. This is used in the REST APIs to identify the service resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the service name is "fabric:/myapp/app1/svc1",
     the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
     versions.
    :vartype service_id: str
    :ivar instance_id: Required. Id of Service instance.
    :vartype instance_id: long
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'service_id': {'required': True},
        'instance_id': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'service_id': {'key': 'ServiceId', 'type': 'str'},
        'instance_id': {'key': 'InstanceId', 'type': 'long'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword service_id: Required. The identity of the service. This ID is an encoded
         representation of the service name. This is used in the REST APIs to identify the service
         resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the service name is "fabric:/myapp/app1/svc1",
         the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
         versions.
        :paramtype service_id: str
        :keyword instance_id: Required. Id of Service instance.
        :paramtype instance_id: long
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(ServiceHealthReportExpiredEvent, self).__init__(**kwargs)
        self.kind = 'ServiceHealthReportExpired'  # type: str
        self.instance_id = kwargs['instance_id']
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class ServiceHealthState(EntityHealthState):
    """Represents the health state of a service, which contains the service identifier and its aggregated health state.

    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar service_name: Name of the service whose health state is represented by this object.
    :vartype service_name: str
    """

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword service_name: Name of the service whose health state is represented by this object.
        :paramtype service_name: str
        """
        super(ServiceHealthState, self).__init__(**kwargs)
        self.service_name = kwargs.get('service_name', None)


class ServiceHealthStateChunk(EntityHealthStateChunk):
    """Represents the health state chunk of a service, which contains the service name, its aggregated health state and any partitions that respect the filters in the cluster health chunk query description.

    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar service_name: The name of the service whose health state chunk is provided in this
     object.
    :vartype service_name: str
    :ivar partition_health_state_chunks: The list of partition health state chunks belonging to the
     service that respect the filters in the cluster health chunk query description.
    :vartype partition_health_state_chunks:
     ~azure.servicefabric.models.PartitionHealthStateChunkList
    """

    _attribute_map = {
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'partition_health_state_chunks': {'key': 'PartitionHealthStateChunks', 'type': 'PartitionHealthStateChunkList'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword service_name: The name of the service whose health state chunk is provided in this
         object.
        :paramtype service_name: str
        :keyword partition_health_state_chunks: The list of partition health state chunks belonging to
         the service that respect the filters in the cluster health chunk query description.
        :paramtype partition_health_state_chunks:
         ~azure.servicefabric.models.PartitionHealthStateChunkList
        """
        super(ServiceHealthStateChunk, self).__init__(**kwargs)
        self.service_name = kwargs.get('service_name', None)
        self.partition_health_state_chunks = kwargs.get('partition_health_state_chunks', None)


class ServiceHealthStateChunkList(msrest.serialization.Model):
    """The list of service health state chunks that respect the input filters in the chunk query. Returned by get cluster health state chunks query.

    :ivar items: The list of service health state chunks that respect the input filters in the
     chunk query.
    :vartype items: list[~azure.servicefabric.models.ServiceHealthStateChunk]
    """

    _attribute_map = {
        'items': {'key': 'Items', 'type': '[ServiceHealthStateChunk]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword items: The list of service health state chunks that respect the input filters in the
         chunk query.
        :paramtype items: list[~azure.servicefabric.models.ServiceHealthStateChunk]
        """
        super(ServiceHealthStateChunkList, self).__init__(**kwargs)
        self.items = kwargs.get('items', None)


class ServiceHealthStateFilter(msrest.serialization.Model):
    """Defines matching criteria to determine whether a service should be included as a child of an application in the cluster health chunk.
The services are only returned if the parent application matches a filter specified in the cluster health chunk query description.
One filter can match zero, one or multiple services, depending on its properties.

    :ivar service_name_filter: The name of the service that matches the filter. The filter is
     applied only to the specified service, if it exists.
     If the service doesn't exist, no service is returned in the cluster health chunk based on this
     filter.
     If the service exists, it is included as the application's child if the health state matches
     the other filter properties.
     If not specified, all services that match the parent filters (if any) are taken into
     consideration and matched against the other filter members, like health state filter.
    :vartype service_name_filter: str
    :ivar health_state_filter: The filter for the health state of the services. It allows selecting
     services if they match the desired health states.
     The possible values are integer value of one of the following health states. Only services
     that match the filter are returned. All services are used to evaluate the cluster aggregated
     health state.
     If not specified, default value is None, unless the service name is specified. If the filter
     has default value and service name is specified, the matching service is returned.
     The state values are flag-based enumeration, so the value could be a combination of these
     values obtained using bitwise 'OR' operator.
     For example, if the provided value is 6, it matches services with HealthState value of OK (2)
     and Warning (4).
    
    
     * Default - Default value. Matches any HealthState. The value is zero.
     * None - Filter that doesn't match any HealthState value. Used in order to return no results
     on a given collection of states. The value is 1.
     * Ok - Filter that matches input with HealthState value Ok. The value is 2.
     * Warning - Filter that matches input with HealthState value Warning. The value is 4.
     * Error - Filter that matches input with HealthState value Error. The value is 8.
     * All - Filter that matches input with any HealthState value. The value is 65535.
    :vartype health_state_filter: int
    :ivar partition_filters: Defines a list of filters that specify which partitions to be included
     in the returned cluster health chunk as children of the service. The partitions are returned
     only if the parent service matches a filter.
     If the list is empty, no partitions are returned. All the partitions are used to evaluate the
     parent service aggregated health state, regardless of the input filters.
     The service filter may specify multiple partition filters.
     For example, it can specify a filter to return all partitions with health state Error and
     another filter to always include a partition identified by its partition ID.
    :vartype partition_filters: list[~azure.servicefabric.models.PartitionHealthStateFilter]
    """

    _attribute_map = {
        'service_name_filter': {'key': 'ServiceNameFilter', 'type': 'str'},
        'health_state_filter': {'key': 'HealthStateFilter', 'type': 'int'},
        'partition_filters': {'key': 'PartitionFilters', 'type': '[PartitionHealthStateFilter]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_name_filter: The name of the service that matches the filter. The filter is
         applied only to the specified service, if it exists.
         If the service doesn't exist, no service is returned in the cluster health chunk based on this
         filter.
         If the service exists, it is included as the application's child if the health state matches
         the other filter properties.
         If not specified, all services that match the parent filters (if any) are taken into
         consideration and matched against the other filter members, like health state filter.
        :paramtype service_name_filter: str
        :keyword health_state_filter: The filter for the health state of the services. It allows
         selecting services if they match the desired health states.
         The possible values are integer value of one of the following health states. Only services
         that match the filter are returned. All services are used to evaluate the cluster aggregated
         health state.
         If not specified, default value is None, unless the service name is specified. If the filter
         has default value and service name is specified, the matching service is returned.
         The state values are flag-based enumeration, so the value could be a combination of these
         values obtained using bitwise 'OR' operator.
         For example, if the provided value is 6, it matches services with HealthState value of OK (2)
         and Warning (4).
        
        
         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535.
        :paramtype health_state_filter: int
        :keyword partition_filters: Defines a list of filters that specify which partitions to be
         included in the returned cluster health chunk as children of the service. The partitions are
         returned only if the parent service matches a filter.
         If the list is empty, no partitions are returned. All the partitions are used to evaluate the
         parent service aggregated health state, regardless of the input filters.
         The service filter may specify multiple partition filters.
         For example, it can specify a filter to return all partitions with health state Error and
         another filter to always include a partition identified by its partition ID.
        :paramtype partition_filters: list[~azure.servicefabric.models.PartitionHealthStateFilter]
        """
        super(ServiceHealthStateFilter, self).__init__(**kwargs)
        self.service_name_filter = kwargs.get('service_name_filter', None)
        self.health_state_filter = kwargs.get('health_state_filter', 0)
        self.partition_filters = kwargs.get('partition_filters', None)


class ServiceIdentity(msrest.serialization.Model):
    """Map service identity friendly name to an application identity.

    :ivar name: The identity friendly name.
    :vartype name: str
    :ivar identity_ref: The application identity name.
    :vartype identity_ref: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'identity_ref': {'key': 'identityRef', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: The identity friendly name.
        :paramtype name: str
        :keyword identity_ref: The application identity name.
        :paramtype identity_ref: str
        """
        super(ServiceIdentity, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.identity_ref = kwargs.get('identity_ref', None)


class ServiceInfo(msrest.serialization.Model):
    """Information about a Service Fabric service.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: StatefulServiceInfo, StatelessServiceInfo.

    All required parameters must be populated in order to send to Azure.

    :ivar id: The identity of the service. This ID is an encoded representation of the service
     name. This is used in the REST APIs to identify the service resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the service name is "fabric:/myapp/app1/svc1",
     the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
     versions.
    :vartype id: str
    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar name: The full name of the service with 'fabric:' URI scheme.
    :vartype name: str
    :ivar type_name: Name of the service type as specified in the service manifest.
    :vartype type_name: str
    :ivar manifest_version: The version of the service manifest.
    :vartype manifest_version: str
    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar service_status: The status of the application. Possible values include: "Unknown",
     "Active", "Upgrading", "Deleting", "Creating", "Failed".
    :vartype service_status: str or ~azure.servicefabric.models.ServiceStatus
    :ivar is_service_group: Whether the service is in a service group.
    :vartype is_service_group: bool
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'Id', 'type': 'str'},
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'name': {'key': 'Name', 'type': 'str'},
        'type_name': {'key': 'TypeName', 'type': 'str'},
        'manifest_version': {'key': 'ManifestVersion', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'service_status': {'key': 'ServiceStatus', 'type': 'str'},
        'is_service_group': {'key': 'IsServiceGroup', 'type': 'bool'},
    }

    _subtype_map = {
        'service_kind': {'Stateful': 'StatefulServiceInfo', 'Stateless': 'StatelessServiceInfo'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword id: The identity of the service. This ID is an encoded representation of the service
         name. This is used in the REST APIs to identify the service resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the service name is "fabric:/myapp/app1/svc1",
         the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
         versions.
        :paramtype id: str
        :keyword name: The full name of the service with 'fabric:' URI scheme.
        :paramtype name: str
        :keyword type_name: Name of the service type as specified in the service manifest.
        :paramtype type_name: str
        :keyword manifest_version: The version of the service manifest.
        :paramtype manifest_version: str
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword service_status: The status of the application. Possible values include: "Unknown",
         "Active", "Upgrading", "Deleting", "Creating", "Failed".
        :paramtype service_status: str or ~azure.servicefabric.models.ServiceStatus
        :keyword is_service_group: Whether the service is in a service group.
        :paramtype is_service_group: bool
        """
        super(ServiceInfo, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.service_kind = None  # type: Optional[str]
        self.name = kwargs.get('name', None)
        self.type_name = kwargs.get('type_name', None)
        self.manifest_version = kwargs.get('manifest_version', None)
        self.health_state = kwargs.get('health_state', None)
        self.service_status = kwargs.get('service_status', None)
        self.is_service_group = kwargs.get('is_service_group', None)


class ServiceLoadMetricDescription(msrest.serialization.Model):
    """Specifies a metric to load balance a service during runtime.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. The name of the metric. If the service chooses to report load during
     runtime, the load metric name should match the name that is specified in Name exactly. Note
     that metric names are case-sensitive.
    :vartype name: str
    :ivar weight: The service load metric relative weight, compared to other metrics configured for
     this service, as a number. Possible values include: "Zero", "Low", "Medium", "High".
    :vartype weight: str or ~azure.servicefabric.models.ServiceLoadMetricWeight
    :ivar primary_default_load: Used only for Stateful services. The default amount of load, as a
     number, that this service creates for this metric when it is a Primary replica.
    :vartype primary_default_load: int
    :ivar secondary_default_load: Used only for Stateful services. The default amount of load, as a
     number, that this service creates for this metric when it is a Secondary replica.
    :vartype secondary_default_load: int
    :ivar auxiliary_default_load: Used only for Stateful services. The default amount of load, as a
     number, that this service creates for this metric when it is an Auxiliary replica.
    :vartype auxiliary_default_load: int
    :ivar default_load: Used only for Stateless services. The default amount of load, as a number,
     that this service creates for this metric.
    :vartype default_load: int
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'weight': {'key': 'Weight', 'type': 'str'},
        'primary_default_load': {'key': 'PrimaryDefaultLoad', 'type': 'int'},
        'secondary_default_load': {'key': 'SecondaryDefaultLoad', 'type': 'int'},
        'auxiliary_default_load': {'key': 'AuxiliaryDefaultLoad', 'type': 'int'},
        'default_load': {'key': 'DefaultLoad', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. The name of the metric. If the service chooses to report load during
         runtime, the load metric name should match the name that is specified in Name exactly. Note
         that metric names are case-sensitive.
        :paramtype name: str
        :keyword weight: The service load metric relative weight, compared to other metrics configured
         for this service, as a number. Possible values include: "Zero", "Low", "Medium", "High".
        :paramtype weight: str or ~azure.servicefabric.models.ServiceLoadMetricWeight
        :keyword primary_default_load: Used only for Stateful services. The default amount of load, as
         a number, that this service creates for this metric when it is a Primary replica.
        :paramtype primary_default_load: int
        :keyword secondary_default_load: Used only for Stateful services. The default amount of load,
         as a number, that this service creates for this metric when it is a Secondary replica.
        :paramtype secondary_default_load: int
        :keyword auxiliary_default_load: Used only for Stateful services. The default amount of load,
         as a number, that this service creates for this metric when it is an Auxiliary replica.
        :paramtype auxiliary_default_load: int
        :keyword default_load: Used only for Stateless services. The default amount of load, as a
         number, that this service creates for this metric.
        :paramtype default_load: int
        """
        super(ServiceLoadMetricDescription, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.weight = kwargs.get('weight', None)
        self.primary_default_load = kwargs.get('primary_default_load', None)
        self.secondary_default_load = kwargs.get('secondary_default_load', None)
        self.auxiliary_default_load = kwargs.get('auxiliary_default_load', None)
        self.default_load = kwargs.get('default_load', None)


class ServiceNameInfo(msrest.serialization.Model):
    """Information about the service name.

    :ivar id: The identity of the service. This ID is an encoded representation of the service
     name. This is used in the REST APIs to identify the service resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the service name is "fabric:/myapp/app1/svc1",
     the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
     versions.
    :vartype id: str
    :ivar name: The full name of the service with 'fabric:' URI scheme.
    :vartype name: str
    """

    _attribute_map = {
        'id': {'key': 'Id', 'type': 'str'},
        'name': {'key': 'Name', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword id: The identity of the service. This ID is an encoded representation of the service
         name. This is used in the REST APIs to identify the service resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the service name is "fabric:/myapp/app1/svc1",
         the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
         versions.
        :paramtype id: str
        :keyword name: The full name of the service with 'fabric:' URI scheme.
        :paramtype name: str
        """
        super(ServiceNameInfo, self).__init__(**kwargs)
        self.id = kwargs.get('id', None)
        self.name = kwargs.get('name', None)


class ServiceNewHealthReportEvent(ServiceEvent):
    """Service Health Report Created event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar service_id: Required. The identity of the service. This ID is an encoded representation
     of the service name. This is used in the REST APIs to identify the service resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the service name is "fabric:/myapp/app1/svc1",
     the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
     versions.
    :vartype service_id: str
    :ivar instance_id: Required. Id of Service instance.
    :vartype instance_id: long
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'service_id': {'required': True},
        'instance_id': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'service_id': {'key': 'ServiceId', 'type': 'str'},
        'instance_id': {'key': 'InstanceId', 'type': 'long'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword service_id: Required. The identity of the service. This ID is an encoded
         representation of the service name. This is used in the REST APIs to identify the service
         resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the service name is "fabric:/myapp/app1/svc1",
         the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
         versions.
        :paramtype service_id: str
        :keyword instance_id: Required. Id of Service instance.
        :paramtype instance_id: long
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(ServiceNewHealthReportEvent, self).__init__(**kwargs)
        self.kind = 'ServiceNewHealthReport'  # type: str
        self.instance_id = kwargs['instance_id']
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class ServicePartitionInfo(msrest.serialization.Model):
    """Information about a partition of a Service Fabric service.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: StatefulServicePartitionInfo, StatelessServicePartitionInfo.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar partition_status: The status of the service fabric service partition. Possible values
     include: "Invalid", "Ready", "NotReady", "InQuorumLoss", "Reconfiguring", "Deleting".
    :vartype partition_status: str or ~azure.servicefabric.models.ServicePartitionStatus
    :ivar partition_information: Information about the partition identity, partitioning scheme and
     keys supported by it.
    :vartype partition_information: ~azure.servicefabric.models.PartitionInformation
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'partition_status': {'key': 'PartitionStatus', 'type': 'str'},
        'partition_information': {'key': 'PartitionInformation', 'type': 'PartitionInformation'},
    }

    _subtype_map = {
        'service_kind': {'Stateful': 'StatefulServicePartitionInfo', 'Stateless': 'StatelessServicePartitionInfo'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword partition_status: The status of the service fabric service partition. Possible values
         include: "Invalid", "Ready", "NotReady", "InQuorumLoss", "Reconfiguring", "Deleting".
        :paramtype partition_status: str or ~azure.servicefabric.models.ServicePartitionStatus
        :keyword partition_information: Information about the partition identity, partitioning scheme
         and keys supported by it.
        :paramtype partition_information: ~azure.servicefabric.models.PartitionInformation
        """
        super(ServicePartitionInfo, self).__init__(**kwargs)
        self.service_kind = None  # type: Optional[str]
        self.health_state = kwargs.get('health_state', None)
        self.partition_status = kwargs.get('partition_status', None)
        self.partition_information = kwargs.get('partition_information', None)


class ServicePlacementPolicyDescription(msrest.serialization.Model):
    """Describes the policy to be used for placement of a Service Fabric service.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ServicePlacementAllowMultipleStatelessInstancesOnNodePolicyDescription, ServicePlacementInvalidDomainPolicyDescription, ServicePlacementNonPartiallyPlaceServicePolicyDescription, ServicePlacementPreferPrimaryDomainPolicyDescription, ServicePlacementRequiredDomainPolicyDescription, ServicePlacementRequireDomainDistributionPolicyDescription.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. The type of placement policy for a service fabric service. Following are
     the possible values.Constant filled by server. Possible values include: "Invalid",
     "InvalidDomain", "RequireDomain", "PreferPrimaryDomain", "RequireDomainDistribution",
     "NonPartiallyPlaceService", "AllowMultipleStatelessInstancesOnNode".
    :vartype type: str or ~azure.servicefabric.models.ServicePlacementPolicyType
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'Type', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'AllowMultipleStatelessInstancesOnNode': 'ServicePlacementAllowMultipleStatelessInstancesOnNodePolicyDescription', 'InvalidDomain': 'ServicePlacementInvalidDomainPolicyDescription', 'NonPartiallyPlaceService': 'ServicePlacementNonPartiallyPlaceServicePolicyDescription', 'PreferPrimaryDomain': 'ServicePlacementPreferPrimaryDomainPolicyDescription', 'RequireDomain': 'ServicePlacementRequiredDomainPolicyDescription', 'RequireDomainDistribution': 'ServicePlacementRequireDomainDistributionPolicyDescription'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(ServicePlacementPolicyDescription, self).__init__(**kwargs)
        self.type = None  # type: Optional[str]


class ServicePlacementAllowMultipleStatelessInstancesOnNodePolicyDescription(ServicePlacementPolicyDescription):
    """Describes the policy to be used for placement of a Service Fabric service allowing multiple stateless instances of a partition of the service to be placed on a node.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. The type of placement policy for a service fabric service. Following are
     the possible values.Constant filled by server. Possible values include: "Invalid",
     "InvalidDomain", "RequireDomain", "PreferPrimaryDomain", "RequireDomainDistribution",
     "NonPartiallyPlaceService", "AllowMultipleStatelessInstancesOnNode".
    :vartype type: str or ~azure.servicefabric.models.ServicePlacementPolicyType
    :ivar domain_name: Holdover from other policy descriptions, not used for this policy, values
     are ignored by runtime. Keeping it for any backwards-compatibility with clients.
    :vartype domain_name: str
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'Type', 'type': 'str'},
        'domain_name': {'key': 'DomainName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword domain_name: Holdover from other policy descriptions, not used for this policy, values
         are ignored by runtime. Keeping it for any backwards-compatibility with clients.
        :paramtype domain_name: str
        """
        super(ServicePlacementAllowMultipleStatelessInstancesOnNodePolicyDescription, self).__init__(**kwargs)
        self.type = 'AllowMultipleStatelessInstancesOnNode'  # type: str
        self.domain_name = kwargs.get('domain_name', None)


class ServicePlacementInvalidDomainPolicyDescription(ServicePlacementPolicyDescription):
    """Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. The type of placement policy for a service fabric service. Following are
     the possible values.Constant filled by server. Possible values include: "Invalid",
     "InvalidDomain", "RequireDomain", "PreferPrimaryDomain", "RequireDomainDistribution",
     "NonPartiallyPlaceService", "AllowMultipleStatelessInstancesOnNode".
    :vartype type: str or ~azure.servicefabric.models.ServicePlacementPolicyType
    :ivar domain_name: The name of the domain that should not be used for placement.
    :vartype domain_name: str
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'Type', 'type': 'str'},
        'domain_name': {'key': 'DomainName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword domain_name: The name of the domain that should not be used for placement.
        :paramtype domain_name: str
        """
        super(ServicePlacementInvalidDomainPolicyDescription, self).__init__(**kwargs)
        self.type = 'InvalidDomain'  # type: str
        self.domain_name = kwargs.get('domain_name', None)


class ServicePlacementNonPartiallyPlaceServicePolicyDescription(ServicePlacementPolicyDescription):
    """Describes the policy to be used for placement of a Service Fabric service where all replicas must be able to be placed in order for any replicas to be created.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. The type of placement policy for a service fabric service. Following are
     the possible values.Constant filled by server. Possible values include: "Invalid",
     "InvalidDomain", "RequireDomain", "PreferPrimaryDomain", "RequireDomainDistribution",
     "NonPartiallyPlaceService", "AllowMultipleStatelessInstancesOnNode".
    :vartype type: str or ~azure.servicefabric.models.ServicePlacementPolicyType
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'Type', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(ServicePlacementNonPartiallyPlaceServicePolicyDescription, self).__init__(**kwargs)
        self.type = 'NonPartiallyPlaceService'  # type: str


class ServicePlacementPreferPrimaryDomainPolicyDescription(ServicePlacementPolicyDescription):
    """Describes the policy to be used for placement of a Service Fabric service where the service's Primary replicas should optimally be placed in a particular domain.

This placement policy is usually used with fault domains in scenarios where the Service Fabric cluster is geographically distributed in order to indicate that a service's primary replica should be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica may not end up located in this domain due to failures, capacity limits, or other constraints.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. The type of placement policy for a service fabric service. Following are
     the possible values.Constant filled by server. Possible values include: "Invalid",
     "InvalidDomain", "RequireDomain", "PreferPrimaryDomain", "RequireDomainDistribution",
     "NonPartiallyPlaceService", "AllowMultipleStatelessInstancesOnNode".
    :vartype type: str or ~azure.servicefabric.models.ServicePlacementPolicyType
    :ivar domain_name: The name of the domain that should used for placement as per this policy.
    :vartype domain_name: str
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'Type', 'type': 'str'},
        'domain_name': {'key': 'DomainName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword domain_name: The name of the domain that should used for placement as per this policy.
        :paramtype domain_name: str
        """
        super(ServicePlacementPreferPrimaryDomainPolicyDescription, self).__init__(**kwargs)
        self.type = 'PreferPrimaryDomain'  # type: str
        self.domain_name = kwargs.get('domain_name', None)


class ServicePlacementRequiredDomainPolicyDescription(ServicePlacementPolicyDescription):
    """Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. The type of placement policy for a service fabric service. Following are
     the possible values.Constant filled by server. Possible values include: "Invalid",
     "InvalidDomain", "RequireDomain", "PreferPrimaryDomain", "RequireDomainDistribution",
     "NonPartiallyPlaceService", "AllowMultipleStatelessInstancesOnNode".
    :vartype type: str or ~azure.servicefabric.models.ServicePlacementPolicyType
    :ivar domain_name: The name of the domain that should used for placement as per this policy.
    :vartype domain_name: str
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'Type', 'type': 'str'},
        'domain_name': {'key': 'DomainName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword domain_name: The name of the domain that should used for placement as per this policy.
        :paramtype domain_name: str
        """
        super(ServicePlacementRequiredDomainPolicyDescription, self).__init__(**kwargs)
        self.type = 'RequireDomain'  # type: str
        self.domain_name = kwargs.get('domain_name', None)


class ServicePlacementRequireDomainDistributionPolicyDescription(ServicePlacementPolicyDescription):
    """Describes the policy to be used for placement of a Service Fabric service where two replicas from the same partition should never be placed in the same fault or upgrade domain.

While this is not common it can expose the service to an increased risk of concurrent failures due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider a case where replicas are deployed across different data center, with one replica per location. In the event that one of the datacenters goes offline, normally the replica that was placed in that datacenter will be packed into one of the remaining datacenters. If this is not desirable then this policy should be set.

    All required parameters must be populated in order to send to Azure.

    :ivar type: Required. The type of placement policy for a service fabric service. Following are
     the possible values.Constant filled by server. Possible values include: "Invalid",
     "InvalidDomain", "RequireDomain", "PreferPrimaryDomain", "RequireDomainDistribution",
     "NonPartiallyPlaceService", "AllowMultipleStatelessInstancesOnNode".
    :vartype type: str or ~azure.servicefabric.models.ServicePlacementPolicyType
    :ivar domain_name: The name of the domain that should used for placement as per this policy.
    :vartype domain_name: str
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'Type', 'type': 'str'},
        'domain_name': {'key': 'DomainName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword domain_name: The name of the domain that should used for placement as per this policy.
        :paramtype domain_name: str
        """
        super(ServicePlacementRequireDomainDistributionPolicyDescription, self).__init__(**kwargs)
        self.type = 'RequireDomainDistribution'  # type: str
        self.domain_name = kwargs.get('domain_name', None)


class ServiceProperties(msrest.serialization.Model):
    """Describes properties of a service resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar description: User readable description of the service.
    :vartype description: str
    :ivar replica_count: The number of replicas of the service to create. Defaults to 1 if not
     specified.
    :vartype replica_count: int
    :ivar execution_policy: The execution policy of the service.
    :vartype execution_policy: ~azure.servicefabric.models.ExecutionPolicy
    :ivar auto_scaling_policies: Auto scaling policies.
    :vartype auto_scaling_policies: list[~azure.servicefabric.models.AutoScalingPolicy]
    :ivar status: Status of the service. Possible values include: "Unknown", "Ready", "Upgrading",
     "Creating", "Deleting", "Failed".
    :vartype status: str or ~azure.servicefabric.models.ResourceStatus
    :ivar status_details: Gives additional information about the current status of the service.
    :vartype status_details: str
    :ivar health_state: Describes the health state of an application resource. Possible values
     include: "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar unhealthy_evaluation: When the service's health state is not 'Ok', this additional
     details from service fabric Health Manager for the user to know why the service is marked
     unhealthy.
    :vartype unhealthy_evaluation: str
    :ivar identity_refs: The service identity list.
    :vartype identity_refs: list[~azure.servicefabric.models.ServiceIdentity]
    :ivar dns_name: Dns name of the service.
    :vartype dns_name: str
    """

    _validation = {
        'status': {'readonly': True},
        'status_details': {'readonly': True},
        'health_state': {'readonly': True},
        'unhealthy_evaluation': {'readonly': True},
    }

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'replica_count': {'key': 'replicaCount', 'type': 'int'},
        'execution_policy': {'key': 'executionPolicy', 'type': 'ExecutionPolicy'},
        'auto_scaling_policies': {'key': 'autoScalingPolicies', 'type': '[AutoScalingPolicy]'},
        'status': {'key': 'status', 'type': 'str'},
        'status_details': {'key': 'statusDetails', 'type': 'str'},
        'health_state': {'key': 'healthState', 'type': 'str'},
        'unhealthy_evaluation': {'key': 'unhealthyEvaluation', 'type': 'str'},
        'identity_refs': {'key': 'identityRefs', 'type': '[ServiceIdentity]'},
        'dns_name': {'key': 'dnsName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword description: User readable description of the service.
        :paramtype description: str
        :keyword replica_count: The number of replicas of the service to create. Defaults to 1 if not
         specified.
        :paramtype replica_count: int
        :keyword execution_policy: The execution policy of the service.
        :paramtype execution_policy: ~azure.servicefabric.models.ExecutionPolicy
        :keyword auto_scaling_policies: Auto scaling policies.
        :paramtype auto_scaling_policies: list[~azure.servicefabric.models.AutoScalingPolicy]
        :keyword identity_refs: The service identity list.
        :paramtype identity_refs: list[~azure.servicefabric.models.ServiceIdentity]
        :keyword dns_name: Dns name of the service.
        :paramtype dns_name: str
        """
        super(ServiceProperties, self).__init__(**kwargs)
        self.description = kwargs.get('description', None)
        self.replica_count = kwargs.get('replica_count', None)
        self.execution_policy = kwargs.get('execution_policy', None)
        self.auto_scaling_policies = kwargs.get('auto_scaling_policies', None)
        self.status = None
        self.status_details = None
        self.health_state = None
        self.unhealthy_evaluation = None
        self.identity_refs = kwargs.get('identity_refs', None)
        self.dns_name = kwargs.get('dns_name', None)


class ServiceReplicaProperties(msrest.serialization.Model):
    """Describes the properties of a service replica.

    All required parameters must be populated in order to send to Azure.

    :ivar os_type: Required. The operation system required by the code in service. Possible values
     include: "Linux", "Windows".
    :vartype os_type: str or ~azure.servicefabric.models.OperatingSystemType
    :ivar code_packages: Required. Describes the set of code packages that forms the service. A
     code package describes the container and the properties for running it. All the code packages
     are started together on the same host and share the same context (network, process etc.).
    :vartype code_packages: list[~azure.servicefabric.models.ContainerCodePackageProperties]
    :ivar network_refs: The names of the private networks that this service needs to be part of.
    :vartype network_refs: list[~azure.servicefabric.models.NetworkRef]
    :ivar diagnostics: Reference to sinks in DiagnosticsDescription.
    :vartype diagnostics: ~azure.servicefabric.models.DiagnosticsRef
    """

    _validation = {
        'os_type': {'required': True},
        'code_packages': {'required': True},
    }

    _attribute_map = {
        'os_type': {'key': 'osType', 'type': 'str'},
        'code_packages': {'key': 'codePackages', 'type': '[ContainerCodePackageProperties]'},
        'network_refs': {'key': 'networkRefs', 'type': '[NetworkRef]'},
        'diagnostics': {'key': 'diagnostics', 'type': 'DiagnosticsRef'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword os_type: Required. The operation system required by the code in service. Possible
         values include: "Linux", "Windows".
        :paramtype os_type: str or ~azure.servicefabric.models.OperatingSystemType
        :keyword code_packages: Required. Describes the set of code packages that forms the service. A
         code package describes the container and the properties for running it. All the code packages
         are started together on the same host and share the same context (network, process etc.).
        :paramtype code_packages: list[~azure.servicefabric.models.ContainerCodePackageProperties]
        :keyword network_refs: The names of the private networks that this service needs to be part of.
        :paramtype network_refs: list[~azure.servicefabric.models.NetworkRef]
        :keyword diagnostics: Reference to sinks in DiagnosticsDescription.
        :paramtype diagnostics: ~azure.servicefabric.models.DiagnosticsRef
        """
        super(ServiceReplicaProperties, self).__init__(**kwargs)
        self.os_type = kwargs['os_type']
        self.code_packages = kwargs['code_packages']
        self.network_refs = kwargs.get('network_refs', None)
        self.diagnostics = kwargs.get('diagnostics', None)


class ServiceReplicaDescription(ServiceReplicaProperties):
    """Describes a replica of a service resource.

    All required parameters must be populated in order to send to Azure.

    :ivar os_type: Required. The operation system required by the code in service. Possible values
     include: "Linux", "Windows".
    :vartype os_type: str or ~azure.servicefabric.models.OperatingSystemType
    :ivar code_packages: Required. Describes the set of code packages that forms the service. A
     code package describes the container and the properties for running it. All the code packages
     are started together on the same host and share the same context (network, process etc.).
    :vartype code_packages: list[~azure.servicefabric.models.ContainerCodePackageProperties]
    :ivar network_refs: The names of the private networks that this service needs to be part of.
    :vartype network_refs: list[~azure.servicefabric.models.NetworkRef]
    :ivar diagnostics: Reference to sinks in DiagnosticsDescription.
    :vartype diagnostics: ~azure.servicefabric.models.DiagnosticsRef
    :ivar replica_name: Required. Name of the replica.
    :vartype replica_name: str
    """

    _validation = {
        'os_type': {'required': True},
        'code_packages': {'required': True},
        'replica_name': {'required': True},
    }

    _attribute_map = {
        'os_type': {'key': 'osType', 'type': 'str'},
        'code_packages': {'key': 'codePackages', 'type': '[ContainerCodePackageProperties]'},
        'network_refs': {'key': 'networkRefs', 'type': '[NetworkRef]'},
        'diagnostics': {'key': 'diagnostics', 'type': 'DiagnosticsRef'},
        'replica_name': {'key': 'replicaName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword os_type: Required. The operation system required by the code in service. Possible
         values include: "Linux", "Windows".
        :paramtype os_type: str or ~azure.servicefabric.models.OperatingSystemType
        :keyword code_packages: Required. Describes the set of code packages that forms the service. A
         code package describes the container and the properties for running it. All the code packages
         are started together on the same host and share the same context (network, process etc.).
        :paramtype code_packages: list[~azure.servicefabric.models.ContainerCodePackageProperties]
        :keyword network_refs: The names of the private networks that this service needs to be part of.
        :paramtype network_refs: list[~azure.servicefabric.models.NetworkRef]
        :keyword diagnostics: Reference to sinks in DiagnosticsDescription.
        :paramtype diagnostics: ~azure.servicefabric.models.DiagnosticsRef
        :keyword replica_name: Required. Name of the replica.
        :paramtype replica_name: str
        """
        super(ServiceReplicaDescription, self).__init__(**kwargs)
        self.replica_name = kwargs['replica_name']


class ServiceResourceDescription(msrest.serialization.Model):
    """This type describes a service resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. Name of the Service resource.
    :vartype name: str
    :ivar os_type: Required. The operation system required by the code in service. Possible values
     include: "Linux", "Windows".
    :vartype os_type: str or ~azure.servicefabric.models.OperatingSystemType
    :ivar code_packages: Required. Describes the set of code packages that forms the service. A
     code package describes the container and the properties for running it. All the code packages
     are started together on the same host and share the same context (network, process etc.).
    :vartype code_packages: list[~azure.servicefabric.models.ContainerCodePackageProperties]
    :ivar network_refs: The names of the private networks that this service needs to be part of.
    :vartype network_refs: list[~azure.servicefabric.models.NetworkRef]
    :ivar diagnostics: Reference to sinks in DiagnosticsDescription.
    :vartype diagnostics: ~azure.servicefabric.models.DiagnosticsRef
    :ivar description: User readable description of the service.
    :vartype description: str
    :ivar replica_count: The number of replicas of the service to create. Defaults to 1 if not
     specified.
    :vartype replica_count: int
    :ivar execution_policy: The execution policy of the service.
    :vartype execution_policy: ~azure.servicefabric.models.ExecutionPolicy
    :ivar auto_scaling_policies: Auto scaling policies.
    :vartype auto_scaling_policies: list[~azure.servicefabric.models.AutoScalingPolicy]
    :ivar status: Status of the service. Possible values include: "Unknown", "Ready", "Upgrading",
     "Creating", "Deleting", "Failed".
    :vartype status: str or ~azure.servicefabric.models.ResourceStatus
    :ivar status_details: Gives additional information about the current status of the service.
    :vartype status_details: str
    :ivar health_state: Describes the health state of an application resource. Possible values
     include: "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar unhealthy_evaluation: When the service's health state is not 'Ok', this additional
     details from service fabric Health Manager for the user to know why the service is marked
     unhealthy.
    :vartype unhealthy_evaluation: str
    :ivar identity_refs: The service identity list.
    :vartype identity_refs: list[~azure.servicefabric.models.ServiceIdentity]
    :ivar dns_name: Dns name of the service.
    :vartype dns_name: str
    """

    _validation = {
        'name': {'required': True},
        'os_type': {'required': True},
        'code_packages': {'required': True},
        'status': {'readonly': True},
        'status_details': {'readonly': True},
        'health_state': {'readonly': True},
        'unhealthy_evaluation': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'os_type': {'key': 'properties.osType', 'type': 'str'},
        'code_packages': {'key': 'properties.codePackages', 'type': '[ContainerCodePackageProperties]'},
        'network_refs': {'key': 'properties.networkRefs', 'type': '[NetworkRef]'},
        'diagnostics': {'key': 'properties.diagnostics', 'type': 'DiagnosticsRef'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'replica_count': {'key': 'properties.replicaCount', 'type': 'int'},
        'execution_policy': {'key': 'properties.executionPolicy', 'type': 'ExecutionPolicy'},
        'auto_scaling_policies': {'key': 'properties.autoScalingPolicies', 'type': '[AutoScalingPolicy]'},
        'status': {'key': 'properties.status', 'type': 'str'},
        'status_details': {'key': 'properties.statusDetails', 'type': 'str'},
        'health_state': {'key': 'properties.healthState', 'type': 'str'},
        'unhealthy_evaluation': {'key': 'properties.unhealthyEvaluation', 'type': 'str'},
        'identity_refs': {'key': 'properties.identityRefs', 'type': '[ServiceIdentity]'},
        'dns_name': {'key': 'properties.dnsName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. Name of the Service resource.
        :paramtype name: str
        :keyword os_type: Required. The operation system required by the code in service. Possible
         values include: "Linux", "Windows".
        :paramtype os_type: str or ~azure.servicefabric.models.OperatingSystemType
        :keyword code_packages: Required. Describes the set of code packages that forms the service. A
         code package describes the container and the properties for running it. All the code packages
         are started together on the same host and share the same context (network, process etc.).
        :paramtype code_packages: list[~azure.servicefabric.models.ContainerCodePackageProperties]
        :keyword network_refs: The names of the private networks that this service needs to be part of.
        :paramtype network_refs: list[~azure.servicefabric.models.NetworkRef]
        :keyword diagnostics: Reference to sinks in DiagnosticsDescription.
        :paramtype diagnostics: ~azure.servicefabric.models.DiagnosticsRef
        :keyword description: User readable description of the service.
        :paramtype description: str
        :keyword replica_count: The number of replicas of the service to create. Defaults to 1 if not
         specified.
        :paramtype replica_count: int
        :keyword execution_policy: The execution policy of the service.
        :paramtype execution_policy: ~azure.servicefabric.models.ExecutionPolicy
        :keyword auto_scaling_policies: Auto scaling policies.
        :paramtype auto_scaling_policies: list[~azure.servicefabric.models.AutoScalingPolicy]
        :keyword identity_refs: The service identity list.
        :paramtype identity_refs: list[~azure.servicefabric.models.ServiceIdentity]
        :keyword dns_name: Dns name of the service.
        :paramtype dns_name: str
        """
        super(ServiceResourceDescription, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.os_type = kwargs['os_type']
        self.code_packages = kwargs['code_packages']
        self.network_refs = kwargs.get('network_refs', None)
        self.diagnostics = kwargs.get('diagnostics', None)
        self.description = kwargs.get('description', None)
        self.replica_count = kwargs.get('replica_count', None)
        self.execution_policy = kwargs.get('execution_policy', None)
        self.auto_scaling_policies = kwargs.get('auto_scaling_policies', None)
        self.status = None
        self.status_details = None
        self.health_state = None
        self.unhealthy_evaluation = None
        self.identity_refs = kwargs.get('identity_refs', None)
        self.dns_name = kwargs.get('dns_name', None)


class ServiceResourceProperties(ServiceReplicaProperties, ServiceProperties):
    """This type describes properties of a service resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar description: User readable description of the service.
    :vartype description: str
    :ivar replica_count: The number of replicas of the service to create. Defaults to 1 if not
     specified.
    :vartype replica_count: int
    :ivar execution_policy: The execution policy of the service.
    :vartype execution_policy: ~azure.servicefabric.models.ExecutionPolicy
    :ivar auto_scaling_policies: Auto scaling policies.
    :vartype auto_scaling_policies: list[~azure.servicefabric.models.AutoScalingPolicy]
    :ivar status: Status of the service. Possible values include: "Unknown", "Ready", "Upgrading",
     "Creating", "Deleting", "Failed".
    :vartype status: str or ~azure.servicefabric.models.ResourceStatus
    :ivar status_details: Gives additional information about the current status of the service.
    :vartype status_details: str
    :ivar health_state: Describes the health state of an application resource. Possible values
     include: "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar unhealthy_evaluation: When the service's health state is not 'Ok', this additional
     details from service fabric Health Manager for the user to know why the service is marked
     unhealthy.
    :vartype unhealthy_evaluation: str
    :ivar identity_refs: The service identity list.
    :vartype identity_refs: list[~azure.servicefabric.models.ServiceIdentity]
    :ivar dns_name: Dns name of the service.
    :vartype dns_name: str
    :ivar os_type: Required. The operation system required by the code in service. Possible values
     include: "Linux", "Windows".
    :vartype os_type: str or ~azure.servicefabric.models.OperatingSystemType
    :ivar code_packages: Required. Describes the set of code packages that forms the service. A
     code package describes the container and the properties for running it. All the code packages
     are started together on the same host and share the same context (network, process etc.).
    :vartype code_packages: list[~azure.servicefabric.models.ContainerCodePackageProperties]
    :ivar network_refs: The names of the private networks that this service needs to be part of.
    :vartype network_refs: list[~azure.servicefabric.models.NetworkRef]
    :ivar diagnostics: Reference to sinks in DiagnosticsDescription.
    :vartype diagnostics: ~azure.servicefabric.models.DiagnosticsRef
    """

    _validation = {
        'status': {'readonly': True},
        'status_details': {'readonly': True},
        'health_state': {'readonly': True},
        'unhealthy_evaluation': {'readonly': True},
        'os_type': {'required': True},
        'code_packages': {'required': True},
    }

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'replica_count': {'key': 'replicaCount', 'type': 'int'},
        'execution_policy': {'key': 'executionPolicy', 'type': 'ExecutionPolicy'},
        'auto_scaling_policies': {'key': 'autoScalingPolicies', 'type': '[AutoScalingPolicy]'},
        'status': {'key': 'status', 'type': 'str'},
        'status_details': {'key': 'statusDetails', 'type': 'str'},
        'health_state': {'key': 'healthState', 'type': 'str'},
        'unhealthy_evaluation': {'key': 'unhealthyEvaluation', 'type': 'str'},
        'identity_refs': {'key': 'identityRefs', 'type': '[ServiceIdentity]'},
        'dns_name': {'key': 'dnsName', 'type': 'str'},
        'os_type': {'key': 'osType', 'type': 'str'},
        'code_packages': {'key': 'codePackages', 'type': '[ContainerCodePackageProperties]'},
        'network_refs': {'key': 'networkRefs', 'type': '[NetworkRef]'},
        'diagnostics': {'key': 'diagnostics', 'type': 'DiagnosticsRef'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword description: User readable description of the service.
        :paramtype description: str
        :keyword replica_count: The number of replicas of the service to create. Defaults to 1 if not
         specified.
        :paramtype replica_count: int
        :keyword execution_policy: The execution policy of the service.
        :paramtype execution_policy: ~azure.servicefabric.models.ExecutionPolicy
        :keyword auto_scaling_policies: Auto scaling policies.
        :paramtype auto_scaling_policies: list[~azure.servicefabric.models.AutoScalingPolicy]
        :keyword identity_refs: The service identity list.
        :paramtype identity_refs: list[~azure.servicefabric.models.ServiceIdentity]
        :keyword dns_name: Dns name of the service.
        :paramtype dns_name: str
        :keyword os_type: Required. The operation system required by the code in service. Possible
         values include: "Linux", "Windows".
        :paramtype os_type: str or ~azure.servicefabric.models.OperatingSystemType
        :keyword code_packages: Required. Describes the set of code packages that forms the service. A
         code package describes the container and the properties for running it. All the code packages
         are started together on the same host and share the same context (network, process etc.).
        :paramtype code_packages: list[~azure.servicefabric.models.ContainerCodePackageProperties]
        :keyword network_refs: The names of the private networks that this service needs to be part of.
        :paramtype network_refs: list[~azure.servicefabric.models.NetworkRef]
        :keyword diagnostics: Reference to sinks in DiagnosticsDescription.
        :paramtype diagnostics: ~azure.servicefabric.models.DiagnosticsRef
        """
        super(ServiceResourceProperties, self).__init__(**kwargs)
        self.description = kwargs.get('description', None)
        self.replica_count = kwargs.get('replica_count', None)
        self.execution_policy = kwargs.get('execution_policy', None)
        self.auto_scaling_policies = kwargs.get('auto_scaling_policies', None)
        self.status = None
        self.status_details = None
        self.health_state = None
        self.unhealthy_evaluation = None
        self.identity_refs = kwargs.get('identity_refs', None)
        self.dns_name = kwargs.get('dns_name', None)
        self.os_type = kwargs['os_type']
        self.code_packages = kwargs['code_packages']
        self.network_refs = kwargs.get('network_refs', None)
        self.diagnostics = kwargs.get('diagnostics', None)


class ServicesHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for services of a certain service type belonging to an application, containing health evaluations for each unhealthy service that impacted current aggregated health state. Can be returned when evaluating application health and the aggregated health state is either Error or Warning.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar service_type_name: Name of the service type of the services.
    :vartype service_type_name: str
    :ivar max_percent_unhealthy_services: Maximum allowed percentage of unhealthy services from the
     ServiceTypeHealthPolicy.
    :vartype max_percent_unhealthy_services: int
    :ivar total_count: Total number of services of the current service type in the application from
     the health store.
    :vartype total_count: long
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
     state. Includes all the unhealthy ServiceHealthEvaluation that impacted the aggregated health.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'service_type_name': {'key': 'ServiceTypeName', 'type': 'str'},
        'max_percent_unhealthy_services': {'key': 'MaxPercentUnhealthyServices', 'type': 'int'},
        'total_count': {'key': 'TotalCount', 'type': 'long'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword service_type_name: Name of the service type of the services.
        :paramtype service_type_name: str
        :keyword max_percent_unhealthy_services: Maximum allowed percentage of unhealthy services from
         the ServiceTypeHealthPolicy.
        :paramtype max_percent_unhealthy_services: int
        :keyword total_count: Total number of services of the current service type in the application
         from the health store.
        :paramtype total_count: long
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
         state. Includes all the unhealthy ServiceHealthEvaluation that impacted the aggregated health.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(ServicesHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'Services'  # type: str
        self.service_type_name = kwargs.get('service_type_name', None)
        self.max_percent_unhealthy_services = kwargs.get('max_percent_unhealthy_services', None)
        self.total_count = kwargs.get('total_count', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class ServiceTypeDescription(msrest.serialization.Model):
    """Describes a service type defined in the service manifest of a provisioned application type. The properties the ones defined in the service manifest.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: StatefulServiceTypeDescription, StatelessServiceTypeDescription.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of service (Stateless or Stateful).Constant filled by server.
     Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar is_stateful: Indicates whether the service type is a stateful service type or a stateless
     service type. This property is true if the service type is a stateful service type, false
     otherwise.
    :vartype is_stateful: bool
    :ivar service_type_name: Name of the service type as specified in the service manifest.
    :vartype service_type_name: str
    :ivar placement_constraints: The placement constraint to be used when instantiating this
     service in a Service Fabric cluster.
    :vartype placement_constraints: str
    :ivar load_metrics: The service load metrics is given as an array of
     ServiceLoadMetricDescription objects.
    :vartype load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: List of service placement policy descriptions.
    :vartype service_placement_policies:
     list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar extensions: List of service type extensions.
    :vartype extensions: list[~azure.servicefabric.models.ServiceTypeExtensionDescription]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'is_stateful': {'key': 'IsStateful', 'type': 'bool'},
        'service_type_name': {'key': 'ServiceTypeName', 'type': 'str'},
        'placement_constraints': {'key': 'PlacementConstraints', 'type': 'str'},
        'load_metrics': {'key': 'LoadMetrics', 'type': '[ServiceLoadMetricDescription]'},
        'service_placement_policies': {'key': 'ServicePlacementPolicies', 'type': '[ServicePlacementPolicyDescription]'},
        'extensions': {'key': 'Extensions', 'type': '[ServiceTypeExtensionDescription]'},
    }

    _subtype_map = {
        'kind': {'Stateful': 'StatefulServiceTypeDescription', 'Stateless': 'StatelessServiceTypeDescription'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword is_stateful: Indicates whether the service type is a stateful service type or a
         stateless service type. This property is true if the service type is a stateful service type,
         false otherwise.
        :paramtype is_stateful: bool
        :keyword service_type_name: Name of the service type as specified in the service manifest.
        :paramtype service_type_name: str
        :keyword placement_constraints: The placement constraint to be used when instantiating this
         service in a Service Fabric cluster.
        :paramtype placement_constraints: str
        :keyword load_metrics: The service load metrics is given as an array of
         ServiceLoadMetricDescription objects.
        :paramtype load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
        :keyword service_placement_policies: List of service placement policy descriptions.
        :paramtype service_placement_policies:
         list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
        :keyword extensions: List of service type extensions.
        :paramtype extensions: list[~azure.servicefabric.models.ServiceTypeExtensionDescription]
        """
        super(ServiceTypeDescription, self).__init__(**kwargs)
        self.kind = None  # type: Optional[str]
        self.is_stateful = kwargs.get('is_stateful', None)
        self.service_type_name = kwargs.get('service_type_name', None)
        self.placement_constraints = kwargs.get('placement_constraints', None)
        self.load_metrics = kwargs.get('load_metrics', None)
        self.service_placement_policies = kwargs.get('service_placement_policies', None)
        self.extensions = kwargs.get('extensions', None)


class ServiceTypeExtensionDescription(msrest.serialization.Model):
    """Describes extension of a service type defined in the service manifest.

    :ivar key: The name of the extension.
    :vartype key: str
    :ivar value: The extension value.
    :vartype value: str
    """

    _attribute_map = {
        'key': {'key': 'Key', 'type': 'str'},
        'value': {'key': 'Value', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword key: The name of the extension.
        :paramtype key: str
        :keyword value: The extension value.
        :paramtype value: str
        """
        super(ServiceTypeExtensionDescription, self).__init__(**kwargs)
        self.key = kwargs.get('key', None)
        self.value = kwargs.get('value', None)


class ServiceTypeHealthPolicy(msrest.serialization.Model):
    """Represents the health policy used to evaluate the health of services belonging to a service type.

    :ivar max_percent_unhealthy_partitions_per_service: The maximum allowed percentage of unhealthy
     partitions per service. Allowed values are Byte values from zero to 100
    
     The percentage represents the maximum tolerated percentage of partitions that can be unhealthy
     before the service is considered in error.
     If the percentage is respected but there is at least one unhealthy partition, the health is
     evaluated as Warning.
     The percentage is calculated by dividing the number of unhealthy partitions over the total
     number of partitions in the service.
     The computation rounds up to tolerate one failure on small numbers of partitions. Default
     percentage is zero.
    :vartype max_percent_unhealthy_partitions_per_service: int
    :ivar max_percent_unhealthy_replicas_per_partition: The maximum allowed percentage of unhealthy
     replicas per partition. Allowed values are Byte values from zero to 100.
    
     The percentage represents the maximum tolerated percentage of replicas that can be unhealthy
     before the partition is considered in error.
     If the percentage is respected but there is at least one unhealthy replica, the health is
     evaluated as Warning.
     The percentage is calculated by dividing the number of unhealthy replicas over the total
     number of replicas in the partition.
     The computation rounds up to tolerate one failure on small numbers of replicas. Default
     percentage is zero.
    :vartype max_percent_unhealthy_replicas_per_partition: int
    :ivar max_percent_unhealthy_services: The maximum allowed percentage of unhealthy services.
     Allowed values are Byte values from zero to 100.
    
     The percentage represents the maximum tolerated percentage of services that can be unhealthy
     before the application is considered in error.
     If the percentage is respected but there is at least one unhealthy service, the health is
     evaluated as Warning.
     This is calculated by dividing the number of unhealthy services of the specific service type
     over the total number of services of the specific service type.
     The computation rounds up to tolerate one failure on small numbers of services. Default
     percentage is zero.
    :vartype max_percent_unhealthy_services: int
    """

    _attribute_map = {
        'max_percent_unhealthy_partitions_per_service': {'key': 'MaxPercentUnhealthyPartitionsPerService', 'type': 'int'},
        'max_percent_unhealthy_replicas_per_partition': {'key': 'MaxPercentUnhealthyReplicasPerPartition', 'type': 'int'},
        'max_percent_unhealthy_services': {'key': 'MaxPercentUnhealthyServices', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword max_percent_unhealthy_partitions_per_service: The maximum allowed percentage of
         unhealthy partitions per service. Allowed values are Byte values from zero to 100
        
         The percentage represents the maximum tolerated percentage of partitions that can be unhealthy
         before the service is considered in error.
         If the percentage is respected but there is at least one unhealthy partition, the health is
         evaluated as Warning.
         The percentage is calculated by dividing the number of unhealthy partitions over the total
         number of partitions in the service.
         The computation rounds up to tolerate one failure on small numbers of partitions. Default
         percentage is zero.
        :paramtype max_percent_unhealthy_partitions_per_service: int
        :keyword max_percent_unhealthy_replicas_per_partition: The maximum allowed percentage of
         unhealthy replicas per partition. Allowed values are Byte values from zero to 100.
        
         The percentage represents the maximum tolerated percentage of replicas that can be unhealthy
         before the partition is considered in error.
         If the percentage is respected but there is at least one unhealthy replica, the health is
         evaluated as Warning.
         The percentage is calculated by dividing the number of unhealthy replicas over the total
         number of replicas in the partition.
         The computation rounds up to tolerate one failure on small numbers of replicas. Default
         percentage is zero.
        :paramtype max_percent_unhealthy_replicas_per_partition: int
        :keyword max_percent_unhealthy_services: The maximum allowed percentage of unhealthy services.
         Allowed values are Byte values from zero to 100.
        
         The percentage represents the maximum tolerated percentage of services that can be unhealthy
         before the application is considered in error.
         If the percentage is respected but there is at least one unhealthy service, the health is
         evaluated as Warning.
         This is calculated by dividing the number of unhealthy services of the specific service type
         over the total number of services of the specific service type.
         The computation rounds up to tolerate one failure on small numbers of services. Default
         percentage is zero.
        :paramtype max_percent_unhealthy_services: int
        """
        super(ServiceTypeHealthPolicy, self).__init__(**kwargs)
        self.max_percent_unhealthy_partitions_per_service = kwargs.get('max_percent_unhealthy_partitions_per_service', 0)
        self.max_percent_unhealthy_replicas_per_partition = kwargs.get('max_percent_unhealthy_replicas_per_partition', 0)
        self.max_percent_unhealthy_services = kwargs.get('max_percent_unhealthy_services', 0)


class ServiceTypeHealthPolicyMapItem(msrest.serialization.Model):
    """Defines an item in ServiceTypeHealthPolicyMap.

    All required parameters must be populated in order to send to Azure.

    :ivar key: Required. The key of the service type health policy map item. This is the name of
     the service type.
    :vartype key: str
    :ivar value: Required. The value of the service type health policy map item. This is the
     ServiceTypeHealthPolicy for this service type.
    :vartype value: ~azure.servicefabric.models.ServiceTypeHealthPolicy
    """

    _validation = {
        'key': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'key': {'key': 'Key', 'type': 'str'},
        'value': {'key': 'Value', 'type': 'ServiceTypeHealthPolicy'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword key: Required. The key of the service type health policy map item. This is the name of
         the service type.
        :paramtype key: str
        :keyword value: Required. The value of the service type health policy map item. This is the
         ServiceTypeHealthPolicy for this service type.
        :paramtype value: ~azure.servicefabric.models.ServiceTypeHealthPolicy
        """
        super(ServiceTypeHealthPolicyMapItem, self).__init__(**kwargs)
        self.key = kwargs['key']
        self.value = kwargs['value']


class ServiceTypeInfo(msrest.serialization.Model):
    """Information about a service type that is defined in a service manifest of a provisioned application type.

    :ivar service_type_description: Describes a service type defined in the service manifest of a
     provisioned application type. The properties the ones defined in the service manifest.
    :vartype service_type_description: ~azure.servicefabric.models.ServiceTypeDescription
    :ivar service_manifest_name: The name of the service manifest in which this service type is
     defined.
    :vartype service_manifest_name: str
    :ivar service_manifest_version: The version of the service manifest in which this service type
     is defined.
    :vartype service_manifest_version: str
    :ivar is_service_group: Indicates whether the service is a service group. If it is, the
     property value is true otherwise false.
    :vartype is_service_group: bool
    """

    _attribute_map = {
        'service_type_description': {'key': 'ServiceTypeDescription', 'type': 'ServiceTypeDescription'},
        'service_manifest_name': {'key': 'ServiceManifestName', 'type': 'str'},
        'service_manifest_version': {'key': 'ServiceManifestVersion', 'type': 'str'},
        'is_service_group': {'key': 'IsServiceGroup', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_type_description: Describes a service type defined in the service manifest of
         a provisioned application type. The properties the ones defined in the service manifest.
        :paramtype service_type_description: ~azure.servicefabric.models.ServiceTypeDescription
        :keyword service_manifest_name: The name of the service manifest in which this service type is
         defined.
        :paramtype service_manifest_name: str
        :keyword service_manifest_version: The version of the service manifest in which this service
         type is defined.
        :paramtype service_manifest_version: str
        :keyword is_service_group: Indicates whether the service is a service group. If it is, the
         property value is true otherwise false.
        :paramtype is_service_group: bool
        """
        super(ServiceTypeInfo, self).__init__(**kwargs)
        self.service_type_description = kwargs.get('service_type_description', None)
        self.service_manifest_name = kwargs.get('service_manifest_name', None)
        self.service_manifest_version = kwargs.get('service_manifest_version', None)
        self.is_service_group = kwargs.get('is_service_group', None)


class ServiceTypeManifest(msrest.serialization.Model):
    """Contains the manifest describing a service type registered as part of an application in a Service Fabric cluster.

    :ivar manifest: The XML manifest as a string.
    :vartype manifest: str
    """

    _attribute_map = {
        'manifest': {'key': 'Manifest', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword manifest: The XML manifest as a string.
        :paramtype manifest: str
        """
        super(ServiceTypeManifest, self).__init__(**kwargs)
        self.manifest = kwargs.get('manifest', None)


class ServiceUpdateDescription(msrest.serialization.Model):
    """A ServiceUpdateDescription contains all of the information necessary to update a service.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: StatefulServiceUpdateDescription, StatelessServiceUpdateDescription.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The service kind.Constant filled by server. Possible values
     include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar flags: Flags indicating whether other properties are set. Each of the associated
     properties corresponds to a flag, specified below, which, if set, indicate that the property is
     specified.
     This property can be a combination of those flags obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then the flags for ReplicaRestartWaitDuration (2) and
     QuorumLossWaitDuration (4) are set.
    
    
     * None - Does not indicate any other properties are set. The value is zero.
     * TargetReplicaSetSize/InstanceCount - Indicates whether the TargetReplicaSetSize property
     (for Stateful services) or the InstanceCount property (for Stateless services) is set. The
     value is 1.
     * ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is set. The
     value is  2.
     * QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is set. The value is
     4.
     * StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is set. The
     value is 8.
     * MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The value is 16.
     * PlacementConstraints - Indicates the PlacementConstraints property is set. The value is 32.
     * PlacementPolicyList - Indicates the ServicePlacementPolicies property is set. The value is
     64.
     * Correlation - Indicates the CorrelationScheme property is set. The value is 128.
     * Metrics - Indicates the ServiceLoadMetrics property is set. The value is 256.
     * DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value is 512.
     * ScalingPolicy - Indicates the ScalingPolicies property is set. The value is 1024.
     * ServicePlacementTimeLimit - Indicates the ServicePlacementTimeLimit property is set. The
     value is 2048.
     * MinInstanceCount - Indicates the MinInstanceCount property is set. The value is 4096.
     * MinInstancePercentage - Indicates the MinInstancePercentage property is set. The value is
     8192.
     * InstanceCloseDelayDuration - Indicates the InstanceCloseDelayDuration property is set. The
     value is 16384.
     * InstanceRestartWaitDuration - Indicates the InstanceCloseDelayDuration property is set. The
     value is 32768.
     * DropSourceReplicaOnMove - Indicates the DropSourceReplicaOnMove property is set. The value
     is 65536.
     * ServiceDnsName - Indicates the ServiceDnsName property is set. The value is 131072.
     * TagsForPlacement - Indicates the TagsForPlacement property is set. The value is 1048576.
     * TagsForRunning - Indicates the TagsForRunning property is set. The value is 2097152.
    :vartype flags: str
    :ivar placement_constraints: The placement constraints as a string. Placement constraints are
     boolean expressions on node properties and allow for restricting a service to particular nodes
     based on the service requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :vartype placement_constraints: str
    :ivar correlation_scheme: The correlation scheme.
    :vartype correlation_scheme: list[~azure.servicefabric.models.ServiceCorrelationDescription]
    :ivar load_metrics: The service load metrics.
    :vartype load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: The service placement policies.
    :vartype service_placement_policies:
     list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar default_move_cost: The move cost for the service. Possible values include: "Zero", "Low",
     "Medium", "High", "VeryHigh".
    :vartype default_move_cost: str or ~azure.servicefabric.models.MoveCost
    :ivar scaling_policies: Scaling policies for this service.
    :vartype scaling_policies: list[~azure.servicefabric.models.ScalingPolicyDescription]
    :ivar service_dns_name: The DNS name of the service.
    :vartype service_dns_name: str
    :ivar tags_for_placement: Tags for placement of this service.
    :vartype tags_for_placement: ~azure.servicefabric.models.NodeTagsDescription
    :ivar tags_for_running: Tags for running of this service.
    :vartype tags_for_running: ~azure.servicefabric.models.NodeTagsDescription
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'flags': {'key': 'Flags', 'type': 'str'},
        'placement_constraints': {'key': 'PlacementConstraints', 'type': 'str'},
        'correlation_scheme': {'key': 'CorrelationScheme', 'type': '[ServiceCorrelationDescription]'},
        'load_metrics': {'key': 'LoadMetrics', 'type': '[ServiceLoadMetricDescription]'},
        'service_placement_policies': {'key': 'ServicePlacementPolicies', 'type': '[ServicePlacementPolicyDescription]'},
        'default_move_cost': {'key': 'DefaultMoveCost', 'type': 'str'},
        'scaling_policies': {'key': 'ScalingPolicies', 'type': '[ScalingPolicyDescription]'},
        'service_dns_name': {'key': 'ServiceDnsName', 'type': 'str'},
        'tags_for_placement': {'key': 'TagsForPlacement', 'type': 'NodeTagsDescription'},
        'tags_for_running': {'key': 'TagsForRunning', 'type': 'NodeTagsDescription'},
    }

    _subtype_map = {
        'service_kind': {'Stateful': 'StatefulServiceUpdateDescription', 'Stateless': 'StatelessServiceUpdateDescription'}
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword flags: Flags indicating whether other properties are set. Each of the associated
         properties corresponds to a flag, specified below, which, if set, indicate that the property is
         specified.
         This property can be a combination of those flags obtained using bitwise 'OR' operator.
         For example, if the provided value is 6 then the flags for ReplicaRestartWaitDuration (2) and
         QuorumLossWaitDuration (4) are set.
        
        
         * None - Does not indicate any other properties are set. The value is zero.
         * TargetReplicaSetSize/InstanceCount - Indicates whether the TargetReplicaSetSize property
         (for Stateful services) or the InstanceCount property (for Stateless services) is set. The
         value is 1.
         * ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is set. The
         value is  2.
         * QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is set. The value is
         4.
         * StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is set. The
         value is 8.
         * MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The value is 16.
         * PlacementConstraints - Indicates the PlacementConstraints property is set. The value is 32.
         * PlacementPolicyList - Indicates the ServicePlacementPolicies property is set. The value is
         64.
         * Correlation - Indicates the CorrelationScheme property is set. The value is 128.
         * Metrics - Indicates the ServiceLoadMetrics property is set. The value is 256.
         * DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value is 512.
         * ScalingPolicy - Indicates the ScalingPolicies property is set. The value is 1024.
         * ServicePlacementTimeLimit - Indicates the ServicePlacementTimeLimit property is set. The
         value is 2048.
         * MinInstanceCount - Indicates the MinInstanceCount property is set. The value is 4096.
         * MinInstancePercentage - Indicates the MinInstancePercentage property is set. The value is
         8192.
         * InstanceCloseDelayDuration - Indicates the InstanceCloseDelayDuration property is set. The
         value is 16384.
         * InstanceRestartWaitDuration - Indicates the InstanceCloseDelayDuration property is set. The
         value is 32768.
         * DropSourceReplicaOnMove - Indicates the DropSourceReplicaOnMove property is set. The value
         is 65536.
         * ServiceDnsName - Indicates the ServiceDnsName property is set. The value is 131072.
         * TagsForPlacement - Indicates the TagsForPlacement property is set. The value is 1048576.
         * TagsForRunning - Indicates the TagsForRunning property is set. The value is 2097152.
        :paramtype flags: str
        :keyword placement_constraints: The placement constraints as a string. Placement constraints
         are boolean expressions on node properties and allow for restricting a service to particular
         nodes based on the service requirements. For example, to place a service on nodes where
         NodeType is blue specify the following: "NodeColor == blue)".
        :paramtype placement_constraints: str
        :keyword correlation_scheme: The correlation scheme.
        :paramtype correlation_scheme: list[~azure.servicefabric.models.ServiceCorrelationDescription]
        :keyword load_metrics: The service load metrics.
        :paramtype load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
        :keyword service_placement_policies: The service placement policies.
        :paramtype service_placement_policies:
         list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
        :keyword default_move_cost: The move cost for the service. Possible values include: "Zero",
         "Low", "Medium", "High", "VeryHigh".
        :paramtype default_move_cost: str or ~azure.servicefabric.models.MoveCost
        :keyword scaling_policies: Scaling policies for this service.
        :paramtype scaling_policies: list[~azure.servicefabric.models.ScalingPolicyDescription]
        :keyword service_dns_name: The DNS name of the service.
        :paramtype service_dns_name: str
        :keyword tags_for_placement: Tags for placement of this service.
        :paramtype tags_for_placement: ~azure.servicefabric.models.NodeTagsDescription
        :keyword tags_for_running: Tags for running of this service.
        :paramtype tags_for_running: ~azure.servicefabric.models.NodeTagsDescription
        """
        super(ServiceUpdateDescription, self).__init__(**kwargs)
        self.service_kind = None  # type: Optional[str]
        self.flags = kwargs.get('flags', None)
        self.placement_constraints = kwargs.get('placement_constraints', None)
        self.correlation_scheme = kwargs.get('correlation_scheme', None)
        self.load_metrics = kwargs.get('load_metrics', None)
        self.service_placement_policies = kwargs.get('service_placement_policies', None)
        self.default_move_cost = kwargs.get('default_move_cost', None)
        self.scaling_policies = kwargs.get('scaling_policies', None)
        self.service_dns_name = kwargs.get('service_dns_name', None)
        self.tags_for_placement = kwargs.get('tags_for_placement', None)
        self.tags_for_running = kwargs.get('tags_for_running', None)


class ServiceUpgradeProgress(msrest.serialization.Model):
    """Information about how many replicas are completed or pending for a specific service during upgrade.

    :ivar service_name: Name of the Service resource.
    :vartype service_name: str
    :ivar completed_replica_count: The number of replicas that completes the upgrade in the
     service.
    :vartype completed_replica_count: str
    :ivar pending_replica_count: The number of replicas that are waiting to be upgraded in the
     service.
    :vartype pending_replica_count: str
    """

    _attribute_map = {
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'completed_replica_count': {'key': 'CompletedReplicaCount', 'type': 'str'},
        'pending_replica_count': {'key': 'PendingReplicaCount', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_name: Name of the Service resource.
        :paramtype service_name: str
        :keyword completed_replica_count: The number of replicas that completes the upgrade in the
         service.
        :paramtype completed_replica_count: str
        :keyword pending_replica_count: The number of replicas that are waiting to be upgraded in the
         service.
        :paramtype pending_replica_count: str
        """
        super(ServiceUpgradeProgress, self).__init__(**kwargs)
        self.service_name = kwargs.get('service_name', None)
        self.completed_replica_count = kwargs.get('completed_replica_count', None)
        self.pending_replica_count = kwargs.get('pending_replica_count', None)


class Setting(msrest.serialization.Model):
    """Describes a setting for the container. The setting file path can be fetched from environment variable "Fabric_SettingPath". The path for Windows container is "C:\secrets". The path for Linux container is "/var/secrets".

    :ivar type: The type of the setting being given in value. Possible values include: "ClearText",
     "KeyVaultReference", "SecretValueReference". Default value: "ClearText".
    :vartype type: str or ~azure.servicefabric.models.SettingType
    :ivar name: The name of the setting.
    :vartype name: str
    :ivar value: The value of the setting, will be processed based on the type provided.
    :vartype value: str
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'value': {'key': 'value', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword type: The type of the setting being given in value. Possible values include:
         "ClearText", "KeyVaultReference", "SecretValueReference". Default value: "ClearText".
        :paramtype type: str or ~azure.servicefabric.models.SettingType
        :keyword name: The name of the setting.
        :paramtype name: str
        :keyword value: The value of the setting, will be processed based on the type provided.
        :paramtype value: str
        """
        super(Setting, self).__init__(**kwargs)
        self.type = kwargs.get('type', "ClearText")
        self.name = kwargs.get('name', None)
        self.value = kwargs.get('value', None)


class SingletonPartitionInformation(PartitionInformation):
    """Information about a partition that is singleton. The services with singleton partitioning scheme are effectively non-partitioned. They only have one partition.

    All required parameters must be populated in order to send to Azure.

    :ivar service_partition_kind: Required. The kind of partitioning scheme used to partition the
     service.Constant filled by server. Possible values include: "Invalid", "Singleton",
     "Int64Range", "Named".
    :vartype service_partition_kind: str or ~azure.servicefabric.models.ServicePartitionKind
    :ivar id: An internal ID used by Service Fabric to uniquely identify a partition. This is a
     randomly generated GUID when the service was created. The partition ID is unique and does not
     change for the lifetime of the service. If the same service was deleted and recreated the IDs
     of its partitions would be different.
    :vartype id: str
    """

    _validation = {
        'service_partition_kind': {'required': True},
    }

    _attribute_map = {
        'service_partition_kind': {'key': 'ServicePartitionKind', 'type': 'str'},
        'id': {'key': 'Id', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword id: An internal ID used by Service Fabric to uniquely identify a partition. This is a
         randomly generated GUID when the service was created. The partition ID is unique and does not
         change for the lifetime of the service. If the same service was deleted and recreated the IDs
         of its partitions would be different.
        :paramtype id: str
        """
        super(SingletonPartitionInformation, self).__init__(**kwargs)
        self.service_partition_kind = 'Singleton'  # type: str


class SingletonPartitionSchemeDescription(PartitionSchemeDescription):
    """Describes the partition scheme of a singleton-partitioned, or non-partitioned service.

    All required parameters must be populated in order to send to Azure.

    :ivar partition_scheme: Required. Specifies how the service is partitioned.Constant filled by
     server. Possible values include: "Invalid", "Singleton", "UniformInt64Range", "Named".
    :vartype partition_scheme: str or ~azure.servicefabric.models.PartitionScheme
    """

    _validation = {
        'partition_scheme': {'required': True},
    }

    _attribute_map = {
        'partition_scheme': {'key': 'PartitionScheme', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        """
        super(SingletonPartitionSchemeDescription, self).__init__(**kwargs)
        self.partition_scheme = 'Singleton'  # type: str


class StartClusterUpgradeDescription(msrest.serialization.Model):
    """Describes the parameters for starting a cluster upgrade.

    :ivar code_version: The cluster code version.
    :vartype code_version: str
    :ivar config_version: The cluster configuration version.
    :vartype config_version: str
    :ivar upgrade_kind: The kind of upgrade out of the following possible values. Possible values
     include: "Invalid", "Rolling". Default value: "Rolling".
    :vartype upgrade_kind: str or ~azure.servicefabric.models.UpgradeKind
    :ivar rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
     values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred. Possible
     values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
     "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
    :vartype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
    :ivar upgrade_replica_set_check_timeout_in_seconds: The maximum amount of time to block
     processing of an upgrade domain and prevent loss of availability when there are unexpected
     issues. When this timeout expires, processing of the upgrade domain will proceed regardless of
     availability loss issues. The timeout is reset at the start of each upgrade domain. Valid
     values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
    :vartype upgrade_replica_set_check_timeout_in_seconds: long
    :ivar force_restart: If true, then processes are forcefully restarted during upgrade even when
     the code version has not changed (the upgrade only changes configuration or data).
    :vartype force_restart: bool
    :ivar sort_order: Defines the order in which an upgrade proceeds through the cluster. Possible
     values include: "Invalid", "Default", "Numeric", "Lexicographical", "ReverseNumeric",
     "ReverseLexicographical". Default value: "Default".
    :vartype sort_order: str or ~azure.servicefabric.models.UpgradeSortOrder
    :ivar monitoring_policy: Describes the parameters for monitoring an upgrade in Monitored mode.
    :vartype monitoring_policy: ~azure.servicefabric.models.MonitoringPolicyDescription
    :ivar cluster_health_policy: Defines a health policy used to evaluate the health of the cluster
     or of a cluster node.
    :vartype cluster_health_policy: ~azure.servicefabric.models.ClusterHealthPolicy
    :ivar enable_delta_health_evaluation: When true, enables delta health evaluation rather than
     absolute health evaluation after completion of each upgrade domain.
    :vartype enable_delta_health_evaluation: bool
    :ivar cluster_upgrade_health_policy: Defines a health policy used to evaluate the health of the
     cluster during a cluster upgrade.
    :vartype cluster_upgrade_health_policy:
     ~azure.servicefabric.models.ClusterUpgradeHealthPolicyObject
    :ivar application_health_policy_map: Defines the application health policy map used to evaluate
     the health of an application or one of its children entities.
    :vartype application_health_policy_map: ~azure.servicefabric.models.ApplicationHealthPolicies
    :ivar instance_close_delay_duration_in_seconds: Duration in seconds, to wait before a stateless
     instance is closed, to allow the active requests to drain gracefully. This would be effective
     when the instance is closing during the application/cluster
     upgrade, only for those instances which have a non-zero delay duration configured in the
     service description. See InstanceCloseDelayDurationSeconds property in $ref:
     "#/definitions/StatelessServiceDescription.yaml" for details.
     Note, the default value of InstanceCloseDelayDurationInSeconds is 4294967295, which indicates
     that the behavior will entirely depend on the delay configured in the stateless service
     description.
    :vartype instance_close_delay_duration_in_seconds: long
    """

    _attribute_map = {
        'code_version': {'key': 'CodeVersion', 'type': 'str'},
        'config_version': {'key': 'ConfigVersion', 'type': 'str'},
        'upgrade_kind': {'key': 'UpgradeKind', 'type': 'str'},
        'rolling_upgrade_mode': {'key': 'RollingUpgradeMode', 'type': 'str'},
        'upgrade_replica_set_check_timeout_in_seconds': {'key': 'UpgradeReplicaSetCheckTimeoutInSeconds', 'type': 'long'},
        'force_restart': {'key': 'ForceRestart', 'type': 'bool'},
        'sort_order': {'key': 'SortOrder', 'type': 'str'},
        'monitoring_policy': {'key': 'MonitoringPolicy', 'type': 'MonitoringPolicyDescription'},
        'cluster_health_policy': {'key': 'ClusterHealthPolicy', 'type': 'ClusterHealthPolicy'},
        'enable_delta_health_evaluation': {'key': 'EnableDeltaHealthEvaluation', 'type': 'bool'},
        'cluster_upgrade_health_policy': {'key': 'ClusterUpgradeHealthPolicy', 'type': 'ClusterUpgradeHealthPolicyObject'},
        'application_health_policy_map': {'key': 'ApplicationHealthPolicyMap', 'type': 'ApplicationHealthPolicies'},
        'instance_close_delay_duration_in_seconds': {'key': 'InstanceCloseDelayDurationInSeconds', 'type': 'long'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword code_version: The cluster code version.
        :paramtype code_version: str
        :keyword config_version: The cluster configuration version.
        :paramtype config_version: str
        :keyword upgrade_kind: The kind of upgrade out of the following possible values. Possible
         values include: "Invalid", "Rolling". Default value: "Rolling".
        :paramtype upgrade_kind: str or ~azure.servicefabric.models.UpgradeKind
        :keyword rolling_upgrade_mode: The mode used to monitor health during a rolling upgrade. The
         values are UnmonitoredAuto, UnmonitoredManual, Monitored, and UnmonitoredDeferred. Possible
         values include: "Invalid", "UnmonitoredAuto", "UnmonitoredManual", "Monitored",
         "UnmonitoredDeferred". Default value: "UnmonitoredAuto".
        :paramtype rolling_upgrade_mode: str or ~azure.servicefabric.models.UpgradeMode
        :keyword upgrade_replica_set_check_timeout_in_seconds: The maximum amount of time to block
         processing of an upgrade domain and prevent loss of availability when there are unexpected
         issues. When this timeout expires, processing of the upgrade domain will proceed regardless of
         availability loss issues. The timeout is reset at the start of each upgrade domain. Valid
         values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
        :paramtype upgrade_replica_set_check_timeout_in_seconds: long
        :keyword force_restart: If true, then processes are forcefully restarted during upgrade even
         when the code version has not changed (the upgrade only changes configuration or data).
        :paramtype force_restart: bool
        :keyword sort_order: Defines the order in which an upgrade proceeds through the cluster.
         Possible values include: "Invalid", "Default", "Numeric", "Lexicographical", "ReverseNumeric",
         "ReverseLexicographical". Default value: "Default".
        :paramtype sort_order: str or ~azure.servicefabric.models.UpgradeSortOrder
        :keyword monitoring_policy: Describes the parameters for monitoring an upgrade in Monitored
         mode.
        :paramtype monitoring_policy: ~azure.servicefabric.models.MonitoringPolicyDescription
        :keyword cluster_health_policy: Defines a health policy used to evaluate the health of the
         cluster or of a cluster node.
        :paramtype cluster_health_policy: ~azure.servicefabric.models.ClusterHealthPolicy
        :keyword enable_delta_health_evaluation: When true, enables delta health evaluation rather than
         absolute health evaluation after completion of each upgrade domain.
        :paramtype enable_delta_health_evaluation: bool
        :keyword cluster_upgrade_health_policy: Defines a health policy used to evaluate the health of
         the cluster during a cluster upgrade.
        :paramtype cluster_upgrade_health_policy:
         ~azure.servicefabric.models.ClusterUpgradeHealthPolicyObject
        :keyword application_health_policy_map: Defines the application health policy map used to
         evaluate the health of an application or one of its children entities.
        :paramtype application_health_policy_map: ~azure.servicefabric.models.ApplicationHealthPolicies
        :keyword instance_close_delay_duration_in_seconds: Duration in seconds, to wait before a
         stateless instance is closed, to allow the active requests to drain gracefully. This would be
         effective when the instance is closing during the application/cluster
         upgrade, only for those instances which have a non-zero delay duration configured in the
         service description. See InstanceCloseDelayDurationSeconds property in $ref:
         "#/definitions/StatelessServiceDescription.yaml" for details.
         Note, the default value of InstanceCloseDelayDurationInSeconds is 4294967295, which indicates
         that the behavior will entirely depend on the delay configured in the stateless service
         description.
        :paramtype instance_close_delay_duration_in_seconds: long
        """
        super(StartClusterUpgradeDescription, self).__init__(**kwargs)
        self.code_version = kwargs.get('code_version', None)
        self.config_version = kwargs.get('config_version', None)
        self.upgrade_kind = kwargs.get('upgrade_kind', "Rolling")
        self.rolling_upgrade_mode = kwargs.get('rolling_upgrade_mode', "UnmonitoredAuto")
        self.upgrade_replica_set_check_timeout_in_seconds = kwargs.get('upgrade_replica_set_check_timeout_in_seconds', 42949672925)
        self.force_restart = kwargs.get('force_restart', False)
        self.sort_order = kwargs.get('sort_order', "Default")
        self.monitoring_policy = kwargs.get('monitoring_policy', None)
        self.cluster_health_policy = kwargs.get('cluster_health_policy', None)
        self.enable_delta_health_evaluation = kwargs.get('enable_delta_health_evaluation', None)
        self.cluster_upgrade_health_policy = kwargs.get('cluster_upgrade_health_policy', None)
        self.application_health_policy_map = kwargs.get('application_health_policy_map', None)
        self.instance_close_delay_duration_in_seconds = kwargs.get('instance_close_delay_duration_in_seconds', 4294967295)


class StartedChaosEvent(ChaosEvent):
    """Describes a Chaos event that gets generated when Chaos is started.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of Chaos event.Constant filled by server. Possible values
     include: "Invalid", "Started", "ExecutingFaults", "Waiting", "ValidationFailed", "TestError",
     "Stopped".
    :vartype kind: str or ~azure.servicefabric.models.ChaosEventKind
    :ivar time_stamp_utc: Required. The UTC timestamp when this Chaos event was generated.
    :vartype time_stamp_utc: ~datetime.datetime
    :ivar chaos_parameters: Defines all the parameters to configure a Chaos run.
    :vartype chaos_parameters: ~azure.servicefabric.models.ChaosParameters
    """

    _validation = {
        'kind': {'required': True},
        'time_stamp_utc': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'time_stamp_utc': {'key': 'TimeStampUtc', 'type': 'iso-8601'},
        'chaos_parameters': {'key': 'ChaosParameters', 'type': 'ChaosParameters'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword time_stamp_utc: Required. The UTC timestamp when this Chaos event was generated.
        :paramtype time_stamp_utc: ~datetime.datetime
        :keyword chaos_parameters: Defines all the parameters to configure a Chaos run.
        :paramtype chaos_parameters: ~azure.servicefabric.models.ChaosParameters
        """
        super(StartedChaosEvent, self).__init__(**kwargs)
        self.kind = 'Started'  # type: str
        self.chaos_parameters = kwargs.get('chaos_parameters', None)


class StatefulReplicaHealthReportExpiredEvent(ReplicaEvent):
    """Stateful Replica Health Report Expired event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar replica_id: Required. Id of a stateful service replica. ReplicaId is used by Service
     Fabric to uniquely identify a replica of a partition. It is unique within a partition and does
     not change for the lifetime of the replica. If a replica gets dropped and another replica gets
     created on the same node for the same partition, it will get a different value for the id.
     Sometimes the id of a stateless service instance is also referred as a replica id.
    :vartype replica_id: long
    :ivar replica_instance_id: Required. Id of Replica instance.
    :vartype replica_instance_id: long
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'partition_id': {'required': True},
        'replica_id': {'required': True},
        'replica_instance_id': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_id': {'key': 'ReplicaId', 'type': 'long'},
        'replica_instance_id': {'key': 'ReplicaInstanceId', 'type': 'long'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword replica_id: Required. Id of a stateful service replica. ReplicaId is used by Service
         Fabric to uniquely identify a replica of a partition. It is unique within a partition and does
         not change for the lifetime of the replica. If a replica gets dropped and another replica gets
         created on the same node for the same partition, it will get a different value for the id.
         Sometimes the id of a stateless service instance is also referred as a replica id.
        :paramtype replica_id: long
        :keyword replica_instance_id: Required. Id of Replica instance.
        :paramtype replica_instance_id: long
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(StatefulReplicaHealthReportExpiredEvent, self).__init__(**kwargs)
        self.kind = 'StatefulReplicaHealthReportExpired'  # type: str
        self.replica_instance_id = kwargs['replica_instance_id']
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class StatefulReplicaNewHealthReportEvent(ReplicaEvent):
    """Stateful Replica Health Report Created event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar replica_id: Required. Id of a stateful service replica. ReplicaId is used by Service
     Fabric to uniquely identify a replica of a partition. It is unique within a partition and does
     not change for the lifetime of the replica. If a replica gets dropped and another replica gets
     created on the same node for the same partition, it will get a different value for the id.
     Sometimes the id of a stateless service instance is also referred as a replica id.
    :vartype replica_id: long
    :ivar replica_instance_id: Required. Id of Replica instance.
    :vartype replica_instance_id: long
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'partition_id': {'required': True},
        'replica_id': {'required': True},
        'replica_instance_id': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_id': {'key': 'ReplicaId', 'type': 'long'},
        'replica_instance_id': {'key': 'ReplicaInstanceId', 'type': 'long'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword replica_id: Required. Id of a stateful service replica. ReplicaId is used by Service
         Fabric to uniquely identify a replica of a partition. It is unique within a partition and does
         not change for the lifetime of the replica. If a replica gets dropped and another replica gets
         created on the same node for the same partition, it will get a different value for the id.
         Sometimes the id of a stateless service instance is also referred as a replica id.
        :paramtype replica_id: long
        :keyword replica_instance_id: Required. Id of Replica instance.
        :paramtype replica_instance_id: long
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(StatefulReplicaNewHealthReportEvent, self).__init__(**kwargs)
        self.kind = 'StatefulReplicaNewHealthReport'  # type: str
        self.replica_instance_id = kwargs['replica_instance_id']
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class StatefulServiceDescription(ServiceDescription):
    """Describes a stateful service.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The service kind.Constant filled by server. Possible values
     include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar application_name: The name of the application, including the 'fabric:' URI scheme.
    :vartype application_name: str
    :ivar service_name: Required. The full name of the service with 'fabric:' URI scheme.
    :vartype service_name: str
    :ivar service_type_name: Required. Name of the service type as specified in the service
     manifest.
    :vartype service_type_name: str
    :ivar initialization_data: The initialization data as an array of bytes. Initialization data is
     passed to service instances or replicas when they are created.
    :vartype initialization_data: list[int]
    :ivar partition_description: Required. The partition description as an object.
    :vartype partition_description: ~azure.servicefabric.models.PartitionSchemeDescription
    :ivar placement_constraints: The placement constraints as a string. Placement constraints are
     boolean expressions on node properties and allow for restricting a service to particular nodes
     based on the service requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :vartype placement_constraints: str
    :ivar correlation_scheme: The correlation scheme.
    :vartype correlation_scheme: list[~azure.servicefabric.models.ServiceCorrelationDescription]
    :ivar service_load_metrics: The service load metrics.
    :vartype service_load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: The service placement policies.
    :vartype service_placement_policies:
     list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar default_move_cost: The move cost for the service. Possible values include: "Zero", "Low",
     "Medium", "High", "VeryHigh".
    :vartype default_move_cost: str or ~azure.servicefabric.models.MoveCost
    :ivar is_default_move_cost_specified: Indicates if the DefaultMoveCost property is specified.
    :vartype is_default_move_cost_specified: bool
    :ivar service_package_activation_mode: The activation mode of service package to be used for a
     service. Possible values include: "SharedProcess", "ExclusiveProcess".
    :vartype service_package_activation_mode: str or
     ~azure.servicefabric.models.ServicePackageActivationMode
    :ivar service_dns_name: The DNS name of the service. It requires the DNS system service to be
     enabled in Service Fabric cluster.
    :vartype service_dns_name: str
    :ivar scaling_policies: Scaling policies for this service.
    :vartype scaling_policies: list[~azure.servicefabric.models.ScalingPolicyDescription]
    :ivar tags_required_to_place: Tags for placement of this service.
    :vartype tags_required_to_place: ~azure.servicefabric.models.NodeTagsDescription
    :ivar tags_required_to_run: Tags for running of this service.
    :vartype tags_required_to_run: ~azure.servicefabric.models.NodeTagsDescription
    :ivar target_replica_set_size: Required. The target replica set size as a number.
    :vartype target_replica_set_size: int
    :ivar min_replica_set_size: Required. The minimum replica set size as a number.
    :vartype min_replica_set_size: int
    :ivar has_persisted_state: Required. A flag indicating whether this is a persistent service
     which stores states on the local disk. If it is then the value of this property is true, if not
     it is false.
    :vartype has_persisted_state: bool
    :ivar flags: Flags indicating whether other properties are set. Each of the associated
     properties corresponds to a flag, specified below, which, if set, indicate that the property is
     specified.
     This property can be a combination of those flags obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then the flags for QuorumLossWaitDuration (2) and
     StandByReplicaKeepDuration(4) are set.
    
    
     * None - Does not indicate any other properties are set. The value is zero.
     * ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is set. The
     value is 1.
     * QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is set. The value is
     2.
     * StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is set. The
     value is 4.
     * ServicePlacementTimeLimit - Indicates the ServicePlacementTimeLimit property is set. The
     value is 8.
     * DropSourceReplicaOnMove - Indicates the DropSourceReplicaOnMove property is set. The value
     is 16.
    :vartype flags: int
    :ivar replica_restart_wait_duration_seconds: The duration, in seconds, between when a replica
     goes down and when a new replica is created.
    :vartype replica_restart_wait_duration_seconds: long
    :ivar quorum_loss_wait_duration_seconds: The maximum duration, in seconds, for which a
     partition is allowed to be in a state of quorum loss.
    :vartype quorum_loss_wait_duration_seconds: long
    :ivar stand_by_replica_keep_duration_seconds: The definition on how long StandBy replicas
     should be maintained before being removed.
    :vartype stand_by_replica_keep_duration_seconds: long
    :ivar service_placement_time_limit_seconds: The duration for which replicas can stay InBuild
     before reporting that build is stuck.
    :vartype service_placement_time_limit_seconds: long
    :ivar drop_source_replica_on_move: Indicates whether to drop source Secondary replica even if
     the target replica has not finished build. If desired behavior is to drop it as soon as
     possible the value of this property is true, if not it is false.
    :vartype drop_source_replica_on_move: bool
    :ivar replica_lifecycle_description: Defines how replicas of this service will behave during
     ther lifecycle.
    :vartype replica_lifecycle_description: ~azure.servicefabric.models.ReplicaLifecycleDescription
    :ivar auxiliary_replica_count: The auxiliary replica count as a number. To use Auxiliary
     replicas, the following must be true: AuxiliaryReplicaCount < (TargetReplicaSetSize+1)/2 and
     TargetReplicaSetSize >=3.
    :vartype auxiliary_replica_count: int
    """

    _validation = {
        'service_kind': {'required': True},
        'service_name': {'required': True},
        'service_type_name': {'required': True},
        'partition_description': {'required': True},
        'target_replica_set_size': {'required': True, 'minimum': 1},
        'min_replica_set_size': {'required': True, 'minimum': 1},
        'has_persisted_state': {'required': True},
        'replica_restart_wait_duration_seconds': {'maximum': 4294967295, 'minimum': 0},
        'quorum_loss_wait_duration_seconds': {'maximum': 4294967295, 'minimum': 0},
        'stand_by_replica_keep_duration_seconds': {'maximum': 4294967295, 'minimum': 0},
        'service_placement_time_limit_seconds': {'maximum': 4294967295, 'minimum': 0},
        'auxiliary_replica_count': {'minimum': 0},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'service_type_name': {'key': 'ServiceTypeName', 'type': 'str'},
        'initialization_data': {'key': 'InitializationData', 'type': '[int]'},
        'partition_description': {'key': 'PartitionDescription', 'type': 'PartitionSchemeDescription'},
        'placement_constraints': {'key': 'PlacementConstraints', 'type': 'str'},
        'correlation_scheme': {'key': 'CorrelationScheme', 'type': '[ServiceCorrelationDescription]'},
        'service_load_metrics': {'key': 'ServiceLoadMetrics', 'type': '[ServiceLoadMetricDescription]'},
        'service_placement_policies': {'key': 'ServicePlacementPolicies', 'type': '[ServicePlacementPolicyDescription]'},
        'default_move_cost': {'key': 'DefaultMoveCost', 'type': 'str'},
        'is_default_move_cost_specified': {'key': 'IsDefaultMoveCostSpecified', 'type': 'bool'},
        'service_package_activation_mode': {'key': 'ServicePackageActivationMode', 'type': 'str'},
        'service_dns_name': {'key': 'ServiceDnsName', 'type': 'str'},
        'scaling_policies': {'key': 'ScalingPolicies', 'type': '[ScalingPolicyDescription]'},
        'tags_required_to_place': {'key': 'TagsRequiredToPlace', 'type': 'NodeTagsDescription'},
        'tags_required_to_run': {'key': 'TagsRequiredToRun', 'type': 'NodeTagsDescription'},
        'target_replica_set_size': {'key': 'TargetReplicaSetSize', 'type': 'int'},
        'min_replica_set_size': {'key': 'MinReplicaSetSize', 'type': 'int'},
        'has_persisted_state': {'key': 'HasPersistedState', 'type': 'bool'},
        'flags': {'key': 'Flags', 'type': 'int'},
        'replica_restart_wait_duration_seconds': {'key': 'ReplicaRestartWaitDurationSeconds', 'type': 'long'},
        'quorum_loss_wait_duration_seconds': {'key': 'QuorumLossWaitDurationSeconds', 'type': 'long'},
        'stand_by_replica_keep_duration_seconds': {'key': 'StandByReplicaKeepDurationSeconds', 'type': 'long'},
        'service_placement_time_limit_seconds': {'key': 'ServicePlacementTimeLimitSeconds', 'type': 'long'},
        'drop_source_replica_on_move': {'key': 'DropSourceReplicaOnMove', 'type': 'bool'},
        'replica_lifecycle_description': {'key': 'ReplicaLifecycleDescription', 'type': 'ReplicaLifecycleDescription'},
        'auxiliary_replica_count': {'key': 'AuxiliaryReplicaCount', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword application_name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype application_name: str
        :keyword service_name: Required. The full name of the service with 'fabric:' URI scheme.
        :paramtype service_name: str
        :keyword service_type_name: Required. Name of the service type as specified in the service
         manifest.
        :paramtype service_type_name: str
        :keyword initialization_data: The initialization data as an array of bytes. Initialization data
         is passed to service instances or replicas when they are created.
        :paramtype initialization_data: list[int]
        :keyword partition_description: Required. The partition description as an object.
        :paramtype partition_description: ~azure.servicefabric.models.PartitionSchemeDescription
        :keyword placement_constraints: The placement constraints as a string. Placement constraints
         are boolean expressions on node properties and allow for restricting a service to particular
         nodes based on the service requirements. For example, to place a service on nodes where
         NodeType is blue specify the following: "NodeColor == blue)".
        :paramtype placement_constraints: str
        :keyword correlation_scheme: The correlation scheme.
        :paramtype correlation_scheme: list[~azure.servicefabric.models.ServiceCorrelationDescription]
        :keyword service_load_metrics: The service load metrics.
        :paramtype service_load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
        :keyword service_placement_policies: The service placement policies.
        :paramtype service_placement_policies:
         list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
        :keyword default_move_cost: The move cost for the service. Possible values include: "Zero",
         "Low", "Medium", "High", "VeryHigh".
        :paramtype default_move_cost: str or ~azure.servicefabric.models.MoveCost
        :keyword is_default_move_cost_specified: Indicates if the DefaultMoveCost property is
         specified.
        :paramtype is_default_move_cost_specified: bool
        :keyword service_package_activation_mode: The activation mode of service package to be used for
         a service. Possible values include: "SharedProcess", "ExclusiveProcess".
        :paramtype service_package_activation_mode: str or
         ~azure.servicefabric.models.ServicePackageActivationMode
        :keyword service_dns_name: The DNS name of the service. It requires the DNS system service to
         be enabled in Service Fabric cluster.
        :paramtype service_dns_name: str
        :keyword scaling_policies: Scaling policies for this service.
        :paramtype scaling_policies: list[~azure.servicefabric.models.ScalingPolicyDescription]
        :keyword tags_required_to_place: Tags for placement of this service.
        :paramtype tags_required_to_place: ~azure.servicefabric.models.NodeTagsDescription
        :keyword tags_required_to_run: Tags for running of this service.
        :paramtype tags_required_to_run: ~azure.servicefabric.models.NodeTagsDescription
        :keyword target_replica_set_size: Required. The target replica set size as a number.
        :paramtype target_replica_set_size: int
        :keyword min_replica_set_size: Required. The minimum replica set size as a number.
        :paramtype min_replica_set_size: int
        :keyword has_persisted_state: Required. A flag indicating whether this is a persistent service
         which stores states on the local disk. If it is then the value of this property is true, if not
         it is false.
        :paramtype has_persisted_state: bool
        :keyword flags: Flags indicating whether other properties are set. Each of the associated
         properties corresponds to a flag, specified below, which, if set, indicate that the property is
         specified.
         This property can be a combination of those flags obtained using bitwise 'OR' operator.
         For example, if the provided value is 6 then the flags for QuorumLossWaitDuration (2) and
         StandByReplicaKeepDuration(4) are set.
        
        
         * None - Does not indicate any other properties are set. The value is zero.
         * ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is set. The
         value is 1.
         * QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is set. The value is
         2.
         * StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is set. The
         value is 4.
         * ServicePlacementTimeLimit - Indicates the ServicePlacementTimeLimit property is set. The
         value is 8.
         * DropSourceReplicaOnMove - Indicates the DropSourceReplicaOnMove property is set. The value
         is 16.
        :paramtype flags: int
        :keyword replica_restart_wait_duration_seconds: The duration, in seconds, between when a
         replica goes down and when a new replica is created.
        :paramtype replica_restart_wait_duration_seconds: long
        :keyword quorum_loss_wait_duration_seconds: The maximum duration, in seconds, for which a
         partition is allowed to be in a state of quorum loss.
        :paramtype quorum_loss_wait_duration_seconds: long
        :keyword stand_by_replica_keep_duration_seconds: The definition on how long StandBy replicas
         should be maintained before being removed.
        :paramtype stand_by_replica_keep_duration_seconds: long
        :keyword service_placement_time_limit_seconds: The duration for which replicas can stay InBuild
         before reporting that build is stuck.
        :paramtype service_placement_time_limit_seconds: long
        :keyword drop_source_replica_on_move: Indicates whether to drop source Secondary replica even
         if the target replica has not finished build. If desired behavior is to drop it as soon as
         possible the value of this property is true, if not it is false.
        :paramtype drop_source_replica_on_move: bool
        :keyword replica_lifecycle_description: Defines how replicas of this service will behave during
         ther lifecycle.
        :paramtype replica_lifecycle_description:
         ~azure.servicefabric.models.ReplicaLifecycleDescription
        :keyword auxiliary_replica_count: The auxiliary replica count as a number. To use Auxiliary
         replicas, the following must be true: AuxiliaryReplicaCount < (TargetReplicaSetSize+1)/2 and
         TargetReplicaSetSize >=3.
        :paramtype auxiliary_replica_count: int
        """
        super(StatefulServiceDescription, self).__init__(**kwargs)
        self.service_kind = 'Stateful'  # type: str
        self.target_replica_set_size = kwargs['target_replica_set_size']
        self.min_replica_set_size = kwargs['min_replica_set_size']
        self.has_persisted_state = kwargs['has_persisted_state']
        self.flags = kwargs.get('flags', None)
        self.replica_restart_wait_duration_seconds = kwargs.get('replica_restart_wait_duration_seconds', None)
        self.quorum_loss_wait_duration_seconds = kwargs.get('quorum_loss_wait_duration_seconds', None)
        self.stand_by_replica_keep_duration_seconds = kwargs.get('stand_by_replica_keep_duration_seconds', None)
        self.service_placement_time_limit_seconds = kwargs.get('service_placement_time_limit_seconds', None)
        self.drop_source_replica_on_move = kwargs.get('drop_source_replica_on_move', None)
        self.replica_lifecycle_description = kwargs.get('replica_lifecycle_description', None)
        self.auxiliary_replica_count = kwargs.get('auxiliary_replica_count', None)


class StatefulServiceInfo(ServiceInfo):
    """Information about a stateful Service Fabric service.

    All required parameters must be populated in order to send to Azure.

    :ivar id: The identity of the service. This ID is an encoded representation of the service
     name. This is used in the REST APIs to identify the service resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the service name is "fabric:/myapp/app1/svc1",
     the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
     versions.
    :vartype id: str
    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar name: The full name of the service with 'fabric:' URI scheme.
    :vartype name: str
    :ivar type_name: Name of the service type as specified in the service manifest.
    :vartype type_name: str
    :ivar manifest_version: The version of the service manifest.
    :vartype manifest_version: str
    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar service_status: The status of the application. Possible values include: "Unknown",
     "Active", "Upgrading", "Deleting", "Creating", "Failed".
    :vartype service_status: str or ~azure.servicefabric.models.ServiceStatus
    :ivar is_service_group: Whether the service is in a service group.
    :vartype is_service_group: bool
    :ivar has_persisted_state: Whether the service has persisted state.
    :vartype has_persisted_state: bool
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'Id', 'type': 'str'},
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'name': {'key': 'Name', 'type': 'str'},
        'type_name': {'key': 'TypeName', 'type': 'str'},
        'manifest_version': {'key': 'ManifestVersion', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'service_status': {'key': 'ServiceStatus', 'type': 'str'},
        'is_service_group': {'key': 'IsServiceGroup', 'type': 'bool'},
        'has_persisted_state': {'key': 'HasPersistedState', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword id: The identity of the service. This ID is an encoded representation of the service
         name. This is used in the REST APIs to identify the service resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the service name is "fabric:/myapp/app1/svc1",
         the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
         versions.
        :paramtype id: str
        :keyword name: The full name of the service with 'fabric:' URI scheme.
        :paramtype name: str
        :keyword type_name: Name of the service type as specified in the service manifest.
        :paramtype type_name: str
        :keyword manifest_version: The version of the service manifest.
        :paramtype manifest_version: str
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword service_status: The status of the application. Possible values include: "Unknown",
         "Active", "Upgrading", "Deleting", "Creating", "Failed".
        :paramtype service_status: str or ~azure.servicefabric.models.ServiceStatus
        :keyword is_service_group: Whether the service is in a service group.
        :paramtype is_service_group: bool
        :keyword has_persisted_state: Whether the service has persisted state.
        :paramtype has_persisted_state: bool
        """
        super(StatefulServiceInfo, self).__init__(**kwargs)
        self.service_kind = 'Stateful'  # type: str
        self.has_persisted_state = kwargs.get('has_persisted_state', None)


class StatefulServicePartitionInfo(ServicePartitionInfo):
    """Information about a partition of a stateful Service Fabric service..

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar partition_status: The status of the service fabric service partition. Possible values
     include: "Invalid", "Ready", "NotReady", "InQuorumLoss", "Reconfiguring", "Deleting".
    :vartype partition_status: str or ~azure.servicefabric.models.ServicePartitionStatus
    :ivar partition_information: Information about the partition identity, partitioning scheme and
     keys supported by it.
    :vartype partition_information: ~azure.servicefabric.models.PartitionInformation
    :ivar target_replica_set_size: The target replica set size as a number.
    :vartype target_replica_set_size: long
    :ivar min_replica_set_size: The minimum replica set size as a number.
    :vartype min_replica_set_size: long
    :ivar auxiliary_replica_count: The auxiliary replica count as a number. To use Auxiliary
     replicas the following must be true, AuxiliaryReplicaCount < (TargetReplicaSetSize+1)/2 and
     TargetReplicaSetSize >=3.
    :vartype auxiliary_replica_count: long
    :ivar last_quorum_loss_duration: The duration for which this partition was in quorum loss. If
     the partition is currently in quorum loss, it returns the duration since it has been in that
     state. This field is using ISO8601 format for specifying the duration.
    :vartype last_quorum_loss_duration: ~datetime.timedelta
    :ivar primary_epoch: An Epoch is a configuration number for the partition as a whole. When the
     configuration of the replica set changes, for example when the Primary replica changes, the
     operations that are replicated from the new Primary replica are said to be a new Epoch from the
     ones which were sent by the old Primary replica.
    :vartype primary_epoch: ~azure.servicefabric.models.Epoch
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'partition_status': {'key': 'PartitionStatus', 'type': 'str'},
        'partition_information': {'key': 'PartitionInformation', 'type': 'PartitionInformation'},
        'target_replica_set_size': {'key': 'TargetReplicaSetSize', 'type': 'long'},
        'min_replica_set_size': {'key': 'MinReplicaSetSize', 'type': 'long'},
        'auxiliary_replica_count': {'key': 'AuxiliaryReplicaCount', 'type': 'long'},
        'last_quorum_loss_duration': {'key': 'LastQuorumLossDuration', 'type': 'duration'},
        'primary_epoch': {'key': 'PrimaryEpoch', 'type': 'Epoch'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword partition_status: The status of the service fabric service partition. Possible values
         include: "Invalid", "Ready", "NotReady", "InQuorumLoss", "Reconfiguring", "Deleting".
        :paramtype partition_status: str or ~azure.servicefabric.models.ServicePartitionStatus
        :keyword partition_information: Information about the partition identity, partitioning scheme
         and keys supported by it.
        :paramtype partition_information: ~azure.servicefabric.models.PartitionInformation
        :keyword target_replica_set_size: The target replica set size as a number.
        :paramtype target_replica_set_size: long
        :keyword min_replica_set_size: The minimum replica set size as a number.
        :paramtype min_replica_set_size: long
        :keyword auxiliary_replica_count: The auxiliary replica count as a number. To use Auxiliary
         replicas the following must be true, AuxiliaryReplicaCount < (TargetReplicaSetSize+1)/2 and
         TargetReplicaSetSize >=3.
        :paramtype auxiliary_replica_count: long
        :keyword last_quorum_loss_duration: The duration for which this partition was in quorum loss.
         If the partition is currently in quorum loss, it returns the duration since it has been in that
         state. This field is using ISO8601 format for specifying the duration.
        :paramtype last_quorum_loss_duration: ~datetime.timedelta
        :keyword primary_epoch: An Epoch is a configuration number for the partition as a whole. When
         the configuration of the replica set changes, for example when the Primary replica changes, the
         operations that are replicated from the new Primary replica are said to be a new Epoch from the
         ones which were sent by the old Primary replica.
        :paramtype primary_epoch: ~azure.servicefabric.models.Epoch
        """
        super(StatefulServicePartitionInfo, self).__init__(**kwargs)
        self.service_kind = 'Stateful'  # type: str
        self.target_replica_set_size = kwargs.get('target_replica_set_size', None)
        self.min_replica_set_size = kwargs.get('min_replica_set_size', None)
        self.auxiliary_replica_count = kwargs.get('auxiliary_replica_count', None)
        self.last_quorum_loss_duration = kwargs.get('last_quorum_loss_duration', None)
        self.primary_epoch = kwargs.get('primary_epoch', None)


class StatefulServiceReplicaHealth(ReplicaHealth):
    """Represents the health of the stateful service replica.
Contains the replica aggregated health state, the health events and the unhealthy evaluations.

    All required parameters must be populated in order to send to Azure.

    :ivar aggregated_health_state: The HealthState representing the aggregated health state of the
     entity computed by Health Manager.
     The health evaluation of the entity reflects all events reported on the entity and its
     children (if any).
     The aggregation is done by applying the desired health policy. Possible values include:
     "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar health_events: The list of health events reported on the entity.
    :vartype health_events: list[~azure.servicefabric.models.HealthEvent]
    :ivar unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
     health state was returned by Health Manager.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    :ivar health_statistics: Shows the health statistics for all children types of the queried
     entity.
    :vartype health_statistics: ~azure.servicefabric.models.HealthStatistics
    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar partition_id: Id of the partition to which this replica belongs.
    :vartype partition_id: str
    :ivar replica_id: Id of a stateful service replica. ReplicaId is used by Service Fabric to
     uniquely identify a replica of a partition. It is unique within a partition and does not change
     for the lifetime of the replica. If a replica gets dropped and another replica gets created on
     the same node for the same partition, it will get a different value for the id. Sometimes the
     id of a stateless service instance is also referred as a replica id.
    :vartype replica_id: str
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'health_events': {'key': 'HealthEvents', 'type': '[HealthEvent]'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
        'health_statistics': {'key': 'HealthStatistics', 'type': 'HealthStatistics'},
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_id': {'key': 'ReplicaId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The HealthState representing the aggregated health state of
         the entity computed by Health Manager.
         The health evaluation of the entity reflects all events reported on the entity and its
         children (if any).
         The aggregation is done by applying the desired health policy. Possible values include:
         "Invalid", "Ok", "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword health_events: The list of health events reported on the entity.
        :paramtype health_events: list[~azure.servicefabric.models.HealthEvent]
        :keyword unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
         health state was returned by Health Manager.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        :keyword health_statistics: Shows the health statistics for all children types of the queried
         entity.
        :paramtype health_statistics: ~azure.servicefabric.models.HealthStatistics
        :keyword partition_id: Id of the partition to which this replica belongs.
        :paramtype partition_id: str
        :keyword replica_id: Id of a stateful service replica. ReplicaId is used by Service Fabric to
         uniquely identify a replica of a partition. It is unique within a partition and does not change
         for the lifetime of the replica. If a replica gets dropped and another replica gets created on
         the same node for the same partition, it will get a different value for the id. Sometimes the
         id of a stateless service instance is also referred as a replica id.
        :paramtype replica_id: str
        """
        super(StatefulServiceReplicaHealth, self).__init__(**kwargs)
        self.service_kind = 'Stateful'  # type: str
        self.replica_id = kwargs.get('replica_id', None)


class StatefulServiceReplicaHealthState(ReplicaHealthState):
    """Represents the health state of the stateful service replica, which contains the replica ID and the aggregated health state.

    All required parameters must be populated in order to send to Azure.

    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar partition_id: The ID of the partition to which this replica belongs.
    :vartype partition_id: str
    :ivar replica_id: Id of a stateful service replica. ReplicaId is used by Service Fabric to
     uniquely identify a replica of a partition. It is unique within a partition and does not change
     for the lifetime of the replica. If a replica gets dropped and another replica gets created on
     the same node for the same partition, it will get a different value for the id. Sometimes the
     id of a stateless service instance is also referred as a replica id.
    :vartype replica_id: str
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_id': {'key': 'ReplicaId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword partition_id: The ID of the partition to which this replica belongs.
        :paramtype partition_id: str
        :keyword replica_id: Id of a stateful service replica. ReplicaId is used by Service Fabric to
         uniquely identify a replica of a partition. It is unique within a partition and does not change
         for the lifetime of the replica. If a replica gets dropped and another replica gets created on
         the same node for the same partition, it will get a different value for the id. Sometimes the
         id of a stateless service instance is also referred as a replica id.
        :paramtype replica_id: str
        """
        super(StatefulServiceReplicaHealthState, self).__init__(**kwargs)
        self.service_kind = 'Stateful'  # type: str
        self.replica_id = kwargs.get('replica_id', None)


class StatefulServiceReplicaInfo(ReplicaInfo):
    """Represents a stateful service replica. This includes information about the identity, role, status, health, node name, uptime, and other details about the replica.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar replica_status: The status of a replica of a service. Possible values include: "Invalid",
     "InBuild", "Standby", "Ready", "Down", "Dropped".
    :vartype replica_status: str or ~azure.servicefabric.models.ReplicaStatus
    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar node_name: The name of a Service Fabric node.
    :vartype node_name: str
    :ivar address: The address the replica is listening on.
    :vartype address: str
    :ivar last_in_build_duration_in_seconds: The last in build duration of the replica in seconds.
    :vartype last_in_build_duration_in_seconds: str
    :ivar replica_role: The role of a replica of a stateful service. Possible values include:
     "Unknown", "None", "Primary", "IdleSecondary", "ActiveSecondary", "IdleAuxiliary",
     "ActiveAuxiliary", "PrimaryAuxiliary".
    :vartype replica_role: str or ~azure.servicefabric.models.ReplicaRole
    :ivar replica_id: Id of a stateful service replica. ReplicaId is used by Service Fabric to
     uniquely identify a replica of a partition. It is unique within a partition and does not change
     for the lifetime of the replica. If a replica gets dropped and another replica gets created on
     the same node for the same partition, it will get a different value for the id. Sometimes the
     id of a stateless service instance is also referred as a replica id.
    :vartype replica_id: str
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'replica_status': {'key': 'ReplicaStatus', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'address': {'key': 'Address', 'type': 'str'},
        'last_in_build_duration_in_seconds': {'key': 'LastInBuildDurationInSeconds', 'type': 'str'},
        'replica_role': {'key': 'ReplicaRole', 'type': 'str'},
        'replica_id': {'key': 'ReplicaId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword replica_status: The status of a replica of a service. Possible values include:
         "Invalid", "InBuild", "Standby", "Ready", "Down", "Dropped".
        :paramtype replica_status: str or ~azure.servicefabric.models.ReplicaStatus
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword node_name: The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword address: The address the replica is listening on.
        :paramtype address: str
        :keyword last_in_build_duration_in_seconds: The last in build duration of the replica in
         seconds.
        :paramtype last_in_build_duration_in_seconds: str
        :keyword replica_role: The role of a replica of a stateful service. Possible values include:
         "Unknown", "None", "Primary", "IdleSecondary", "ActiveSecondary", "IdleAuxiliary",
         "ActiveAuxiliary", "PrimaryAuxiliary".
        :paramtype replica_role: str or ~azure.servicefabric.models.ReplicaRole
        :keyword replica_id: Id of a stateful service replica. ReplicaId is used by Service Fabric to
         uniquely identify a replica of a partition. It is unique within a partition and does not change
         for the lifetime of the replica. If a replica gets dropped and another replica gets created on
         the same node for the same partition, it will get a different value for the id. Sometimes the
         id of a stateless service instance is also referred as a replica id.
        :paramtype replica_id: str
        """
        super(StatefulServiceReplicaInfo, self).__init__(**kwargs)
        self.service_kind = 'Stateful'  # type: str
        self.replica_role = kwargs.get('replica_role', None)
        self.replica_id = kwargs.get('replica_id', None)


class StatefulServiceTypeDescription(ServiceTypeDescription):
    """Describes a stateful service type defined in the service manifest of a provisioned application type.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of service (Stateless or Stateful).Constant filled by server.
     Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar is_stateful: Indicates whether the service type is a stateful service type or a stateless
     service type. This property is true if the service type is a stateful service type, false
     otherwise.
    :vartype is_stateful: bool
    :ivar service_type_name: Name of the service type as specified in the service manifest.
    :vartype service_type_name: str
    :ivar placement_constraints: The placement constraint to be used when instantiating this
     service in a Service Fabric cluster.
    :vartype placement_constraints: str
    :ivar load_metrics: The service load metrics is given as an array of
     ServiceLoadMetricDescription objects.
    :vartype load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: List of service placement policy descriptions.
    :vartype service_placement_policies:
     list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar extensions: List of service type extensions.
    :vartype extensions: list[~azure.servicefabric.models.ServiceTypeExtensionDescription]
    :ivar has_persisted_state: A flag indicating whether this is a persistent service which stores
     states on the local disk. If it is then the value of this property is true, if not it is false.
    :vartype has_persisted_state: bool
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'is_stateful': {'key': 'IsStateful', 'type': 'bool'},
        'service_type_name': {'key': 'ServiceTypeName', 'type': 'str'},
        'placement_constraints': {'key': 'PlacementConstraints', 'type': 'str'},
        'load_metrics': {'key': 'LoadMetrics', 'type': '[ServiceLoadMetricDescription]'},
        'service_placement_policies': {'key': 'ServicePlacementPolicies', 'type': '[ServicePlacementPolicyDescription]'},
        'extensions': {'key': 'Extensions', 'type': '[ServiceTypeExtensionDescription]'},
        'has_persisted_state': {'key': 'HasPersistedState', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword is_stateful: Indicates whether the service type is a stateful service type or a
         stateless service type. This property is true if the service type is a stateful service type,
         false otherwise.
        :paramtype is_stateful: bool
        :keyword service_type_name: Name of the service type as specified in the service manifest.
        :paramtype service_type_name: str
        :keyword placement_constraints: The placement constraint to be used when instantiating this
         service in a Service Fabric cluster.
        :paramtype placement_constraints: str
        :keyword load_metrics: The service load metrics is given as an array of
         ServiceLoadMetricDescription objects.
        :paramtype load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
        :keyword service_placement_policies: List of service placement policy descriptions.
        :paramtype service_placement_policies:
         list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
        :keyword extensions: List of service type extensions.
        :paramtype extensions: list[~azure.servicefabric.models.ServiceTypeExtensionDescription]
        :keyword has_persisted_state: A flag indicating whether this is a persistent service which
         stores states on the local disk. If it is then the value of this property is true, if not it is
         false.
        :paramtype has_persisted_state: bool
        """
        super(StatefulServiceTypeDescription, self).__init__(**kwargs)
        self.kind = 'Stateful'  # type: str
        self.has_persisted_state = kwargs.get('has_persisted_state', None)


class StatefulServiceUpdateDescription(ServiceUpdateDescription):
    """Describes an update for a stateful service.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The service kind.Constant filled by server. Possible values
     include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar flags: Flags indicating whether other properties are set. Each of the associated
     properties corresponds to a flag, specified below, which, if set, indicate that the property is
     specified.
     This property can be a combination of those flags obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then the flags for ReplicaRestartWaitDuration (2) and
     QuorumLossWaitDuration (4) are set.
    
    
     * None - Does not indicate any other properties are set. The value is zero.
     * TargetReplicaSetSize/InstanceCount - Indicates whether the TargetReplicaSetSize property
     (for Stateful services) or the InstanceCount property (for Stateless services) is set. The
     value is 1.
     * ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is set. The
     value is  2.
     * QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is set. The value is
     4.
     * StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is set. The
     value is 8.
     * MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The value is 16.
     * PlacementConstraints - Indicates the PlacementConstraints property is set. The value is 32.
     * PlacementPolicyList - Indicates the ServicePlacementPolicies property is set. The value is
     64.
     * Correlation - Indicates the CorrelationScheme property is set. The value is 128.
     * Metrics - Indicates the ServiceLoadMetrics property is set. The value is 256.
     * DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value is 512.
     * ScalingPolicy - Indicates the ScalingPolicies property is set. The value is 1024.
     * ServicePlacementTimeLimit - Indicates the ServicePlacementTimeLimit property is set. The
     value is 2048.
     * MinInstanceCount - Indicates the MinInstanceCount property is set. The value is 4096.
     * MinInstancePercentage - Indicates the MinInstancePercentage property is set. The value is
     8192.
     * InstanceCloseDelayDuration - Indicates the InstanceCloseDelayDuration property is set. The
     value is 16384.
     * InstanceRestartWaitDuration - Indicates the InstanceCloseDelayDuration property is set. The
     value is 32768.
     * DropSourceReplicaOnMove - Indicates the DropSourceReplicaOnMove property is set. The value
     is 65536.
     * ServiceDnsName - Indicates the ServiceDnsName property is set. The value is 131072.
     * TagsForPlacement - Indicates the TagsForPlacement property is set. The value is 1048576.
     * TagsForRunning - Indicates the TagsForRunning property is set. The value is 2097152.
    :vartype flags: str
    :ivar placement_constraints: The placement constraints as a string. Placement constraints are
     boolean expressions on node properties and allow for restricting a service to particular nodes
     based on the service requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :vartype placement_constraints: str
    :ivar correlation_scheme: The correlation scheme.
    :vartype correlation_scheme: list[~azure.servicefabric.models.ServiceCorrelationDescription]
    :ivar load_metrics: The service load metrics.
    :vartype load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: The service placement policies.
    :vartype service_placement_policies:
     list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar default_move_cost: The move cost for the service. Possible values include: "Zero", "Low",
     "Medium", "High", "VeryHigh".
    :vartype default_move_cost: str or ~azure.servicefabric.models.MoveCost
    :ivar scaling_policies: Scaling policies for this service.
    :vartype scaling_policies: list[~azure.servicefabric.models.ScalingPolicyDescription]
    :ivar service_dns_name: The DNS name of the service.
    :vartype service_dns_name: str
    :ivar tags_for_placement: Tags for placement of this service.
    :vartype tags_for_placement: ~azure.servicefabric.models.NodeTagsDescription
    :ivar tags_for_running: Tags for running of this service.
    :vartype tags_for_running: ~azure.servicefabric.models.NodeTagsDescription
    :ivar target_replica_set_size: The target replica set size as a number.
    :vartype target_replica_set_size: int
    :ivar min_replica_set_size: The minimum replica set size as a number.
    :vartype min_replica_set_size: int
    :ivar replica_restart_wait_duration_seconds: The duration, in seconds, between when a replica
     goes down and when a new replica is created.
    :vartype replica_restart_wait_duration_seconds: str
    :ivar quorum_loss_wait_duration_seconds: The maximum duration, in seconds, for which a
     partition is allowed to be in a state of quorum loss.
    :vartype quorum_loss_wait_duration_seconds: str
    :ivar stand_by_replica_keep_duration_seconds: The definition on how long StandBy replicas
     should be maintained before being removed.
    :vartype stand_by_replica_keep_duration_seconds: str
    :ivar service_placement_time_limit_seconds: The duration for which replicas can stay InBuild
     before reporting that build is stuck.
    :vartype service_placement_time_limit_seconds: str
    :ivar drop_source_replica_on_move: Indicates whether to drop source Secondary replica even if
     the target replica has not finished build. If desired behavior is to drop it as soon as
     possible the value of this property is true, if not it is false.
    :vartype drop_source_replica_on_move: bool
    :ivar replica_lifecycle_description: Defines how replicas of this service will behave during
     ther lifecycle.
    :vartype replica_lifecycle_description: ~azure.servicefabric.models.ReplicaLifecycleDescription
    :ivar auxiliary_replica_count: The auxiliary replica count as a number. To use Auxiliary
     replicas, the following must be true: AuxiliaryReplicaCount < (TargetReplicaSetSize+1)/2 and
     TargetReplicaSetSize >=3.
    :vartype auxiliary_replica_count: int
    """

    _validation = {
        'service_kind': {'required': True},
        'target_replica_set_size': {'minimum': 1},
        'min_replica_set_size': {'minimum': 1},
        'auxiliary_replica_count': {'minimum': 0},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'flags': {'key': 'Flags', 'type': 'str'},
        'placement_constraints': {'key': 'PlacementConstraints', 'type': 'str'},
        'correlation_scheme': {'key': 'CorrelationScheme', 'type': '[ServiceCorrelationDescription]'},
        'load_metrics': {'key': 'LoadMetrics', 'type': '[ServiceLoadMetricDescription]'},
        'service_placement_policies': {'key': 'ServicePlacementPolicies', 'type': '[ServicePlacementPolicyDescription]'},
        'default_move_cost': {'key': 'DefaultMoveCost', 'type': 'str'},
        'scaling_policies': {'key': 'ScalingPolicies', 'type': '[ScalingPolicyDescription]'},
        'service_dns_name': {'key': 'ServiceDnsName', 'type': 'str'},
        'tags_for_placement': {'key': 'TagsForPlacement', 'type': 'NodeTagsDescription'},
        'tags_for_running': {'key': 'TagsForRunning', 'type': 'NodeTagsDescription'},
        'target_replica_set_size': {'key': 'TargetReplicaSetSize', 'type': 'int'},
        'min_replica_set_size': {'key': 'MinReplicaSetSize', 'type': 'int'},
        'replica_restart_wait_duration_seconds': {'key': 'ReplicaRestartWaitDurationSeconds', 'type': 'str'},
        'quorum_loss_wait_duration_seconds': {'key': 'QuorumLossWaitDurationSeconds', 'type': 'str'},
        'stand_by_replica_keep_duration_seconds': {'key': 'StandByReplicaKeepDurationSeconds', 'type': 'str'},
        'service_placement_time_limit_seconds': {'key': 'ServicePlacementTimeLimitSeconds', 'type': 'str'},
        'drop_source_replica_on_move': {'key': 'DropSourceReplicaOnMove', 'type': 'bool'},
        'replica_lifecycle_description': {'key': 'ReplicaLifecycleDescription', 'type': 'ReplicaLifecycleDescription'},
        'auxiliary_replica_count': {'key': 'AuxiliaryReplicaCount', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword flags: Flags indicating whether other properties are set. Each of the associated
         properties corresponds to a flag, specified below, which, if set, indicate that the property is
         specified.
         This property can be a combination of those flags obtained using bitwise 'OR' operator.
         For example, if the provided value is 6 then the flags for ReplicaRestartWaitDuration (2) and
         QuorumLossWaitDuration (4) are set.
        
        
         * None - Does not indicate any other properties are set. The value is zero.
         * TargetReplicaSetSize/InstanceCount - Indicates whether the TargetReplicaSetSize property
         (for Stateful services) or the InstanceCount property (for Stateless services) is set. The
         value is 1.
         * ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is set. The
         value is  2.
         * QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is set. The value is
         4.
         * StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is set. The
         value is 8.
         * MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The value is 16.
         * PlacementConstraints - Indicates the PlacementConstraints property is set. The value is 32.
         * PlacementPolicyList - Indicates the ServicePlacementPolicies property is set. The value is
         64.
         * Correlation - Indicates the CorrelationScheme property is set. The value is 128.
         * Metrics - Indicates the ServiceLoadMetrics property is set. The value is 256.
         * DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value is 512.
         * ScalingPolicy - Indicates the ScalingPolicies property is set. The value is 1024.
         * ServicePlacementTimeLimit - Indicates the ServicePlacementTimeLimit property is set. The
         value is 2048.
         * MinInstanceCount - Indicates the MinInstanceCount property is set. The value is 4096.
         * MinInstancePercentage - Indicates the MinInstancePercentage property is set. The value is
         8192.
         * InstanceCloseDelayDuration - Indicates the InstanceCloseDelayDuration property is set. The
         value is 16384.
         * InstanceRestartWaitDuration - Indicates the InstanceCloseDelayDuration property is set. The
         value is 32768.
         * DropSourceReplicaOnMove - Indicates the DropSourceReplicaOnMove property is set. The value
         is 65536.
         * ServiceDnsName - Indicates the ServiceDnsName property is set. The value is 131072.
         * TagsForPlacement - Indicates the TagsForPlacement property is set. The value is 1048576.
         * TagsForRunning - Indicates the TagsForRunning property is set. The value is 2097152.
        :paramtype flags: str
        :keyword placement_constraints: The placement constraints as a string. Placement constraints
         are boolean expressions on node properties and allow for restricting a service to particular
         nodes based on the service requirements. For example, to place a service on nodes where
         NodeType is blue specify the following: "NodeColor == blue)".
        :paramtype placement_constraints: str
        :keyword correlation_scheme: The correlation scheme.
        :paramtype correlation_scheme: list[~azure.servicefabric.models.ServiceCorrelationDescription]
        :keyword load_metrics: The service load metrics.
        :paramtype load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
        :keyword service_placement_policies: The service placement policies.
        :paramtype service_placement_policies:
         list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
        :keyword default_move_cost: The move cost for the service. Possible values include: "Zero",
         "Low", "Medium", "High", "VeryHigh".
        :paramtype default_move_cost: str or ~azure.servicefabric.models.MoveCost
        :keyword scaling_policies: Scaling policies for this service.
        :paramtype scaling_policies: list[~azure.servicefabric.models.ScalingPolicyDescription]
        :keyword service_dns_name: The DNS name of the service.
        :paramtype service_dns_name: str
        :keyword tags_for_placement: Tags for placement of this service.
        :paramtype tags_for_placement: ~azure.servicefabric.models.NodeTagsDescription
        :keyword tags_for_running: Tags for running of this service.
        :paramtype tags_for_running: ~azure.servicefabric.models.NodeTagsDescription
        :keyword target_replica_set_size: The target replica set size as a number.
        :paramtype target_replica_set_size: int
        :keyword min_replica_set_size: The minimum replica set size as a number.
        :paramtype min_replica_set_size: int
        :keyword replica_restart_wait_duration_seconds: The duration, in seconds, between when a
         replica goes down and when a new replica is created.
        :paramtype replica_restart_wait_duration_seconds: str
        :keyword quorum_loss_wait_duration_seconds: The maximum duration, in seconds, for which a
         partition is allowed to be in a state of quorum loss.
        :paramtype quorum_loss_wait_duration_seconds: str
        :keyword stand_by_replica_keep_duration_seconds: The definition on how long StandBy replicas
         should be maintained before being removed.
        :paramtype stand_by_replica_keep_duration_seconds: str
        :keyword service_placement_time_limit_seconds: The duration for which replicas can stay InBuild
         before reporting that build is stuck.
        :paramtype service_placement_time_limit_seconds: str
        :keyword drop_source_replica_on_move: Indicates whether to drop source Secondary replica even
         if the target replica has not finished build. If desired behavior is to drop it as soon as
         possible the value of this property is true, if not it is false.
        :paramtype drop_source_replica_on_move: bool
        :keyword replica_lifecycle_description: Defines how replicas of this service will behave during
         ther lifecycle.
        :paramtype replica_lifecycle_description:
         ~azure.servicefabric.models.ReplicaLifecycleDescription
        :keyword auxiliary_replica_count: The auxiliary replica count as a number. To use Auxiliary
         replicas, the following must be true: AuxiliaryReplicaCount < (TargetReplicaSetSize+1)/2 and
         TargetReplicaSetSize >=3.
        :paramtype auxiliary_replica_count: int
        """
        super(StatefulServiceUpdateDescription, self).__init__(**kwargs)
        self.service_kind = 'Stateful'  # type: str
        self.target_replica_set_size = kwargs.get('target_replica_set_size', None)
        self.min_replica_set_size = kwargs.get('min_replica_set_size', None)
        self.replica_restart_wait_duration_seconds = kwargs.get('replica_restart_wait_duration_seconds', None)
        self.quorum_loss_wait_duration_seconds = kwargs.get('quorum_loss_wait_duration_seconds', None)
        self.stand_by_replica_keep_duration_seconds = kwargs.get('stand_by_replica_keep_duration_seconds', None)
        self.service_placement_time_limit_seconds = kwargs.get('service_placement_time_limit_seconds', None)
        self.drop_source_replica_on_move = kwargs.get('drop_source_replica_on_move', None)
        self.replica_lifecycle_description = kwargs.get('replica_lifecycle_description', None)
        self.auxiliary_replica_count = kwargs.get('auxiliary_replica_count', None)


class StatelessReplicaHealthReportExpiredEvent(ReplicaEvent):
    """Stateless Replica Health Report Expired event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar replica_id: Required. Id of a stateful service replica. ReplicaId is used by Service
     Fabric to uniquely identify a replica of a partition. It is unique within a partition and does
     not change for the lifetime of the replica. If a replica gets dropped and another replica gets
     created on the same node for the same partition, it will get a different value for the id.
     Sometimes the id of a stateless service instance is also referred as a replica id.
    :vartype replica_id: long
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'partition_id': {'required': True},
        'replica_id': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_id': {'key': 'ReplicaId', 'type': 'long'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword replica_id: Required. Id of a stateful service replica. ReplicaId is used by Service
         Fabric to uniquely identify a replica of a partition. It is unique within a partition and does
         not change for the lifetime of the replica. If a replica gets dropped and another replica gets
         created on the same node for the same partition, it will get a different value for the id.
         Sometimes the id of a stateless service instance is also referred as a replica id.
        :paramtype replica_id: long
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(StatelessReplicaHealthReportExpiredEvent, self).__init__(**kwargs)
        self.kind = 'StatelessReplicaHealthReportExpired'  # type: str
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class StatelessReplicaNewHealthReportEvent(ReplicaEvent):
    """Stateless Replica Health Report Created event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of FabricEvent.Constant filled by server. Possible values
     include: "ClusterEvent", "ContainerInstanceEvent", "NodeEvent", "ApplicationEvent",
     "ServiceEvent", "PartitionEvent", "ReplicaEvent", "PartitionAnalysisEvent",
     "ApplicationCreated", "ApplicationDeleted", "ApplicationNewHealthReport",
     "ApplicationHealthReportExpired", "ApplicationUpgradeCompleted",
     "ApplicationUpgradeDomainCompleted", "ApplicationUpgradeRollbackCompleted",
     "ApplicationUpgradeRollbackStarted", "ApplicationUpgradeStarted",
     "DeployedApplicationNewHealthReport", "DeployedApplicationHealthReportExpired",
     "ApplicationProcessExited", "ApplicationContainerInstanceExited", "NodeAborted",
     "NodeAddedToCluster", "NodeClosed", "NodeDeactivateCompleted", "NodeDeactivateStarted",
     "NodeDown", "NodeNewHealthReport", "NodeHealthReportExpired", "NodeOpenSucceeded",
     "NodeOpenFailed", "NodeRemovedFromCluster", "NodeUp", "PartitionNewHealthReport",
     "PartitionHealthReportExpired", "PartitionReconfigured", "PartitionPrimaryMoveAnalysis",
     "ServiceCreated", "ServiceDeleted", "ServiceNewHealthReport", "ServiceHealthReportExpired",
     "DeployedServicePackageNewHealthReport", "DeployedServicePackageHealthReportExpired",
     "StatefulReplicaNewHealthReport", "StatefulReplicaHealthReportExpired",
     "StatelessReplicaNewHealthReport", "StatelessReplicaHealthReportExpired",
     "ClusterNewHealthReport", "ClusterHealthReportExpired", "ClusterUpgradeCompleted",
     "ClusterUpgradeDomainCompleted", "ClusterUpgradeRollbackCompleted",
     "ClusterUpgradeRollbackStarted", "ClusterUpgradeStarted", "ChaosStopped", "ChaosStarted",
     "ChaosCodePackageRestartScheduled", "ChaosReplicaRemovalScheduled",
     "ChaosPartitionSecondaryMoveScheduled", "ChaosPartitionPrimaryMoveScheduled",
     "ChaosReplicaRestartScheduled", "ChaosNodeRestartScheduled".
    :vartype kind: str or ~azure.servicefabric.models.FabricEventKind
    :ivar event_instance_id: Required. The identifier for the FabricEvent instance.
    :vartype event_instance_id: str
    :ivar category: The category of event.
    :vartype category: str
    :ivar time_stamp: Required. The time event was logged.
    :vartype time_stamp: ~datetime.datetime
    :ivar has_correlated_events: Shows there is existing related events available.
    :vartype has_correlated_events: bool
    :ivar partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
     partition. This is a randomly generated GUID when the service was created. The partition ID is
     unique and does not change for the lifetime of the service. If the same service was deleted and
     recreated the IDs of its partitions would be different.
    :vartype partition_id: str
    :ivar replica_id: Required. Id of a stateful service replica. ReplicaId is used by Service
     Fabric to uniquely identify a replica of a partition. It is unique within a partition and does
     not change for the lifetime of the replica. If a replica gets dropped and another replica gets
     created on the same node for the same partition, it will get a different value for the id.
     Sometimes the id of a stateless service instance is also referred as a replica id.
    :vartype replica_id: long
    :ivar source_id: Required. Id of report source.
    :vartype source_id: str
    :ivar property: Required. Describes the property.
    :vartype property: str
    :ivar health_state: Required. Describes the property health state.
    :vartype health_state: str
    :ivar time_to_live_ms: Required. Time to live in milli-seconds.
    :vartype time_to_live_ms: long
    :ivar sequence_number: Required. Sequence number of report.
    :vartype sequence_number: long
    :ivar description: Required. Description of report.
    :vartype description: str
    :ivar remove_when_expired: Required. Indicates the removal when it expires.
    :vartype remove_when_expired: bool
    :ivar source_utc_timestamp: Required. Source time.
    :vartype source_utc_timestamp: ~datetime.datetime
    """

    _validation = {
        'kind': {'required': True},
        'event_instance_id': {'required': True},
        'time_stamp': {'required': True},
        'partition_id': {'required': True},
        'replica_id': {'required': True},
        'source_id': {'required': True},
        'property': {'required': True},
        'health_state': {'required': True},
        'time_to_live_ms': {'required': True},
        'sequence_number': {'required': True},
        'description': {'required': True},
        'remove_when_expired': {'required': True},
        'source_utc_timestamp': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'event_instance_id': {'key': 'EventInstanceId', 'type': 'str'},
        'category': {'key': 'Category', 'type': 'str'},
        'time_stamp': {'key': 'TimeStamp', 'type': 'iso-8601'},
        'has_correlated_events': {'key': 'HasCorrelatedEvents', 'type': 'bool'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_id': {'key': 'ReplicaId', 'type': 'long'},
        'source_id': {'key': 'SourceId', 'type': 'str'},
        'property': {'key': 'Property', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'time_to_live_ms': {'key': 'TimeToLiveMs', 'type': 'long'},
        'sequence_number': {'key': 'SequenceNumber', 'type': 'long'},
        'description': {'key': 'Description', 'type': 'str'},
        'remove_when_expired': {'key': 'RemoveWhenExpired', 'type': 'bool'},
        'source_utc_timestamp': {'key': 'SourceUtcTimestamp', 'type': 'iso-8601'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword event_instance_id: Required. The identifier for the FabricEvent instance.
        :paramtype event_instance_id: str
        :keyword category: The category of event.
        :paramtype category: str
        :keyword time_stamp: Required. The time event was logged.
        :paramtype time_stamp: ~datetime.datetime
        :keyword has_correlated_events: Shows there is existing related events available.
        :paramtype has_correlated_events: bool
        :keyword partition_id: Required. An internal ID used by Service Fabric to uniquely identify a
         partition. This is a randomly generated GUID when the service was created. The partition ID is
         unique and does not change for the lifetime of the service. If the same service was deleted and
         recreated the IDs of its partitions would be different.
        :paramtype partition_id: str
        :keyword replica_id: Required. Id of a stateful service replica. ReplicaId is used by Service
         Fabric to uniquely identify a replica of a partition. It is unique within a partition and does
         not change for the lifetime of the replica. If a replica gets dropped and another replica gets
         created on the same node for the same partition, it will get a different value for the id.
         Sometimes the id of a stateless service instance is also referred as a replica id.
        :paramtype replica_id: long
        :keyword source_id: Required. Id of report source.
        :paramtype source_id: str
        :keyword property: Required. Describes the property.
        :paramtype property: str
        :keyword health_state: Required. Describes the property health state.
        :paramtype health_state: str
        :keyword time_to_live_ms: Required. Time to live in milli-seconds.
        :paramtype time_to_live_ms: long
        :keyword sequence_number: Required. Sequence number of report.
        :paramtype sequence_number: long
        :keyword description: Required. Description of report.
        :paramtype description: str
        :keyword remove_when_expired: Required. Indicates the removal when it expires.
        :paramtype remove_when_expired: bool
        :keyword source_utc_timestamp: Required. Source time.
        :paramtype source_utc_timestamp: ~datetime.datetime
        """
        super(StatelessReplicaNewHealthReportEvent, self).__init__(**kwargs)
        self.kind = 'StatelessReplicaNewHealthReport'  # type: str
        self.source_id = kwargs['source_id']
        self.property = kwargs['property']
        self.health_state = kwargs['health_state']
        self.time_to_live_ms = kwargs['time_to_live_ms']
        self.sequence_number = kwargs['sequence_number']
        self.description = kwargs['description']
        self.remove_when_expired = kwargs['remove_when_expired']
        self.source_utc_timestamp = kwargs['source_utc_timestamp']


class StatelessServiceDescription(ServiceDescription):
    """Describes a stateless service.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The service kind.Constant filled by server. Possible values
     include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar application_name: The name of the application, including the 'fabric:' URI scheme.
    :vartype application_name: str
    :ivar service_name: Required. The full name of the service with 'fabric:' URI scheme.
    :vartype service_name: str
    :ivar service_type_name: Required. Name of the service type as specified in the service
     manifest.
    :vartype service_type_name: str
    :ivar initialization_data: The initialization data as an array of bytes. Initialization data is
     passed to service instances or replicas when they are created.
    :vartype initialization_data: list[int]
    :ivar partition_description: Required. The partition description as an object.
    :vartype partition_description: ~azure.servicefabric.models.PartitionSchemeDescription
    :ivar placement_constraints: The placement constraints as a string. Placement constraints are
     boolean expressions on node properties and allow for restricting a service to particular nodes
     based on the service requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :vartype placement_constraints: str
    :ivar correlation_scheme: The correlation scheme.
    :vartype correlation_scheme: list[~azure.servicefabric.models.ServiceCorrelationDescription]
    :ivar service_load_metrics: The service load metrics.
    :vartype service_load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: The service placement policies.
    :vartype service_placement_policies:
     list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar default_move_cost: The move cost for the service. Possible values include: "Zero", "Low",
     "Medium", "High", "VeryHigh".
    :vartype default_move_cost: str or ~azure.servicefabric.models.MoveCost
    :ivar is_default_move_cost_specified: Indicates if the DefaultMoveCost property is specified.
    :vartype is_default_move_cost_specified: bool
    :ivar service_package_activation_mode: The activation mode of service package to be used for a
     service. Possible values include: "SharedProcess", "ExclusiveProcess".
    :vartype service_package_activation_mode: str or
     ~azure.servicefabric.models.ServicePackageActivationMode
    :ivar service_dns_name: The DNS name of the service. It requires the DNS system service to be
     enabled in Service Fabric cluster.
    :vartype service_dns_name: str
    :ivar scaling_policies: Scaling policies for this service.
    :vartype scaling_policies: list[~azure.servicefabric.models.ScalingPolicyDescription]
    :ivar tags_required_to_place: Tags for placement of this service.
    :vartype tags_required_to_place: ~azure.servicefabric.models.NodeTagsDescription
    :ivar tags_required_to_run: Tags for running of this service.
    :vartype tags_required_to_run: ~azure.servicefabric.models.NodeTagsDescription
    :ivar instance_count: Required. The instance count.
    :vartype instance_count: int
    :ivar min_instance_count: MinInstanceCount is the minimum number of instances that must be up
     to meet the EnsureAvailability safety check during operations like upgrade or deactivate node.
     The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
     InstanceCount) ).
     Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted
     into the number of nodes on which the instances are allowed to be placed according to the
     placement constraints on the service.
    :vartype min_instance_count: int
    :ivar min_instance_percentage: MinInstancePercentage is the minimum percentage of InstanceCount
     that must be up to meet the EnsureAvailability safety check during operations like upgrade or
     deactivate node.
     The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
     InstanceCount) ).
     Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first
     converted into the number of nodes on which the instances are allowed to be placed according to
     the placement constraints on the service.
    :vartype min_instance_percentage: int
    :ivar flags: Flags indicating whether other properties are set. Each of the associated
     properties corresponds to a flag, specified below, which, if set, indicate that the property is
     specified.
     This property can be a combination of those flags obtained using bitwise 'OR' operator.
     For example, if the provided value is 1 then the flags for InstanceCloseDelayDuration is set.
    
    
     * None - Does not indicate any other properties are set. The value is zero.
     * InstanceCloseDelayDuration - Indicates the InstanceCloseDelayDuration property is set. The
     value is 1.
     * InstanceRestartWaitDuration - Indicates the InstanceRestartWaitDurationSeconds property is
     set. The value is 2.
    :vartype flags: int
    :ivar instance_close_delay_duration_seconds: Duration in seconds, to wait before a stateless
     instance is closed, to allow the active requests to drain gracefully. This would be effective
     when the instance is closing during the application/cluster upgrade and disabling node.
     The endpoint exposed on this instance is removed prior to starting the delay, which prevents
     new connections to this instance.
     In addition, clients that have subscribed to service endpoint change
     events(https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.servicemanagementclient.registerservicenotificationfilterasync),
     can do
     the following upon receiving the endpoint removal notification:
    
     .. code-block::
    
        - Stop sending new requests to this instance.
        - Close existing connections after in-flight requests have completed.
        - Connect to a different instance of the service partition for future requests.
    
     Note, the default value of InstanceCloseDelayDuration is 0, which indicates that there won't
     be any delay or removal of the endpoint prior to closing the instance.
    :vartype instance_close_delay_duration_seconds: long
    :ivar instance_lifecycle_description: Defines how instances of this service will behave during
     their lifecycle.
    :vartype instance_lifecycle_description:
     ~azure.servicefabric.models.InstanceLifecycleDescription
    :ivar instance_restart_wait_duration_seconds: When a stateless instance goes down, this timer
     starts. When it expires Service Fabric will create a new instance on any node in the cluster.
     This configuration is to reduce unnecessary creation of a new instance in situations where the
     instance going down is likely to recover in a short time. For example, during an upgrade.
     The default value is 0, which indicates that when stateless instance goes down, Service Fabric
     will immediately start building its replacement.
    :vartype instance_restart_wait_duration_seconds: long
    """

    _validation = {
        'service_kind': {'required': True},
        'service_name': {'required': True},
        'service_type_name': {'required': True},
        'partition_description': {'required': True},
        'instance_count': {'required': True, 'minimum': -1},
        'min_instance_count': {'minimum': 1},
        'min_instance_percentage': {'maximum': 100, 'minimum': 0},
        'instance_close_delay_duration_seconds': {'maximum': 4294967295, 'minimum': 0},
        'instance_restart_wait_duration_seconds': {'maximum': 4294967295, 'minimum': 0},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'application_name': {'key': 'ApplicationName', 'type': 'str'},
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'service_type_name': {'key': 'ServiceTypeName', 'type': 'str'},
        'initialization_data': {'key': 'InitializationData', 'type': '[int]'},
        'partition_description': {'key': 'PartitionDescription', 'type': 'PartitionSchemeDescription'},
        'placement_constraints': {'key': 'PlacementConstraints', 'type': 'str'},
        'correlation_scheme': {'key': 'CorrelationScheme', 'type': '[ServiceCorrelationDescription]'},
        'service_load_metrics': {'key': 'ServiceLoadMetrics', 'type': '[ServiceLoadMetricDescription]'},
        'service_placement_policies': {'key': 'ServicePlacementPolicies', 'type': '[ServicePlacementPolicyDescription]'},
        'default_move_cost': {'key': 'DefaultMoveCost', 'type': 'str'},
        'is_default_move_cost_specified': {'key': 'IsDefaultMoveCostSpecified', 'type': 'bool'},
        'service_package_activation_mode': {'key': 'ServicePackageActivationMode', 'type': 'str'},
        'service_dns_name': {'key': 'ServiceDnsName', 'type': 'str'},
        'scaling_policies': {'key': 'ScalingPolicies', 'type': '[ScalingPolicyDescription]'},
        'tags_required_to_place': {'key': 'TagsRequiredToPlace', 'type': 'NodeTagsDescription'},
        'tags_required_to_run': {'key': 'TagsRequiredToRun', 'type': 'NodeTagsDescription'},
        'instance_count': {'key': 'InstanceCount', 'type': 'int'},
        'min_instance_count': {'key': 'MinInstanceCount', 'type': 'int'},
        'min_instance_percentage': {'key': 'MinInstancePercentage', 'type': 'int'},
        'flags': {'key': 'Flags', 'type': 'int'},
        'instance_close_delay_duration_seconds': {'key': 'InstanceCloseDelayDurationSeconds', 'type': 'long'},
        'instance_lifecycle_description': {'key': 'InstanceLifecycleDescription', 'type': 'InstanceLifecycleDescription'},
        'instance_restart_wait_duration_seconds': {'key': 'InstanceRestartWaitDurationSeconds', 'type': 'long'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword application_name: The name of the application, including the 'fabric:' URI scheme.
        :paramtype application_name: str
        :keyword service_name: Required. The full name of the service with 'fabric:' URI scheme.
        :paramtype service_name: str
        :keyword service_type_name: Required. Name of the service type as specified in the service
         manifest.
        :paramtype service_type_name: str
        :keyword initialization_data: The initialization data as an array of bytes. Initialization data
         is passed to service instances or replicas when they are created.
        :paramtype initialization_data: list[int]
        :keyword partition_description: Required. The partition description as an object.
        :paramtype partition_description: ~azure.servicefabric.models.PartitionSchemeDescription
        :keyword placement_constraints: The placement constraints as a string. Placement constraints
         are boolean expressions on node properties and allow for restricting a service to particular
         nodes based on the service requirements. For example, to place a service on nodes where
         NodeType is blue specify the following: "NodeColor == blue)".
        :paramtype placement_constraints: str
        :keyword correlation_scheme: The correlation scheme.
        :paramtype correlation_scheme: list[~azure.servicefabric.models.ServiceCorrelationDescription]
        :keyword service_load_metrics: The service load metrics.
        :paramtype service_load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
        :keyword service_placement_policies: The service placement policies.
        :paramtype service_placement_policies:
         list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
        :keyword default_move_cost: The move cost for the service. Possible values include: "Zero",
         "Low", "Medium", "High", "VeryHigh".
        :paramtype default_move_cost: str or ~azure.servicefabric.models.MoveCost
        :keyword is_default_move_cost_specified: Indicates if the DefaultMoveCost property is
         specified.
        :paramtype is_default_move_cost_specified: bool
        :keyword service_package_activation_mode: The activation mode of service package to be used for
         a service. Possible values include: "SharedProcess", "ExclusiveProcess".
        :paramtype service_package_activation_mode: str or
         ~azure.servicefabric.models.ServicePackageActivationMode
        :keyword service_dns_name: The DNS name of the service. It requires the DNS system service to
         be enabled in Service Fabric cluster.
        :paramtype service_dns_name: str
        :keyword scaling_policies: Scaling policies for this service.
        :paramtype scaling_policies: list[~azure.servicefabric.models.ScalingPolicyDescription]
        :keyword tags_required_to_place: Tags for placement of this service.
        :paramtype tags_required_to_place: ~azure.servicefabric.models.NodeTagsDescription
        :keyword tags_required_to_run: Tags for running of this service.
        :paramtype tags_required_to_run: ~azure.servicefabric.models.NodeTagsDescription
        :keyword instance_count: Required. The instance count.
        :paramtype instance_count: int
        :keyword min_instance_count: MinInstanceCount is the minimum number of instances that must be
         up to meet the EnsureAvailability safety check during operations like upgrade or deactivate
         node.
         The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
         InstanceCount) ).
         Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted
         into the number of nodes on which the instances are allowed to be placed according to the
         placement constraints on the service.
        :paramtype min_instance_count: int
        :keyword min_instance_percentage: MinInstancePercentage is the minimum percentage of
         InstanceCount that must be up to meet the EnsureAvailability safety check during operations
         like upgrade or deactivate node.
         The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
         InstanceCount) ).
         Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first
         converted into the number of nodes on which the instances are allowed to be placed according to
         the placement constraints on the service.
        :paramtype min_instance_percentage: int
        :keyword flags: Flags indicating whether other properties are set. Each of the associated
         properties corresponds to a flag, specified below, which, if set, indicate that the property is
         specified.
         This property can be a combination of those flags obtained using bitwise 'OR' operator.
         For example, if the provided value is 1 then the flags for InstanceCloseDelayDuration is set.
        
        
         * None - Does not indicate any other properties are set. The value is zero.
         * InstanceCloseDelayDuration - Indicates the InstanceCloseDelayDuration property is set. The
         value is 1.
         * InstanceRestartWaitDuration - Indicates the InstanceRestartWaitDurationSeconds property is
         set. The value is 2.
        :paramtype flags: int
        :keyword instance_close_delay_duration_seconds: Duration in seconds, to wait before a stateless
         instance is closed, to allow the active requests to drain gracefully. This would be effective
         when the instance is closing during the application/cluster upgrade and disabling node.
         The endpoint exposed on this instance is removed prior to starting the delay, which prevents
         new connections to this instance.
         In addition, clients that have subscribed to service endpoint change
         events(https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.servicemanagementclient.registerservicenotificationfilterasync),
         can do
         the following upon receiving the endpoint removal notification:
        
         .. code-block::
        
            - Stop sending new requests to this instance.
            - Close existing connections after in-flight requests have completed.
            - Connect to a different instance of the service partition for future requests.
        
         Note, the default value of InstanceCloseDelayDuration is 0, which indicates that there won't
         be any delay or removal of the endpoint prior to closing the instance.
        :paramtype instance_close_delay_duration_seconds: long
        :keyword instance_lifecycle_description: Defines how instances of this service will behave
         during their lifecycle.
        :paramtype instance_lifecycle_description:
         ~azure.servicefabric.models.InstanceLifecycleDescription
        :keyword instance_restart_wait_duration_seconds: When a stateless instance goes down, this
         timer starts. When it expires Service Fabric will create a new instance on any node in the
         cluster.
         This configuration is to reduce unnecessary creation of a new instance in situations where the
         instance going down is likely to recover in a short time. For example, during an upgrade.
         The default value is 0, which indicates that when stateless instance goes down, Service Fabric
         will immediately start building its replacement.
        :paramtype instance_restart_wait_duration_seconds: long
        """
        super(StatelessServiceDescription, self).__init__(**kwargs)
        self.service_kind = 'Stateless'  # type: str
        self.instance_count = kwargs['instance_count']
        self.min_instance_count = kwargs.get('min_instance_count', 1)
        self.min_instance_percentage = kwargs.get('min_instance_percentage', 0)
        self.flags = kwargs.get('flags', None)
        self.instance_close_delay_duration_seconds = kwargs.get('instance_close_delay_duration_seconds', None)
        self.instance_lifecycle_description = kwargs.get('instance_lifecycle_description', None)
        self.instance_restart_wait_duration_seconds = kwargs.get('instance_restart_wait_duration_seconds', None)


class StatelessServiceInfo(ServiceInfo):
    """Information about a stateless Service Fabric service.

    All required parameters must be populated in order to send to Azure.

    :ivar id: The identity of the service. This ID is an encoded representation of the service
     name. This is used in the REST APIs to identify the service resource.
     Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
     if the service name is "fabric:/myapp/app1/svc1",
     the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
     versions.
    :vartype id: str
    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar name: The full name of the service with 'fabric:' URI scheme.
    :vartype name: str
    :ivar type_name: Name of the service type as specified in the service manifest.
    :vartype type_name: str
    :ivar manifest_version: The version of the service manifest.
    :vartype manifest_version: str
    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar service_status: The status of the application. Possible values include: "Unknown",
     "Active", "Upgrading", "Deleting", "Creating", "Failed".
    :vartype service_status: str or ~azure.servicefabric.models.ServiceStatus
    :ivar is_service_group: Whether the service is in a service group.
    :vartype is_service_group: bool
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'Id', 'type': 'str'},
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'name': {'key': 'Name', 'type': 'str'},
        'type_name': {'key': 'TypeName', 'type': 'str'},
        'manifest_version': {'key': 'ManifestVersion', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'service_status': {'key': 'ServiceStatus', 'type': 'str'},
        'is_service_group': {'key': 'IsServiceGroup', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword id: The identity of the service. This ID is an encoded representation of the service
         name. This is used in the REST APIs to identify the service resource.
         Starting in version 6.0, hierarchical names are delimited with the "~" character. For example,
         if the service name is "fabric:/myapp/app1/svc1",
         the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
         versions.
        :paramtype id: str
        :keyword name: The full name of the service with 'fabric:' URI scheme.
        :paramtype name: str
        :keyword type_name: Name of the service type as specified in the service manifest.
        :paramtype type_name: str
        :keyword manifest_version: The version of the service manifest.
        :paramtype manifest_version: str
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword service_status: The status of the application. Possible values include: "Unknown",
         "Active", "Upgrading", "Deleting", "Creating", "Failed".
        :paramtype service_status: str or ~azure.servicefabric.models.ServiceStatus
        :keyword is_service_group: Whether the service is in a service group.
        :paramtype is_service_group: bool
        """
        super(StatelessServiceInfo, self).__init__(**kwargs)
        self.service_kind = 'Stateless'  # type: str


class StatelessServiceInstanceHealth(ReplicaHealth):
    """Represents the health of the stateless service instance.
Contains the instance aggregated health state, the health events and the unhealthy evaluations.

    All required parameters must be populated in order to send to Azure.

    :ivar aggregated_health_state: The HealthState representing the aggregated health state of the
     entity computed by Health Manager.
     The health evaluation of the entity reflects all events reported on the entity and its
     children (if any).
     The aggregation is done by applying the desired health policy. Possible values include:
     "Invalid", "Ok", "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar health_events: The list of health events reported on the entity.
    :vartype health_events: list[~azure.servicefabric.models.HealthEvent]
    :ivar unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
     health state was returned by Health Manager.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    :ivar health_statistics: Shows the health statistics for all children types of the queried
     entity.
    :vartype health_statistics: ~azure.servicefabric.models.HealthStatistics
    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar partition_id: Id of the partition to which this replica belongs.
    :vartype partition_id: str
    :ivar instance_id: Id of a stateless service instance. InstanceId is used by Service Fabric to
     uniquely identify an instance of a partition of a stateless service. It is unique within a
     partition and does not change for the lifetime of the instance. If the instance has failed over
     on the same or different node, it will get a different value for the InstanceId.
    :vartype instance_id: str
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'health_events': {'key': 'HealthEvents', 'type': '[HealthEvent]'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
        'health_statistics': {'key': 'HealthStatistics', 'type': 'HealthStatistics'},
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'instance_id': {'key': 'InstanceId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The HealthState representing the aggregated health state of
         the entity computed by Health Manager.
         The health evaluation of the entity reflects all events reported on the entity and its
         children (if any).
         The aggregation is done by applying the desired health policy. Possible values include:
         "Invalid", "Ok", "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword health_events: The list of health events reported on the entity.
        :paramtype health_events: list[~azure.servicefabric.models.HealthEvent]
        :keyword unhealthy_evaluations: The unhealthy evaluations that show why the current aggregated
         health state was returned by Health Manager.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        :keyword health_statistics: Shows the health statistics for all children types of the queried
         entity.
        :paramtype health_statistics: ~azure.servicefabric.models.HealthStatistics
        :keyword partition_id: Id of the partition to which this replica belongs.
        :paramtype partition_id: str
        :keyword instance_id: Id of a stateless service instance. InstanceId is used by Service Fabric
         to uniquely identify an instance of a partition of a stateless service. It is unique within a
         partition and does not change for the lifetime of the instance. If the instance has failed over
         on the same or different node, it will get a different value for the InstanceId.
        :paramtype instance_id: str
        """
        super(StatelessServiceInstanceHealth, self).__init__(**kwargs)
        self.service_kind = 'Stateless'  # type: str
        self.instance_id = kwargs.get('instance_id', None)


class StatelessServiceInstanceHealthState(ReplicaHealthState):
    """Represents the health state of the stateless service instance, which contains the instance ID and the aggregated health state.

    All required parameters must be populated in order to send to Azure.

    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar partition_id: The ID of the partition to which this replica belongs.
    :vartype partition_id: str
    :ivar replica_id: Id of the stateless service instance on the wire this field is called
     ReplicaId.
    :vartype replica_id: str
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'replica_id': {'key': 'ReplicaId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword partition_id: The ID of the partition to which this replica belongs.
        :paramtype partition_id: str
        :keyword replica_id: Id of the stateless service instance on the wire this field is called
         ReplicaId.
        :paramtype replica_id: str
        """
        super(StatelessServiceInstanceHealthState, self).__init__(**kwargs)
        self.service_kind = 'Stateless'  # type: str
        self.replica_id = kwargs.get('replica_id', None)


class StatelessServiceInstanceInfo(ReplicaInfo):
    """Represents a stateless service instance. This includes information about the identity, status, health, node name, uptime, and other details about the instance.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar replica_status: The status of a replica of a service. Possible values include: "Invalid",
     "InBuild", "Standby", "Ready", "Down", "Dropped".
    :vartype replica_status: str or ~azure.servicefabric.models.ReplicaStatus
    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar node_name: The name of a Service Fabric node.
    :vartype node_name: str
    :ivar address: The address the replica is listening on.
    :vartype address: str
    :ivar last_in_build_duration_in_seconds: The last in build duration of the replica in seconds.
    :vartype last_in_build_duration_in_seconds: str
    :ivar instance_id: Id of a stateless service instance. InstanceId is used by Service Fabric to
     uniquely identify an instance of a partition of a stateless service. It is unique within a
     partition and does not change for the lifetime of the instance. If the instance has failed over
     on the same or different node, it will get a different value for the InstanceId.
    :vartype instance_id: str
    """

    _validation = {
        'service_kind': {'required': True},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'replica_status': {'key': 'ReplicaStatus', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'node_name': {'key': 'NodeName', 'type': 'str'},
        'address': {'key': 'Address', 'type': 'str'},
        'last_in_build_duration_in_seconds': {'key': 'LastInBuildDurationInSeconds', 'type': 'str'},
        'instance_id': {'key': 'InstanceId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword replica_status: The status of a replica of a service. Possible values include:
         "Invalid", "InBuild", "Standby", "Ready", "Down", "Dropped".
        :paramtype replica_status: str or ~azure.servicefabric.models.ReplicaStatus
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword node_name: The name of a Service Fabric node.
        :paramtype node_name: str
        :keyword address: The address the replica is listening on.
        :paramtype address: str
        :keyword last_in_build_duration_in_seconds: The last in build duration of the replica in
         seconds.
        :paramtype last_in_build_duration_in_seconds: str
        :keyword instance_id: Id of a stateless service instance. InstanceId is used by Service Fabric
         to uniquely identify an instance of a partition of a stateless service. It is unique within a
         partition and does not change for the lifetime of the instance. If the instance has failed over
         on the same or different node, it will get a different value for the InstanceId.
        :paramtype instance_id: str
        """
        super(StatelessServiceInstanceInfo, self).__init__(**kwargs)
        self.service_kind = 'Stateless'  # type: str
        self.instance_id = kwargs.get('instance_id', None)


class StatelessServicePartitionInfo(ServicePartitionInfo):
    """Information about a partition of a stateless Service Fabric service.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The kind of service (Stateless or Stateful).Constant filled by
     server. Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar health_state: The health state of a Service Fabric entity such as Cluster, Node,
     Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype health_state: str or ~azure.servicefabric.models.HealthState
    :ivar partition_status: The status of the service fabric service partition. Possible values
     include: "Invalid", "Ready", "NotReady", "InQuorumLoss", "Reconfiguring", "Deleting".
    :vartype partition_status: str or ~azure.servicefabric.models.ServicePartitionStatus
    :ivar partition_information: Information about the partition identity, partitioning scheme and
     keys supported by it.
    :vartype partition_information: ~azure.servicefabric.models.PartitionInformation
    :ivar instance_count: Number of instances of this partition.
    :vartype instance_count: long
    :ivar min_instance_count: MinInstanceCount is the minimum number of instances that must be up
     to meet the EnsureAvailability safety check during operations like upgrade or deactivate node.
     The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
     InstanceCount) ).
     Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted
     into the number of nodes on which the instances are allowed to be placed according to the
     placement constraints on the service.
    :vartype min_instance_count: int
    :ivar min_instance_percentage: MinInstancePercentage is the minimum percentage of InstanceCount
     that must be up to meet the EnsureAvailability safety check during operations like upgrade or
     deactivate node.
     The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
     InstanceCount) ).
     Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first
     converted into the number of nodes on which the instances are allowed to be placed according to
     the placement constraints on the service.
    :vartype min_instance_percentage: int
    """

    _validation = {
        'service_kind': {'required': True},
        'min_instance_count': {'minimum': 1},
        'min_instance_percentage': {'maximum': 100, 'minimum': 0},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'health_state': {'key': 'HealthState', 'type': 'str'},
        'partition_status': {'key': 'PartitionStatus', 'type': 'str'},
        'partition_information': {'key': 'PartitionInformation', 'type': 'PartitionInformation'},
        'instance_count': {'key': 'InstanceCount', 'type': 'long'},
        'min_instance_count': {'key': 'MinInstanceCount', 'type': 'int'},
        'min_instance_percentage': {'key': 'MinInstancePercentage', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword health_state: The health state of a Service Fabric entity such as Cluster, Node,
         Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype health_state: str or ~azure.servicefabric.models.HealthState
        :keyword partition_status: The status of the service fabric service partition. Possible values
         include: "Invalid", "Ready", "NotReady", "InQuorumLoss", "Reconfiguring", "Deleting".
        :paramtype partition_status: str or ~azure.servicefabric.models.ServicePartitionStatus
        :keyword partition_information: Information about the partition identity, partitioning scheme
         and keys supported by it.
        :paramtype partition_information: ~azure.servicefabric.models.PartitionInformation
        :keyword instance_count: Number of instances of this partition.
        :paramtype instance_count: long
        :keyword min_instance_count: MinInstanceCount is the minimum number of instances that must be
         up to meet the EnsureAvailability safety check during operations like upgrade or deactivate
         node.
         The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
         InstanceCount) ).
         Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted
         into the number of nodes on which the instances are allowed to be placed according to the
         placement constraints on the service.
        :paramtype min_instance_count: int
        :keyword min_instance_percentage: MinInstancePercentage is the minimum percentage of
         InstanceCount that must be up to meet the EnsureAvailability safety check during operations
         like upgrade or deactivate node.
         The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
         InstanceCount) ).
         Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first
         converted into the number of nodes on which the instances are allowed to be placed according to
         the placement constraints on the service.
        :paramtype min_instance_percentage: int
        """
        super(StatelessServicePartitionInfo, self).__init__(**kwargs)
        self.service_kind = 'Stateless'  # type: str
        self.instance_count = kwargs.get('instance_count', None)
        self.min_instance_count = kwargs.get('min_instance_count', 1)
        self.min_instance_percentage = kwargs.get('min_instance_percentage', 0)


class StatelessServiceTypeDescription(ServiceTypeDescription):
    """Describes a stateless service type defined in the service manifest of a provisioned application type.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of service (Stateless or Stateful).Constant filled by server.
     Possible values include: "Invalid", "Stateless", "Stateful".
    :vartype kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar is_stateful: Indicates whether the service type is a stateful service type or a stateless
     service type. This property is true if the service type is a stateful service type, false
     otherwise.
    :vartype is_stateful: bool
    :ivar service_type_name: Name of the service type as specified in the service manifest.
    :vartype service_type_name: str
    :ivar placement_constraints: The placement constraint to be used when instantiating this
     service in a Service Fabric cluster.
    :vartype placement_constraints: str
    :ivar load_metrics: The service load metrics is given as an array of
     ServiceLoadMetricDescription objects.
    :vartype load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: List of service placement policy descriptions.
    :vartype service_placement_policies:
     list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar extensions: List of service type extensions.
    :vartype extensions: list[~azure.servicefabric.models.ServiceTypeExtensionDescription]
    :ivar use_implicit_host: A flag indicating if this type is not implemented and hosted by a user
     service process, but is implicitly hosted by a system created process. This value is true for
     services using the guest executable services, false otherwise.
    :vartype use_implicit_host: bool
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'is_stateful': {'key': 'IsStateful', 'type': 'bool'},
        'service_type_name': {'key': 'ServiceTypeName', 'type': 'str'},
        'placement_constraints': {'key': 'PlacementConstraints', 'type': 'str'},
        'load_metrics': {'key': 'LoadMetrics', 'type': '[ServiceLoadMetricDescription]'},
        'service_placement_policies': {'key': 'ServicePlacementPolicies', 'type': '[ServicePlacementPolicyDescription]'},
        'extensions': {'key': 'Extensions', 'type': '[ServiceTypeExtensionDescription]'},
        'use_implicit_host': {'key': 'UseImplicitHost', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword is_stateful: Indicates whether the service type is a stateful service type or a
         stateless service type. This property is true if the service type is a stateful service type,
         false otherwise.
        :paramtype is_stateful: bool
        :keyword service_type_name: Name of the service type as specified in the service manifest.
        :paramtype service_type_name: str
        :keyword placement_constraints: The placement constraint to be used when instantiating this
         service in a Service Fabric cluster.
        :paramtype placement_constraints: str
        :keyword load_metrics: The service load metrics is given as an array of
         ServiceLoadMetricDescription objects.
        :paramtype load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
        :keyword service_placement_policies: List of service placement policy descriptions.
        :paramtype service_placement_policies:
         list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
        :keyword extensions: List of service type extensions.
        :paramtype extensions: list[~azure.servicefabric.models.ServiceTypeExtensionDescription]
        :keyword use_implicit_host: A flag indicating if this type is not implemented and hosted by a
         user service process, but is implicitly hosted by a system created process. This value is true
         for services using the guest executable services, false otherwise.
        :paramtype use_implicit_host: bool
        """
        super(StatelessServiceTypeDescription, self).__init__(**kwargs)
        self.kind = 'Stateless'  # type: str
        self.use_implicit_host = kwargs.get('use_implicit_host', None)


class StatelessServiceUpdateDescription(ServiceUpdateDescription):
    """Describes an update for a stateless service.

    All required parameters must be populated in order to send to Azure.

    :ivar service_kind: Required. The service kind.Constant filled by server. Possible values
     include: "Invalid", "Stateless", "Stateful".
    :vartype service_kind: str or ~azure.servicefabric.models.ServiceKind
    :ivar flags: Flags indicating whether other properties are set. Each of the associated
     properties corresponds to a flag, specified below, which, if set, indicate that the property is
     specified.
     This property can be a combination of those flags obtained using bitwise 'OR' operator.
     For example, if the provided value is 6 then the flags for ReplicaRestartWaitDuration (2) and
     QuorumLossWaitDuration (4) are set.
    
    
     * None - Does not indicate any other properties are set. The value is zero.
     * TargetReplicaSetSize/InstanceCount - Indicates whether the TargetReplicaSetSize property
     (for Stateful services) or the InstanceCount property (for Stateless services) is set. The
     value is 1.
     * ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is set. The
     value is  2.
     * QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is set. The value is
     4.
     * StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is set. The
     value is 8.
     * MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The value is 16.
     * PlacementConstraints - Indicates the PlacementConstraints property is set. The value is 32.
     * PlacementPolicyList - Indicates the ServicePlacementPolicies property is set. The value is
     64.
     * Correlation - Indicates the CorrelationScheme property is set. The value is 128.
     * Metrics - Indicates the ServiceLoadMetrics property is set. The value is 256.
     * DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value is 512.
     * ScalingPolicy - Indicates the ScalingPolicies property is set. The value is 1024.
     * ServicePlacementTimeLimit - Indicates the ServicePlacementTimeLimit property is set. The
     value is 2048.
     * MinInstanceCount - Indicates the MinInstanceCount property is set. The value is 4096.
     * MinInstancePercentage - Indicates the MinInstancePercentage property is set. The value is
     8192.
     * InstanceCloseDelayDuration - Indicates the InstanceCloseDelayDuration property is set. The
     value is 16384.
     * InstanceRestartWaitDuration - Indicates the InstanceCloseDelayDuration property is set. The
     value is 32768.
     * DropSourceReplicaOnMove - Indicates the DropSourceReplicaOnMove property is set. The value
     is 65536.
     * ServiceDnsName - Indicates the ServiceDnsName property is set. The value is 131072.
     * TagsForPlacement - Indicates the TagsForPlacement property is set. The value is 1048576.
     * TagsForRunning - Indicates the TagsForRunning property is set. The value is 2097152.
    :vartype flags: str
    :ivar placement_constraints: The placement constraints as a string. Placement constraints are
     boolean expressions on node properties and allow for restricting a service to particular nodes
     based on the service requirements. For example, to place a service on nodes where NodeType is
     blue specify the following: "NodeColor == blue)".
    :vartype placement_constraints: str
    :ivar correlation_scheme: The correlation scheme.
    :vartype correlation_scheme: list[~azure.servicefabric.models.ServiceCorrelationDescription]
    :ivar load_metrics: The service load metrics.
    :vartype load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
    :ivar service_placement_policies: The service placement policies.
    :vartype service_placement_policies:
     list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
    :ivar default_move_cost: The move cost for the service. Possible values include: "Zero", "Low",
     "Medium", "High", "VeryHigh".
    :vartype default_move_cost: str or ~azure.servicefabric.models.MoveCost
    :ivar scaling_policies: Scaling policies for this service.
    :vartype scaling_policies: list[~azure.servicefabric.models.ScalingPolicyDescription]
    :ivar service_dns_name: The DNS name of the service.
    :vartype service_dns_name: str
    :ivar tags_for_placement: Tags for placement of this service.
    :vartype tags_for_placement: ~azure.servicefabric.models.NodeTagsDescription
    :ivar tags_for_running: Tags for running of this service.
    :vartype tags_for_running: ~azure.servicefabric.models.NodeTagsDescription
    :ivar instance_count: The instance count.
    :vartype instance_count: int
    :ivar min_instance_count: MinInstanceCount is the minimum number of instances that must be up
     to meet the EnsureAvailability safety check during operations like upgrade or deactivate node.
     The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
     InstanceCount) ).
     Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted
     into the number of nodes on which the instances are allowed to be placed according to the
     placement constraints on the service.
    :vartype min_instance_count: int
    :ivar min_instance_percentage: MinInstancePercentage is the minimum percentage of InstanceCount
     that must be up to meet the EnsureAvailability safety check during operations like upgrade or
     deactivate node.
     The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
     InstanceCount) ).
     Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first
     converted into the number of nodes on which the instances are allowed to be placed according to
     the placement constraints on the service.
    :vartype min_instance_percentage: int
    :ivar instance_close_delay_duration_seconds: Duration in seconds, to wait before a stateless
     instance is closed, to allow the active requests to drain gracefully. This would be effective
     when the instance is closing during the application/cluster upgrade and disabling node.
     The endpoint exposed on this instance is removed prior to starting the delay, which prevents
     new connections to this instance.
     In addition, clients that have subscribed to service endpoint change
     events(https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.servicemanagementclient.registerservicenotificationfilterasync),
     can do
     the following upon receiving the endpoint removal notification:
    
     .. code-block::
    
        - Stop sending new requests to this instance.
        - Close existing connections after in-flight requests have completed.
        - Connect to a different instance of the service partition for future requests.
    :vartype instance_close_delay_duration_seconds: str
    :ivar instance_lifecycle_description: Defines how instances of this service will behave during
     their lifecycle.
    :vartype instance_lifecycle_description:
     ~azure.servicefabric.models.InstanceLifecycleDescription
    :ivar instance_restart_wait_duration_seconds: When a stateless instance goes down, this timer
     starts. When it expires Service Fabric will create a new instance on any node in the cluster.
     This configuration is to reduce unnecessary creation of a new instance in situations where the
     instance going down is likely to recover in a short time. For example, during an upgrade.
     The default value is 0, which indicates that when stateless instance goes down, Service Fabric
     will immediately start building its replacement.
    :vartype instance_restart_wait_duration_seconds: str
    """

    _validation = {
        'service_kind': {'required': True},
        'instance_count': {'minimum': -1},
        'min_instance_count': {'minimum': 1},
        'min_instance_percentage': {'maximum': 100, 'minimum': 0},
    }

    _attribute_map = {
        'service_kind': {'key': 'ServiceKind', 'type': 'str'},
        'flags': {'key': 'Flags', 'type': 'str'},
        'placement_constraints': {'key': 'PlacementConstraints', 'type': 'str'},
        'correlation_scheme': {'key': 'CorrelationScheme', 'type': '[ServiceCorrelationDescription]'},
        'load_metrics': {'key': 'LoadMetrics', 'type': '[ServiceLoadMetricDescription]'},
        'service_placement_policies': {'key': 'ServicePlacementPolicies', 'type': '[ServicePlacementPolicyDescription]'},
        'default_move_cost': {'key': 'DefaultMoveCost', 'type': 'str'},
        'scaling_policies': {'key': 'ScalingPolicies', 'type': '[ScalingPolicyDescription]'},
        'service_dns_name': {'key': 'ServiceDnsName', 'type': 'str'},
        'tags_for_placement': {'key': 'TagsForPlacement', 'type': 'NodeTagsDescription'},
        'tags_for_running': {'key': 'TagsForRunning', 'type': 'NodeTagsDescription'},
        'instance_count': {'key': 'InstanceCount', 'type': 'int'},
        'min_instance_count': {'key': 'MinInstanceCount', 'type': 'int'},
        'min_instance_percentage': {'key': 'MinInstancePercentage', 'type': 'int'},
        'instance_close_delay_duration_seconds': {'key': 'InstanceCloseDelayDurationSeconds', 'type': 'str'},
        'instance_lifecycle_description': {'key': 'InstanceLifecycleDescription', 'type': 'InstanceLifecycleDescription'},
        'instance_restart_wait_duration_seconds': {'key': 'InstanceRestartWaitDurationSeconds', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword flags: Flags indicating whether other properties are set. Each of the associated
         properties corresponds to a flag, specified below, which, if set, indicate that the property is
         specified.
         This property can be a combination of those flags obtained using bitwise 'OR' operator.
         For example, if the provided value is 6 then the flags for ReplicaRestartWaitDuration (2) and
         QuorumLossWaitDuration (4) are set.
        
        
         * None - Does not indicate any other properties are set. The value is zero.
         * TargetReplicaSetSize/InstanceCount - Indicates whether the TargetReplicaSetSize property
         (for Stateful services) or the InstanceCount property (for Stateless services) is set. The
         value is 1.
         * ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is set. The
         value is  2.
         * QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is set. The value is
         4.
         * StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is set. The
         value is 8.
         * MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The value is 16.
         * PlacementConstraints - Indicates the PlacementConstraints property is set. The value is 32.
         * PlacementPolicyList - Indicates the ServicePlacementPolicies property is set. The value is
         64.
         * Correlation - Indicates the CorrelationScheme property is set. The value is 128.
         * Metrics - Indicates the ServiceLoadMetrics property is set. The value is 256.
         * DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value is 512.
         * ScalingPolicy - Indicates the ScalingPolicies property is set. The value is 1024.
         * ServicePlacementTimeLimit - Indicates the ServicePlacementTimeLimit property is set. The
         value is 2048.
         * MinInstanceCount - Indicates the MinInstanceCount property is set. The value is 4096.
         * MinInstancePercentage - Indicates the MinInstancePercentage property is set. The value is
         8192.
         * InstanceCloseDelayDuration - Indicates the InstanceCloseDelayDuration property is set. The
         value is 16384.
         * InstanceRestartWaitDuration - Indicates the InstanceCloseDelayDuration property is set. The
         value is 32768.
         * DropSourceReplicaOnMove - Indicates the DropSourceReplicaOnMove property is set. The value
         is 65536.
         * ServiceDnsName - Indicates the ServiceDnsName property is set. The value is 131072.
         * TagsForPlacement - Indicates the TagsForPlacement property is set. The value is 1048576.
         * TagsForRunning - Indicates the TagsForRunning property is set. The value is 2097152.
        :paramtype flags: str
        :keyword placement_constraints: The placement constraints as a string. Placement constraints
         are boolean expressions on node properties and allow for restricting a service to particular
         nodes based on the service requirements. For example, to place a service on nodes where
         NodeType is blue specify the following: "NodeColor == blue)".
        :paramtype placement_constraints: str
        :keyword correlation_scheme: The correlation scheme.
        :paramtype correlation_scheme: list[~azure.servicefabric.models.ServiceCorrelationDescription]
        :keyword load_metrics: The service load metrics.
        :paramtype load_metrics: list[~azure.servicefabric.models.ServiceLoadMetricDescription]
        :keyword service_placement_policies: The service placement policies.
        :paramtype service_placement_policies:
         list[~azure.servicefabric.models.ServicePlacementPolicyDescription]
        :keyword default_move_cost: The move cost for the service. Possible values include: "Zero",
         "Low", "Medium", "High", "VeryHigh".
        :paramtype default_move_cost: str or ~azure.servicefabric.models.MoveCost
        :keyword scaling_policies: Scaling policies for this service.
        :paramtype scaling_policies: list[~azure.servicefabric.models.ScalingPolicyDescription]
        :keyword service_dns_name: The DNS name of the service.
        :paramtype service_dns_name: str
        :keyword tags_for_placement: Tags for placement of this service.
        :paramtype tags_for_placement: ~azure.servicefabric.models.NodeTagsDescription
        :keyword tags_for_running: Tags for running of this service.
        :paramtype tags_for_running: ~azure.servicefabric.models.NodeTagsDescription
        :keyword instance_count: The instance count.
        :paramtype instance_count: int
        :keyword min_instance_count: MinInstanceCount is the minimum number of instances that must be
         up to meet the EnsureAvailability safety check during operations like upgrade or deactivate
         node.
         The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
         InstanceCount) ).
         Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted
         into the number of nodes on which the instances are allowed to be placed according to the
         placement constraints on the service.
        :paramtype min_instance_count: int
        :keyword min_instance_percentage: MinInstancePercentage is the minimum percentage of
         InstanceCount that must be up to meet the EnsureAvailability safety check during operations
         like upgrade or deactivate node.
         The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
         InstanceCount) ).
         Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first
         converted into the number of nodes on which the instances are allowed to be placed according to
         the placement constraints on the service.
        :paramtype min_instance_percentage: int
        :keyword instance_close_delay_duration_seconds: Duration in seconds, to wait before a stateless
         instance is closed, to allow the active requests to drain gracefully. This would be effective
         when the instance is closing during the application/cluster upgrade and disabling node.
         The endpoint exposed on this instance is removed prior to starting the delay, which prevents
         new connections to this instance.
         In addition, clients that have subscribed to service endpoint change
         events(https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.servicemanagementclient.registerservicenotificationfilterasync),
         can do
         the following upon receiving the endpoint removal notification:
        
         .. code-block::
        
            - Stop sending new requests to this instance.
            - Close existing connections after in-flight requests have completed.
            - Connect to a different instance of the service partition for future requests.
        :paramtype instance_close_delay_duration_seconds: str
        :keyword instance_lifecycle_description: Defines how instances of this service will behave
         during their lifecycle.
        :paramtype instance_lifecycle_description:
         ~azure.servicefabric.models.InstanceLifecycleDescription
        :keyword instance_restart_wait_duration_seconds: When a stateless instance goes down, this
         timer starts. When it expires Service Fabric will create a new instance on any node in the
         cluster.
         This configuration is to reduce unnecessary creation of a new instance in situations where the
         instance going down is likely to recover in a short time. For example, during an upgrade.
         The default value is 0, which indicates that when stateless instance goes down, Service Fabric
         will immediately start building its replacement.
        :paramtype instance_restart_wait_duration_seconds: str
        """
        super(StatelessServiceUpdateDescription, self).__init__(**kwargs)
        self.service_kind = 'Stateless'  # type: str
        self.instance_count = kwargs.get('instance_count', None)
        self.min_instance_count = kwargs.get('min_instance_count', 1)
        self.min_instance_percentage = kwargs.get('min_instance_percentage', 0)
        self.instance_close_delay_duration_seconds = kwargs.get('instance_close_delay_duration_seconds', None)
        self.instance_lifecycle_description = kwargs.get('instance_lifecycle_description', None)
        self.instance_restart_wait_duration_seconds = kwargs.get('instance_restart_wait_duration_seconds', None)


class StoppedChaosEvent(ChaosEvent):
    """Describes a Chaos event that gets generated when Chaos stops because either the user issued a stop or the time to run was up.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of Chaos event.Constant filled by server. Possible values
     include: "Invalid", "Started", "ExecutingFaults", "Waiting", "ValidationFailed", "TestError",
     "Stopped".
    :vartype kind: str or ~azure.servicefabric.models.ChaosEventKind
    :ivar time_stamp_utc: Required. The UTC timestamp when this Chaos event was generated.
    :vartype time_stamp_utc: ~datetime.datetime
    :ivar reason: Describes why Chaos stopped. Chaos can stop because of StopChaos API call or the
     timeToRun provided in ChaosParameters is over.
    :vartype reason: str
    """

    _validation = {
        'kind': {'required': True},
        'time_stamp_utc': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'time_stamp_utc': {'key': 'TimeStampUtc', 'type': 'iso-8601'},
        'reason': {'key': 'Reason', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword time_stamp_utc: Required. The UTC timestamp when this Chaos event was generated.
        :paramtype time_stamp_utc: ~datetime.datetime
        :keyword reason: Describes why Chaos stopped. Chaos can stop because of StopChaos API call or
         the timeToRun provided in ChaosParameters is over.
        :paramtype reason: str
        """
        super(StoppedChaosEvent, self).__init__(**kwargs)
        self.kind = 'Stopped'  # type: str
        self.reason = kwargs.get('reason', None)


class StringPropertyValue(PropertyValue):
    """Describes a Service Fabric property value of type String.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property, determined by the type of data. Following are the
     possible values.Constant filled by server. Possible values include: "Invalid", "Binary",
     "Int64", "Double", "String", "Guid".
    :vartype kind: str or ~azure.servicefabric.models.PropertyValueKind
    :ivar data: Required. The data of the property value.
    :vartype data: str
    """

    _validation = {
        'kind': {'required': True},
        'data': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'data': {'key': 'Data', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword data: Required. The data of the property value.
        :paramtype data: str
        """
        super(StringPropertyValue, self).__init__(**kwargs)
        self.kind = 'String'  # type: str
        self.data = kwargs['data']


class SuccessfulPropertyBatchInfo(PropertyBatchInfo):
    """Derived from PropertyBatchInfo. Represents the property batch succeeding. Contains the results of any "Get" operations in the batch.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of property batch info, determined by the results of a property
     batch. The following are the possible values.Constant filled by server. Possible values
     include: "Invalid", "Successful", "Failed".
    :vartype kind: str or ~azure.servicefabric.models.PropertyBatchInfoKind
    :ivar properties: A map containing the properties that were requested through any "Get"
     property batch operations. The key represents the index of the "Get" operation in the original
     request, in string form. The value is the property. If a property is not found, it will not be
     in the map.
    :vartype properties: dict[str, ~azure.servicefabric.models.PropertyInfo]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'properties': {'key': 'Properties', 'type': '{PropertyInfo}'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword properties: A map containing the properties that were requested through any "Get"
         property batch operations. The key represents the index of the "Get" operation in the original
         request, in string form. The value is the property. If a property is not found, it will not be
         in the map.
        :paramtype properties: dict[str, ~azure.servicefabric.models.PropertyInfo]
        """
        super(SuccessfulPropertyBatchInfo, self).__init__(**kwargs)
        self.kind = 'Successful'  # type: str
        self.properties = kwargs.get('properties', None)


class SystemApplicationHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for the fabric:/System application, containing information about the data and the algorithm used by health store to evaluate health. The evaluation is returned only when the aggregated health state of the cluster is either Error or Warning.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the current aggregated
     health state of the system application. The types of the unhealthy evaluations can be
     DeployedApplicationsHealthEvaluation, ServicesHealthEvaluation or EventHealthEvaluation.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the current
         aggregated health state of the system application. The types of the unhealthy evaluations can
         be DeployedApplicationsHealthEvaluation, ServicesHealthEvaluation or EventHealthEvaluation.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(SystemApplicationHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'SystemApplication'  # type: str
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class TcpConfig(msrest.serialization.Model):
    """Describes the tcp configuration for external connectivity for this network.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. tcp gateway config name.
    :vartype name: str
    :ivar port: Required. Specifies the port at which the service endpoint below needs to be
     exposed.
    :vartype port: int
    :ivar destination: Required. Describes destination endpoint for routing traffic.
    :vartype destination: ~azure.servicefabric.models.GatewayDestination
    """

    _validation = {
        'name': {'required': True},
        'port': {'required': True},
        'destination': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'port': {'key': 'port', 'type': 'int'},
        'destination': {'key': 'destination', 'type': 'GatewayDestination'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. tcp gateway config name.
        :paramtype name: str
        :keyword port: Required. Specifies the port at which the service endpoint below needs to be
         exposed.
        :paramtype port: int
        :keyword destination: Required. Describes destination endpoint for routing traffic.
        :paramtype destination: ~azure.servicefabric.models.GatewayDestination
        """
        super(TcpConfig, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.port = kwargs['port']
        self.destination = kwargs['destination']


class TestErrorChaosEvent(ChaosEvent):
    """Describes a Chaos event that gets generated when an unexpected event occurs in the Chaos engine.
For example, due to the cluster snapshot being inconsistent, while faulting an entity, Chaos found that the entity was already faulted -- which would be an unexpected event.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of Chaos event.Constant filled by server. Possible values
     include: "Invalid", "Started", "ExecutingFaults", "Waiting", "ValidationFailed", "TestError",
     "Stopped".
    :vartype kind: str or ~azure.servicefabric.models.ChaosEventKind
    :ivar time_stamp_utc: Required. The UTC timestamp when this Chaos event was generated.
    :vartype time_stamp_utc: ~datetime.datetime
    :ivar reason: Describes why TestErrorChaosEvent was generated. For example, Chaos tries to
     fault a partition but finds that the partition is no longer fault tolerant, then a
     TestErrorEvent gets generated with the reason stating that the partition is not fault tolerant.
    :vartype reason: str
    """

    _validation = {
        'kind': {'required': True},
        'time_stamp_utc': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'time_stamp_utc': {'key': 'TimeStampUtc', 'type': 'iso-8601'},
        'reason': {'key': 'Reason', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword time_stamp_utc: Required. The UTC timestamp when this Chaos event was generated.
        :paramtype time_stamp_utc: ~datetime.datetime
        :keyword reason: Describes why TestErrorChaosEvent was generated. For example, Chaos tries to
         fault a partition but finds that the partition is no longer fault tolerant, then a
         TestErrorEvent gets generated with the reason stating that the partition is not fault tolerant.
        :paramtype reason: str
        """
        super(TestErrorChaosEvent, self).__init__(**kwargs)
        self.kind = 'TestError'  # type: str
        self.reason = kwargs.get('reason', None)


class TimeBasedBackupScheduleDescription(BackupScheduleDescription):
    """Describes the time based backup schedule.

    All required parameters must be populated in order to send to Azure.

    :ivar schedule_kind: Required. The kind of backup schedule, time based or frequency
     based.Constant filled by server. Possible values include: "Invalid", "TimeBased",
     "FrequencyBased".
    :vartype schedule_kind: str or ~azure.servicefabric.models.BackupScheduleKind
    :ivar schedule_frequency_type: Required. Describes the frequency with which to run the time
     based backup schedule. Possible values include: "Invalid", "Daily", "Weekly".
    :vartype schedule_frequency_type: str or
     ~azure.servicefabric.models.BackupScheduleFrequencyType
    :ivar run_days: List of days of a week when to trigger the periodic backup. This is valid only
     when the backup schedule frequency type is weekly.
    :vartype run_days: list[str or ~azure.servicefabric.models.DayOfWeek]
    :ivar run_times: Required. Represents the list of exact time during the day in ISO8601 format.
     Like '19:00:00' will represent '7PM' during the day. Date specified along with time will be
     ignored.
    :vartype run_times: list[~datetime.datetime]
    """

    _validation = {
        'schedule_kind': {'required': True},
        'schedule_frequency_type': {'required': True},
        'run_times': {'required': True},
    }

    _attribute_map = {
        'schedule_kind': {'key': 'ScheduleKind', 'type': 'str'},
        'schedule_frequency_type': {'key': 'ScheduleFrequencyType', 'type': 'str'},
        'run_days': {'key': 'RunDays', 'type': '[str]'},
        'run_times': {'key': 'RunTimes', 'type': '[iso-8601]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword schedule_frequency_type: Required. Describes the frequency with which to run the time
         based backup schedule. Possible values include: "Invalid", "Daily", "Weekly".
        :paramtype schedule_frequency_type: str or
         ~azure.servicefabric.models.BackupScheduleFrequencyType
        :keyword run_days: List of days of a week when to trigger the periodic backup. This is valid
         only when the backup schedule frequency type is weekly.
        :paramtype run_days: list[str or ~azure.servicefabric.models.DayOfWeek]
        :keyword run_times: Required. Represents the list of exact time during the day in ISO8601
         format. Like '19:00:00' will represent '7PM' during the day. Date specified along with time
         will be ignored.
        :paramtype run_times: list[~datetime.datetime]
        """
        super(TimeBasedBackupScheduleDescription, self).__init__(**kwargs)
        self.schedule_kind = 'TimeBased'  # type: str
        self.schedule_frequency_type = kwargs['schedule_frequency_type']
        self.run_days = kwargs.get('run_days', None)
        self.run_times = kwargs['run_times']


class TimeOfDay(msrest.serialization.Model):
    """Defines an hour and minute of the day specified in 24 hour time.

    :ivar hour: Represents the hour of the day. Value must be between 0 and 23 inclusive.
    :vartype hour: int
    :ivar minute: Represents the minute of the hour. Value must be between 0 to 59 inclusive.
    :vartype minute: int
    """

    _validation = {
        'hour': {'maximum': 23, 'minimum': 0},
        'minute': {'maximum': 59, 'minimum': 0},
    }

    _attribute_map = {
        'hour': {'key': 'Hour', 'type': 'int'},
        'minute': {'key': 'Minute', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword hour: Represents the hour of the day. Value must be between 0 and 23 inclusive.
        :paramtype hour: int
        :keyword minute: Represents the minute of the hour. Value must be between 0 to 59 inclusive.
        :paramtype minute: int
        """
        super(TimeOfDay, self).__init__(**kwargs)
        self.hour = kwargs.get('hour', None)
        self.minute = kwargs.get('minute', None)


class TimeRange(msrest.serialization.Model):
    """Defines a time range in a 24 hour day specified by a start and end time.

    :ivar start_time: Defines an hour and minute of the day specified in 24 hour time.
    :vartype start_time: ~azure.servicefabric.models.TimeOfDay
    :ivar end_time: Defines an hour and minute of the day specified in 24 hour time.
    :vartype end_time: ~azure.servicefabric.models.TimeOfDay
    """

    _attribute_map = {
        'start_time': {'key': 'StartTime', 'type': 'TimeOfDay'},
        'end_time': {'key': 'EndTime', 'type': 'TimeOfDay'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword start_time: Defines an hour and minute of the day specified in 24 hour time.
        :paramtype start_time: ~azure.servicefabric.models.TimeOfDay
        :keyword end_time: Defines an hour and minute of the day specified in 24 hour time.
        :paramtype end_time: ~azure.servicefabric.models.TimeOfDay
        """
        super(TimeRange, self).__init__(**kwargs)
        self.start_time = kwargs.get('start_time', None)
        self.end_time = kwargs.get('end_time', None)


class UniformInt64RangePartitionSchemeDescription(PartitionSchemeDescription):
    """Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.

    All required parameters must be populated in order to send to Azure.

    :ivar partition_scheme: Required. Specifies how the service is partitioned.Constant filled by
     server. Possible values include: "Invalid", "Singleton", "UniformInt64Range", "Named".
    :vartype partition_scheme: str or ~azure.servicefabric.models.PartitionScheme
    :ivar count: Required. The number of partitions.
    :vartype count: int
    :ivar low_key: Required. String indicating the lower bound of the partition key range that
     should be split between the partitions.
    :vartype low_key: str
    :ivar high_key: Required. String indicating the upper bound of the partition key range that
     should be split between the partitions.
    :vartype high_key: str
    """

    _validation = {
        'partition_scheme': {'required': True},
        'count': {'required': True},
        'low_key': {'required': True},
        'high_key': {'required': True},
    }

    _attribute_map = {
        'partition_scheme': {'key': 'PartitionScheme', 'type': 'str'},
        'count': {'key': 'Count', 'type': 'int'},
        'low_key': {'key': 'LowKey', 'type': 'str'},
        'high_key': {'key': 'HighKey', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword count: Required. The number of partitions.
        :paramtype count: int
        :keyword low_key: Required. String indicating the lower bound of the partition key range that
         should be split between the partitions.
        :paramtype low_key: str
        :keyword high_key: Required. String indicating the upper bound of the partition key range that
         should be split between the partitions.
        :paramtype high_key: str
        """
        super(UniformInt64RangePartitionSchemeDescription, self).__init__(**kwargs)
        self.partition_scheme = 'UniformInt64Range'  # type: str
        self.count = kwargs['count']
        self.low_key = kwargs['low_key']
        self.high_key = kwargs['high_key']


class UnplacedReplicaInformation(msrest.serialization.Model):
    """Contains information for an unplaced replica.

    :ivar service_name: The name of the service.
    :vartype service_name: str
    :ivar partition_id: The ID of the partition.
    :vartype partition_id: str
    :ivar unplaced_replica_details: List of reasons due to which a replica cannot be placed.
    :vartype unplaced_replica_details: list[str]
    """

    _attribute_map = {
        'service_name': {'key': 'ServiceName', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'unplaced_replica_details': {'key': 'UnplacedReplicaDetails', 'type': '[str]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_name: The name of the service.
        :paramtype service_name: str
        :keyword partition_id: The ID of the partition.
        :paramtype partition_id: str
        :keyword unplaced_replica_details: List of reasons due to which a replica cannot be placed.
        :paramtype unplaced_replica_details: list[str]
        """
        super(UnplacedReplicaInformation, self).__init__(**kwargs)
        self.service_name = kwargs.get('service_name', None)
        self.partition_id = kwargs.get('partition_id', None)
        self.unplaced_replica_details = kwargs.get('unplaced_replica_details', None)


class UnprovisionApplicationTypeDescriptionInfo(msrest.serialization.Model):
    """Describes the operation to unregister or unprovision an application type and its version that was registered with the Service Fabric.

    All required parameters must be populated in order to send to Azure.

    :ivar application_type_version: Required. The version of the application type as defined in the
     application manifest.
    :vartype application_type_version: str
    :ivar async_property: The flag indicating whether or not unprovision should occur
     asynchronously. When set to true, the unprovision operation returns when the request is
     accepted by the system, and the unprovision operation continues without any timeout limit. The
     default value is false. However, we recommend setting it to true for large application packages
     that were provisioned.
    :vartype async_property: bool
    """

    _validation = {
        'application_type_version': {'required': True},
    }

    _attribute_map = {
        'application_type_version': {'key': 'ApplicationTypeVersion', 'type': 'str'},
        'async_property': {'key': 'Async', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword application_type_version: Required. The version of the application type as defined in
         the application manifest.
        :paramtype application_type_version: str
        :keyword async_property: The flag indicating whether or not unprovision should occur
         asynchronously. When set to true, the unprovision operation returns when the request is
         accepted by the system, and the unprovision operation continues without any timeout limit. The
         default value is false. However, we recommend setting it to true for large application packages
         that were provisioned.
        :paramtype async_property: bool
        """
        super(UnprovisionApplicationTypeDescriptionInfo, self).__init__(**kwargs)
        self.application_type_version = kwargs['application_type_version']
        self.async_property = kwargs.get('async_property', None)


class UnprovisionFabricDescription(msrest.serialization.Model):
    """Describes the parameters for unprovisioning a cluster.

    :ivar code_version: The cluster code package version.
    :vartype code_version: str
    :ivar config_version: The cluster manifest version.
    :vartype config_version: str
    """

    _attribute_map = {
        'code_version': {'key': 'CodeVersion', 'type': 'str'},
        'config_version': {'key': 'ConfigVersion', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword code_version: The cluster code package version.
        :paramtype code_version: str
        :keyword config_version: The cluster manifest version.
        :paramtype config_version: str
        """
        super(UnprovisionFabricDescription, self).__init__(**kwargs)
        self.code_version = kwargs.get('code_version', None)
        self.config_version = kwargs.get('config_version', None)


class UpdateClusterUpgradeDescription(msrest.serialization.Model):
    """Parameters for updating a cluster upgrade.

    :ivar upgrade_kind: The type of upgrade out of the following possible values. Possible values
     include: "Invalid", "Rolling", "Rolling_ForceRestart". Default value: "Rolling".
    :vartype upgrade_kind: str or ~azure.servicefabric.models.UpgradeType
    :ivar update_description: Describes the parameters for updating a rolling upgrade of
     application or cluster.
    :vartype update_description: ~azure.servicefabric.models.RollingUpgradeUpdateDescription
    :ivar cluster_health_policy: Defines a health policy used to evaluate the health of the cluster
     or of a cluster node.
    :vartype cluster_health_policy: ~azure.servicefabric.models.ClusterHealthPolicy
    :ivar enable_delta_health_evaluation: When true, enables delta health evaluation rather than
     absolute health evaluation after completion of each upgrade domain.
    :vartype enable_delta_health_evaluation: bool
    :ivar cluster_upgrade_health_policy: Defines a health policy used to evaluate the health of the
     cluster during a cluster upgrade.
    :vartype cluster_upgrade_health_policy:
     ~azure.servicefabric.models.ClusterUpgradeHealthPolicyObject
    :ivar application_health_policy_map: Defines the application health policy map used to evaluate
     the health of an application or one of its children entities.
    :vartype application_health_policy_map: ~azure.servicefabric.models.ApplicationHealthPolicies
    """

    _attribute_map = {
        'upgrade_kind': {'key': 'UpgradeKind', 'type': 'str'},
        'update_description': {'key': 'UpdateDescription', 'type': 'RollingUpgradeUpdateDescription'},
        'cluster_health_policy': {'key': 'ClusterHealthPolicy', 'type': 'ClusterHealthPolicy'},
        'enable_delta_health_evaluation': {'key': 'EnableDeltaHealthEvaluation', 'type': 'bool'},
        'cluster_upgrade_health_policy': {'key': 'ClusterUpgradeHealthPolicy', 'type': 'ClusterUpgradeHealthPolicyObject'},
        'application_health_policy_map': {'key': 'ApplicationHealthPolicyMap', 'type': 'ApplicationHealthPolicies'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword upgrade_kind: The type of upgrade out of the following possible values. Possible
         values include: "Invalid", "Rolling", "Rolling_ForceRestart". Default value: "Rolling".
        :paramtype upgrade_kind: str or ~azure.servicefabric.models.UpgradeType
        :keyword update_description: Describes the parameters for updating a rolling upgrade of
         application or cluster.
        :paramtype update_description: ~azure.servicefabric.models.RollingUpgradeUpdateDescription
        :keyword cluster_health_policy: Defines a health policy used to evaluate the health of the
         cluster or of a cluster node.
        :paramtype cluster_health_policy: ~azure.servicefabric.models.ClusterHealthPolicy
        :keyword enable_delta_health_evaluation: When true, enables delta health evaluation rather than
         absolute health evaluation after completion of each upgrade domain.
        :paramtype enable_delta_health_evaluation: bool
        :keyword cluster_upgrade_health_policy: Defines a health policy used to evaluate the health of
         the cluster during a cluster upgrade.
        :paramtype cluster_upgrade_health_policy:
         ~azure.servicefabric.models.ClusterUpgradeHealthPolicyObject
        :keyword application_health_policy_map: Defines the application health policy map used to
         evaluate the health of an application or one of its children entities.
        :paramtype application_health_policy_map: ~azure.servicefabric.models.ApplicationHealthPolicies
        """
        super(UpdateClusterUpgradeDescription, self).__init__(**kwargs)
        self.upgrade_kind = kwargs.get('upgrade_kind', "Rolling")
        self.update_description = kwargs.get('update_description', None)
        self.cluster_health_policy = kwargs.get('cluster_health_policy', None)
        self.enable_delta_health_evaluation = kwargs.get('enable_delta_health_evaluation', None)
        self.cluster_upgrade_health_policy = kwargs.get('cluster_upgrade_health_policy', None)
        self.application_health_policy_map = kwargs.get('application_health_policy_map', None)


class UpdatePartitionLoadResult(msrest.serialization.Model):
    """Specifies result of updating load for specified partitions. The output will be ordered based on the partition ID.

    :ivar partition_id: Id of the partition.
    :vartype partition_id: str
    :ivar partition_error_code: If OperationState is Completed - this is 0.  If OperationState is
     Faulted - this is an error code indicating the reason.
    :vartype partition_error_code: int
    """

    _attribute_map = {
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
        'partition_error_code': {'key': 'PartitionErrorCode', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword partition_id: Id of the partition.
        :paramtype partition_id: str
        :keyword partition_error_code: If OperationState is Completed - this is 0.  If OperationState
         is Faulted - this is an error code indicating the reason.
        :paramtype partition_error_code: int
        """
        super(UpdatePartitionLoadResult, self).__init__(**kwargs)
        self.partition_id = kwargs.get('partition_id', None)
        self.partition_error_code = kwargs.get('partition_error_code', None)


class UpgradeDomainDeltaNodesCheckHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for delta unhealthy cluster nodes in an upgrade domain, containing health evaluations for each unhealthy node that impacted current aggregated health state.
Can be returned during cluster upgrade when cluster aggregated health state is Warning or Error.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar upgrade_domain_name: Name of the upgrade domain where nodes health is currently
     evaluated.
    :vartype upgrade_domain_name: str
    :ivar baseline_error_count: Number of upgrade domain nodes with aggregated heath state Error in
     the health store at the beginning of the cluster upgrade.
    :vartype baseline_error_count: long
    :ivar baseline_total_count: Total number of upgrade domain nodes in the health store at the
     beginning of the cluster upgrade.
    :vartype baseline_total_count: long
    :ivar max_percent_delta_unhealthy_nodes: Maximum allowed percentage of upgrade domain delta
     unhealthy nodes from the ClusterUpgradeHealthPolicy.
    :vartype max_percent_delta_unhealthy_nodes: int
    :ivar total_count: Total number of upgrade domain nodes in the health store.
    :vartype total_count: long
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
     state. Includes all the unhealthy NodeHealthEvaluation that impacted the aggregated health.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'upgrade_domain_name': {'key': 'UpgradeDomainName', 'type': 'str'},
        'baseline_error_count': {'key': 'BaselineErrorCount', 'type': 'long'},
        'baseline_total_count': {'key': 'BaselineTotalCount', 'type': 'long'},
        'max_percent_delta_unhealthy_nodes': {'key': 'MaxPercentDeltaUnhealthyNodes', 'type': 'int'},
        'total_count': {'key': 'TotalCount', 'type': 'long'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword upgrade_domain_name: Name of the upgrade domain where nodes health is currently
         evaluated.
        :paramtype upgrade_domain_name: str
        :keyword baseline_error_count: Number of upgrade domain nodes with aggregated heath state Error
         in the health store at the beginning of the cluster upgrade.
        :paramtype baseline_error_count: long
        :keyword baseline_total_count: Total number of upgrade domain nodes in the health store at the
         beginning of the cluster upgrade.
        :paramtype baseline_total_count: long
        :keyword max_percent_delta_unhealthy_nodes: Maximum allowed percentage of upgrade domain delta
         unhealthy nodes from the ClusterUpgradeHealthPolicy.
        :paramtype max_percent_delta_unhealthy_nodes: int
        :keyword total_count: Total number of upgrade domain nodes in the health store.
        :paramtype total_count: long
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
         state. Includes all the unhealthy NodeHealthEvaluation that impacted the aggregated health.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(UpgradeDomainDeltaNodesCheckHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'UpgradeDomainDeltaNodesCheck'  # type: str
        self.upgrade_domain_name = kwargs.get('upgrade_domain_name', None)
        self.baseline_error_count = kwargs.get('baseline_error_count', None)
        self.baseline_total_count = kwargs.get('baseline_total_count', None)
        self.max_percent_delta_unhealthy_nodes = kwargs.get('max_percent_delta_unhealthy_nodes', None)
        self.total_count = kwargs.get('total_count', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class UpgradeDomainDeployedApplicationsHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for deployed applications in an upgrade domain, containing health evaluations for each unhealthy deployed application that impacted current aggregated health state. Can be returned when evaluating cluster health during cluster upgrade and the aggregated health state is either Error or Warning.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar upgrade_domain_name: Name of the upgrade domain where deployed applications health is
     currently evaluated.
    :vartype upgrade_domain_name: str
    :ivar max_percent_unhealthy_deployed_applications: Maximum allowed percentage of unhealthy
     deployed applications from the ClusterHealthPolicy.
    :vartype max_percent_unhealthy_deployed_applications: int
    :ivar total_count: Total number of deployed applications in the current upgrade domain.
    :vartype total_count: long
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
     state. Includes all the unhealthy DeployedApplicationHealthEvaluation that impacted the
     aggregated health.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'upgrade_domain_name': {'key': 'UpgradeDomainName', 'type': 'str'},
        'max_percent_unhealthy_deployed_applications': {'key': 'MaxPercentUnhealthyDeployedApplications', 'type': 'int'},
        'total_count': {'key': 'TotalCount', 'type': 'long'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword upgrade_domain_name: Name of the upgrade domain where deployed applications health is
         currently evaluated.
        :paramtype upgrade_domain_name: str
        :keyword max_percent_unhealthy_deployed_applications: Maximum allowed percentage of unhealthy
         deployed applications from the ClusterHealthPolicy.
        :paramtype max_percent_unhealthy_deployed_applications: int
        :keyword total_count: Total number of deployed applications in the current upgrade domain.
        :paramtype total_count: long
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
         state. Includes all the unhealthy DeployedApplicationHealthEvaluation that impacted the
         aggregated health.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(UpgradeDomainDeployedApplicationsHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'UpgradeDomainDeployedApplications'  # type: str
        self.upgrade_domain_name = kwargs.get('upgrade_domain_name', None)
        self.max_percent_unhealthy_deployed_applications = kwargs.get('max_percent_unhealthy_deployed_applications', None)
        self.total_count = kwargs.get('total_count', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class UpgradeDomainInfo(msrest.serialization.Model):
    """Information about an upgrade domain.

    :ivar name: The name of the upgrade domain.
    :vartype name: str
    :ivar state: The state of the upgrade domain. Possible values include: "Invalid", "Pending",
     "InProgress", "Completed".
    :vartype state: str or ~azure.servicefabric.models.UpgradeDomainState
    """

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'state': {'key': 'State', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: The name of the upgrade domain.
        :paramtype name: str
        :keyword state: The state of the upgrade domain. Possible values include: "Invalid", "Pending",
         "InProgress", "Completed".
        :paramtype state: str or ~azure.servicefabric.models.UpgradeDomainState
        """
        super(UpgradeDomainInfo, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.state = kwargs.get('state', None)


class UpgradeDomainNodesHealthEvaluation(HealthEvaluation):
    """Represents health evaluation for cluster nodes in an upgrade domain, containing health evaluations for each unhealthy node that impacted current aggregated health state. Can be returned when evaluating cluster health during cluster upgrade and the aggregated health state is either Error or Warning.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The health manager in the cluster performs health evaluations in
     determining the aggregated health state of an entity. This enumeration provides information on
     the kind of evaluation that was performed. Following are the possible values.Constant filled by
     server. Possible values include: "Invalid", "Event", "Replicas", "Partitions",
     "DeployedServicePackages", "DeployedApplications", "Services", "Nodes", "Applications",
     "SystemApplication", "UpgradeDomainDeployedApplications", "UpgradeDomainNodes", "Replica",
     "Partition", "DeployedServicePackage", "DeployedApplication", "Service", "Node", "Application",
     "DeltaNodesCheck", "UpgradeDomainDeltaNodesCheck", "ApplicationTypeApplications",
     "NodeTypeNodes".
    :vartype kind: str or ~azure.servicefabric.models.HealthEvaluationKind
    :ivar aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
     Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
     "Warning", "Error", "Unknown".
    :vartype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
    :ivar description: Description of the health evaluation, which represents a summary of the
     evaluation process.
    :vartype description: str
    :ivar upgrade_domain_name: Name of the upgrade domain where nodes health is currently
     evaluated.
    :vartype upgrade_domain_name: str
    :ivar max_percent_unhealthy_nodes: Maximum allowed percentage of unhealthy nodes from the
     ClusterHealthPolicy.
    :vartype max_percent_unhealthy_nodes: int
    :ivar total_count: Total number of nodes in the current upgrade domain.
    :vartype total_count: long
    :ivar unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
     state. Includes all the unhealthy NodeHealthEvaluation that impacted the aggregated health.
    :vartype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'aggregated_health_state': {'key': 'AggregatedHealthState', 'type': 'str'},
        'description': {'key': 'Description', 'type': 'str'},
        'upgrade_domain_name': {'key': 'UpgradeDomainName', 'type': 'str'},
        'max_percent_unhealthy_nodes': {'key': 'MaxPercentUnhealthyNodes', 'type': 'int'},
        'total_count': {'key': 'TotalCount', 'type': 'long'},
        'unhealthy_evaluations': {'key': 'UnhealthyEvaluations', 'type': '[HealthEvaluationWrapper]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword aggregated_health_state: The health state of a Service Fabric entity such as Cluster,
         Node, Application, Service, Partition, Replica etc. Possible values include: "Invalid", "Ok",
         "Warning", "Error", "Unknown".
        :paramtype aggregated_health_state: str or ~azure.servicefabric.models.HealthState
        :keyword description: Description of the health evaluation, which represents a summary of the
         evaluation process.
        :paramtype description: str
        :keyword upgrade_domain_name: Name of the upgrade domain where nodes health is currently
         evaluated.
        :paramtype upgrade_domain_name: str
        :keyword max_percent_unhealthy_nodes: Maximum allowed percentage of unhealthy nodes from the
         ClusterHealthPolicy.
        :paramtype max_percent_unhealthy_nodes: int
        :keyword total_count: Total number of nodes in the current upgrade domain.
        :paramtype total_count: long
        :keyword unhealthy_evaluations: List of unhealthy evaluations that led to the aggregated health
         state. Includes all the unhealthy NodeHealthEvaluation that impacted the aggregated health.
        :paramtype unhealthy_evaluations: list[~azure.servicefabric.models.HealthEvaluationWrapper]
        """
        super(UpgradeDomainNodesHealthEvaluation, self).__init__(**kwargs)
        self.kind = 'UpgradeDomainNodes'  # type: str
        self.upgrade_domain_name = kwargs.get('upgrade_domain_name', None)
        self.max_percent_unhealthy_nodes = kwargs.get('max_percent_unhealthy_nodes', None)
        self.total_count = kwargs.get('total_count', None)
        self.unhealthy_evaluations = kwargs.get('unhealthy_evaluations', None)


class UpgradeOrchestrationServiceState(msrest.serialization.Model):
    """Service state of Service Fabric Upgrade Orchestration Service.

    :ivar service_state: The state of Service Fabric Upgrade Orchestration Service.
    :vartype service_state: str
    """

    _attribute_map = {
        'service_state': {'key': 'ServiceState', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_state: The state of Service Fabric Upgrade Orchestration Service.
        :paramtype service_state: str
        """
        super(UpgradeOrchestrationServiceState, self).__init__(**kwargs)
        self.service_state = kwargs.get('service_state', None)


class UpgradeOrchestrationServiceStateSummary(msrest.serialization.Model):
    """Service state summary of Service Fabric Upgrade Orchestration Service.

    :ivar current_code_version: The current code version of the cluster.
    :vartype current_code_version: str
    :ivar current_manifest_version: The current manifest version of the cluster.
    :vartype current_manifest_version: str
    :ivar target_code_version: The target code version of  the cluster.
    :vartype target_code_version: str
    :ivar target_manifest_version: The target manifest version of the cluster.
    :vartype target_manifest_version: str
    :ivar pending_upgrade_type: The type of the pending upgrade of the cluster.
    :vartype pending_upgrade_type: str
    """

    _attribute_map = {
        'current_code_version': {'key': 'CurrentCodeVersion', 'type': 'str'},
        'current_manifest_version': {'key': 'CurrentManifestVersion', 'type': 'str'},
        'target_code_version': {'key': 'TargetCodeVersion', 'type': 'str'},
        'target_manifest_version': {'key': 'TargetManifestVersion', 'type': 'str'},
        'pending_upgrade_type': {'key': 'PendingUpgradeType', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword current_code_version: The current code version of the cluster.
        :paramtype current_code_version: str
        :keyword current_manifest_version: The current manifest version of the cluster.
        :paramtype current_manifest_version: str
        :keyword target_code_version: The target code version of  the cluster.
        :paramtype target_code_version: str
        :keyword target_manifest_version: The target manifest version of the cluster.
        :paramtype target_manifest_version: str
        :keyword pending_upgrade_type: The type of the pending upgrade of the cluster.
        :paramtype pending_upgrade_type: str
        """
        super(UpgradeOrchestrationServiceStateSummary, self).__init__(**kwargs)
        self.current_code_version = kwargs.get('current_code_version', None)
        self.current_manifest_version = kwargs.get('current_manifest_version', None)
        self.target_code_version = kwargs.get('target_code_version', None)
        self.target_manifest_version = kwargs.get('target_manifest_version', None)
        self.pending_upgrade_type = kwargs.get('pending_upgrade_type', None)


class UpgradeUnitInfo(msrest.serialization.Model):
    """Information about an upgrade unit.

    :ivar name: The name of the upgrade unit.
    :vartype name: str
    :ivar state: The state of the upgrade unit. Possible values include: "Invalid", "Pending",
     "InProgress", "Completed", "Failed".
    :vartype state: str or ~azure.servicefabric.models.UpgradeUnitState
    """

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'state': {'key': 'State', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: The name of the upgrade unit.
        :paramtype name: str
        :keyword state: The state of the upgrade unit. Possible values include: "Invalid", "Pending",
         "InProgress", "Completed", "Failed".
        :paramtype state: str or ~azure.servicefabric.models.UpgradeUnitState
        """
        super(UpgradeUnitInfo, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.state = kwargs.get('state', None)


class UploadChunkRange(msrest.serialization.Model):
    """Information about which portion of the file to upload.

    :ivar start_position: The start position of the portion of the file. It's represented by the
     number of bytes.
    :vartype start_position: str
    :ivar end_position: The end position of the portion of the file. It's represented by the number
     of bytes.
    :vartype end_position: str
    """

    _attribute_map = {
        'start_position': {'key': 'StartPosition', 'type': 'str'},
        'end_position': {'key': 'EndPosition', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword start_position: The start position of the portion of the file. It's represented by the
         number of bytes.
        :paramtype start_position: str
        :keyword end_position: The end position of the portion of the file. It's represented by the
         number of bytes.
        :paramtype end_position: str
        """
        super(UploadChunkRange, self).__init__(**kwargs)
        self.start_position = kwargs.get('start_position', None)
        self.end_position = kwargs.get('end_position', None)


class UploadSession(msrest.serialization.Model):
    """Information about a image store upload session.

    :ivar upload_sessions: When querying upload session by upload session ID, the result contains
     only one upload session. When querying upload session by image store relative path, the result
     might contain multiple upload sessions.
    :vartype upload_sessions: list[~azure.servicefabric.models.UploadSessionInfo]
    """

    _attribute_map = {
        'upload_sessions': {'key': 'UploadSessions', 'type': '[UploadSessionInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword upload_sessions: When querying upload session by upload session ID, the result
         contains only one upload session. When querying upload session by image store relative path,
         the result might contain multiple upload sessions.
        :paramtype upload_sessions: list[~azure.servicefabric.models.UploadSessionInfo]
        """
        super(UploadSession, self).__init__(**kwargs)
        self.upload_sessions = kwargs.get('upload_sessions', None)


class UploadSessionInfo(msrest.serialization.Model):
    """Information about an image store upload session. A session is associated with a relative path in the image store.

    :ivar store_relative_path: The remote location within image store. This path is relative to the
     image store root.
    :vartype store_relative_path: str
    :ivar session_id: A unique ID of the upload session. A session ID can be reused only if the
     session was committed or removed.
    :vartype session_id: str
    :ivar modified_date: The date and time when the upload session was last modified.
    :vartype modified_date: ~datetime.datetime
    :ivar file_size: The size in bytes of the uploading file.
    :vartype file_size: str
    :ivar expected_ranges: List of chunk ranges that image store has not received yet.
    :vartype expected_ranges: list[~azure.servicefabric.models.UploadChunkRange]
    """

    _attribute_map = {
        'store_relative_path': {'key': 'StoreRelativePath', 'type': 'str'},
        'session_id': {'key': 'SessionId', 'type': 'str'},
        'modified_date': {'key': 'ModifiedDate', 'type': 'iso-8601'},
        'file_size': {'key': 'FileSize', 'type': 'str'},
        'expected_ranges': {'key': 'ExpectedRanges', 'type': '[UploadChunkRange]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword store_relative_path: The remote location within image store. This path is relative to
         the image store root.
        :paramtype store_relative_path: str
        :keyword session_id: A unique ID of the upload session. A session ID can be reused only if the
         session was committed or removed.
        :paramtype session_id: str
        :keyword modified_date: The date and time when the upload session was last modified.
        :paramtype modified_date: ~datetime.datetime
        :keyword file_size: The size in bytes of the uploading file.
        :paramtype file_size: str
        :keyword expected_ranges: List of chunk ranges that image store has not received yet.
        :paramtype expected_ranges: list[~azure.servicefabric.models.UploadChunkRange]
        """
        super(UploadSessionInfo, self).__init__(**kwargs)
        self.store_relative_path = kwargs.get('store_relative_path', None)
        self.session_id = kwargs.get('session_id', None)
        self.modified_date = kwargs.get('modified_date', None)
        self.file_size = kwargs.get('file_size', None)
        self.expected_ranges = kwargs.get('expected_ranges', None)


class UsageInfo(msrest.serialization.Model):
    """Information about how much space and how many files in the file system the ImageStore is using in this category.

    :ivar used_space: the size of all files in this category.
    :vartype used_space: str
    :ivar file_count: the number of all files in this category.
    :vartype file_count: str
    """

    _attribute_map = {
        'used_space': {'key': 'UsedSpace', 'type': 'str'},
        'file_count': {'key': 'FileCount', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword used_space: the size of all files in this category.
        :paramtype used_space: str
        :keyword file_count: the number of all files in this category.
        :paramtype file_count: str
        """
        super(UsageInfo, self).__init__(**kwargs)
        self.used_space = kwargs.get('used_space', None)
        self.file_count = kwargs.get('file_count', None)


class ValidateClusterUpgradeResult(msrest.serialization.Model):
    """Specifies result of validating a cluster upgrade.

    :ivar service_host_upgrade_impact: The expected impact of the upgrade. Possible values include:
     "Invalid", "None", "ServiceHostRestart", "UnexpectedServiceHostRestart".
    :vartype service_host_upgrade_impact: str or
     ~azure.servicefabric.models.ServiceHostUpgradeImpact
    :ivar validation_details: A string containing additional details for the Fabric upgrade
     validation result.
    :vartype validation_details: str
    """

    _attribute_map = {
        'service_host_upgrade_impact': {'key': 'ServiceHostUpgradeImpact', 'type': 'str'},
        'validation_details': {'key': 'ValidationDetails', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword service_host_upgrade_impact: The expected impact of the upgrade. Possible values
         include: "Invalid", "None", "ServiceHostRestart", "UnexpectedServiceHostRestart".
        :paramtype service_host_upgrade_impact: str or
         ~azure.servicefabric.models.ServiceHostUpgradeImpact
        :keyword validation_details: A string containing additional details for the Fabric upgrade
         validation result.
        :paramtype validation_details: str
        """
        super(ValidateClusterUpgradeResult, self).__init__(**kwargs)
        self.service_host_upgrade_impact = kwargs.get('service_host_upgrade_impact', None)
        self.validation_details = kwargs.get('validation_details', None)


class ValidationFailedChaosEvent(ChaosEvent):
    """Chaos event corresponding to a failure during validation.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of Chaos event.Constant filled by server. Possible values
     include: "Invalid", "Started", "ExecutingFaults", "Waiting", "ValidationFailed", "TestError",
     "Stopped".
    :vartype kind: str or ~azure.servicefabric.models.ChaosEventKind
    :ivar time_stamp_utc: Required. The UTC timestamp when this Chaos event was generated.
    :vartype time_stamp_utc: ~datetime.datetime
    :ivar reason: Describes why the ValidationFailedChaosEvent was generated. This may happen
     because more than MaxPercentUnhealthyNodes are unhealthy for more than
     MaxClusterStabilizationTimeout. This reason will be in the Reason property of the
     ValidationFailedChaosEvent as a string.
    :vartype reason: str
    """

    _validation = {
        'kind': {'required': True},
        'time_stamp_utc': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'time_stamp_utc': {'key': 'TimeStampUtc', 'type': 'iso-8601'},
        'reason': {'key': 'Reason', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword time_stamp_utc: Required. The UTC timestamp when this Chaos event was generated.
        :paramtype time_stamp_utc: ~datetime.datetime
        :keyword reason: Describes why the ValidationFailedChaosEvent was generated. This may happen
         because more than MaxPercentUnhealthyNodes are unhealthy for more than
         MaxClusterStabilizationTimeout. This reason will be in the Reason property of the
         ValidationFailedChaosEvent as a string.
        :paramtype reason: str
        """
        super(ValidationFailedChaosEvent, self).__init__(**kwargs)
        self.kind = 'ValidationFailed'  # type: str
        self.reason = kwargs.get('reason', None)


class VolumeProviderParametersAzureFile(msrest.serialization.Model):
    """This type describes a volume provided by an Azure Files file share.

    All required parameters must be populated in order to send to Azure.

    :ivar account_name: Required. Name of the Azure storage account for the File Share.
    :vartype account_name: str
    :ivar account_key: Access key of the Azure storage account for the File Share.
    :vartype account_key: str
    :ivar share_name: Required. Name of the Azure Files file share that provides storage for the
     volume.
    :vartype share_name: str
    """

    _validation = {
        'account_name': {'required': True},
        'share_name': {'required': True},
    }

    _attribute_map = {
        'account_name': {'key': 'accountName', 'type': 'str'},
        'account_key': {'key': 'accountKey', 'type': 'str'},
        'share_name': {'key': 'shareName', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword account_name: Required. Name of the Azure storage account for the File Share.
        :paramtype account_name: str
        :keyword account_key: Access key of the Azure storage account for the File Share.
        :paramtype account_key: str
        :keyword share_name: Required. Name of the Azure Files file share that provides storage for the
         volume.
        :paramtype share_name: str
        """
        super(VolumeProviderParametersAzureFile, self).__init__(**kwargs)
        self.account_name = kwargs['account_name']
        self.account_key = kwargs.get('account_key', None)
        self.share_name = kwargs['share_name']


class VolumeResourceDescription(msrest.serialization.Model):
    """This type describes a volume resource.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar name: Required. Name of the Volume resource.
    :vartype name: str
    :ivar description: User readable description of the volume.
    :vartype description: str
    :ivar status: Status of the volume. Possible values include: "Unknown", "Ready", "Upgrading",
     "Creating", "Deleting", "Failed".
    :vartype status: str or ~azure.servicefabric.models.ResourceStatus
    :ivar status_details: Gives additional information about the current status of the volume.
    :vartype status_details: str
    :ivar provider: Required. Provider of the volume. Possible values include: "SFAzureFile".
    :vartype provider: str or ~azure.servicefabric.models.VolumeProvider
    :ivar azure_file_parameters: This type describes a volume provided by an Azure Files file
     share.
    :vartype azure_file_parameters: ~azure.servicefabric.models.VolumeProviderParametersAzureFile
    """

    _validation = {
        'name': {'required': True},
        'status': {'readonly': True},
        'status_details': {'readonly': True},
        'provider': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'status': {'key': 'properties.status', 'type': 'str'},
        'status_details': {'key': 'properties.statusDetails', 'type': 'str'},
        'provider': {'key': 'properties.provider', 'type': 'str'},
        'azure_file_parameters': {'key': 'properties.azureFileParameters', 'type': 'VolumeProviderParametersAzureFile'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword name: Required. Name of the Volume resource.
        :paramtype name: str
        :keyword description: User readable description of the volume.
        :paramtype description: str
        :keyword provider: Required. Provider of the volume. Possible values include: "SFAzureFile".
        :paramtype provider: str or ~azure.servicefabric.models.VolumeProvider
        :keyword azure_file_parameters: This type describes a volume provided by an Azure Files file
         share.
        :paramtype azure_file_parameters: ~azure.servicefabric.models.VolumeProviderParametersAzureFile
        """
        super(VolumeResourceDescription, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.description = kwargs.get('description', None)
        self.status = None
        self.status_details = None
        self.provider = kwargs['provider']
        self.azure_file_parameters = kwargs.get('azure_file_parameters', None)


class WaitForInbuildReplicaSafetyCheck(PartitionSafetyCheck):
    """Safety check that waits for the replica build operation to finish. This indicates that there is a replica that is going through the copy or is providing data for building another replica. Bring the node down will abort this copy operation which are typically expensive involving data movements.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of safety check performed by service fabric before continuing
     with the operations. These checks ensure the availability of the service and the reliability of
     the state. Following are the kinds of safety checks.Constant filled by server. Possible values
     include: "Invalid", "EnsureSeedNodeQuorum", "EnsurePartitionQuorum", "WaitForPrimaryPlacement",
     "WaitForPrimarySwap", "WaitForReconfiguration", "WaitForInbuildReplica", "EnsureAvailability".
    :vartype kind: str or ~azure.servicefabric.models.SafetyCheckKind
    :ivar partition_id: Id of the partition which is undergoing the safety check.
    :vartype partition_id: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword partition_id: Id of the partition which is undergoing the safety check.
        :paramtype partition_id: str
        """
        super(WaitForInbuildReplicaSafetyCheck, self).__init__(**kwargs)
        self.kind = 'WaitForInbuildReplica'  # type: str


class WaitForPrimaryPlacementSafetyCheck(PartitionSafetyCheck):
    """Safety check that waits for the primary replica that was moved out of the node due to upgrade to be placed back again on that node.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of safety check performed by service fabric before continuing
     with the operations. These checks ensure the availability of the service and the reliability of
     the state. Following are the kinds of safety checks.Constant filled by server. Possible values
     include: "Invalid", "EnsureSeedNodeQuorum", "EnsurePartitionQuorum", "WaitForPrimaryPlacement",
     "WaitForPrimarySwap", "WaitForReconfiguration", "WaitForInbuildReplica", "EnsureAvailability".
    :vartype kind: str or ~azure.servicefabric.models.SafetyCheckKind
    :ivar partition_id: Id of the partition which is undergoing the safety check.
    :vartype partition_id: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword partition_id: Id of the partition which is undergoing the safety check.
        :paramtype partition_id: str
        """
        super(WaitForPrimaryPlacementSafetyCheck, self).__init__(**kwargs)
        self.kind = 'WaitForPrimaryPlacement'  # type: str


class WaitForPrimarySwapSafetyCheck(PartitionSafetyCheck):
    """Safety check that waits for the primary replica to be moved out of the node before starting an upgrade to ensure the availability of the primary replica for the partition.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of safety check performed by service fabric before continuing
     with the operations. These checks ensure the availability of the service and the reliability of
     the state. Following are the kinds of safety checks.Constant filled by server. Possible values
     include: "Invalid", "EnsureSeedNodeQuorum", "EnsurePartitionQuorum", "WaitForPrimaryPlacement",
     "WaitForPrimarySwap", "WaitForReconfiguration", "WaitForInbuildReplica", "EnsureAvailability".
    :vartype kind: str or ~azure.servicefabric.models.SafetyCheckKind
    :ivar partition_id: Id of the partition which is undergoing the safety check.
    :vartype partition_id: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword partition_id: Id of the partition which is undergoing the safety check.
        :paramtype partition_id: str
        """
        super(WaitForPrimarySwapSafetyCheck, self).__init__(**kwargs)
        self.kind = 'WaitForPrimarySwap'  # type: str


class WaitForReconfigurationSafetyCheck(PartitionSafetyCheck):
    """Safety check that waits for the current reconfiguration of the partition to be completed before starting an upgrade.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of safety check performed by service fabric before continuing
     with the operations. These checks ensure the availability of the service and the reliability of
     the state. Following are the kinds of safety checks.Constant filled by server. Possible values
     include: "Invalid", "EnsureSeedNodeQuorum", "EnsurePartitionQuorum", "WaitForPrimaryPlacement",
     "WaitForPrimarySwap", "WaitForReconfiguration", "WaitForInbuildReplica", "EnsureAvailability".
    :vartype kind: str or ~azure.servicefabric.models.SafetyCheckKind
    :ivar partition_id: Id of the partition which is undergoing the safety check.
    :vartype partition_id: str
    """

    _validation = {
        'kind': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'partition_id': {'key': 'PartitionId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword partition_id: Id of the partition which is undergoing the safety check.
        :paramtype partition_id: str
        """
        super(WaitForReconfigurationSafetyCheck, self).__init__(**kwargs)
        self.kind = 'WaitForReconfiguration'  # type: str


class WaitingChaosEvent(ChaosEvent):
    """Describes a Chaos event that gets generated when Chaos is waiting for the cluster to become ready for faulting, for example, Chaos may be waiting for the on-going upgrade to finish.

    All required parameters must be populated in order to send to Azure.

    :ivar kind: Required. The kind of Chaos event.Constant filled by server. Possible values
     include: "Invalid", "Started", "ExecutingFaults", "Waiting", "ValidationFailed", "TestError",
     "Stopped".
    :vartype kind: str or ~azure.servicefabric.models.ChaosEventKind
    :ivar time_stamp_utc: Required. The UTC timestamp when this Chaos event was generated.
    :vartype time_stamp_utc: ~datetime.datetime
    :ivar reason: Describes why the WaitingChaosEvent was generated, for example, due to a cluster
     upgrade.
    :vartype reason: str
    """

    _validation = {
        'kind': {'required': True},
        'time_stamp_utc': {'required': True},
    }

    _attribute_map = {
        'kind': {'key': 'Kind', 'type': 'str'},
        'time_stamp_utc': {'key': 'TimeStampUtc', 'type': 'iso-8601'},
        'reason': {'key': 'Reason', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        """
        :keyword time_stamp_utc: Required. The UTC timestamp when this Chaos event was generated.
        :paramtype time_stamp_utc: ~datetime.datetime
        :keyword reason: Describes why the WaitingChaosEvent was generated, for example, due to a
         cluster upgrade.
        :paramtype reason: str
        """
        super(WaitingChaosEvent, self).__init__(**kwargs)
        self.kind = 'Waiting'  # type: str
        self.reason = kwargs.get('reason', None)

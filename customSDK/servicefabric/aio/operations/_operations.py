# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
import sys
from typing import Any, Callable, Dict, List, Optional, TypeVar, cast

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat

from ...operations._operations import build_add_configuration_parameter_overrides_request, build_add_node_tags_request, build_backup_partition_request, build_cancel_operation_request, build_cancel_repair_task_request, build_commit_image_store_upload_session_request, build_copy_image_store_content_request, build_create_application_request, build_create_backup_policy_request, build_create_compose_deployment_request, build_create_name_request, build_create_repair_task_request, build_create_service_from_template_request, build_create_service_request, build_delete_application_request, build_delete_backup_policy_request, build_delete_image_store_content_request, build_delete_image_store_upload_session_request, build_delete_name_request, build_delete_property_request, build_delete_repair_task_request, build_delete_service_request, build_deploy_service_package_to_node_request, build_disable_application_backup_request, build_disable_node_request, build_disable_partition_backup_request, build_disable_service_backup_request, build_enable_application_backup_request, build_enable_node_request, build_enable_partition_backup_request, build_enable_service_backup_request, build_force_approve_repair_task_request, build_get_aad_metadata_request, build_get_all_entities_backed_up_by_policy_request, build_get_application_backup_configuration_info_request, build_get_application_backup_list_request, build_get_application_event_list_request, build_get_application_health_request, build_get_application_health_using_policy_request, build_get_application_info_list_request, build_get_application_info_request, build_get_application_load_info_request, build_get_application_manifest_request, build_get_application_name_info_request, build_get_application_type_info_list_by_name_request, build_get_application_type_info_list_request, build_get_application_upgrade_request, build_get_applications_event_list_request, build_get_backup_policy_by_name_request, build_get_backup_policy_list_request, build_get_backups_from_backup_location_request, build_get_chaos_events_request, build_get_chaos_request, build_get_chaos_schedule_request, build_get_cluster_configuration_request, build_get_cluster_configuration_upgrade_status_request, build_get_cluster_event_list_request, build_get_cluster_health_chunk_request, build_get_cluster_health_chunk_using_policy_and_advanced_filters_request, build_get_cluster_health_request, build_get_cluster_health_using_policy_request, build_get_cluster_load_request, build_get_cluster_manifest_request, build_get_cluster_upgrade_progress_request, build_get_cluster_version_request, build_get_compose_deployment_status_list_request, build_get_compose_deployment_status_request, build_get_compose_deployment_upgrade_progress_request, build_get_configuration_overrides_request, build_get_container_logs_deployed_on_node_request, build_get_containers_event_list_request, build_get_correlated_event_list_request, build_get_data_loss_progress_request, build_get_deployed_application_health_request, build_get_deployed_application_health_using_policy_request, build_get_deployed_application_info_list_request, build_get_deployed_application_info_request, build_get_deployed_code_package_info_list_request, build_get_deployed_service_package_health_request, build_get_deployed_service_package_health_using_policy_request, build_get_deployed_service_package_info_list_by_name_request, build_get_deployed_service_package_info_list_request, build_get_deployed_service_replica_detail_info_by_partition_id_request, build_get_deployed_service_replica_detail_info_request, build_get_deployed_service_replica_info_list_request, build_get_deployed_service_type_info_by_name_request, build_get_deployed_service_type_info_list_request, build_get_fault_operation_list_request, build_get_image_store_content_request, build_get_image_store_folder_size_request, build_get_image_store_info_request, build_get_image_store_root_content_request, build_get_image_store_root_folder_size_request, build_get_image_store_upload_session_by_id_request, build_get_image_store_upload_session_by_path_request, build_get_loaded_partition_info_list_request, build_get_name_exists_info_request, build_get_node_event_list_request, build_get_node_health_request, build_get_node_health_using_policy_request, build_get_node_info_list_request, build_get_node_info_request, build_get_node_load_info_request, build_get_node_transition_progress_request, build_get_nodes_event_list_request, build_get_partition_backup_configuration_info_request, build_get_partition_backup_list_request, build_get_partition_backup_progress_request, build_get_partition_event_list_request, build_get_partition_health_request, build_get_partition_health_using_policy_request, build_get_partition_info_list_request, build_get_partition_info_request, build_get_partition_load_information_request, build_get_partition_replica_event_list_request, build_get_partition_replicas_event_list_request, build_get_partition_restart_progress_request, build_get_partition_restore_progress_request, build_get_partitions_event_list_request, build_get_property_info_list_request, build_get_property_info_request, build_get_provisioned_fabric_code_version_info_list_request, build_get_provisioned_fabric_config_version_info_list_request, build_get_quorum_loss_progress_request, build_get_repair_task_list_request, build_get_replica_health_request, build_get_replica_health_using_policy_request, build_get_replica_info_list_request, build_get_replica_info_request, build_get_service_backup_configuration_info_request, build_get_service_backup_list_request, build_get_service_description_request, build_get_service_event_list_request, build_get_service_health_request, build_get_service_health_using_policy_request, build_get_service_info_list_request, build_get_service_info_request, build_get_service_manifest_request, build_get_service_name_info_request, build_get_service_type_info_by_name_request, build_get_service_type_info_list_request, build_get_services_event_list_request, build_get_sub_name_info_list_request, build_get_unplaced_replica_information_request, build_get_upgrade_orchestration_service_state_request, build_invoke_container_api_request, build_invoke_infrastructure_command_request, build_invoke_infrastructure_query_request, build_mesh_application_create_or_update_request, build_mesh_application_delete_request, build_mesh_application_get_request, build_mesh_application_get_upgrade_progress_request, build_mesh_application_list_request, build_mesh_code_package_get_container_logs_request, build_mesh_gateway_create_or_update_request, build_mesh_gateway_delete_request, build_mesh_gateway_get_request, build_mesh_gateway_list_request, build_mesh_network_create_or_update_request, build_mesh_network_delete_request, build_mesh_network_get_request, build_mesh_network_list_request, build_mesh_secret_create_or_update_request, build_mesh_secret_delete_request, build_mesh_secret_get_request, build_mesh_secret_list_request, build_mesh_secret_value_add_value_request, build_mesh_secret_value_delete_request, build_mesh_secret_value_get_request, build_mesh_secret_value_list_request, build_mesh_secret_value_show_request, build_mesh_service_get_request, build_mesh_service_list_request, build_mesh_service_replica_get_request, build_mesh_service_replica_list_request, build_mesh_volume_create_or_update_request, build_mesh_volume_delete_request, build_mesh_volume_get_request, build_mesh_volume_list_request, build_move_auxiliary_replica_request, build_move_instance_request, build_move_primary_replica_request, build_move_secondary_replica_request, build_post_chaos_schedule_request, build_provision_application_type_request, build_provision_cluster_request, build_put_property_request, build_recover_all_partitions_request, build_recover_partition_request, build_recover_service_partitions_request, build_recover_system_partitions_request, build_remove_compose_deployment_request, build_remove_configuration_overrides_request, build_remove_node_state_request, build_remove_node_tags_request, build_remove_replica_request, build_report_application_health_request, build_report_cluster_health_request, build_report_deployed_application_health_request, build_report_deployed_service_package_health_request, build_report_node_health_request, build_report_partition_health_request, build_report_replica_health_request, build_report_service_health_request, build_reset_partition_load_request, build_resolve_service_request, build_restart_deployed_code_package_request, build_restart_node_request, build_restart_replica_request, build_restore_partition_request, build_resume_application_backup_request, build_resume_application_upgrade_request, build_resume_cluster_upgrade_request, build_resume_partition_backup_request, build_resume_service_backup_request, build_rollback_application_upgrade_request, build_rollback_cluster_upgrade_request, build_set_upgrade_orchestration_service_state_request, build_start_application_upgrade_request, build_start_chaos_request, build_start_cluster_configuration_upgrade_request, build_start_cluster_upgrade_request, build_start_compose_deployment_upgrade_request, build_start_data_loss_request, build_start_node_transition_request, build_start_partition_restart_request, build_start_quorum_loss_request, build_start_rollback_compose_deployment_upgrade_request, build_stop_chaos_request, build_submit_property_batch_request, build_suspend_application_backup_request, build_suspend_partition_backup_request, build_suspend_service_backup_request, build_toggle_verbose_service_placement_health_reporting_request, build_unprovision_application_type_request, build_unprovision_cluster_request, build_update_application_arm_metadata_request, build_update_application_request, build_update_application_type_arm_metadata_request, build_update_application_upgrade_request, build_update_backup_policy_request, build_update_cluster_upgrade_request, build_update_partition_load_request, build_update_repair_execution_state_request, build_update_repair_task_health_policy_request, build_update_service_arm_metadata_request, build_update_service_request, build_upload_file_chunk_request, build_upload_file_request, build_validate_cluster_upgrade_request
from .._vendor import MixinABC
if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any] # pylint: disable=unsubscriptable-object
T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class ServiceFabricClientAPIsOperationsMixin(MixinABC):  # pylint: disable=too-many-public-methods

    @distributed_trace_async
    async def get_cluster_manifest(
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Get the Service Fabric cluster manifest.

        Get the Service Fabric cluster manifest. The cluster manifest contains properties of the
        cluster that include different node types on the cluster,
        security configurations, fault, and upgrade domain topologies, etc.

        These properties are specified as part of the ClusterConfig.JSON file while deploying a
        stand-alone cluster. However, most of the information in the cluster manifest
        is generated internally by service fabric during cluster deployment in other deployment
        scenarios (e.g. when using Azure portal).

        The contents of the cluster manifest are for informational purposes only and users are not
        expected to take a dependency on the format of the file contents or its interpretation.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Manifest": "str"  # Optional. The contents of the cluster manifest file.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_cluster_manifest_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_cluster_health(
        self,
        *,
        nodes_health_state_filter: Optional[int] = 0,
        applications_health_state_filter: Optional[int] = 0,
        events_health_state_filter: Optional[int] = 0,
        exclude_health_statistics: Optional[bool] = False,
        include_system_application_health_statistics: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the health of a Service Fabric cluster.

        Use EventsHealthStateFilter to filter the collection of health events reported on the cluster
        based on the health state.
        Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the
        collection of nodes and applications returned based on their aggregated health state.

        :keyword nodes_health_state_filter: Allows filtering of the node health state objects returned
         in the result of cluster health query
         based on their health state. The possible values for this parameter include integer value of
         one of the
         following health states. Only nodes that match the filter are returned. All nodes are used to
         evaluate the aggregated health state.
         If not specified, all entries are returned.
         The state values are flag-based enumeration, so the value could be a combination of these
         values obtained using bitwise 'OR' operator.
         For example, if the provided value is 6 then health state of nodes with HealthState value of
         OK (2) and Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype nodes_health_state_filter: int
        :keyword applications_health_state_filter: Allows filtering of the application health state
         objects returned in the result of cluster health
         query based on their health state.
         The possible values for this parameter include integer value obtained from members or bitwise
         operations
         on members of HealthStateFilter enumeration. Only applications that match the filter are
         returned.
         All applications are used to evaluate the aggregated health state. If not specified, all
         entries are returned.
         The state values are flag-based enumeration, so the value could be a combination of these
         values obtained using bitwise 'OR' operator.
         For example, if the provided value is 6 then health state of applications with HealthState
         value of OK (2) and Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype applications_health_state_filter: int
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword exclude_health_statistics: Indicates whether the health statistics should be returned
         as part of the query result. False by default.
         The statistics show the number of children entities in health state Ok, Warning, and Error.
         Default value is False.
        :paramtype exclude_health_statistics: bool
        :keyword include_system_application_health_statistics: Indicates whether the health statistics
         should include the fabric:/System application health statistics. False by default.
         If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the
         entities that belong to the fabric:/System application.
         Otherwise, the query result includes health statistics only for user applications.
         The health statistics must be included in the query result for this parameter to be applied.
         Default value is False.
        :paramtype include_system_application_health_statistics: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "ApplicationHealthStates": [
                        {
                            "AggregatedHealthState": "str",  # Optional. The health state
                              of a Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "Name": "str"  # Optional. The name of the application,
                              including the 'fabric:' URI scheme.
                        }
                    ],
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "NodeHealthStates": [
                        {
                            "AggregatedHealthState": "str",  # Optional. The health state
                              of a Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "Id": {
                                "Id": "str"  # Optional. Value of the node Id. This
                                  is a 128 bit integer.
                            },
                            "Name": "str"  # Optional. The name of a Service Fabric node.
                        }
                    ],
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_cluster_health_request(
            api_version=api_version,
            nodes_health_state_filter=nodes_health_state_filter,
            applications_health_state_filter=applications_health_state_filter,
            events_health_state_filter=events_health_state_filter,
            exclude_health_statistics=exclude_health_statistics,
            include_system_application_health_statistics=include_system_application_health_statistics,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_cluster_health_using_policy(
        self,
        cluster_health_policies: Optional[JSON] = None,
        *,
        nodes_health_state_filter: Optional[int] = 0,
        applications_health_state_filter: Optional[int] = 0,
        events_health_state_filter: Optional[int] = 0,
        exclude_health_statistics: Optional[bool] = False,
        include_system_application_health_statistics: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the health of a Service Fabric cluster using the specified policy.

        Use EventsHealthStateFilter to filter the collection of health events reported on the cluster
        based on the health state.
        Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the
        collection of nodes and applications returned based on their aggregated health state.
        Use ClusterHealthPolicies to override the health policies used to evaluate the health.

        :param cluster_health_policies: Describes the health policies used to evaluate the cluster
         health.
         If not present, the health evaluation uses the cluster health policy defined in the cluster
         manifest or the default cluster health policy.
         By default, each application is evaluated using its specific application health policy,
         defined in the application manifest, or the default health policy, if no policy is defined in
         manifest.
         If the application health policy map is specified, and it has an entry for an application, the
         specified application health policy
         is used to evaluate the application health. Default value is None.
        :type cluster_health_policies: JSON
        :keyword nodes_health_state_filter: Allows filtering of the node health state objects returned
         in the result of cluster health query
         based on their health state. The possible values for this parameter include integer value of
         one of the
         following health states. Only nodes that match the filter are returned. All nodes are used to
         evaluate the aggregated health state.
         If not specified, all entries are returned.
         The state values are flag-based enumeration, so the value could be a combination of these
         values obtained using bitwise 'OR' operator.
         For example, if the provided value is 6 then health state of nodes with HealthState value of
         OK (2) and Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype nodes_health_state_filter: int
        :keyword applications_health_state_filter: Allows filtering of the application health state
         objects returned in the result of cluster health
         query based on their health state.
         The possible values for this parameter include integer value obtained from members or bitwise
         operations
         on members of HealthStateFilter enumeration. Only applications that match the filter are
         returned.
         All applications are used to evaluate the aggregated health state. If not specified, all
         entries are returned.
         The state values are flag-based enumeration, so the value could be a combination of these
         values obtained using bitwise 'OR' operator.
         For example, if the provided value is 6 then health state of applications with HealthState
         value of OK (2) and Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype applications_health_state_filter: int
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword exclude_health_statistics: Indicates whether the health statistics should be returned
         as part of the query result. False by default.
         The statistics show the number of children entities in health state Ok, Warning, and Error.
         Default value is False.
        :paramtype exclude_health_statistics: bool
        :keyword include_system_application_health_statistics: Indicates whether the health statistics
         should include the fabric:/System application health statistics. False by default.
         If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the
         entities that belong to the fabric:/System application.
         Otherwise, the query result includes health statistics only for user applications.
         The health statistics must be included in the query result for this parameter to be applied.
         Default value is False.
        :paramtype include_system_application_health_statistics: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                cluster_health_policies = {
                    "ApplicationHealthPolicyMap": [
                        {
                            "Key": "str",  # Required. The key of the application health
                              policy map item. This is the name of the application.
                            "Value": {
                                "ConsiderWarningAsError": bool,  # Optional.
                                  Indicates whether warnings are treated with the same severity as
                                  errors.
                                "DefaultServiceTypeHealthPolicy": {
                                    "MaxPercentUnhealthyPartitionsPerService": 0,
                                      # Optional. The maximum allowed percentage of unhealthy
                                      partitions per service. Allowed values are Byte values from zero
                                      to 100"n"nThe percentage represents the maximum tolerated
                                      percentage of partitions that can be unhealthy before the service
                                      is considered in error."nIf the percentage is respected but there
                                      is at least one unhealthy partition, the health is evaluated as
                                      Warning."nThe percentage is calculated by dividing the number of
                                      unhealthy partitions over the total number of partitions in the
                                      service."nThe computation rounds up to tolerate one failure on
                                      small numbers of partitions. Default percentage is zero.
                                    "MaxPercentUnhealthyReplicasPerPartition": 0,
                                      # Optional. The maximum allowed percentage of unhealthy replicas
                                      per partition. Allowed values are Byte values from zero to
                                      100."n"nThe percentage represents the maximum tolerated
                                      percentage of replicas that can be unhealthy before the partition
                                      is considered in error."nIf the percentage is respected but there
                                      is at least one unhealthy replica, the health is evaluated as
                                      Warning."nThe percentage is calculated by dividing the number of
                                      unhealthy replicas over the total number of replicas in the
                                      partition."nThe computation rounds up to tolerate one failure on
                                      small numbers of replicas. Default percentage is zero.
                                    "MaxPercentUnhealthyServices": 0  # Optional.
                                      The maximum allowed percentage of unhealthy services. Allowed
                                      values are Byte values from zero to 100."n"nThe percentage
                                      represents the maximum tolerated percentage of services that can
                                      be unhealthy before the application is considered in error."nIf
                                      the percentage is respected but there is at least one unhealthy
                                      service, the health is evaluated as Warning."nThis is calculated
                                      by dividing the number of unhealthy services of the specific
                                      service type over the total number of services of the specific
                                      service type."nThe computation rounds up to tolerate one failure
                                      on small numbers of services. Default percentage is zero.
                                },
                                "MaxPercentUnhealthyDeployedApplications": 0,  #
                                  Optional. The maximum allowed percentage of unhealthy deployed
                                  applications. Allowed values are Byte values from zero to 100."nThe
                                  percentage represents the maximum tolerated percentage of deployed
                                  applications that can be unhealthy before the application is
                                  considered in error."nThis is calculated by dividing the number of
                                  unhealthy deployed applications over the number of nodes where the
                                  application is currently deployed on in the cluster."nThe computation
                                  rounds up to tolerate one failure on small numbers of nodes. Default
                                  percentage is zero.
                                "ServiceTypeHealthPolicyMap": [
                                    {
                                        "Key": "str",  # Required. The key of
                                          the service type health policy map item. This is the name of
                                          the service type.
                                        "Value": {
                "MaxPercentUnhealthyPartitionsPerService": 0,  #
                                              Optional. The maximum allowed percentage of unhealthy
                                              partitions per service. Allowed values are Byte values
                                              from zero to 100"n"nThe percentage represents the maximum
                                              tolerated percentage of partitions that can be unhealthy
                                              before the service is considered in error."nIf the
                                              percentage is respected but there is at least one
                                              unhealthy partition, the health is evaluated as
                                              Warning."nThe percentage is calculated by dividing the
                                              number of unhealthy partitions over the total number of
                                              partitions in the service."nThe computation rounds up to
                                              tolerate one failure on small numbers of partitions.
                                              Default percentage is zero.
                "MaxPercentUnhealthyReplicasPerPartition": 0,  #
                                              Optional. The maximum allowed percentage of unhealthy
                                              replicas per partition. Allowed values are Byte values
                                              from zero to 100."n"nThe percentage represents the
                                              maximum tolerated percentage of replicas that can be
                                              unhealthy before the partition is considered in
                                              error."nIf the percentage is respected but there is at
                                              least one unhealthy replica, the health is evaluated as
                                              Warning."nThe percentage is calculated by dividing the
                                              number of unhealthy replicas over the total number of
                                              replicas in the partition."nThe computation rounds up to
                                              tolerate one failure on small numbers of replicas.
                                              Default percentage is zero.
                "MaxPercentUnhealthyServices": 0  # Optional. The maximum
                                              allowed percentage of unhealthy services. Allowed values
                                              are Byte values from zero to 100."n"nThe percentage
                                              represents the maximum tolerated percentage of services
                                              that can be unhealthy before the application is
                                              considered in error."nIf the percentage is respected but
                                              there is at least one unhealthy service, the health is
                                              evaluated as Warning."nThis is calculated by dividing the
                                              number of unhealthy services of the specific service type
                                              over the total number of services of the specific service
                                              type."nThe computation rounds up to tolerate one failure
                                              on small numbers of services. Default percentage is zero.
                                        }
                                    }
                                ]
                            }
                        }
                    ],
                    "ClusterHealthPolicy": {
                        "ApplicationTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the application
                                  type health policy map item. This is the name of the application
                                  type.
                                "Value": 0  # Required. The value of the application
                                  type health policy map item."nThe max percent unhealthy applications
                                  allowed for the application type. Must be between zero and 100.
                            }
                        ],
                        "ConsiderWarningAsError": bool,  # Optional. Indicates whether
                          warnings are treated with the same severity as errors.
                        "MaxPercentUnhealthyApplications": 0,  # Optional. The maximum
                          allowed percentage of unhealthy applications before reporting an error. For
                          example, to allow 10% of applications to be unhealthy, this value would be
                          10."n"nThe percentage represents the maximum tolerated percentage of
                          applications that can be unhealthy before the cluster is considered in
                          error."nIf the percentage is respected but there is at least one unhealthy
                          application, the health is evaluated as Warning."nThis is calculated by
                          dividing the number of unhealthy applications over the total number of
                          application instances in the cluster, excluding applications of application
                          types that are included in the ApplicationTypeHealthPolicyMap."nThe
                          computation rounds up to tolerate one failure on small numbers of
                          applications. Default percentage is zero.
                        "MaxPercentUnhealthyNodes": 0,  # Optional. The maximum allowed
                          percentage of unhealthy nodes before reporting an error. For example, to
                          allow 10% of nodes to be unhealthy, this value would be 10."n"nThe percentage
                          represents the maximum tolerated percentage of nodes that can be unhealthy
                          before the cluster is considered in error."nIf the percentage is respected
                          but there is at least one unhealthy node, the health is evaluated as
                          Warning."nThe percentage is calculated by dividing the number of unhealthy
                          nodes over the total number of nodes in the cluster."nThe computation rounds
                          up to tolerate one failure on small numbers of nodes. Default percentage is
                          zero."n"nIn large clusters, some nodes will always be down or out for
                          repairs, so this percentage should be configured to tolerate that.
                        "NodeTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the node type
                                  health policy map item. This is the name of the node type.
                                "Value": 0  # Required. The value of the node type
                                  health policy map item."nIf the percentage is respected but there is
                                  at least one unhealthy node in the node type, the health is evaluated
                                  as Warning. "nThe percentage is calculated by dividing the number of
                                  unhealthy nodes over the total number of nodes in the node type.
                                  "nThe computation rounds up to tolerate one failure on small numbers
                                  of nodes."nThe max percent unhealthy nodes allowed for the node type.
                                  Must be between zero and 100.
                            }
                        ]
                    }
                }

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "ApplicationHealthStates": [
                        {
                            "AggregatedHealthState": "str",  # Optional. The health state
                              of a Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "Name": "str"  # Optional. The name of the application,
                              including the 'fabric:' URI scheme.
                        }
                    ],
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "NodeHealthStates": [
                        {
                            "AggregatedHealthState": "str",  # Optional. The health state
                              of a Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "Id": {
                                "Id": "str"  # Optional. Value of the node Id. This
                                  is a 128 bit integer.
                            },
                            "Name": "str"  # Optional. The name of a Service Fabric node.
                        }
                    ],
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        if cluster_health_policies is not None:
            _json = cluster_health_policies
        else:
            _json = None

        request = build_get_cluster_health_using_policy_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            nodes_health_state_filter=nodes_health_state_filter,
            applications_health_state_filter=applications_health_state_filter,
            events_health_state_filter=events_health_state_filter,
            exclude_health_statistics=exclude_health_statistics,
            include_system_application_health_statistics=include_system_application_health_statistics,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_cluster_health_chunk(
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the health of a Service Fabric cluster using health chunks.

        Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health
        state of the cluster, but none of the cluster entities.
        To expand the cluster health and get the health state of all or some of the entities, use the
        POST URI and specify the cluster health chunk query description.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ApplicationHealthStateChunks": {
                        "Items": [
                            {
                                "ApplicationName": "str",  # Optional. The name of
                                  the application, including the 'fabric:' URI scheme.
                                "ApplicationTypeName": "str",  # Optional. The
                                  application type name as defined in the application manifest.
                                "DeployedApplicationHealthStateChunks": {
                                    "Items": [
                                        {
                "DeployedServicePackageHealthStateChunks": {
                                                "Items": [
                                                    {
                "HealthState": "str",  # Optional. The health
                                                          state of a Service Fabric entity such as
                                                          Cluster, Node, Application, Service,
                                                          Partition, Replica etc. Known values are:
                                                          "Invalid", "Ok", "Warning", "Error",
                                                          "Unknown".
                "ServiceManifestName": "str",  # Optional.
                                                          The name of the service manifest.
                "ServicePackageActivationId": "str"  #
                                                          Optional. The ActivationId of a deployed
                                                          service package. If
                                                          ServicePackageActivationMode specified at the
                                                          time of creating the service"nis
                                                          'SharedProcess' (or if it is not specified,
                                                          in which case it defaults to
                                                          'SharedProcess'), then value of
                                                          ServicePackageActivationId"nis always an
                                                          empty string.
                                                    }
                                                ]
                                            },
                                            "HealthState": "str",  #
                                              Optional. The health state of a Service Fabric entity
                                              such as Cluster, Node, Application, Service, Partition,
                                              Replica etc. Known values are: "Invalid", "Ok",
                                              "Warning", "Error", "Unknown".
                                            "NodeName": "str"  #
                                              Optional. The name of node where the application is
                                              deployed.
                                        }
                                    ]
                                },
                                "HealthState": "str",  # Optional. The health state
                                  of a Service Fabric entity such as Cluster, Node, Application,
                                  Service, Partition, Replica etc. Known values are: "Invalid", "Ok",
                                  "Warning", "Error", "Unknown".
                                "ServiceHealthStateChunks": {
                                    "Items": [
                                        {
                                            "HealthState": "str",  #
                                              Optional. The health state of a Service Fabric entity
                                              such as Cluster, Node, Application, Service, Partition,
                                              Replica etc. Known values are: "Invalid", "Ok",
                                              "Warning", "Error", "Unknown".
                                            "PartitionHealthStateChunks":
                                              {
                                                "Items": [
                                                    {
                "HealthState": "str",  # Optional. The health
                                                          state of a Service Fabric entity such as
                                                          Cluster, Node, Application, Service,
                                                          Partition, Replica etc. Known values are:
                                                          "Invalid", "Ok", "Warning", "Error",
                                                          "Unknown".
                "PartitionId": str,  # Optional. The Id of
                                                          the partition.
                "ReplicaHealthStateChunks": {
                "Items": [
                {
                "HealthState": "str",  #
                                                                      Optional. The health state of a
                                                                      Service Fabric entity such as
                                                                      Cluster, Node, Application,
                                                                      Service, Partition, Replica etc.
                                                                      Known values are: "Invalid",
                                                                      "Ok", "Warning", "Error",
                                                                      "Unknown".
                "ReplicaOrInstanceId": "str"  #
                                                                      Optional. Id of a stateful
                                                                      service replica or a stateless
                                                                      service instance. This ID is used
                                                                      in the queries that apply to both
                                                                      stateful and stateless services.
                                                                      It is used by Service Fabric to
                                                                      uniquely identify a replica of a
                                                                      partition of a stateful service
                                                                      or an instance of a stateless
                                                                      service partition. It is unique
                                                                      within a partition and does not
                                                                      change for the lifetime of the
                                                                      replica or the instance. If a
                                                                      stateful replica gets dropped and
                                                                      another replica gets created on
                                                                      the same node for the same
                                                                      partition, it will get a
                                                                      different value for the ID. If a
                                                                      stateless instance is failed over
                                                                      on the same or different node it
                                                                      will get a different value for
                                                                      the ID.
                }
                ]
                                                        }
                                                    }
                                                ]
                                            },
                                            "ServiceName": "str"  #
                                              Optional. The name of the service whose health state
                                              chunk is provided in this object.
                                        }
                                    ]
                                }
                            }
                        ],
                        "TotalCount": 0.0  # Optional. Total number of entity health state
                          objects that match the specified filters from the cluster health chunk query
                          description.
                    },
                    "HealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the cluster computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired cluster
                      health policy and the application health policies. Known values are: "Invalid",
                      "Ok", "Warning", "Error", "Unknown".
                    "NodeHealthStateChunks": {
                        "Items": [
                            {
                                "HealthState": "str",  # Optional. The health state
                                  of a Service Fabric entity such as Cluster, Node, Application,
                                  Service, Partition, Replica etc. Known values are: "Invalid", "Ok",
                                  "Warning", "Error", "Unknown".
                                "NodeName": "str"  # Optional. The name of a Service
                                  Fabric node.
                            }
                        ],
                        "TotalCount": 0.0  # Optional. Total number of entity health state
                          objects that match the specified filters from the cluster health chunk query
                          description.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_cluster_health_chunk_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_cluster_health_chunk_using_policy_and_advanced_filters(
        self,
        cluster_health_chunk_query_description: Optional[JSON] = None,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the health of a Service Fabric cluster using health chunks.

        Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done
        based on the input cluster health chunk query description.
        The query description allows users to specify health policies for evaluating the cluster and
        its children.
        Users can specify very flexible filters to select which cluster entities to return. The
        selection can be done based on the entities health state and based on the hierarchy.
        The query can return multi-level children of the entities based on the specified filters. For
        example, it can return one application with a specified name, and for this application, return
        only services that are in Error or Warning, and all partitions and replicas for one of these
        services.

        :param cluster_health_chunk_query_description: Describes the cluster and application health
         policies used to evaluate the cluster health and the filters to select which cluster entities
         to be returned.
         If the cluster health policy is present, it is used to evaluate the cluster events and the
         cluster nodes. If not present, the health evaluation uses the cluster health policy defined in
         the cluster manifest or the default cluster health policy.
         By default, each application is evaluated using its specific application health policy,
         defined in the application manifest, or the default health policy, if no policy is defined in
         manifest.
         If the application health policy map is specified, and it has an entry for an application, the
         specified application health policy
         is used to evaluate the application health.
         Users can specify very flexible filters to select which cluster entities to include in
         response. The selection can be done based on the entities health state and based on the
         hierarchy.
         The query can return multi-level children of the entities based on the specified filters. For
         example, it can return one application with a specified name, and for this application, return
         only services that are in Error or Warning, and all partitions and replicas for one of these
         services. Default value is None.
        :type cluster_health_chunk_query_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                cluster_health_chunk_query_description = {
                    "ApplicationFilters": [
                        {
                            "ApplicationNameFilter": "str",  # Optional. The name of the
                              application that matches the filter, as a fabric uri. The filter is
                              applied only to the specified application, if it exists."nIf the
                              application doesn't exist, no application is returned in the cluster
                              health chunk based on this filter."nIf the application exists, it is
                              included in the cluster health chunk if it respects the other filter
                              properties."nIf not specified, all applications are matched against the
                              other filter members, like health state filter.
                            "ApplicationTypeNameFilter": "str",  # Optional. The name of
                              the application type that matches the filter."nIf specified, the filter
                              is applied only to applications of the selected application type, if any
                              exists."nIf no applications of the specified application type exists, no
                              application is returned in the cluster health chunk based on this
                              filter."nEach application of the specified application type is included
                              in the cluster health chunk if it respects the other filter
                              properties."nIf not specified, all applications are matched against the
                              other filter members, like health state filter.
                            "DeployedApplicationFilters": [
                                {
                                    "DeployedServicePackageFilters": [
                                        {
                                            "HealthStateFilter": 0,  #
                                              Optional. The filter for the health state of the deployed
                                              service packages. It allows selecting deployed service
                                              packages if they match the desired health states."nThe
                                              possible values are integer value of one of the following
                                              health states. Only deployed service packages that match
                                              the filter are returned. All deployed service packages
                                              are used to evaluate the parent deployed application
                                              aggregated health state."nIf not specified, default value
                                              is None, unless the deployed service package ID is
                                              specified. If the filter has default value and deployed
                                              service package ID is specified, the matching deployed
                                              service package is returned."nThe state values are
                                              flag-based enumeration, so the value could be a
                                              combination of these values obtained using bitwise 'OR'
                                              operator."nFor example, if the provided value is 6, it
                                              matches deployed service packages with HealthState value
                                              of OK (2) and Warning (4)."n"n"n* Default - Default
                                              value. Matches any HealthState. The value is zero."n*
                                              None - Filter that doesn't match any HealthState value.
                                              Used in order to return no results on a given collection
                                              of states. The value is 1."n* Ok - Filter that matches
                                              input with HealthState value Ok. The value is 2."n*
                                              Warning - Filter that matches input with HealthState
                                              value Warning. The value is 4."n* Error - Filter that
                                              matches input with HealthState value Error. The value is
                                              8."n* All - Filter that matches input with any
                                              HealthState value. The value is 65535.
                                            "ServiceManifestNameFilter":
                                              "str",  # Optional. The name of the service manifest
                                              which identifies the deployed service packages that
                                              matches the filter."nIf specified, the filter is applied
                                              only to the specified deployed service packages, if
                                              any."nIf no deployed service packages with specified
                                              manifest name exist, nothing is returned in the cluster
                                              health chunk based on this filter."nIf any deployed
                                              service package exists, they are included in the cluster
                                              health chunk if it respects the other filter
                                              properties."nIf not specified, all deployed service
                                              packages that match the parent filters (if any) are taken
                                              into consideration and matched against the other filter
                                              members, like health state filter.
                "ServicePackageActivationIdFilter": "str"  # Optional.
                                              The activation ID of a deployed service package that
                                              matches the filter."nIf not specified, the filter applies
                                              to all deployed service packages that match the other
                                              parameters."nIf specified, the filter matches only the
                                              deployed service package with the specified activation
                                              ID.
                                        }
                                    ],
                                    "HealthStateFilter": 0,  # Optional. The
                                      filter for the health state of the deployed applications. It
                                      allows selecting deployed applications if they match the desired
                                      health states."nThe possible values are integer value of one of
                                      the following health states. Only deployed applications that
                                      match the filter are returned. All deployed applications are used
                                      to evaluate the cluster aggregated health state."nIf not
                                      specified, default value is None, unless the node name is
                                      specified. If the filter has default value and node name is
                                      specified, the matching deployed application is returned."nThe
                                      state values are flag-based enumeration, so the value could be a
                                      combination of these values obtained using bitwise 'OR'
                                      operator."nFor example, if the provided value is 6, it matches
                                      deployed applications with HealthState value of OK (2) and
                                      Warning (4)."n"n"n* Default - Default value. Matches any
                                      HealthState. The value is zero."n* None - Filter that doesn't
                                      match any HealthState value. Used in order to return no results
                                      on a given collection of states. The value is 1."n* Ok - Filter
                                      that matches input with HealthState value Ok. The value is 2."n*
                                      Warning - Filter that matches input with HealthState value
                                      Warning. The value is 4."n* Error - Filter that matches input
                                      with HealthState value Error. The value is 8."n* All - Filter
                                      that matches input with any HealthState value. The value is
                                      65535.
                                    "NodeNameFilter": "str"  # Optional. The name
                                      of the node where the application is deployed in order to match
                                      the filter."nIf specified, the filter is applied only to the
                                      application deployed on the specified node."nIf the application
                                      is not deployed on the node with the specified name, no deployed
                                      application is returned in the cluster health chunk based on this
                                      filter."nOtherwise, the deployed application is included in the
                                      cluster health chunk if it respects the other filter
                                      properties."nIf not specified, all deployed applications that
                                      match the parent filters (if any) are taken into consideration
                                      and matched against the other filter members, like health state
                                      filter.
                                }
                            ],
                            "HealthStateFilter": 0,  # Optional. The filter for the
                              health state of the applications. It allows selecting applications if
                              they match the desired health states."nThe possible values are integer
                              value of one of the following health states. Only applications that match
                              the filter are returned. All applications are used to evaluate the
                              cluster aggregated health state."nIf not specified, default value is
                              None, unless the application name or the application type name are
                              specified. If the filter has default value and application name is
                              specified, the matching application is returned."nThe state values are
                              flag-based enumeration, so the value could be a combination of these
                              values obtained using bitwise 'OR' operator."nFor example, if the
                              provided value is 6, it matches applications with HealthState value of OK
                              (2) and Warning (4)."n"n"n* Default - Default value. Matches any
                              HealthState. The value is zero."n* None - Filter that doesn't match any
                              HealthState value. Used in order to return no results on a given
                              collection of states. The value is 1."n* Ok - Filter that matches input
                              with HealthState value Ok. The value is 2."n* Warning - Filter that
                              matches input with HealthState value Warning. The value is 4."n* Error -
                              Filter that matches input with HealthState value Error. The value is
                              8."n* All - Filter that matches input with any HealthState value. The
                              value is 65535.
                            "ServiceFilters": [
                                {
                                    "HealthStateFilter": 0,  # Optional. The
                                      filter for the health state of the services. It allows selecting
                                      services if they match the desired health states."nThe possible
                                      values are integer value of one of the following health states.
                                      Only services that match the filter are returned. All services
                                      are used to evaluate the cluster aggregated health state."nIf not
                                      specified, default value is None, unless the service name is
                                      specified. If the filter has default value and service name is
                                      specified, the matching service is returned."nThe state values
                                      are flag-based enumeration, so the value could be a combination
                                      of these values obtained using bitwise 'OR' operator."nFor
                                      example, if the provided value is 6, it matches services with
                                      HealthState value of OK (2) and Warning (4)."n"n"n* Default -
                                      Default value. Matches any HealthState. The value is zero."n*
                                      None - Filter that doesn't match any HealthState value. Used in
                                      order to return no results on a given collection of states. The
                                      value is 1."n* Ok - Filter that matches input with HealthState
                                      value Ok. The value is 2."n* Warning - Filter that matches input
                                      with HealthState value Warning. The value is 4."n* Error - Filter
                                      that matches input with HealthState value Error. The value is
                                      8."n* All - Filter that matches input with any HealthState value.
                                      The value is 65535.
                                    "PartitionFilters": [
                                        {
                                            "HealthStateFilter": 0,  #
                                              Optional. The filter for the health state of the
                                              partitions. It allows selecting partitions if they match
                                              the desired health states."nThe possible values are
                                              integer value of one of the following health states. Only
                                              partitions that match the filter are returned. All
                                              partitions are used to evaluate the cluster aggregated
                                              health state."nIf not specified, default value is None,
                                              unless the partition ID is specified. If the filter has
                                              default value and partition ID is specified, the matching
                                              partition is returned."nThe state values are flag-based
                                              enumeration, so the value could be a combination of these
                                              values obtained using bitwise 'OR' operator."nFor
                                              example, if the provided value is 6, it matches
                                              partitions with HealthState value of OK (2) and Warning
                                              (4)."n"n"n* Default - Default value. Matches any
                                              HealthState. The value is zero."n* None - Filter that
                                              doesn't match any HealthState value. Used in order to
                                              return no results on a given collection of states. The
                                              value is 1."n* Ok - Filter that matches input with
                                              HealthState value Ok. The value is 2."n* Warning - Filter
                                              that matches input with HealthState value Warning. The
                                              value is 4."n* Error - Filter that matches input with
                                              HealthState value Error. The value is 8."n* All - Filter
                                              that matches input with any HealthState value. The value
                                              is 65535.
                                            "PartitionIdFilter": str,  #
                                              Optional. ID of the partition that matches the filter.
                                              The filter is applied only to the specified partition, if
                                              it exists."nIf the partition doesn't exist, no partition
                                              is returned in the cluster health chunk based on this
                                              filter."nIf the partition exists, it is included in the
                                              cluster health chunk if it respects the other filter
                                              properties."nIf not specified, all partitions that match
                                              the parent filters (if any) are taken into consideration
                                              and matched against the other filter members, like health
                                              state filter.
                                            "ReplicaFilters": [
                                                {
                "HealthStateFilter": 0,  # Optional. The filter
                                                      for the health state of the replicas. It allows
                                                      selecting replicas if they match the desired
                                                      health states."nThe possible values are integer
                                                      value of one of the following health states. Only
                                                      replicas that match the filter are returned. All
                                                      replicas are used to evaluate the parent
                                                      partition aggregated health state."nIf not
                                                      specified, default value is None, unless the
                                                      replica ID is specified. If the filter has
                                                      default value and replica ID is specified, the
                                                      matching replica is returned."nThe state values
                                                      are flag-based enumeration, so the value could be
                                                      a combination of these values obtained using
                                                      bitwise 'OR' operator."nFor example, if the
                                                      provided value is 6, it matches replicas with
                                                      HealthState value of OK (2) and Warning
                                                      (4)."n"n"n* Default - Default value. Matches any
                                                      HealthState. The value is zero."n* None - Filter
                                                      that doesn't match any HealthState value. Used in
                                                      order to return no results on a given collection
                                                      of states. The value is 1."n* Ok - Filter that
                                                      matches input with HealthState value Ok. The
                                                      value is 2."n* Warning - Filter that matches
                                                      input with HealthState value Warning. The value
                                                      is 4."n* Error - Filter that matches input with
                                                      HealthState value Error. The value is 8."n* All -
                                                      Filter that matches input with any HealthState
                                                      value. The value is 65535.
                "ReplicaOrInstanceIdFilter": "str"  # Optional.
                                                      Id of the stateful service replica or stateless
                                                      service instance that matches the filter. The
                                                      filter is applied only to the specified replica,
                                                      if it exists."nIf the replica doesn't exist, no
                                                      replica is returned in the cluster health chunk
                                                      based on this filter."nIf the replica exists, it
                                                      is included in the cluster health chunk if it
                                                      respects the other filter properties."nIf not
                                                      specified, all replicas that match the parent
                                                      filters (if any) are taken into consideration and
                                                      matched against the other filter members, like
                                                      health state filter.
                                                }
                                            ]
                                        }
                                    ],
                                    "ServiceNameFilter": "str"  # Optional. The
                                      name of the service that matches the filter. The filter is
                                      applied only to the specified service, if it exists."nIf the
                                      service doesn't exist, no service is returned in the cluster
                                      health chunk based on this filter."nIf the service exists, it is
                                      included as the application's child if the health state matches
                                      the other filter properties."nIf not specified, all services that
                                      match the parent filters (if any) are taken into consideration
                                      and matched against the other filter members, like health state
                                      filter.
                                }
                            ]
                        }
                    ],
                    "ApplicationHealthPolicies": {
                        "ApplicationHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the application
                                  health policy map item. This is the name of the application.
                                "Value": {
                                    "ConsiderWarningAsError": bool,  # Optional.
                                      Indicates whether warnings are treated with the same severity as
                                      errors.
                                    "DefaultServiceTypeHealthPolicy": {
                "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional.
                                          The maximum allowed percentage of unhealthy partitions per
                                          service. Allowed values are Byte values from zero to
                                          100"n"nThe percentage represents the maximum tolerated
                                          percentage of partitions that can be unhealthy before the
                                          service is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy partition, the
                                          health is evaluated as Warning."nThe percentage is calculated
                                          by dividing the number of unhealthy partitions over the total
                                          number of partitions in the service."nThe computation rounds
                                          up to tolerate one failure on small numbers of partitions.
                                          Default percentage is zero.
                "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional.
                                          The maximum allowed percentage of unhealthy replicas per
                                          partition. Allowed values are Byte values from zero to
                                          100."n"nThe percentage represents the maximum tolerated
                                          percentage of replicas that can be unhealthy before the
                                          partition is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy replica, the
                                          health is evaluated as Warning."nThe percentage is calculated
                                          by dividing the number of unhealthy replicas over the total
                                          number of replicas in the partition."nThe computation rounds
                                          up to tolerate one failure on small numbers of replicas.
                                          Default percentage is zero.
                                        "MaxPercentUnhealthyServices": 0  #
                                          Optional. The maximum allowed percentage of unhealthy
                                          services. Allowed values are Byte values from zero to
                                          100."n"nThe percentage represents the maximum tolerated
                                          percentage of services that can be unhealthy before the
                                          application is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy service, the
                                          health is evaluated as Warning."nThis is calculated by
                                          dividing the number of unhealthy services of the specific
                                          service type over the total number of services of the
                                          specific service type."nThe computation rounds up to tolerate
                                          one failure on small numbers of services. Default percentage
                                          is zero.
                                    },
                                    "MaxPercentUnhealthyDeployedApplications": 0,
                                      # Optional. The maximum allowed percentage of unhealthy deployed
                                      applications. Allowed values are Byte values from zero to
                                      100."nThe percentage represents the maximum tolerated percentage
                                      of deployed applications that can be unhealthy before the
                                      application is considered in error."nThis is calculated by
                                      dividing the number of unhealthy deployed applications over the
                                      number of nodes where the application is currently deployed on in
                                      the cluster."nThe computation rounds up to tolerate one failure
                                      on small numbers of nodes. Default percentage is zero.
                                    "ServiceTypeHealthPolicyMap": [
                                        {
                                            "Key": "str",  # Required.
                                              The key of the service type health policy map item. This
                                              is the name of the service type.
                                            "Value": {
                "MaxPercentUnhealthyPartitionsPerService": 0,  #
                                                  Optional. The maximum allowed percentage of unhealthy
                                                  partitions per service. Allowed values are Byte
                                                  values from zero to 100"n"nThe percentage represents
                                                  the maximum tolerated percentage of partitions that
                                                  can be unhealthy before the service is considered in
                                                  error."nIf the percentage is respected but there is
                                                  at least one unhealthy partition, the health is
                                                  evaluated as Warning."nThe percentage is calculated
                                                  by dividing the number of unhealthy partitions over
                                                  the total number of partitions in the service."nThe
                                                  computation rounds up to tolerate one failure on
                                                  small numbers of partitions. Default percentage is
                                                  zero.
                "MaxPercentUnhealthyReplicasPerPartition": 0,  #
                                                  Optional. The maximum allowed percentage of unhealthy
                                                  replicas per partition. Allowed values are Byte
                                                  values from zero to 100."n"nThe percentage represents
                                                  the maximum tolerated percentage of replicas that can
                                                  be unhealthy before the partition is considered in
                                                  error."nIf the percentage is respected but there is
                                                  at least one unhealthy replica, the health is
                                                  evaluated as Warning."nThe percentage is calculated
                                                  by dividing the number of unhealthy replicas over the
                                                  total number of replicas in the partition."nThe
                                                  computation rounds up to tolerate one failure on
                                                  small numbers of replicas. Default percentage is
                                                  zero.
                "MaxPercentUnhealthyServices": 0  # Optional. The
                                                  maximum allowed percentage of unhealthy services.
                                                  Allowed values are Byte values from zero to
                                                  100."n"nThe percentage represents the maximum
                                                  tolerated percentage of services that can be
                                                  unhealthy before the application is considered in
                                                  error."nIf the percentage is respected but there is
                                                  at least one unhealthy service, the health is
                                                  evaluated as Warning."nThis is calculated by dividing
                                                  the number of unhealthy services of the specific
                                                  service type over the total number of services of the
                                                  specific service type."nThe computation rounds up to
                                                  tolerate one failure on small numbers of services.
                                                  Default percentage is zero.
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    },
                    "ClusterHealthPolicy": {
                        "ApplicationTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the application
                                  type health policy map item. This is the name of the application
                                  type.
                                "Value": 0  # Required. The value of the application
                                  type health policy map item."nThe max percent unhealthy applications
                                  allowed for the application type. Must be between zero and 100.
                            }
                        ],
                        "ConsiderWarningAsError": bool,  # Optional. Indicates whether
                          warnings are treated with the same severity as errors.
                        "MaxPercentUnhealthyApplications": 0,  # Optional. The maximum
                          allowed percentage of unhealthy applications before reporting an error. For
                          example, to allow 10% of applications to be unhealthy, this value would be
                          10."n"nThe percentage represents the maximum tolerated percentage of
                          applications that can be unhealthy before the cluster is considered in
                          error."nIf the percentage is respected but there is at least one unhealthy
                          application, the health is evaluated as Warning."nThis is calculated by
                          dividing the number of unhealthy applications over the total number of
                          application instances in the cluster, excluding applications of application
                          types that are included in the ApplicationTypeHealthPolicyMap."nThe
                          computation rounds up to tolerate one failure on small numbers of
                          applications. Default percentage is zero.
                        "MaxPercentUnhealthyNodes": 0,  # Optional. The maximum allowed
                          percentage of unhealthy nodes before reporting an error. For example, to
                          allow 10% of nodes to be unhealthy, this value would be 10."n"nThe percentage
                          represents the maximum tolerated percentage of nodes that can be unhealthy
                          before the cluster is considered in error."nIf the percentage is respected
                          but there is at least one unhealthy node, the health is evaluated as
                          Warning."nThe percentage is calculated by dividing the number of unhealthy
                          nodes over the total number of nodes in the cluster."nThe computation rounds
                          up to tolerate one failure on small numbers of nodes. Default percentage is
                          zero."n"nIn large clusters, some nodes will always be down or out for
                          repairs, so this percentage should be configured to tolerate that.
                        "NodeTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the node type
                                  health policy map item. This is the name of the node type.
                                "Value": 0  # Required. The value of the node type
                                  health policy map item."nIf the percentage is respected but there is
                                  at least one unhealthy node in the node type, the health is evaluated
                                  as Warning. "nThe percentage is calculated by dividing the number of
                                  unhealthy nodes over the total number of nodes in the node type.
                                  "nThe computation rounds up to tolerate one failure on small numbers
                                  of nodes."nThe max percent unhealthy nodes allowed for the node type.
                                  Must be between zero and 100.
                            }
                        ]
                    },
                    "NodeFilters": [
                        {
                            "HealthStateFilter": 0,  # Optional. The filter for the
                              health state of the nodes. It allows selecting nodes if they match the
                              desired health states."nThe possible values are integer value of one of
                              the following health states. Only nodes that match the filter are
                              returned. All nodes are used to evaluate the cluster aggregated health
                              state."nIf not specified, default value is None, unless the node name is
                              specified. If the filter has default value and node name is specified,
                              the matching node is returned."nThe state values are flag-based
                              enumeration, so the value could be a combination of these values obtained
                              using bitwise 'OR' operator."nFor example, if the provided value is 6, it
                              matches nodes with HealthState value of OK (2) and Warning (4)."n"n"n*
                              Default - Default value. Matches any HealthState. The value is zero."n*
                              None - Filter that doesn't match any HealthState value. Used in order to
                              return no results on a given collection of states. The value is 1."n* Ok
                              - Filter that matches input with HealthState value Ok. The value is 2."n*
                              Warning - Filter that matches input with HealthState value Warning. The
                              value is 4."n* Error - Filter that matches input with HealthState value
                              Error. The value is 8."n* All - Filter that matches input with any
                              HealthState value. The value is 65535.
                            "NodeNameFilter": "str"  # Optional. Name of the node that
                              matches the filter. The filter is applied only to the specified node, if
                              it exists."nIf the node doesn't exist, no node is returned in the cluster
                              health chunk based on this filter."nIf the node exists, it is included in
                              the cluster health chunk if the health state matches the other filter
                              properties."nIf not specified, all nodes that match the parent filters
                              (if any) are taken into consideration and matched against the other
                              filter members, like health state filter.
                        }
                    ]
                }

                # response body for status code(s): 200
                response.json() == {
                    "ApplicationHealthStateChunks": {
                        "Items": [
                            {
                                "ApplicationName": "str",  # Optional. The name of
                                  the application, including the 'fabric:' URI scheme.
                                "ApplicationTypeName": "str",  # Optional. The
                                  application type name as defined in the application manifest.
                                "DeployedApplicationHealthStateChunks": {
                                    "Items": [
                                        {
                "DeployedServicePackageHealthStateChunks": {
                                                "Items": [
                                                    {
                "HealthState": "str",  # Optional. The health
                                                          state of a Service Fabric entity such as
                                                          Cluster, Node, Application, Service,
                                                          Partition, Replica etc. Known values are:
                                                          "Invalid", "Ok", "Warning", "Error",
                                                          "Unknown".
                "ServiceManifestName": "str",  # Optional.
                                                          The name of the service manifest.
                "ServicePackageActivationId": "str"  #
                                                          Optional. The ActivationId of a deployed
                                                          service package. If
                                                          ServicePackageActivationMode specified at the
                                                          time of creating the service"nis
                                                          'SharedProcess' (or if it is not specified,
                                                          in which case it defaults to
                                                          'SharedProcess'), then value of
                                                          ServicePackageActivationId"nis always an
                                                          empty string.
                                                    }
                                                ]
                                            },
                                            "HealthState": "str",  #
                                              Optional. The health state of a Service Fabric entity
                                              such as Cluster, Node, Application, Service, Partition,
                                              Replica etc. Known values are: "Invalid", "Ok",
                                              "Warning", "Error", "Unknown".
                                            "NodeName": "str"  #
                                              Optional. The name of node where the application is
                                              deployed.
                                        }
                                    ]
                                },
                                "HealthState": "str",  # Optional. The health state
                                  of a Service Fabric entity such as Cluster, Node, Application,
                                  Service, Partition, Replica etc. Known values are: "Invalid", "Ok",
                                  "Warning", "Error", "Unknown".
                                "ServiceHealthStateChunks": {
                                    "Items": [
                                        {
                                            "HealthState": "str",  #
                                              Optional. The health state of a Service Fabric entity
                                              such as Cluster, Node, Application, Service, Partition,
                                              Replica etc. Known values are: "Invalid", "Ok",
                                              "Warning", "Error", "Unknown".
                                            "PartitionHealthStateChunks":
                                              {
                                                "Items": [
                                                    {
                "HealthState": "str",  # Optional. The health
                                                          state of a Service Fabric entity such as
                                                          Cluster, Node, Application, Service,
                                                          Partition, Replica etc. Known values are:
                                                          "Invalid", "Ok", "Warning", "Error",
                                                          "Unknown".
                "PartitionId": str,  # Optional. The Id of
                                                          the partition.
                "ReplicaHealthStateChunks": {
                "Items": [
                {
                "HealthState": "str",  #
                                                                      Optional. The health state of a
                                                                      Service Fabric entity such as
                                                                      Cluster, Node, Application,
                                                                      Service, Partition, Replica etc.
                                                                      Known values are: "Invalid",
                                                                      "Ok", "Warning", "Error",
                                                                      "Unknown".
                "ReplicaOrInstanceId": "str"  #
                                                                      Optional. Id of a stateful
                                                                      service replica or a stateless
                                                                      service instance. This ID is used
                                                                      in the queries that apply to both
                                                                      stateful and stateless services.
                                                                      It is used by Service Fabric to
                                                                      uniquely identify a replica of a
                                                                      partition of a stateful service
                                                                      or an instance of a stateless
                                                                      service partition. It is unique
                                                                      within a partition and does not
                                                                      change for the lifetime of the
                                                                      replica or the instance. If a
                                                                      stateful replica gets dropped and
                                                                      another replica gets created on
                                                                      the same node for the same
                                                                      partition, it will get a
                                                                      different value for the ID. If a
                                                                      stateless instance is failed over
                                                                      on the same or different node it
                                                                      will get a different value for
                                                                      the ID.
                }
                ]
                                                        }
                                                    }
                                                ]
                                            },
                                            "ServiceName": "str"  #
                                              Optional. The name of the service whose health state
                                              chunk is provided in this object.
                                        }
                                    ]
                                }
                            }
                        ],
                        "TotalCount": 0.0  # Optional. Total number of entity health state
                          objects that match the specified filters from the cluster health chunk query
                          description.
                    },
                    "HealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the cluster computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired cluster
                      health policy and the application health policies. Known values are: "Invalid",
                      "Ok", "Warning", "Error", "Unknown".
                    "NodeHealthStateChunks": {
                        "Items": [
                            {
                                "HealthState": "str",  # Optional. The health state
                                  of a Service Fabric entity such as Cluster, Node, Application,
                                  Service, Partition, Replica etc. Known values are: "Invalid", "Ok",
                                  "Warning", "Error", "Unknown".
                                "NodeName": "str"  # Optional. The name of a Service
                                  Fabric node.
                            }
                        ],
                        "TotalCount": 0.0  # Optional. Total number of entity health state
                          objects that match the specified filters from the cluster health chunk query
                          description.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        if cluster_health_chunk_query_description is not None:
            _json = cluster_health_chunk_query_description
        else:
            _json = None

        request = build_get_cluster_health_chunk_using_policy_and_advanced_filters_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def report_cluster_health(  # pylint: disable=inconsistent-return-statements
        self,
        health_information: JSON,
        *,
        immediate: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Sends a health report on the Service Fabric cluster.

        Sends a health report on a Service Fabric cluster. The report must contain the information
        about the source of the health report and property on which it is reported.
        The report is sent to a Service Fabric gateway node, which forwards to the health store.
        The report may be accepted by the gateway, but rejected by the health store after extra
        validation.
        For example, the health store may reject the report because of an invalid parameter, like a
        stale sequence number.
        To see whether the report was applied in the health store, run GetClusterHealth and check that
        the report appears in the HealthEvents section.

        :param health_information: Describes the health information for the health report. This
         information needs to be present in all of the health reports sent to the health manager.
        :type health_information: JSON
        :keyword immediate: A flag that indicates whether the report should be sent immediately.
         A health report is sent to a Service Fabric gateway Application, which forwards to the health
         store.
         If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
         store, regardless of the fabric client settings that the HTTP Gateway Application is using.
         This is useful for critical reports that should be sent as soon as possible.
         Depending on timing and other conditions, sending the report may still fail, for example if
         the HTTP Gateway is closed or the message doesn't reach the Gateway.
         If Immediate is set to false, the report is sent based on the health client settings from the
         HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
         configuration.
         This is the recommended setting because it allows the health client to optimize health
         reporting messages to health store as well as health report processing.
         By default, reports are not sent immediately. Default value is False.
        :paramtype immediate: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                health_information = {
                    "Description": "str",  # Optional. The description of the health information.
                      It represents free text used to add human readable information about the
                      report."nThe maximum string length for the description is 4096 characters."nIf
                      the provided string is longer, it will be automatically truncated."nWhen
                      truncated, the last characters of the description contain a marker "[Truncated]",
                      and total string size is 4096 characters."nThe presence of the marker indicates
                      to users that truncation occurred."nNote that when truncated, the description has
                      less than 4096 characters from the original string.
                    "HealthReportId": "str",  # Optional. A health report ID which identifies the
                      health report and can be used to find more detailed information about a specific
                      health event at"naka.ms/sfhealthid.
                    "HealthState": "str",  # Required. The health state of a Service Fabric
                      entity such as Cluster, Node, Application, Service, Partition, Replica etc. Known
                      values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "Property": "str",  # Required. The property of the health information. An
                      entity can have health reports for different properties."nThe property is a
                      string and not a fixed enumeration to allow the reporter flexibility to
                      categorize the state condition that triggers the report."nFor example, a reporter
                      with SourceId "LocalWatchdog" can monitor the state of the available disk on a
                      node,"nso it can report "AvailableDisk" property on that node."nThe same reporter
                      can monitor the node connectivity, so it can report a property "Connectivity" on
                      the same node."nIn the health store, these reports are treated as separate health
                      events for the specified node."n"nTogether with the SourceId, the property
                      uniquely identifies the health information.
                    "RemoveWhenExpired": bool,  # Optional. Value that indicates whether the
                      report is removed from health store when it expires."nIf set to true, the report
                      is removed from the health store after it expires."nIf set to false, the report
                      is treated as an error when expired. The value of this property is false by
                      default."nWhen clients report periodically, they should set RemoveWhenExpired
                      false (default)."nThis way, if the reporter has issues (e.g. deadlock) and can't
                      report, the entity is evaluated at error when the health report expires."nThis
                      flags the entity as being in Error health state.
                    "SequenceNumber": "str",  # Optional. The sequence number for this health
                      report as a numeric string."nThe report sequence number is used by the health
                      store to detect stale reports."nIf not specified, a sequence number is
                      auto-generated by the health client when a report is added.
                    "SourceId": "str",  # Required. The source name that identifies the
                      client/watchdog/system component that generated the health information.
                    "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The duration for
                      which this health report is valid. This field uses ISO8601 format for specifying
                      the duration."nWhen clients report periodically, they should send reports with
                      higher frequency than time to live."nIf clients report on transition, they can
                      set the time to live to infinite."nWhen time to live expires, the health event
                      that contains the health information"nis either removed from health store, if
                      RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                      false."n"nIf not specified, time to live defaults to infinite value.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = health_information

        request = build_report_cluster_health_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            immediate=immediate,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_provisioned_fabric_code_version_info_list(
        self,
        *,
        code_version: Optional[str] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets a list of fabric code versions that are provisioned in a Service Fabric cluster.

        Gets a list of information about fabric code versions that are provisioned in the cluster. The
        parameter CodeVersion can be used to optionally filter the output to only that particular
        version.

        :keyword code_version: The product version of Service Fabric. Default value is None.
        :paramtype code_version: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "CodeVersion": "str"  # Optional. The product version of Service
                          Fabric.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_provisioned_fabric_code_version_info_list_request(
            api_version=api_version,
            code_version=code_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_provisioned_fabric_config_version_info_list(
        self,
        *,
        config_version: Optional[str] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets a list of fabric config versions that are provisioned in a Service Fabric cluster.

        Gets a list of information about fabric config versions that are provisioned in the cluster.
        The parameter ConfigVersion can be used to optionally filter the output to only that particular
        version.

        :keyword config_version: The config version of Service Fabric. Default value is None.
        :paramtype config_version: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "ConfigVersion": "str"  # Optional. The config version of Service
                          Fabric.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_provisioned_fabric_config_version_info_list_request(
            api_version=api_version,
            config_version=config_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_cluster_upgrade_progress(
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the progress of the current cluster upgrade.

        Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in
        progress, get the last state of the previous cluster upgrade.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "CodeVersion": "str",  # Optional. The ServiceFabric code version of the
                      cluster.
                    "ConfigVersion": "str",  # Optional. The cluster configuration version
                      (specified in the cluster manifest).
                    "CurrentUpgradeDomainProgress": {
                        "DomainName": "str",  # Optional. The name of the upgrade domain.
                        "NodeUpgradeProgressList": [
                            {
                                "NodeName": "str",  # Optional. The name of a Service
                                  Fabric node.
                                "PendingSafetyChecks": [
                                    {
                                        "SafetyCheck": {
                                            Kind: Kind
                                        }
                                    }
                                ],
                                "UpgradeDuration": "str",  # Optional. The estimated
                                  time spent processing the node since it was deactivated during a
                                  node-by-node upgrade.
                                "UpgradePhase": "str"  # Optional. The state of the
                                  upgrading node. Known values are: "Invalid", "PreUpgradeSafetyCheck",
                                  "Upgrading", "PostUpgradeSafetyCheck".
                            }
                        ]
                    },
                    "CurrentUpgradeUnitsProgress": {
                        "DomainName": "str",  # Optional. The name of the upgrade domain. Not
                          applicable to node-by-node upgrades.
                        "NodeUpgradeProgressList": [
                            {
                                "NodeName": "str",  # Optional. The name of a Service
                                  Fabric node.
                                "PendingSafetyChecks": [
                                    {
                                        "SafetyCheck": {
                                            Kind: Kind
                                        }
                                    }
                                ],
                                "UpgradeDuration": "str",  # Optional. The estimated
                                  time spent processing the node since it was deactivated during a
                                  node-by-node upgrade.
                                "UpgradePhase": "str"  # Optional. The state of the
                                  upgrading node. Known values are: "Invalid", "PreUpgradeSafetyCheck",
                                  "Upgrading", "PostUpgradeSafetyCheck".
                            }
                        ]
                    },
                    "FailureReason": "str",  # Optional. The cause of an upgrade failure that
                      resulted in FailureAction being executed. Known values are: "None",
                      "Interrupted", "HealthCheck", "UpgradeDomainTimeout", "OverallUpgradeTimeout".
                    "FailureTimestampUtc": "str",  # Optional. The failure time of the upgrade in
                      UTC.
                    "IsNodeByNode": bool,  # Optional. Indicates whether this upgrade is
                      node-by-node.
                    "NextUpgradeDomain": "str",  # Optional. The name of the next upgrade domain
                      to be processed. Not applicable to node-by-node upgrades.
                    "RollingUpgradeMode": "UnmonitoredAuto",  # Optional. Default value is
                      "UnmonitoredAuto". The mode used to monitor health during a rolling upgrade. The
                      values are UnmonitoredAuto, UnmonitoredManual, Monitored, and
                      UnmonitoredDeferred. Known values are: "Invalid", "UnmonitoredAuto",
                      "UnmonitoredManual", "Monitored", "UnmonitoredDeferred". Default value:
                      "UnmonitoredAuto".
                    "StartTimestampUtc": "str",  # Optional. The start time of the upgrade in
                      UTC.
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ],
                    "UpgradeDescription": {
                        "ApplicationHealthPolicyMap": {
                            "ApplicationHealthPolicyMap": [
                                {
                                    "Key": "str",  # Required. The key of the
                                      application health policy map item. This is the name of the
                                      application.
                                    "Value": {
                                        "ConsiderWarningAsError": bool,  #
                                          Optional. Indicates whether warnings are treated with the
                                          same severity as errors.
                                        "DefaultServiceTypeHealthPolicy": {
                "MaxPercentUnhealthyPartitionsPerService": 0,  #
                                              Optional. The maximum allowed percentage of unhealthy
                                              partitions per service. Allowed values are Byte values
                                              from zero to 100"n"nThe percentage represents the maximum
                                              tolerated percentage of partitions that can be unhealthy
                                              before the service is considered in error."nIf the
                                              percentage is respected but there is at least one
                                              unhealthy partition, the health is evaluated as
                                              Warning."nThe percentage is calculated by dividing the
                                              number of unhealthy partitions over the total number of
                                              partitions in the service."nThe computation rounds up to
                                              tolerate one failure on small numbers of partitions.
                                              Default percentage is zero.
                "MaxPercentUnhealthyReplicasPerPartition": 0,  #
                                              Optional. The maximum allowed percentage of unhealthy
                                              replicas per partition. Allowed values are Byte values
                                              from zero to 100."n"nThe percentage represents the
                                              maximum tolerated percentage of replicas that can be
                                              unhealthy before the partition is considered in
                                              error."nIf the percentage is respected but there is at
                                              least one unhealthy replica, the health is evaluated as
                                              Warning."nThe percentage is calculated by dividing the
                                              number of unhealthy replicas over the total number of
                                              replicas in the partition."nThe computation rounds up to
                                              tolerate one failure on small numbers of replicas.
                                              Default percentage is zero.
                "MaxPercentUnhealthyServices": 0  # Optional. The maximum
                                              allowed percentage of unhealthy services. Allowed values
                                              are Byte values from zero to 100."n"nThe percentage
                                              represents the maximum tolerated percentage of services
                                              that can be unhealthy before the application is
                                              considered in error."nIf the percentage is respected but
                                              there is at least one unhealthy service, the health is
                                              evaluated as Warning."nThis is calculated by dividing the
                                              number of unhealthy services of the specific service type
                                              over the total number of services of the specific service
                                              type."nThe computation rounds up to tolerate one failure
                                              on small numbers of services. Default percentage is zero.
                                        },
                "MaxPercentUnhealthyDeployedApplications": 0,  # Optional.
                                          The maximum allowed percentage of unhealthy deployed
                                          applications. Allowed values are Byte values from zero to
                                          100."nThe percentage represents the maximum tolerated
                                          percentage of deployed applications that can be unhealthy
                                          before the application is considered in error."nThis is
                                          calculated by dividing the number of unhealthy deployed
                                          applications over the number of nodes where the application
                                          is currently deployed on in the cluster."nThe computation
                                          rounds up to tolerate one failure on small numbers of nodes.
                                          Default percentage is zero.
                                        "ServiceTypeHealthPolicyMap": [
                                            {
                                                "Key": "str",  #
                                                  Required. The key of the service type health policy
                                                  map item. This is the name of the service type.
                                                "Value": {
                "MaxPercentUnhealthyPartitionsPerService": 0,  #
                                                      Optional. The maximum allowed percentage of
                                                      unhealthy partitions per service. Allowed values
                                                      are Byte values from zero to 100"n"nThe
                                                      percentage represents the maximum tolerated
                                                      percentage of partitions that can be unhealthy
                                                      before the service is considered in error."nIf
                                                      the percentage is respected but there is at least
                                                      one unhealthy partition, the health is evaluated
                                                      as Warning."nThe percentage is calculated by
                                                      dividing the number of unhealthy partitions over
                                                      the total number of partitions in the
                                                      service."nThe computation rounds up to tolerate
                                                      one failure on small numbers of partitions.
                                                      Default percentage is zero.
                "MaxPercentUnhealthyReplicasPerPartition": 0,  #
                                                      Optional. The maximum allowed percentage of
                                                      unhealthy replicas per partition. Allowed values
                                                      are Byte values from zero to 100."n"nThe
                                                      percentage represents the maximum tolerated
                                                      percentage of replicas that can be unhealthy
                                                      before the partition is considered in error."nIf
                                                      the percentage is respected but there is at least
                                                      one unhealthy replica, the health is evaluated as
                                                      Warning."nThe percentage is calculated by
                                                      dividing the number of unhealthy replicas over
                                                      the total number of replicas in the
                                                      partition."nThe computation rounds up to tolerate
                                                      one failure on small numbers of replicas. Default
                                                      percentage is zero.
                "MaxPercentUnhealthyServices": 0  # Optional. The
                                                      maximum allowed percentage of unhealthy services.
                                                      Allowed values are Byte values from zero to
                                                      100."n"nThe percentage represents the maximum
                                                      tolerated percentage of services that can be
                                                      unhealthy before the application is considered in
                                                      error."nIf the percentage is respected but there
                                                      is at least one unhealthy service, the health is
                                                      evaluated as Warning."nThis is calculated by
                                                      dividing the number of unhealthy services of the
                                                      specific service type over the total number of
                                                      services of the specific service type."nThe
                                                      computation rounds up to tolerate one failure on
                                                      small numbers of services. Default percentage is
                                                      zero.
                                                }
                                            }
                                        ]
                                    }
                                }
                            ]
                        },
                        "ClusterHealthPolicy": {
                            "ApplicationTypeHealthPolicyMap": [
                                {
                                    "Key": "str",  # Required. The key of the
                                      application type health policy map item. This is the name of the
                                      application type.
                                    "Value": 0  # Required. The value of the
                                      application type health policy map item."nThe max percent
                                      unhealthy applications allowed for the application type. Must be
                                      between zero and 100.
                                }
                            ],
                            "ConsiderWarningAsError": bool,  # Optional. Indicates
                              whether warnings are treated with the same severity as errors.
                            "MaxPercentUnhealthyApplications": 0,  # Optional. The
                              maximum allowed percentage of unhealthy applications before reporting an
                              error. For example, to allow 10% of applications to be unhealthy, this
                              value would be 10."n"nThe percentage represents the maximum tolerated
                              percentage of applications that can be unhealthy before the cluster is
                              considered in error."nIf the percentage is respected but there is at
                              least one unhealthy application, the health is evaluated as
                              Warning."nThis is calculated by dividing the number of unhealthy
                              applications over the total number of application instances in the
                              cluster, excluding applications of application types that are included in
                              the ApplicationTypeHealthPolicyMap."nThe computation rounds up to
                              tolerate one failure on small numbers of applications. Default percentage
                              is zero.
                            "MaxPercentUnhealthyNodes": 0,  # Optional. The maximum
                              allowed percentage of unhealthy nodes before reporting an error. For
                              example, to allow 10% of nodes to be unhealthy, this value would be
                              10."n"nThe percentage represents the maximum tolerated percentage of
                              nodes that can be unhealthy before the cluster is considered in
                              error."nIf the percentage is respected but there is at least one
                              unhealthy node, the health is evaluated as Warning."nThe percentage is
                              calculated by dividing the number of unhealthy nodes over the total
                              number of nodes in the cluster."nThe computation rounds up to tolerate
                              one failure on small numbers of nodes. Default percentage is zero."n"nIn
                              large clusters, some nodes will always be down or out for repairs, so
                              this percentage should be configured to tolerate that.
                            "NodeTypeHealthPolicyMap": [
                                {
                                    "Key": "str",  # Required. The key of the
                                      node type health policy map item. This is the name of the node
                                      type.
                                    "Value": 0  # Required. The value of the node
                                      type health policy map item."nIf the percentage is respected but
                                      there is at least one unhealthy node in the node type, the health
                                      is evaluated as Warning. "nThe percentage is calculated by
                                      dividing the number of unhealthy nodes over the total number of
                                      nodes in the node type. "nThe computation rounds up to tolerate
                                      one failure on small numbers of nodes."nThe max percent unhealthy
                                      nodes allowed for the node type. Must be between zero and 100.
                                }
                            ]
                        },
                        "ClusterUpgradeHealthPolicy": {
                            "MaxPercentDeltaUnhealthyNodes": 0,  # Optional. The maximum
                              allowed percentage of nodes health degradation allowed during cluster
                              upgrades. The delta is measured between the state of the nodes at the
                              beginning of upgrade and the state of the nodes at the time of the health
                              evaluation. The check is performed after every upgrade domain upgrade
                              completion to make sure the global state of the cluster is within
                              tolerated limits. The default value is 10%.
                            "MaxPercentUpgradeDomainDeltaUnhealthyNodes": 0  # Optional.
                              The maximum allowed percentage of upgrade domain nodes health degradation
                              allowed during cluster upgrades. The delta is measured between the state
                              of the upgrade domain nodes at the beginning of upgrade and the state of
                              the upgrade domain nodes at the time of the health evaluation. The check
                              is performed after every upgrade domain upgrade completion for all
                              completed upgrade domains to make sure the state of the upgrade domains
                              is within tolerated limits. The default value is 15%.
                        },
                        "CodeVersion": "str",  # Optional. The ServiceFabric code version of
                          the cluster.
                        "ConfigVersion": "str",  # Optional. The cluster configuration
                          version (specified in the cluster manifest).
                        "EnableDeltaHealthEvaluation": bool,  # Optional. When true, enables
                          delta health evaluation rather than absolute health evaluation after
                          completion of each upgrade domain.
                        "ForceRestart": bool,  # Optional. If true, then processes are
                          forcefully restarted during upgrade even when the code version has not
                          changed (the upgrade only changes configuration or data).
                        "MonitoringPolicy": {
                            "FailureAction": "str",  # Optional. The compensating action
                              to perform when a Monitored upgrade encounters monitoring policy or
                              health policy violations."nInvalid indicates the failure action is
                              invalid. Rollback specifies that the upgrade will start rolling back
                              automatically."nManual indicates that the upgrade will switch to
                              UnmonitoredManual upgrade mode. Known values are: "Invalid", "Rollback",
                              "Manual".
                            "HealthCheckRetryTimeoutInMilliseconds": "PT0H10M0S",  #
                              Optional. Default value is "PT0H10M0S". The amount of time to retry
                              health evaluation when the application or cluster is unhealthy before
                              FailureAction is executed. It is first interpreted as a string
                              representing an ISO 8601 duration. If that fails, then it is interpreted
                              as a number representing the total number of milliseconds.
                            "HealthCheckStableDurationInMilliseconds": "PT0H2M0S",  #
                              Optional. Default value is "PT0H2M0S". The amount of time that the
                              application or cluster must remain healthy before the upgrade proceeds to
                              the next upgrade domain. It is first interpreted as a string representing
                              an ISO 8601 duration. If that fails, then it is interpreted as a number
                              representing the total number of milliseconds.
                            "HealthCheckWaitDurationInMilliseconds": "0",  # Optional.
                              Default value is "0". The amount of time to wait after completing an
                              upgrade domain before applying health policies. It is first interpreted
                              as a string representing an ISO 8601 duration. If that fails, then it is
                              interpreted as a number representing the total number of milliseconds.
                            "UpgradeDomainTimeoutInMilliseconds":
                              "P10675199DT02H48M05.4775807S",  # Optional. Default value is
                              "P10675199DT02H48M05.4775807S". The amount of time each upgrade domain
                              has to complete before FailureAction is executed. It is first interpreted
                              as a string representing an ISO 8601 duration. If that fails, then it is
                              interpreted as a number representing the total number of milliseconds.
                            "UpgradeTimeoutInMilliseconds":
                              "P10675199DT02H48M05.4775807S"  # Optional. Default value is
                              "P10675199DT02H48M05.4775807S". The amount of time the overall upgrade
                              has to complete before FailureAction is executed. It is first interpreted
                              as a string representing an ISO 8601 duration. If that fails, then it is
                              interpreted as a number representing the total number of milliseconds.
                        },
                        "RollingUpgradeMode": "UnmonitoredAuto",  # Optional. Default value
                          is "UnmonitoredAuto". The mode used to monitor health during a rolling
                          upgrade. The values are UnmonitoredAuto, UnmonitoredManual, Monitored, and
                          UnmonitoredDeferred. Known values are: "Invalid", "UnmonitoredAuto",
                          "UnmonitoredManual", "Monitored", "UnmonitoredDeferred". Default value:
                          "UnmonitoredAuto".
                        "SortOrder": "Default",  # Optional. Default value is "Default".
                          Defines the order in which an upgrade proceeds through the cluster. Known
                          values are: "Invalid", "Default", "Numeric", "Lexicographical",
                          "ReverseNumeric", "ReverseLexicographical". Default value: "Default".
                        "UpgradeKind": "Rolling",  # Optional. Default value is "Rolling".
                          The kind of upgrade out of the following possible values. Known values are:
                          "Invalid", "Rolling". Default value: "Rolling".
                        "UpgradeReplicaSetCheckTimeoutInSeconds": 42949672925  # Optional.
                          Default value is 42949672925. The maximum amount of time to block processing
                          of an upgrade domain and prevent loss of availability when there are
                          unexpected issues. When this timeout expires, processing of the upgrade
                          domain will proceed regardless of availability loss issues. The timeout is
                          reset at the start of each upgrade domain. Valid values are between 0 and
                          42949672925 inclusive. (unsigned 32-bit integer).
                    },
                    "UpgradeDomainDurationInMilliseconds": "str",  # Optional. The estimated
                      elapsed time spent processing the current upgrade domain. Not applicable to
                      node-by-node upgrades.
                    "UpgradeDomainProgressAtFailure": {
                        "DomainName": "str",  # Optional. The name of the upgrade domain.
                        "NodeUpgradeProgressList": [
                            {
                                "NodeName": "str",  # Optional. The name of a Service
                                  Fabric node.
                                "PendingSafetyChecks": [
                                    {
                                        "SafetyCheck": {
                                            Kind: Kind
                                        }
                                    }
                                ],
                                "UpgradeDuration": "str",  # Optional. The estimated
                                  time spent processing the node since it was deactivated during a
                                  node-by-node upgrade.
                                "UpgradePhase": "str"  # Optional. The state of the
                                  upgrading node. Known values are: "Invalid", "PreUpgradeSafetyCheck",
                                  "Upgrading", "PostUpgradeSafetyCheck".
                            }
                        ]
                    },
                    "UpgradeDomains": [
                        {
                            "Name": "str",  # Optional. The name of the upgrade domain.
                            "State": "str"  # Optional. The state of the upgrade domain.
                              Known values are: "Invalid", "Pending", "InProgress", "Completed".
                        }
                    ],
                    "UpgradeDurationInMilliseconds": "str",  # Optional. The estimated elapsed
                      time spent processing the current overall upgrade.
                    "UpgradeState": "str",  # Optional. The state of the upgrade domain. Known
                      values are: "Invalid", "RollingBackInProgress", "RollingBackCompleted",
                      "RollingForwardPending", "RollingForwardInProgress", "RollingForwardCompleted",
                      "Failed".
                    "UpgradeUnits": [
                        {
                            "Name": "str",  # Optional. The name of the upgrade unit.
                            "State": "str"  # Optional. The state of the upgrade unit.
                              Known values are: "Invalid", "Pending", "InProgress", "Completed",
                              "Failed".
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_cluster_upgrade_progress_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_cluster_configuration(
        self,
        *,
        configuration_api_version: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Get the Service Fabric standalone cluster configuration.

        The cluster configuration contains properties of the cluster that include different node types
        on the cluster,
        security configurations, fault, and upgrade domain topologies, etc.

        :keyword configuration_api_version: The API version of the Standalone cluster json
         configuration.
        :paramtype configuration_api_version: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ClusterConfiguration": "str"  # Optional. The contents of the cluster
                      configuration file.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_cluster_configuration_request(
            api_version=api_version,
            configuration_api_version=configuration_api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_cluster_configuration_upgrade_status(
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Get the cluster configuration upgrade status of a Service Fabric standalone cluster.

        Get the cluster configuration upgrade status details of a Service Fabric standalone cluster.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ConfigVersion": "str",  # Optional. The cluster configuration version.
                    "Details": "str",  # Optional. The cluster upgrade status details.
                    "ProgressStatus": 0,  # Optional. The cluster manifest version.
                    "UpgradeState": "str"  # Optional. The state of the upgrade domain. Known
                      values are: "Invalid", "RollingBackInProgress", "RollingBackCompleted",
                      "RollingForwardPending", "RollingForwardInProgress", "RollingForwardCompleted",
                      "Failed".
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_cluster_configuration_upgrade_status_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_upgrade_orchestration_service_state(
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Get the service state of Service Fabric Upgrade Orchestration Service.

        Get the service state of Service Fabric Upgrade Orchestration Service. This API is internally
        used for support purposes.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ServiceState": "str"  # Optional. The state of Service Fabric Upgrade
                      Orchestration Service.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_upgrade_orchestration_service_state_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def set_upgrade_orchestration_service_state(
        self,
        upgrade_orchestration_service_state: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Update the service state of Service Fabric Upgrade Orchestration Service.

        Update the service state of Service Fabric Upgrade Orchestration Service. This API is
        internally used for support purposes.

        :param upgrade_orchestration_service_state: Service state of Service Fabric Upgrade
         Orchestration Service.
        :type upgrade_orchestration_service_state: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                upgrade_orchestration_service_state = {
                    "ServiceState": "str"  # Optional. The state of Service Fabric Upgrade
                      Orchestration Service.
                }

                # response body for status code(s): 200
                response.json() == {
                    "CurrentCodeVersion": "str",  # Optional. The current code version of the
                      cluster.
                    "CurrentManifestVersion": "str",  # Optional. The current manifest version of
                      the cluster.
                    "PendingUpgradeType": "str",  # Optional. The type of the pending upgrade of
                      the cluster.
                    "TargetCodeVersion": "str",  # Optional. The target code version of  the
                      cluster.
                    "TargetManifestVersion": "str"  # Optional. The target manifest version of
                      the cluster.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = upgrade_orchestration_service_state

        request = build_set_upgrade_orchestration_service_state_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def provision_cluster(  # pylint: disable=inconsistent-return-statements
        self,
        provision_fabric_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Provision the code or configuration packages of a Service Fabric cluster.

        Validate and provision the code or configuration packages of a Service Fabric cluster.

        :param provision_fabric_description: Describes the parameters for provisioning a cluster.
        :type provision_fabric_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                provision_fabric_description = {
                    "ClusterManifestFilePath": "str",  # Optional. The cluster manifest file
                      path.
                    "CodeFilePath": "str"  # Optional. The cluster code package file path.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = provision_fabric_description

        request = build_provision_cluster_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def unprovision_cluster(  # pylint: disable=inconsistent-return-statements
        self,
        unprovision_fabric_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Unprovision the code or configuration packages of a Service Fabric cluster.

        It is supported to unprovision code and configuration separately.

        :param unprovision_fabric_description: Describes the parameters for unprovisioning a cluster.
        :type unprovision_fabric_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                unprovision_fabric_description = {
                    "CodeVersion": "str",  # Optional. The cluster code package version.
                    "ConfigVersion": "str"  # Optional. The cluster manifest version.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = unprovision_fabric_description

        request = build_unprovision_cluster_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def rollback_cluster_upgrade(  # pylint: disable=inconsistent-return-statements
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Roll back the upgrade of a Service Fabric cluster.

        Roll back the code or configuration upgrade of a Service Fabric cluster.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_rollback_cluster_upgrade_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def resume_cluster_upgrade(  # pylint: disable=inconsistent-return-statements
        self,
        resume_cluster_upgrade_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Make the cluster upgrade move on to the next upgrade domain.

        Make the cluster code or configuration upgrade move on to the next upgrade domain if
        appropriate.

        :param resume_cluster_upgrade_description: Describes the parameters for resuming a cluster
         upgrade.
        :type resume_cluster_upgrade_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resume_cluster_upgrade_description = {
                    "UpgradeDomain": "str"  # Required. The next upgrade domain for this cluster
                      upgrade.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = resume_cluster_upgrade_description

        request = build_resume_cluster_upgrade_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def start_cluster_upgrade(  # pylint: disable=inconsistent-return-statements
        self,
        start_cluster_upgrade_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Start upgrading the code or configuration version of a Service Fabric cluster.

        Validate the supplied upgrade parameters and start upgrading the code or configuration version
        of a Service Fabric cluster if the parameters are valid.

        :param start_cluster_upgrade_description: Describes the parameters for starting a cluster
         upgrade.
        :type start_cluster_upgrade_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                start_cluster_upgrade_description = {
                    "ApplicationHealthPolicyMap": {
                        "ApplicationHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the application
                                  health policy map item. This is the name of the application.
                                "Value": {
                                    "ConsiderWarningAsError": bool,  # Optional.
                                      Indicates whether warnings are treated with the same severity as
                                      errors.
                                    "DefaultServiceTypeHealthPolicy": {
                "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional.
                                          The maximum allowed percentage of unhealthy partitions per
                                          service. Allowed values are Byte values from zero to
                                          100"n"nThe percentage represents the maximum tolerated
                                          percentage of partitions that can be unhealthy before the
                                          service is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy partition, the
                                          health is evaluated as Warning."nThe percentage is calculated
                                          by dividing the number of unhealthy partitions over the total
                                          number of partitions in the service."nThe computation rounds
                                          up to tolerate one failure on small numbers of partitions.
                                          Default percentage is zero.
                "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional.
                                          The maximum allowed percentage of unhealthy replicas per
                                          partition. Allowed values are Byte values from zero to
                                          100."n"nThe percentage represents the maximum tolerated
                                          percentage of replicas that can be unhealthy before the
                                          partition is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy replica, the
                                          health is evaluated as Warning."nThe percentage is calculated
                                          by dividing the number of unhealthy replicas over the total
                                          number of replicas in the partition."nThe computation rounds
                                          up to tolerate one failure on small numbers of replicas.
                                          Default percentage is zero.
                                        "MaxPercentUnhealthyServices": 0  #
                                          Optional. The maximum allowed percentage of unhealthy
                                          services. Allowed values are Byte values from zero to
                                          100."n"nThe percentage represents the maximum tolerated
                                          percentage of services that can be unhealthy before the
                                          application is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy service, the
                                          health is evaluated as Warning."nThis is calculated by
                                          dividing the number of unhealthy services of the specific
                                          service type over the total number of services of the
                                          specific service type."nThe computation rounds up to tolerate
                                          one failure on small numbers of services. Default percentage
                                          is zero.
                                    },
                                    "MaxPercentUnhealthyDeployedApplications": 0,
                                      # Optional. The maximum allowed percentage of unhealthy deployed
                                      applications. Allowed values are Byte values from zero to
                                      100."nThe percentage represents the maximum tolerated percentage
                                      of deployed applications that can be unhealthy before the
                                      application is considered in error."nThis is calculated by
                                      dividing the number of unhealthy deployed applications over the
                                      number of nodes where the application is currently deployed on in
                                      the cluster."nThe computation rounds up to tolerate one failure
                                      on small numbers of nodes. Default percentage is zero.
                                    "ServiceTypeHealthPolicyMap": [
                                        {
                                            "Key": "str",  # Required.
                                              The key of the service type health policy map item. This
                                              is the name of the service type.
                                            "Value": {
                "MaxPercentUnhealthyPartitionsPerService": 0,  #
                                                  Optional. The maximum allowed percentage of unhealthy
                                                  partitions per service. Allowed values are Byte
                                                  values from zero to 100"n"nThe percentage represents
                                                  the maximum tolerated percentage of partitions that
                                                  can be unhealthy before the service is considered in
                                                  error."nIf the percentage is respected but there is
                                                  at least one unhealthy partition, the health is
                                                  evaluated as Warning."nThe percentage is calculated
                                                  by dividing the number of unhealthy partitions over
                                                  the total number of partitions in the service."nThe
                                                  computation rounds up to tolerate one failure on
                                                  small numbers of partitions. Default percentage is
                                                  zero.
                "MaxPercentUnhealthyReplicasPerPartition": 0,  #
                                                  Optional. The maximum allowed percentage of unhealthy
                                                  replicas per partition. Allowed values are Byte
                                                  values from zero to 100."n"nThe percentage represents
                                                  the maximum tolerated percentage of replicas that can
                                                  be unhealthy before the partition is considered in
                                                  error."nIf the percentage is respected but there is
                                                  at least one unhealthy replica, the health is
                                                  evaluated as Warning."nThe percentage is calculated
                                                  by dividing the number of unhealthy replicas over the
                                                  total number of replicas in the partition."nThe
                                                  computation rounds up to tolerate one failure on
                                                  small numbers of replicas. Default percentage is
                                                  zero.
                "MaxPercentUnhealthyServices": 0  # Optional. The
                                                  maximum allowed percentage of unhealthy services.
                                                  Allowed values are Byte values from zero to
                                                  100."n"nThe percentage represents the maximum
                                                  tolerated percentage of services that can be
                                                  unhealthy before the application is considered in
                                                  error."nIf the percentage is respected but there is
                                                  at least one unhealthy service, the health is
                                                  evaluated as Warning."nThis is calculated by dividing
                                                  the number of unhealthy services of the specific
                                                  service type over the total number of services of the
                                                  specific service type."nThe computation rounds up to
                                                  tolerate one failure on small numbers of services.
                                                  Default percentage is zero.
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    },
                    "ClusterHealthPolicy": {
                        "ApplicationTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the application
                                  type health policy map item. This is the name of the application
                                  type.
                                "Value": 0  # Required. The value of the application
                                  type health policy map item."nThe max percent unhealthy applications
                                  allowed for the application type. Must be between zero and 100.
                            }
                        ],
                        "ConsiderWarningAsError": bool,  # Optional. Indicates whether
                          warnings are treated with the same severity as errors.
                        "MaxPercentUnhealthyApplications": 0,  # Optional. The maximum
                          allowed percentage of unhealthy applications before reporting an error. For
                          example, to allow 10% of applications to be unhealthy, this value would be
                          10."n"nThe percentage represents the maximum tolerated percentage of
                          applications that can be unhealthy before the cluster is considered in
                          error."nIf the percentage is respected but there is at least one unhealthy
                          application, the health is evaluated as Warning."nThis is calculated by
                          dividing the number of unhealthy applications over the total number of
                          application instances in the cluster, excluding applications of application
                          types that are included in the ApplicationTypeHealthPolicyMap."nThe
                          computation rounds up to tolerate one failure on small numbers of
                          applications. Default percentage is zero.
                        "MaxPercentUnhealthyNodes": 0,  # Optional. The maximum allowed
                          percentage of unhealthy nodes before reporting an error. For example, to
                          allow 10% of nodes to be unhealthy, this value would be 10."n"nThe percentage
                          represents the maximum tolerated percentage of nodes that can be unhealthy
                          before the cluster is considered in error."nIf the percentage is respected
                          but there is at least one unhealthy node, the health is evaluated as
                          Warning."nThe percentage is calculated by dividing the number of unhealthy
                          nodes over the total number of nodes in the cluster."nThe computation rounds
                          up to tolerate one failure on small numbers of nodes. Default percentage is
                          zero."n"nIn large clusters, some nodes will always be down or out for
                          repairs, so this percentage should be configured to tolerate that.
                        "NodeTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the node type
                                  health policy map item. This is the name of the node type.
                                "Value": 0  # Required. The value of the node type
                                  health policy map item."nIf the percentage is respected but there is
                                  at least one unhealthy node in the node type, the health is evaluated
                                  as Warning. "nThe percentage is calculated by dividing the number of
                                  unhealthy nodes over the total number of nodes in the node type.
                                  "nThe computation rounds up to tolerate one failure on small numbers
                                  of nodes."nThe max percent unhealthy nodes allowed for the node type.
                                  Must be between zero and 100.
                            }
                        ]
                    },
                    "ClusterUpgradeHealthPolicy": {
                        "MaxPercentDeltaUnhealthyNodes": 0,  # Optional. The maximum allowed
                          percentage of nodes health degradation allowed during cluster upgrades. The
                          delta is measured between the state of the nodes at the beginning of upgrade
                          and the state of the nodes at the time of the health evaluation. The check is
                          performed after every upgrade domain upgrade completion to make sure the
                          global state of the cluster is within tolerated limits. The default value is
                          10%.
                        "MaxPercentUpgradeDomainDeltaUnhealthyNodes": 0  # Optional. The
                          maximum allowed percentage of upgrade domain nodes health degradation allowed
                          during cluster upgrades. The delta is measured between the state of the
                          upgrade domain nodes at the beginning of upgrade and the state of the upgrade
                          domain nodes at the time of the health evaluation. The check is performed
                          after every upgrade domain upgrade completion for all completed upgrade
                          domains to make sure the state of the upgrade domains is within tolerated
                          limits. The default value is 15%.
                    },
                    "CodeVersion": "str",  # Optional. The cluster code version.
                    "ConfigVersion": "str",  # Optional. The cluster configuration version.
                    "EnableDeltaHealthEvaluation": bool,  # Optional. When true, enables delta
                      health evaluation rather than absolute health evaluation after completion of each
                      upgrade domain.
                    "ForceRestart": bool,  # Optional. If true, then processes are forcefully
                      restarted during upgrade even when the code version has not changed (the upgrade
                      only changes configuration or data).
                    "InstanceCloseDelayDurationInSeconds": 4294967295,  # Optional. Default value
                      is 4294967295. Duration in seconds, to wait before a stateless instance is
                      closed, to allow the active requests to drain gracefully. This would be effective
                      when the instance is closing during the application/cluster"nupgrade, only for
                      those instances which have a non-zero delay duration configured in the service
                      description. See InstanceCloseDelayDurationSeconds property in $ref:
                      "#/definitions/StatelessServiceDescription.yaml" for details."nNote, the default
                      value of InstanceCloseDelayDurationInSeconds is 4294967295, which indicates that
                      the behavior will entirely depend on the delay configured in the stateless
                      service description.
                    "MonitoringPolicy": {
                        "FailureAction": "str",  # Optional. The compensating action to
                          perform when a Monitored upgrade encounters monitoring policy or health
                          policy violations."nInvalid indicates the failure action is invalid. Rollback
                          specifies that the upgrade will start rolling back automatically."nManual
                          indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
                          Known values are: "Invalid", "Rollback", "Manual".
                        "HealthCheckRetryTimeoutInMilliseconds": "PT0H10M0S",  # Optional.
                          Default value is "PT0H10M0S". The amount of time to retry health evaluation
                          when the application or cluster is unhealthy before FailureAction is
                          executed. It is first interpreted as a string representing an ISO 8601
                          duration. If that fails, then it is interpreted as a number representing the
                          total number of milliseconds.
                        "HealthCheckStableDurationInMilliseconds": "PT0H2M0S",  # Optional.
                          Default value is "PT0H2M0S". The amount of time that the application or
                          cluster must remain healthy before the upgrade proceeds to the next upgrade
                          domain. It is first interpreted as a string representing an ISO 8601
                          duration. If that fails, then it is interpreted as a number representing the
                          total number of milliseconds.
                        "HealthCheckWaitDurationInMilliseconds": "0",  # Optional. Default
                          value is "0". The amount of time to wait after completing an upgrade domain
                          before applying health policies. It is first interpreted as a string
                          representing an ISO 8601 duration. If that fails, then it is interpreted as a
                          number representing the total number of milliseconds.
                        "UpgradeDomainTimeoutInMilliseconds": "P10675199DT02H48M05.4775807S",
                          # Optional. Default value is "P10675199DT02H48M05.4775807S". The amount of
                          time each upgrade domain has to complete before FailureAction is executed. It
                          is first interpreted as a string representing an ISO 8601 duration. If that
                          fails, then it is interpreted as a number representing the total number of
                          milliseconds.
                        "UpgradeTimeoutInMilliseconds": "P10675199DT02H48M05.4775807S"  #
                          Optional. Default value is "P10675199DT02H48M05.4775807S". The amount of time
                          the overall upgrade has to complete before FailureAction is executed. It is
                          first interpreted as a string representing an ISO 8601 duration. If that
                          fails, then it is interpreted as a number representing the total number of
                          milliseconds.
                    },
                    "RollingUpgradeMode": "UnmonitoredAuto",  # Optional. Default value is
                      "UnmonitoredAuto". The mode used to monitor health during a rolling upgrade. The
                      values are UnmonitoredAuto, UnmonitoredManual, Monitored, and
                      UnmonitoredDeferred. Known values are: "Invalid", "UnmonitoredAuto",
                      "UnmonitoredManual", "Monitored", "UnmonitoredDeferred". Default value:
                      "UnmonitoredAuto".
                    "SortOrder": "Default",  # Optional. Default value is "Default". Defines the
                      order in which an upgrade proceeds through the cluster. Known values are:
                      "Invalid", "Default", "Numeric", "Lexicographical", "ReverseNumeric",
                      "ReverseLexicographical". Default value: "Default".
                    "UpgradeKind": "Rolling",  # Optional. Default value is "Rolling". The kind
                      of upgrade out of the following possible values. Known values are: "Invalid",
                      "Rolling". Default value: "Rolling".
                    "UpgradeReplicaSetCheckTimeoutInSeconds": 42949672925  # Optional. Default
                      value is 42949672925. The maximum amount of time to block processing of an
                      upgrade domain and prevent loss of availability when there are unexpected issues.
                      When this timeout expires, processing of the upgrade domain will proceed
                      regardless of availability loss issues. The timeout is reset at the start of each
                      upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
                      32-bit integer).
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = start_cluster_upgrade_description

        request = build_start_cluster_upgrade_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def start_cluster_configuration_upgrade(  # pylint: disable=inconsistent-return-statements
        self,
        cluster_configuration_upgrade_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Start upgrading the configuration of a Service Fabric standalone cluster.

        Validate the supplied configuration upgrade parameters and start upgrading the cluster
        configuration if the parameters are valid.

        :param cluster_configuration_upgrade_description: Parameters for a standalone cluster
         configuration upgrade.
        :type cluster_configuration_upgrade_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                cluster_configuration_upgrade_description = {
                    "ApplicationHealthPolicies": {
                        "ApplicationHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the application
                                  health policy map item. This is the name of the application.
                                "Value": {
                                    "ConsiderWarningAsError": bool,  # Optional.
                                      Indicates whether warnings are treated with the same severity as
                                      errors.
                                    "DefaultServiceTypeHealthPolicy": {
                "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional.
                                          The maximum allowed percentage of unhealthy partitions per
                                          service. Allowed values are Byte values from zero to
                                          100"n"nThe percentage represents the maximum tolerated
                                          percentage of partitions that can be unhealthy before the
                                          service is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy partition, the
                                          health is evaluated as Warning."nThe percentage is calculated
                                          by dividing the number of unhealthy partitions over the total
                                          number of partitions in the service."nThe computation rounds
                                          up to tolerate one failure on small numbers of partitions.
                                          Default percentage is zero.
                "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional.
                                          The maximum allowed percentage of unhealthy replicas per
                                          partition. Allowed values are Byte values from zero to
                                          100."n"nThe percentage represents the maximum tolerated
                                          percentage of replicas that can be unhealthy before the
                                          partition is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy replica, the
                                          health is evaluated as Warning."nThe percentage is calculated
                                          by dividing the number of unhealthy replicas over the total
                                          number of replicas in the partition."nThe computation rounds
                                          up to tolerate one failure on small numbers of replicas.
                                          Default percentage is zero.
                                        "MaxPercentUnhealthyServices": 0  #
                                          Optional. The maximum allowed percentage of unhealthy
                                          services. Allowed values are Byte values from zero to
                                          100."n"nThe percentage represents the maximum tolerated
                                          percentage of services that can be unhealthy before the
                                          application is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy service, the
                                          health is evaluated as Warning."nThis is calculated by
                                          dividing the number of unhealthy services of the specific
                                          service type over the total number of services of the
                                          specific service type."nThe computation rounds up to tolerate
                                          one failure on small numbers of services. Default percentage
                                          is zero.
                                    },
                                    "MaxPercentUnhealthyDeployedApplications": 0,
                                      # Optional. The maximum allowed percentage of unhealthy deployed
                                      applications. Allowed values are Byte values from zero to
                                      100."nThe percentage represents the maximum tolerated percentage
                                      of deployed applications that can be unhealthy before the
                                      application is considered in error."nThis is calculated by
                                      dividing the number of unhealthy deployed applications over the
                                      number of nodes where the application is currently deployed on in
                                      the cluster."nThe computation rounds up to tolerate one failure
                                      on small numbers of nodes. Default percentage is zero.
                                    "ServiceTypeHealthPolicyMap": [
                                        {
                                            "Key": "str",  # Required.
                                              The key of the service type health policy map item. This
                                              is the name of the service type.
                                            "Value": {
                "MaxPercentUnhealthyPartitionsPerService": 0,  #
                                                  Optional. The maximum allowed percentage of unhealthy
                                                  partitions per service. Allowed values are Byte
                                                  values from zero to 100"n"nThe percentage represents
                                                  the maximum tolerated percentage of partitions that
                                                  can be unhealthy before the service is considered in
                                                  error."nIf the percentage is respected but there is
                                                  at least one unhealthy partition, the health is
                                                  evaluated as Warning."nThe percentage is calculated
                                                  by dividing the number of unhealthy partitions over
                                                  the total number of partitions in the service."nThe
                                                  computation rounds up to tolerate one failure on
                                                  small numbers of partitions. Default percentage is
                                                  zero.
                "MaxPercentUnhealthyReplicasPerPartition": 0,  #
                                                  Optional. The maximum allowed percentage of unhealthy
                                                  replicas per partition. Allowed values are Byte
                                                  values from zero to 100."n"nThe percentage represents
                                                  the maximum tolerated percentage of replicas that can
                                                  be unhealthy before the partition is considered in
                                                  error."nIf the percentage is respected but there is
                                                  at least one unhealthy replica, the health is
                                                  evaluated as Warning."nThe percentage is calculated
                                                  by dividing the number of unhealthy replicas over the
                                                  total number of replicas in the partition."nThe
                                                  computation rounds up to tolerate one failure on
                                                  small numbers of replicas. Default percentage is
                                                  zero.
                "MaxPercentUnhealthyServices": 0  # Optional. The
                                                  maximum allowed percentage of unhealthy services.
                                                  Allowed values are Byte values from zero to
                                                  100."n"nThe percentage represents the maximum
                                                  tolerated percentage of services that can be
                                                  unhealthy before the application is considered in
                                                  error."nIf the percentage is respected but there is
                                                  at least one unhealthy service, the health is
                                                  evaluated as Warning."nThis is calculated by dividing
                                                  the number of unhealthy services of the specific
                                                  service type over the total number of services of the
                                                  specific service type."nThe computation rounds up to
                                                  tolerate one failure on small numbers of services.
                                                  Default percentage is zero.
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    },
                    "ClusterConfig": "str",  # Required. The cluster configuration as a JSON
                      string. For example, `this file
                      <https://github.com/Azure-Samples/service-fabric-dotnet-standalone-cluster-configuration/blob/master/Samples/ClusterConfig.Unsecure.DevCluster.json>`_
                      contains JSON describing the `nodes and other properties of the cluster
                      <https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-manifest>`_.
                    "HealthCheckRetryTimeout": "PT0H0M0S",  # Optional. Default value is
                      "PT0H0M0S". The length of time between attempts to perform health checks if the
                      application or cluster is not healthy.
                    "HealthCheckStableDurationInSeconds": "PT0H0M0S",  # Optional. Default value
                      is "PT0H0M0S". The length of time that the application or cluster must remain
                      healthy before the upgrade proceeds to the next upgrade domain.
                    "HealthCheckWaitDurationInSeconds": "PT0H0M0S",  # Optional. Default value is
                      "PT0H0M0S". The length of time to wait after completing an upgrade domain before
                      starting the health checks process.
                    "MaxPercentDeltaUnhealthyNodes": 0,  # Optional. The maximum allowed
                      percentage of delta health degradation during the upgrade. Allowed values are
                      integer values from zero to 100.
                    "MaxPercentUnhealthyApplications": 0,  # Optional. The maximum allowed
                      percentage of unhealthy applications during the upgrade. Allowed values are
                      integer values from zero to 100.
                    "MaxPercentUnhealthyNodes": 0,  # Optional. The maximum allowed percentage of
                      unhealthy nodes during the upgrade. Allowed values are integer values from zero
                      to 100.
                    "MaxPercentUpgradeDomainDeltaUnhealthyNodes": 0,  # Optional. The maximum
                      allowed percentage of upgrade domain delta health degradation during the upgrade.
                      Allowed values are integer values from zero to 100.
                    "UpgradeDomainTimeoutInSeconds": "PT0H0M0S",  # Optional. Default value is
                      "PT0H0M0S". The timeout for the upgrade domain.
                    "UpgradeTimeoutInSeconds": "PT0H0M0S"  # Optional. Default value is
                      "PT0H0M0S". The upgrade timeout.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = cluster_configuration_upgrade_description

        request = build_start_cluster_configuration_upgrade_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def update_cluster_upgrade(  # pylint: disable=inconsistent-return-statements
        self,
        update_cluster_upgrade_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Update the upgrade parameters of a Service Fabric cluster upgrade.

        Update the upgrade parameters used during a Service Fabric cluster upgrade.

        :param update_cluster_upgrade_description: Parameters for updating a cluster upgrade.
        :type update_cluster_upgrade_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                update_cluster_upgrade_description = {
                    "ApplicationHealthPolicyMap": {
                        "ApplicationHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the application
                                  health policy map item. This is the name of the application.
                                "Value": {
                                    "ConsiderWarningAsError": bool,  # Optional.
                                      Indicates whether warnings are treated with the same severity as
                                      errors.
                                    "DefaultServiceTypeHealthPolicy": {
                "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional.
                                          The maximum allowed percentage of unhealthy partitions per
                                          service. Allowed values are Byte values from zero to
                                          100"n"nThe percentage represents the maximum tolerated
                                          percentage of partitions that can be unhealthy before the
                                          service is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy partition, the
                                          health is evaluated as Warning."nThe percentage is calculated
                                          by dividing the number of unhealthy partitions over the total
                                          number of partitions in the service."nThe computation rounds
                                          up to tolerate one failure on small numbers of partitions.
                                          Default percentage is zero.
                "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional.
                                          The maximum allowed percentage of unhealthy replicas per
                                          partition. Allowed values are Byte values from zero to
                                          100."n"nThe percentage represents the maximum tolerated
                                          percentage of replicas that can be unhealthy before the
                                          partition is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy replica, the
                                          health is evaluated as Warning."nThe percentage is calculated
                                          by dividing the number of unhealthy replicas over the total
                                          number of replicas in the partition."nThe computation rounds
                                          up to tolerate one failure on small numbers of replicas.
                                          Default percentage is zero.
                                        "MaxPercentUnhealthyServices": 0  #
                                          Optional. The maximum allowed percentage of unhealthy
                                          services. Allowed values are Byte values from zero to
                                          100."n"nThe percentage represents the maximum tolerated
                                          percentage of services that can be unhealthy before the
                                          application is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy service, the
                                          health is evaluated as Warning."nThis is calculated by
                                          dividing the number of unhealthy services of the specific
                                          service type over the total number of services of the
                                          specific service type."nThe computation rounds up to tolerate
                                          one failure on small numbers of services. Default percentage
                                          is zero.
                                    },
                                    "MaxPercentUnhealthyDeployedApplications": 0,
                                      # Optional. The maximum allowed percentage of unhealthy deployed
                                      applications. Allowed values are Byte values from zero to
                                      100."nThe percentage represents the maximum tolerated percentage
                                      of deployed applications that can be unhealthy before the
                                      application is considered in error."nThis is calculated by
                                      dividing the number of unhealthy deployed applications over the
                                      number of nodes where the application is currently deployed on in
                                      the cluster."nThe computation rounds up to tolerate one failure
                                      on small numbers of nodes. Default percentage is zero.
                                    "ServiceTypeHealthPolicyMap": [
                                        {
                                            "Key": "str",  # Required.
                                              The key of the service type health policy map item. This
                                              is the name of the service type.
                                            "Value": {
                "MaxPercentUnhealthyPartitionsPerService": 0,  #
                                                  Optional. The maximum allowed percentage of unhealthy
                                                  partitions per service. Allowed values are Byte
                                                  values from zero to 100"n"nThe percentage represents
                                                  the maximum tolerated percentage of partitions that
                                                  can be unhealthy before the service is considered in
                                                  error."nIf the percentage is respected but there is
                                                  at least one unhealthy partition, the health is
                                                  evaluated as Warning."nThe percentage is calculated
                                                  by dividing the number of unhealthy partitions over
                                                  the total number of partitions in the service."nThe
                                                  computation rounds up to tolerate one failure on
                                                  small numbers of partitions. Default percentage is
                                                  zero.
                "MaxPercentUnhealthyReplicasPerPartition": 0,  #
                                                  Optional. The maximum allowed percentage of unhealthy
                                                  replicas per partition. Allowed values are Byte
                                                  values from zero to 100."n"nThe percentage represents
                                                  the maximum tolerated percentage of replicas that can
                                                  be unhealthy before the partition is considered in
                                                  error."nIf the percentage is respected but there is
                                                  at least one unhealthy replica, the health is
                                                  evaluated as Warning."nThe percentage is calculated
                                                  by dividing the number of unhealthy replicas over the
                                                  total number of replicas in the partition."nThe
                                                  computation rounds up to tolerate one failure on
                                                  small numbers of replicas. Default percentage is
                                                  zero.
                "MaxPercentUnhealthyServices": 0  # Optional. The
                                                  maximum allowed percentage of unhealthy services.
                                                  Allowed values are Byte values from zero to
                                                  100."n"nThe percentage represents the maximum
                                                  tolerated percentage of services that can be
                                                  unhealthy before the application is considered in
                                                  error."nIf the percentage is respected but there is
                                                  at least one unhealthy service, the health is
                                                  evaluated as Warning."nThis is calculated by dividing
                                                  the number of unhealthy services of the specific
                                                  service type over the total number of services of the
                                                  specific service type."nThe computation rounds up to
                                                  tolerate one failure on small numbers of services.
                                                  Default percentage is zero.
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    },
                    "ClusterHealthPolicy": {
                        "ApplicationTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the application
                                  type health policy map item. This is the name of the application
                                  type.
                                "Value": 0  # Required. The value of the application
                                  type health policy map item."nThe max percent unhealthy applications
                                  allowed for the application type. Must be between zero and 100.
                            }
                        ],
                        "ConsiderWarningAsError": bool,  # Optional. Indicates whether
                          warnings are treated with the same severity as errors.
                        "MaxPercentUnhealthyApplications": 0,  # Optional. The maximum
                          allowed percentage of unhealthy applications before reporting an error. For
                          example, to allow 10% of applications to be unhealthy, this value would be
                          10."n"nThe percentage represents the maximum tolerated percentage of
                          applications that can be unhealthy before the cluster is considered in
                          error."nIf the percentage is respected but there is at least one unhealthy
                          application, the health is evaluated as Warning."nThis is calculated by
                          dividing the number of unhealthy applications over the total number of
                          application instances in the cluster, excluding applications of application
                          types that are included in the ApplicationTypeHealthPolicyMap."nThe
                          computation rounds up to tolerate one failure on small numbers of
                          applications. Default percentage is zero.
                        "MaxPercentUnhealthyNodes": 0,  # Optional. The maximum allowed
                          percentage of unhealthy nodes before reporting an error. For example, to
                          allow 10% of nodes to be unhealthy, this value would be 10."n"nThe percentage
                          represents the maximum tolerated percentage of nodes that can be unhealthy
                          before the cluster is considered in error."nIf the percentage is respected
                          but there is at least one unhealthy node, the health is evaluated as
                          Warning."nThe percentage is calculated by dividing the number of unhealthy
                          nodes over the total number of nodes in the cluster."nThe computation rounds
                          up to tolerate one failure on small numbers of nodes. Default percentage is
                          zero."n"nIn large clusters, some nodes will always be down or out for
                          repairs, so this percentage should be configured to tolerate that.
                        "NodeTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the node type
                                  health policy map item. This is the name of the node type.
                                "Value": 0  # Required. The value of the node type
                                  health policy map item."nIf the percentage is respected but there is
                                  at least one unhealthy node in the node type, the health is evaluated
                                  as Warning. "nThe percentage is calculated by dividing the number of
                                  unhealthy nodes over the total number of nodes in the node type.
                                  "nThe computation rounds up to tolerate one failure on small numbers
                                  of nodes."nThe max percent unhealthy nodes allowed for the node type.
                                  Must be between zero and 100.
                            }
                        ]
                    },
                    "ClusterUpgradeHealthPolicy": {
                        "MaxPercentDeltaUnhealthyNodes": 0,  # Optional. The maximum allowed
                          percentage of nodes health degradation allowed during cluster upgrades. The
                          delta is measured between the state of the nodes at the beginning of upgrade
                          and the state of the nodes at the time of the health evaluation. The check is
                          performed after every upgrade domain upgrade completion to make sure the
                          global state of the cluster is within tolerated limits. The default value is
                          10%.
                        "MaxPercentUpgradeDomainDeltaUnhealthyNodes": 0  # Optional. The
                          maximum allowed percentage of upgrade domain nodes health degradation allowed
                          during cluster upgrades. The delta is measured between the state of the
                          upgrade domain nodes at the beginning of upgrade and the state of the upgrade
                          domain nodes at the time of the health evaluation. The check is performed
                          after every upgrade domain upgrade completion for all completed upgrade
                          domains to make sure the state of the upgrade domains is within tolerated
                          limits. The default value is 15%.
                    },
                    "EnableDeltaHealthEvaluation": bool,  # Optional. When true, enables delta
                      health evaluation rather than absolute health evaluation after completion of each
                      upgrade domain.
                    "UpdateDescription": {
                        "FailureAction": "str",  # Optional. The compensating action to
                          perform when a Monitored upgrade encounters monitoring policy or health
                          policy violations."nInvalid indicates the failure action is invalid. Rollback
                          specifies that the upgrade will start rolling back automatically."nManual
                          indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
                          Known values are: "Invalid", "Rollback", "Manual".
                        "ForceRestart": bool,  # Optional. If true, then processes are
                          forcefully restarted during upgrade even when the code version has not
                          changed (the upgrade only changes configuration or data).
                        "HealthCheckRetryTimeoutInMilliseconds": "PT0H10M0S",  # Optional.
                          Default value is "PT0H10M0S". The amount of time to retry health evaluation
                          when the application or cluster is unhealthy before FailureAction is
                          executed. It is first interpreted as a string representing an ISO 8601
                          duration. If that fails, then it is interpreted as a number representing the
                          total number of milliseconds.
                        "HealthCheckStableDurationInMilliseconds": "PT0H2M0S",  # Optional.
                          Default value is "PT0H2M0S". The amount of time that the application or
                          cluster must remain healthy before the upgrade proceeds to the next upgrade
                          domain. It is first interpreted as a string representing an ISO 8601
                          duration. If that fails, then it is interpreted as a number representing the
                          total number of milliseconds.
                        "HealthCheckWaitDurationInMilliseconds": "0",  # Optional. Default
                          value is "0". The amount of time to wait after completing an upgrade domain
                          before applying health policies. It is first interpreted as a string
                          representing an ISO 8601 duration. If that fails, then it is interpreted as a
                          number representing the total number of milliseconds.
                        "InstanceCloseDelayDurationInSeconds": 4294967295,  # Optional.
                          Default value is 4294967295. Duration in seconds, to wait before a stateless
                          instance is closed, to allow the active requests to drain gracefully. This
                          would be effective when the instance is closing during the
                          application/cluster"nupgrade, only for those instances which have a non-zero
                          delay duration configured in the service description. See
                          InstanceCloseDelayDurationSeconds property in $ref:
                          "#/definitions/StatelessServiceDescription.yaml" for details."nNote, the
                          default value of InstanceCloseDelayDurationInSeconds is 4294967295, which
                          indicates that the behavior will entirely depend on the delay configured in
                          the stateless service description.
                        "ReplicaSetCheckTimeoutInMilliseconds": 42949672925,  # Optional.
                          Default value is 42949672925. The maximum amount of time to block processing
                          of an upgrade domain and prevent loss of availability when there are
                          unexpected issues. When this timeout expires, processing of the upgrade
                          domain will proceed regardless of availability loss issues. The timeout is
                          reset at the start of each upgrade domain. Valid values are between 0 and
                          42949672925 inclusive. (unsigned 32-bit integer).
                        "RollingUpgradeMode": "UnmonitoredAuto",  # Default value is
                          "UnmonitoredAuto". Required. The mode used to monitor health during a rolling
                          upgrade. The values are UnmonitoredAuto, UnmonitoredManual, Monitored, and
                          UnmonitoredDeferred. Known values are: "Invalid", "UnmonitoredAuto",
                          "UnmonitoredManual", "Monitored", "UnmonitoredDeferred". Default value:
                          "UnmonitoredAuto".
                        "UpgradeDomainTimeoutInMilliseconds": "P10675199DT02H48M05.4775807S",
                          # Optional. Default value is "P10675199DT02H48M05.4775807S". The amount of
                          time each upgrade domain has to complete before FailureAction is executed. It
                          is first interpreted as a string representing an ISO 8601 duration. If that
                          fails, then it is interpreted as a number representing the total number of
                          milliseconds.
                        "UpgradeTimeoutInMilliseconds": "P10675199DT02H48M05.4775807S"  #
                          Optional. Default value is "P10675199DT02H48M05.4775807S". The amount of time
                          the overall upgrade has to complete before FailureAction is executed. It is
                          first interpreted as a string representing an ISO 8601 duration. If that
                          fails, then it is interpreted as a number representing the total number of
                          milliseconds.
                    },
                    "UpgradeKind": "Rolling"  # Optional. Default value is "Rolling". The type of
                      upgrade out of the following possible values. Known values are: "Invalid",
                      "Rolling", "Rolling_ForceRestart". Default value: "Rolling".
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = update_cluster_upgrade_description

        request = build_update_cluster_upgrade_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_aad_metadata(
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the Azure Active Directory metadata used for secured connection to cluster.

        Gets the Azure Active Directory metadata used for secured connection to cluster.
        This API is not supposed to be called separately. It provides information needed to set up an
        Azure Active Directory secured connection with a Service Fabric cluster.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "metadata": {
                        "authority": "str",  # Optional. The AAD authority url.
                        "client": "str",  # Optional. The AAD client application Id.
                        "cluster": "str",  # Optional. The AAD cluster application Id.
                        "login": "str",  # Optional. The AAD login url.
                        "redirect": "str",  # Optional. The client application redirect
                          address.
                        "tenant": "str"  # Optional. The AAD tenant Id.
                    },
                    "type": "str"  # Optional. The client authentication method.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_aad_metadata_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_cluster_version(
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Get the current Service Fabric cluster version.

        If a cluster upgrade is happening, then this API will return the lowest (older) version of the
        current and target cluster runtime versions.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Version": "str"  # Optional. The Service Fabric cluster runtime version.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_cluster_version_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_cluster_load(
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the load of a Service Fabric cluster.

        Retrieves the load information of a Service Fabric cluster for all the metrics that have load
        or capacity defined.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "LastBalancingEndTimeUtc": "2020-02-20 00:00:00",  # Optional. The end time
                      of last resource balancing run.
                    "LastBalancingStartTimeUtc": "2020-02-20 00:00:00",  # Optional. The starting
                      time of last resource balancing run.
                    "LoadMetricInformation": [
                        {
                            "Action": "str",  # Optional. The current action being taken
                              with regard to this metric.
                            "ActivityThreshold": "str",  # Optional. The Activity
                              Threshold specified for this metric in the system Cluster Manifest.
                            "BalancingThreshold": "str",  # Optional. The balancing
                              threshold for a certain metric.
                            "BufferedClusterCapacityRemaining": "str",  # Optional.
                              Remaining capacity in the cluster excluding the reserved space.
                            "ClusterBufferedCapacity": "str",  # Optional. Remaining
                              capacity in the cluster excluding the reserved space. In future releases
                              of Service Fabric this parameter will be deprecated in favor of
                              BufferedClusterCapacityRemaining.
                            "ClusterCapacity": "str",  # Optional. The total cluster
                              capacity for a given metric.
                            "ClusterCapacityRemaining": "str",  # Optional. The remaining
                              capacity for the metric in the cluster.
                            "ClusterLoad": "str",  # Optional. The total cluster load. In
                              future releases of Service Fabric this parameter will be deprecated in
                              favor of CurrentClusterLoad.
                            "ClusterRemainingBufferedCapacity": "str",  # Optional. The
                              remaining percentage of cluster total capacity for this metric.
                            "ClusterRemainingCapacity": "str",  # Optional. The remaining
                              capacity for the metric in the cluster. In future releases of Service
                              Fabric this parameter will be deprecated in favor of
                              ClusterCapacityRemaining.
                            "CurrentClusterLoad": "str",  # Optional. The total cluster
                              load.
                            "DeviationAfter": "str",  # Optional. The standard average
                              deviation of the metrics after resource balancer run.
                            "DeviationBefore": "str",  # Optional. The standard average
                              deviation of the metrics before resource balancer run.
                            "IsBalancedAfter": bool,  # Optional. Value that indicates
                              whether the metrics is balanced or not after resource balancer run.
                            "IsBalancedBefore": bool,  # Optional. Value that indicates
                              whether the metrics is balanced or not before resource balancer run.
                            "IsClusterCapacityViolation": bool,  # Optional. Indicates
                              that the metric is currently over capacity in the cluster.
                            "MaxNodeLoadNodeId": {
                                "Id": "str"  # Optional. Value of the node Id. This
                                  is a 128 bit integer.
                            },
                            "MaxNodeLoadValue": "str",  # Optional. The maximum load on
                              any node for this metric. In future releases of Service Fabric this
                              parameter will be deprecated in favor of MaximumNodeLoad.
                            "MaximumNodeLoad": "str",  # Optional. The maximum load on
                              any node for this metric.
                            "MinNodeLoadNodeId": {
                                "Id": "str"  # Optional. Value of the node Id. This
                                  is a 128 bit integer.
                            },
                            "MinNodeLoadValue": "str",  # Optional. The minimum load on
                              any node for this metric. In future releases of Service Fabric this
                              parameter will be deprecated in favor of MinimumNodeLoad.
                            "MinimumNodeLoad": "str",  # Optional. The minimum load on
                              any node for this metric.
                            "Name": "str",  # Optional. Name of the metric for which this
                              load information is provided.
                            "NodeBufferPercentage": "str",  # Optional. The reserved
                              percentage of total node capacity for this metric.
                            "PlannedLoadRemoval": "str"  # Optional. This value
                              represents the load of the replicas that are planned to be removed in the
                              future within the cluster."nThis kind of load is reported for replicas
                              that are currently being moving to other nodes and for replicas that are
                              currently being dropped but still use the load on the source node.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_cluster_load_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def toggle_verbose_service_placement_health_reporting(  # pylint: disable=inconsistent-return-statements
        self,
        *,
        enabled: bool,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Changes the verbosity of service placement health reporting.

        If verbosity is set to true, then detailed health reports will be generated when replicas
        cannot be placed or dropped.
        If verbosity is set to false, then no health reports will be generated when replicas cannot be
        placed or dropped.

        :keyword enabled: The verbosity of service placement health reporting.
        :paramtype enabled: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_toggle_verbose_service_placement_health_reporting_request(
            api_version=api_version,
            enabled=enabled,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def validate_cluster_upgrade(
        self,
        start_cluster_upgrade_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Validate and assess the impact of a code or configuration version update of a Service Fabric
        cluster.

        Validate the supplied upgrade parameters and assess the expected impact of a code or
        configuration version upgrade of a Service Fabric cluster. The upgrade will not be initiated.

        :param start_cluster_upgrade_description: Describes the parameters for starting a cluster
         upgrade.
        :type start_cluster_upgrade_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '8.2'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "8.2". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                start_cluster_upgrade_description = {
                    "ApplicationHealthPolicyMap": {
                        "ApplicationHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the application
                                  health policy map item. This is the name of the application.
                                "Value": {
                                    "ConsiderWarningAsError": bool,  # Optional.
                                      Indicates whether warnings are treated with the same severity as
                                      errors.
                                    "DefaultServiceTypeHealthPolicy": {
                "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional.
                                          The maximum allowed percentage of unhealthy partitions per
                                          service. Allowed values are Byte values from zero to
                                          100"n"nThe percentage represents the maximum tolerated
                                          percentage of partitions that can be unhealthy before the
                                          service is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy partition, the
                                          health is evaluated as Warning."nThe percentage is calculated
                                          by dividing the number of unhealthy partitions over the total
                                          number of partitions in the service."nThe computation rounds
                                          up to tolerate one failure on small numbers of partitions.
                                          Default percentage is zero.
                "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional.
                                          The maximum allowed percentage of unhealthy replicas per
                                          partition. Allowed values are Byte values from zero to
                                          100."n"nThe percentage represents the maximum tolerated
                                          percentage of replicas that can be unhealthy before the
                                          partition is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy replica, the
                                          health is evaluated as Warning."nThe percentage is calculated
                                          by dividing the number of unhealthy replicas over the total
                                          number of replicas in the partition."nThe computation rounds
                                          up to tolerate one failure on small numbers of replicas.
                                          Default percentage is zero.
                                        "MaxPercentUnhealthyServices": 0  #
                                          Optional. The maximum allowed percentage of unhealthy
                                          services. Allowed values are Byte values from zero to
                                          100."n"nThe percentage represents the maximum tolerated
                                          percentage of services that can be unhealthy before the
                                          application is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy service, the
                                          health is evaluated as Warning."nThis is calculated by
                                          dividing the number of unhealthy services of the specific
                                          service type over the total number of services of the
                                          specific service type."nThe computation rounds up to tolerate
                                          one failure on small numbers of services. Default percentage
                                          is zero.
                                    },
                                    "MaxPercentUnhealthyDeployedApplications": 0,
                                      # Optional. The maximum allowed percentage of unhealthy deployed
                                      applications. Allowed values are Byte values from zero to
                                      100."nThe percentage represents the maximum tolerated percentage
                                      of deployed applications that can be unhealthy before the
                                      application is considered in error."nThis is calculated by
                                      dividing the number of unhealthy deployed applications over the
                                      number of nodes where the application is currently deployed on in
                                      the cluster."nThe computation rounds up to tolerate one failure
                                      on small numbers of nodes. Default percentage is zero.
                                    "ServiceTypeHealthPolicyMap": [
                                        {
                                            "Key": "str",  # Required.
                                              The key of the service type health policy map item. This
                                              is the name of the service type.
                                            "Value": {
                "MaxPercentUnhealthyPartitionsPerService": 0,  #
                                                  Optional. The maximum allowed percentage of unhealthy
                                                  partitions per service. Allowed values are Byte
                                                  values from zero to 100"n"nThe percentage represents
                                                  the maximum tolerated percentage of partitions that
                                                  can be unhealthy before the service is considered in
                                                  error."nIf the percentage is respected but there is
                                                  at least one unhealthy partition, the health is
                                                  evaluated as Warning."nThe percentage is calculated
                                                  by dividing the number of unhealthy partitions over
                                                  the total number of partitions in the service."nThe
                                                  computation rounds up to tolerate one failure on
                                                  small numbers of partitions. Default percentage is
                                                  zero.
                "MaxPercentUnhealthyReplicasPerPartition": 0,  #
                                                  Optional. The maximum allowed percentage of unhealthy
                                                  replicas per partition. Allowed values are Byte
                                                  values from zero to 100."n"nThe percentage represents
                                                  the maximum tolerated percentage of replicas that can
                                                  be unhealthy before the partition is considered in
                                                  error."nIf the percentage is respected but there is
                                                  at least one unhealthy replica, the health is
                                                  evaluated as Warning."nThe percentage is calculated
                                                  by dividing the number of unhealthy replicas over the
                                                  total number of replicas in the partition."nThe
                                                  computation rounds up to tolerate one failure on
                                                  small numbers of replicas. Default percentage is
                                                  zero.
                "MaxPercentUnhealthyServices": 0  # Optional. The
                                                  maximum allowed percentage of unhealthy services.
                                                  Allowed values are Byte values from zero to
                                                  100."n"nThe percentage represents the maximum
                                                  tolerated percentage of services that can be
                                                  unhealthy before the application is considered in
                                                  error."nIf the percentage is respected but there is
                                                  at least one unhealthy service, the health is
                                                  evaluated as Warning."nThis is calculated by dividing
                                                  the number of unhealthy services of the specific
                                                  service type over the total number of services of the
                                                  specific service type."nThe computation rounds up to
                                                  tolerate one failure on small numbers of services.
                                                  Default percentage is zero.
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    },
                    "ClusterHealthPolicy": {
                        "ApplicationTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the application
                                  type health policy map item. This is the name of the application
                                  type.
                                "Value": 0  # Required. The value of the application
                                  type health policy map item."nThe max percent unhealthy applications
                                  allowed for the application type. Must be between zero and 100.
                            }
                        ],
                        "ConsiderWarningAsError": bool,  # Optional. Indicates whether
                          warnings are treated with the same severity as errors.
                        "MaxPercentUnhealthyApplications": 0,  # Optional. The maximum
                          allowed percentage of unhealthy applications before reporting an error. For
                          example, to allow 10% of applications to be unhealthy, this value would be
                          10."n"nThe percentage represents the maximum tolerated percentage of
                          applications that can be unhealthy before the cluster is considered in
                          error."nIf the percentage is respected but there is at least one unhealthy
                          application, the health is evaluated as Warning."nThis is calculated by
                          dividing the number of unhealthy applications over the total number of
                          application instances in the cluster, excluding applications of application
                          types that are included in the ApplicationTypeHealthPolicyMap."nThe
                          computation rounds up to tolerate one failure on small numbers of
                          applications. Default percentage is zero.
                        "MaxPercentUnhealthyNodes": 0,  # Optional. The maximum allowed
                          percentage of unhealthy nodes before reporting an error. For example, to
                          allow 10% of nodes to be unhealthy, this value would be 10."n"nThe percentage
                          represents the maximum tolerated percentage of nodes that can be unhealthy
                          before the cluster is considered in error."nIf the percentage is respected
                          but there is at least one unhealthy node, the health is evaluated as
                          Warning."nThe percentage is calculated by dividing the number of unhealthy
                          nodes over the total number of nodes in the cluster."nThe computation rounds
                          up to tolerate one failure on small numbers of nodes. Default percentage is
                          zero."n"nIn large clusters, some nodes will always be down or out for
                          repairs, so this percentage should be configured to tolerate that.
                        "NodeTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the node type
                                  health policy map item. This is the name of the node type.
                                "Value": 0  # Required. The value of the node type
                                  health policy map item."nIf the percentage is respected but there is
                                  at least one unhealthy node in the node type, the health is evaluated
                                  as Warning. "nThe percentage is calculated by dividing the number of
                                  unhealthy nodes over the total number of nodes in the node type.
                                  "nThe computation rounds up to tolerate one failure on small numbers
                                  of nodes."nThe max percent unhealthy nodes allowed for the node type.
                                  Must be between zero and 100.
                            }
                        ]
                    },
                    "ClusterUpgradeHealthPolicy": {
                        "MaxPercentDeltaUnhealthyNodes": 0,  # Optional. The maximum allowed
                          percentage of nodes health degradation allowed during cluster upgrades. The
                          delta is measured between the state of the nodes at the beginning of upgrade
                          and the state of the nodes at the time of the health evaluation. The check is
                          performed after every upgrade domain upgrade completion to make sure the
                          global state of the cluster is within tolerated limits. The default value is
                          10%.
                        "MaxPercentUpgradeDomainDeltaUnhealthyNodes": 0  # Optional. The
                          maximum allowed percentage of upgrade domain nodes health degradation allowed
                          during cluster upgrades. The delta is measured between the state of the
                          upgrade domain nodes at the beginning of upgrade and the state of the upgrade
                          domain nodes at the time of the health evaluation. The check is performed
                          after every upgrade domain upgrade completion for all completed upgrade
                          domains to make sure the state of the upgrade domains is within tolerated
                          limits. The default value is 15%.
                    },
                    "CodeVersion": "str",  # Optional. The cluster code version.
                    "ConfigVersion": "str",  # Optional. The cluster configuration version.
                    "EnableDeltaHealthEvaluation": bool,  # Optional. When true, enables delta
                      health evaluation rather than absolute health evaluation after completion of each
                      upgrade domain.
                    "ForceRestart": bool,  # Optional. If true, then processes are forcefully
                      restarted during upgrade even when the code version has not changed (the upgrade
                      only changes configuration or data).
                    "InstanceCloseDelayDurationInSeconds": 4294967295,  # Optional. Default value
                      is 4294967295. Duration in seconds, to wait before a stateless instance is
                      closed, to allow the active requests to drain gracefully. This would be effective
                      when the instance is closing during the application/cluster"nupgrade, only for
                      those instances which have a non-zero delay duration configured in the service
                      description. See InstanceCloseDelayDurationSeconds property in $ref:
                      "#/definitions/StatelessServiceDescription.yaml" for details."nNote, the default
                      value of InstanceCloseDelayDurationInSeconds is 4294967295, which indicates that
                      the behavior will entirely depend on the delay configured in the stateless
                      service description.
                    "MonitoringPolicy": {
                        "FailureAction": "str",  # Optional. The compensating action to
                          perform when a Monitored upgrade encounters monitoring policy or health
                          policy violations."nInvalid indicates the failure action is invalid. Rollback
                          specifies that the upgrade will start rolling back automatically."nManual
                          indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
                          Known values are: "Invalid", "Rollback", "Manual".
                        "HealthCheckRetryTimeoutInMilliseconds": "PT0H10M0S",  # Optional.
                          Default value is "PT0H10M0S". The amount of time to retry health evaluation
                          when the application or cluster is unhealthy before FailureAction is
                          executed. It is first interpreted as a string representing an ISO 8601
                          duration. If that fails, then it is interpreted as a number representing the
                          total number of milliseconds.
                        "HealthCheckStableDurationInMilliseconds": "PT0H2M0S",  # Optional.
                          Default value is "PT0H2M0S". The amount of time that the application or
                          cluster must remain healthy before the upgrade proceeds to the next upgrade
                          domain. It is first interpreted as a string representing an ISO 8601
                          duration. If that fails, then it is interpreted as a number representing the
                          total number of milliseconds.
                        "HealthCheckWaitDurationInMilliseconds": "0",  # Optional. Default
                          value is "0". The amount of time to wait after completing an upgrade domain
                          before applying health policies. It is first interpreted as a string
                          representing an ISO 8601 duration. If that fails, then it is interpreted as a
                          number representing the total number of milliseconds.
                        "UpgradeDomainTimeoutInMilliseconds": "P10675199DT02H48M05.4775807S",
                          # Optional. Default value is "P10675199DT02H48M05.4775807S". The amount of
                          time each upgrade domain has to complete before FailureAction is executed. It
                          is first interpreted as a string representing an ISO 8601 duration. If that
                          fails, then it is interpreted as a number representing the total number of
                          milliseconds.
                        "UpgradeTimeoutInMilliseconds": "P10675199DT02H48M05.4775807S"  #
                          Optional. Default value is "P10675199DT02H48M05.4775807S". The amount of time
                          the overall upgrade has to complete before FailureAction is executed. It is
                          first interpreted as a string representing an ISO 8601 duration. If that
                          fails, then it is interpreted as a number representing the total number of
                          milliseconds.
                    },
                    "RollingUpgradeMode": "UnmonitoredAuto",  # Optional. Default value is
                      "UnmonitoredAuto". The mode used to monitor health during a rolling upgrade. The
                      values are UnmonitoredAuto, UnmonitoredManual, Monitored, and
                      UnmonitoredDeferred. Known values are: "Invalid", "UnmonitoredAuto",
                      "UnmonitoredManual", "Monitored", "UnmonitoredDeferred". Default value:
                      "UnmonitoredAuto".
                    "SortOrder": "Default",  # Optional. Default value is "Default". Defines the
                      order in which an upgrade proceeds through the cluster. Known values are:
                      "Invalid", "Default", "Numeric", "Lexicographical", "ReverseNumeric",
                      "ReverseLexicographical". Default value: "Default".
                    "UpgradeKind": "Rolling",  # Optional. Default value is "Rolling". The kind
                      of upgrade out of the following possible values. Known values are: "Invalid",
                      "Rolling". Default value: "Rolling".
                    "UpgradeReplicaSetCheckTimeoutInSeconds": 42949672925  # Optional. Default
                      value is 42949672925. The maximum amount of time to block processing of an
                      upgrade domain and prevent loss of availability when there are unexpected issues.
                      When this timeout expires, processing of the upgrade domain will proceed
                      regardless of availability loss issues. The timeout is reset at the start of each
                      upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
                      32-bit integer).
                }

                # response body for status code(s): 200
                response.json() == {
                    "ServiceHostUpgradeImpact": "str",  # Optional. The expected impact of the
                      upgrade. Known values are: "Invalid", "None", "ServiceHostRestart",
                      "UnexpectedServiceHostRestart".
                    "ValidationDetails": "str"  # Optional. A string containing additional
                      details for the Fabric upgrade validation result.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "8.2"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = start_cluster_upgrade_description

        request = build_validate_cluster_upgrade_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_node_info_list(
        self,
        *,
        continuation_token_parameter: Optional[str] = None,
        node_status_filter: Optional[str] = "default",
        max_results: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the list of nodes in the Service Fabric cluster.

        The response includes the name, status, ID, health, uptime, and other details about the nodes.

        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword node_status_filter: Allows filtering the nodes based on the NodeStatus. Only the nodes
         that are matching the specified filter value will be returned. The filter value can be one of
         the following. Known values are: "default", "all", "up", "down", "enabling", "disabling",
         "disabled", "unknown", and "removed". Default value is "default".
        :paramtype node_status_filter: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.3'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.3". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "CodeVersion": "str",  # Optional. The version of Service
                              Fabric binaries that the node is running.
                            "ConfigVersion": "str",  # Optional. The version of Service
                              Fabric cluster manifest that the node is using.
                            "FaultDomain": "str",  # Optional. The fault domain of the
                              node.
                            "HealthState": "str",  # Optional. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "Id": {
                                "Id": "str"  # Optional. Value of the node Id. This
                                  is a 128 bit integer.
                            },
                            "InfrastructurePlacementID": "str",  # Optional. PlacementID
                              used by the InfrastructureService.
                            "InstanceId": "str",  # Optional. The ID representing the
                              node instance. While the ID of the node is deterministically generated
                              from the node name and remains same across restarts, the InstanceId
                              changes every time node restarts.
                            "IpAddressOrFQDN": "str",  # Optional. The IP address or
                              fully qualified domain name of the node.
                            "IsNodeByNodeUpgradeInProgress": bool,  # Optional. Indicates
                              if a node-by-node upgrade is currently being performed on this node.
                            "IsSeedNode": bool,  # Optional. Indicates if the node is a
                              seed node or not. Returns true if the node is a seed node, otherwise
                              false. A quorum of seed nodes are required for proper operation of
                              Service Fabric cluster.
                            "IsStopped": bool,  # Optional. Indicates if the node is
                              stopped by calling stop node API or not. Returns true if the node is
                              stopped, otherwise false.
                            "Name": "str",  # Optional. The name of a Service Fabric
                              node.
                            "NodeDeactivationInfo": {
                                "NodeDeactivationIntent": "str",  # Optional. The
                                  intent or the reason for deactivating the node. Following are the
                                  possible values for it. Known values are: "Invalid", "Pause",
                                  "Restart", "RemoveData", "RemoveNode".
                                "NodeDeactivationStatus": "str",  # Optional. The
                                  status of node deactivation operation. Following are the possible
                                  values. Known values are: "None", "SafetyCheckInProgress",
                                  "SafetyCheckComplete", "Completed".
                                "NodeDeactivationTask": [
                                    {
                                        "NodeDeactivationIntent": "str",  #
                                          Optional. The intent or the reason for deactivating the node.
                                          Following are the possible values for it. Known values are:
                                          "Invalid", "Pause", "Restart", "RemoveData", "RemoveNode".
                                        "NodeDeactivationTaskId": {
                                            "Id": "str",  # Optional.
                                              Value of the task id.
                                            "NodeDeactivationTaskType":
                                              "str"  # Optional. The type of the task that performed
                                              the node deactivation. Following are the possible values.
                                              Known values are: "Invalid", "Infrastructure", "Repair",
                                              "Client".
                                        }
                                    }
                                ],
                                "PendingSafetyChecks": [
                                    {
                                        "SafetyCheck": {
                                            Kind: Kind
                                        }
                                    }
                                ]
                            },
                            "NodeDownAt": "2020-02-20 00:00:00",  # Optional. Date time
                              in UTC when the node went down. If node has never been down then this
                              value will be zero date time.
                            "NodeDownTimeInSeconds": "str",  # Optional. Time in seconds
                              since the node has been in NodeStatus Down. Value zero indicates node is
                              not NodeStatus Down.
                            "NodeStatus": "str",  # Optional. The status of the node.
                              Known values are: "Invalid", "Up", "Down", "Enabling", "Disabling",
                              "Disabled", "Unknown", "Removed".
                            "NodeTags": [
                                "str"  # Optional. List that contains tags, which
                                  will be applied to the nodes.
                            ],
                            "NodeUpAt": "2020-02-20 00:00:00",  # Optional. Date time in
                              UTC when the node came up. If the node has never been up then this value
                              will be zero date time.
                            "NodeUpTimeInSeconds": "str",  # Optional. Time in seconds
                              since the node has been in NodeStatus Up. Value zero indicates that the
                              node is not Up.
                            "Type": "str",  # Optional. The type of the node.
                            "UpgradeDomain": "str"  # Optional. The upgrade domain of the
                              node.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.3"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_node_info_list_request(
            api_version=api_version,
            continuation_token_parameter=continuation_token_parameter,
            node_status_filter=node_status_filter,
            max_results=max_results,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_node_info(
        self,
        node_name: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Gets the information about a specific node in the Service Fabric cluster.

        The response includes the name, status, ID, health, uptime, and other details about the node.

        :param node_name: The name of the node.
        :type node_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "CodeVersion": "str",  # Optional. The version of Service Fabric binaries
                      that the node is running.
                    "ConfigVersion": "str",  # Optional. The version of Service Fabric cluster
                      manifest that the node is using.
                    "FaultDomain": "str",  # Optional. The fault domain of the node.
                    "HealthState": "str",  # Optional. The health state of a Service Fabric
                      entity such as Cluster, Node, Application, Service, Partition, Replica etc. Known
                      values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "Id": {
                        "Id": "str"  # Optional. Value of the node Id. This is a 128 bit
                          integer.
                    },
                    "InfrastructurePlacementID": "str",  # Optional. PlacementID used by the
                      InfrastructureService.
                    "InstanceId": "str",  # Optional. The ID representing the node instance.
                      While the ID of the node is deterministically generated from the node name and
                      remains same across restarts, the InstanceId changes every time node restarts.
                    "IpAddressOrFQDN": "str",  # Optional. The IP address or fully qualified
                      domain name of the node.
                    "IsNodeByNodeUpgradeInProgress": bool,  # Optional. Indicates if a
                      node-by-node upgrade is currently being performed on this node.
                    "IsSeedNode": bool,  # Optional. Indicates if the node is a seed node or not.
                      Returns true if the node is a seed node, otherwise false. A quorum of seed nodes
                      are required for proper operation of Service Fabric cluster.
                    "IsStopped": bool,  # Optional. Indicates if the node is stopped by calling
                      stop node API or not. Returns true if the node is stopped, otherwise false.
                    "Name": "str",  # Optional. The name of a Service Fabric node.
                    "NodeDeactivationInfo": {
                        "NodeDeactivationIntent": "str",  # Optional. The intent or the
                          reason for deactivating the node. Following are the possible values for it.
                          Known values are: "Invalid", "Pause", "Restart", "RemoveData", "RemoveNode".
                        "NodeDeactivationStatus": "str",  # Optional. The status of node
                          deactivation operation. Following are the possible values. Known values are:
                          "None", "SafetyCheckInProgress", "SafetyCheckComplete", "Completed".
                        "NodeDeactivationTask": [
                            {
                                "NodeDeactivationIntent": "str",  # Optional. The
                                  intent or the reason for deactivating the node. Following are the
                                  possible values for it. Known values are: "Invalid", "Pause",
                                  "Restart", "RemoveData", "RemoveNode".
                                "NodeDeactivationTaskId": {
                                    "Id": "str",  # Optional. Value of the task
                                      id.
                                    "NodeDeactivationTaskType": "str"  #
                                      Optional. The type of the task that performed the node
                                      deactivation. Following are the possible values. Known values
                                      are: "Invalid", "Infrastructure", "Repair", "Client".
                                }
                            }
                        ],
                        "PendingSafetyChecks": [
                            {
                                "SafetyCheck": {
                                    Kind: Kind
                                }
                            }
                        ]
                    },
                    "NodeDownAt": "2020-02-20 00:00:00",  # Optional. Date time in UTC when the
                      node went down. If node has never been down then this value will be zero date
                      time.
                    "NodeDownTimeInSeconds": "str",  # Optional. Time in seconds since the node
                      has been in NodeStatus Down. Value zero indicates node is not NodeStatus Down.
                    "NodeStatus": "str",  # Optional. The status of the node. Known values are:
                      "Invalid", "Up", "Down", "Enabling", "Disabling", "Disabled", "Unknown",
                      "Removed".
                    "NodeTags": [
                        "str"  # Optional. List that contains tags, which will be applied to
                          the nodes.
                    ],
                    "NodeUpAt": "2020-02-20 00:00:00",  # Optional. Date time in UTC when the
                      node came up. If the node has never been up then this value will be zero date
                      time.
                    "NodeUpTimeInSeconds": "str",  # Optional. Time in seconds since the node has
                      been in NodeStatus Up. Value zero indicates that the node is not Up.
                    "Type": "str",  # Optional. The type of the node.
                    "UpgradeDomain": "str"  # Optional. The upgrade domain of the node.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_get_node_info_request(
            node_name=node_name,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get_node_health(
        self,
        node_name: str,
        *,
        events_health_state_filter: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the health of a Service Fabric node.

        Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection
        of health events reported on the node based on the health state. If the node that you specify
        by name does not exist in the health store, this returns an error.

        :param node_name: The name of the node.
        :type node_name: str
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "Name": "str",  # Optional. Name of the node whose health information is
                      described by this object.
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_node_health_request(
            node_name=node_name,
            api_version=api_version,
            events_health_state_filter=events_health_state_filter,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_node_health_using_policy(
        self,
        node_name: str,
        cluster_health_policy: Optional[JSON] = None,
        *,
        events_health_state_filter: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the health of a Service Fabric node, by using the specified health policy.

        Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection
        of health events reported on the node based on the health state. Use ClusterHealthPolicy in the
        POST body to override the health policies used to evaluate the health. If the node that you
        specify by name does not exist in the health store, this returns an error.

        :param node_name: The name of the node.
        :type node_name: str
        :param cluster_health_policy: Describes the health policies used to evaluate the health of a
         cluster or node. If not present, the health evaluation uses the health policy from cluster
         manifest or the default health policy. Default value is None.
        :type cluster_health_policy: JSON
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                cluster_health_policy = {
                    "ApplicationTypeHealthPolicyMap": [
                        {
                            "Key": "str",  # Required. The key of the application type
                              health policy map item. This is the name of the application type.
                            "Value": 0  # Required. The value of the application type
                              health policy map item."nThe max percent unhealthy applications allowed
                              for the application type. Must be between zero and 100.
                        }
                    ],
                    "ConsiderWarningAsError": bool,  # Optional. Indicates whether warnings are
                      treated with the same severity as errors.
                    "MaxPercentUnhealthyApplications": 0,  # Optional. The maximum allowed
                      percentage of unhealthy applications before reporting an error. For example, to
                      allow 10% of applications to be unhealthy, this value would be 10."n"nThe
                      percentage represents the maximum tolerated percentage of applications that can
                      be unhealthy before the cluster is considered in error."nIf the percentage is
                      respected but there is at least one unhealthy application, the health is
                      evaluated as Warning."nThis is calculated by dividing the number of unhealthy
                      applications over the total number of application instances in the cluster,
                      excluding applications of application types that are included in the
                      ApplicationTypeHealthPolicyMap."nThe computation rounds up to tolerate one
                      failure on small numbers of applications. Default percentage is zero.
                    "MaxPercentUnhealthyNodes": 0,  # Optional. The maximum allowed percentage of
                      unhealthy nodes before reporting an error. For example, to allow 10% of nodes to
                      be unhealthy, this value would be 10."n"nThe percentage represents the maximum
                      tolerated percentage of nodes that can be unhealthy before the cluster is
                      considered in error."nIf the percentage is respected but there is at least one
                      unhealthy node, the health is evaluated as Warning."nThe percentage is calculated
                      by dividing the number of unhealthy nodes over the total number of nodes in the
                      cluster."nThe computation rounds up to tolerate one failure on small numbers of
                      nodes. Default percentage is zero."n"nIn large clusters, some nodes will always
                      be down or out for repairs, so this percentage should be configured to tolerate
                      that.
                    "NodeTypeHealthPolicyMap": [
                        {
                            "Key": "str",  # Required. The key of the node type health
                              policy map item. This is the name of the node type.
                            "Value": 0  # Required. The value of the node type health
                              policy map item."nIf the percentage is respected but there is at least
                              one unhealthy node in the node type, the health is evaluated as Warning.
                              "nThe percentage is calculated by dividing the number of unhealthy nodes
                              over the total number of nodes in the node type. "nThe computation rounds
                              up to tolerate one failure on small numbers of nodes."nThe max percent
                              unhealthy nodes allowed for the node type. Must be between zero and 100.
                        }
                    ]
                }

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "Name": "str",  # Optional. Name of the node whose health information is
                      described by this object.
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        if cluster_health_policy is not None:
            _json = cluster_health_policy
        else:
            _json = None

        request = build_get_node_health_using_policy_request(
            node_name=node_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            events_health_state_filter=events_health_state_filter,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def report_node_health(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        health_information: JSON,
        *,
        immediate: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Sends a health report on the Service Fabric node.

        Reports health state of the specified Service Fabric node. The report must contain the
        information about the source of the health report and property on which it is reported.
        The report is sent to a Service Fabric gateway node, which forwards to the health store.
        The report may be accepted by the gateway, but rejected by the health store after extra
        validation.
        For example, the health store may reject the report because of an invalid parameter, like a
        stale sequence number.
        To see whether the report was applied in the health store, run GetNodeHealth and check that the
        report appears in the HealthEvents section.

        :param node_name: The name of the node.
        :type node_name: str
        :param health_information: Describes the health information for the health report. This
         information needs to be present in all of the health reports sent to the health manager.
        :type health_information: JSON
        :keyword immediate: A flag that indicates whether the report should be sent immediately.
         A health report is sent to a Service Fabric gateway Application, which forwards to the health
         store.
         If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
         store, regardless of the fabric client settings that the HTTP Gateway Application is using.
         This is useful for critical reports that should be sent as soon as possible.
         Depending on timing and other conditions, sending the report may still fail, for example if
         the HTTP Gateway is closed or the message doesn't reach the Gateway.
         If Immediate is set to false, the report is sent based on the health client settings from the
         HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
         configuration.
         This is the recommended setting because it allows the health client to optimize health
         reporting messages to health store as well as health report processing.
         By default, reports are not sent immediately. Default value is False.
        :paramtype immediate: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                health_information = {
                    "Description": "str",  # Optional. The description of the health information.
                      It represents free text used to add human readable information about the
                      report."nThe maximum string length for the description is 4096 characters."nIf
                      the provided string is longer, it will be automatically truncated."nWhen
                      truncated, the last characters of the description contain a marker "[Truncated]",
                      and total string size is 4096 characters."nThe presence of the marker indicates
                      to users that truncation occurred."nNote that when truncated, the description has
                      less than 4096 characters from the original string.
                    "HealthReportId": "str",  # Optional. A health report ID which identifies the
                      health report and can be used to find more detailed information about a specific
                      health event at"naka.ms/sfhealthid.
                    "HealthState": "str",  # Required. The health state of a Service Fabric
                      entity such as Cluster, Node, Application, Service, Partition, Replica etc. Known
                      values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "Property": "str",  # Required. The property of the health information. An
                      entity can have health reports for different properties."nThe property is a
                      string and not a fixed enumeration to allow the reporter flexibility to
                      categorize the state condition that triggers the report."nFor example, a reporter
                      with SourceId "LocalWatchdog" can monitor the state of the available disk on a
                      node,"nso it can report "AvailableDisk" property on that node."nThe same reporter
                      can monitor the node connectivity, so it can report a property "Connectivity" on
                      the same node."nIn the health store, these reports are treated as separate health
                      events for the specified node."n"nTogether with the SourceId, the property
                      uniquely identifies the health information.
                    "RemoveWhenExpired": bool,  # Optional. Value that indicates whether the
                      report is removed from health store when it expires."nIf set to true, the report
                      is removed from the health store after it expires."nIf set to false, the report
                      is treated as an error when expired. The value of this property is false by
                      default."nWhen clients report periodically, they should set RemoveWhenExpired
                      false (default)."nThis way, if the reporter has issues (e.g. deadlock) and can't
                      report, the entity is evaluated at error when the health report expires."nThis
                      flags the entity as being in Error health state.
                    "SequenceNumber": "str",  # Optional. The sequence number for this health
                      report as a numeric string."nThe report sequence number is used by the health
                      store to detect stale reports."nIf not specified, a sequence number is
                      auto-generated by the health client when a report is added.
                    "SourceId": "str",  # Required. The source name that identifies the
                      client/watchdog/system component that generated the health information.
                    "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The duration for
                      which this health report is valid. This field uses ISO8601 format for specifying
                      the duration."nWhen clients report periodically, they should send reports with
                      higher frequency than time to live."nIf clients report on transition, they can
                      set the time to live to infinite."nWhen time to live expires, the health event
                      that contains the health information"nis either removed from health store, if
                      RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                      false."n"nIf not specified, time to live defaults to infinite value.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = health_information

        request = build_report_node_health_request(
            node_name=node_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            immediate=immediate,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_node_load_info(
        self,
        node_name: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the load information of a Service Fabric node.

        Retrieves the load information of a Service Fabric node for all the metrics that have load or
        capacity defined.

        :param node_name: The name of the node.
        :type node_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "NodeLoadMetricInformation": [
                        {
                            "BufferedNodeCapacityRemaining": "str",  # Optional. The
                              remaining capacity which is not reserved by NodeBufferPercentage for this
                              metric on the node.
                            "CurrentNodeLoad": "str",  # Optional. Current load on the
                              node for this metric.
                            "IsCapacityViolation": bool,  # Optional. Indicates if there
                              is a capacity violation for this metric on the node.
                            "Name": "str",  # Optional. Name of the metric for which this
                              load information is provided.
                            "NodeBufferedCapacity": "str",  # Optional. The value that
                              indicates the reserved capacity for this metric on the node.
                            "NodeCapacity": "str",  # Optional. Total capacity on the
                              node for this metric.
                            "NodeCapacityRemaining": "str",  # Optional. The remaining
                              capacity on the node for the metric.
                            "NodeLoad": "str",  # Optional. Current load on the node for
                              this metric. In future releases of Service Fabric this parameter will be
                              deprecated in favor of CurrentNodeLoad.
                            "NodeRemainingBufferedCapacity": "str",  # Optional. The
                              remaining reserved capacity for this metric on the node. In future
                              releases of Service Fabric this parameter will be deprecated in favor of
                              BufferedNodeCapacityRemaining.
                            "NodeRemainingCapacity": "str",  # Optional. The remaining
                              capacity on the node for this metric. In future releases of Service
                              Fabric this parameter will be deprecated in favor of
                              NodeCapacityRemaining.
                            "PlannedNodeLoadRemoval": "str"  # Optional. This value
                              represents the load of the replicas that are planned to be removed in the
                              future."nThis kind of load is reported for replicas that are currently
                              being moving to other nodes and for replicas that are currently being
                              dropped but still use the load on the source node.
                        }
                    ],
                    "NodeName": "str"  # Optional. Name of the node for which the load
                      information is provided by this object.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_node_load_info_request(
            node_name=node_name,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def disable_node(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        deactivation_intent_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Deactivate a Service Fabric cluster node with the specified deactivation intent.

        Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the
        deactivation is in progress, the deactivation intent can be increased, but not decreased (for
        example, a node that is deactivated with the Pause intent can be deactivated further with
        Restart, but not the other way around. Nodes may be reactivated using the Activate a node
        operation any time after they are deactivated. If the deactivation is not complete, this will
        cancel the deactivation. A node that goes down and comes back up while deactivated will still
        need to be reactivated before services will be placed on that node.

        :param node_name: The name of the node.
        :type node_name: str
        :param deactivation_intent_description: Describes the intent or reason for deactivating the
         node.
        :type deactivation_intent_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                deactivation_intent_description = {
                    "DeactivationIntent": "str"  # Optional. Describes the intent or reason for
                      deactivating the node. The possible values are following. Known values are:
                      "Pause", "Restart", "RemoveData".
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = deactivation_intent_description

        request = build_disable_node_request(
            node_name=node_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def enable_node(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Activate a Service Fabric cluster node that is currently deactivated.

        Activates a Service Fabric cluster node that is currently deactivated. Once activated, the node
        will again become a viable target for placing new replicas, and any deactivated replicas
        remaining on the node will be reactivated.

        :param node_name: The name of the node.
        :type node_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_enable_node_request(
            node_name=node_name,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def remove_node_state(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Notifies Service Fabric that the persisted state on a node has been permanently removed or
        lost.

        This implies that it is not possible to recover the persisted state of that node. This
        generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has
        to be down for this operation to be successful. This operation lets Service Fabric know that
        the replicas on that node no longer exist, and that Service Fabric should stop waiting for
        those replicas to come back up. Do not run this cmdlet if the state on the node has not been
        removed and the node can come back up with its state intact. Starting from Service Fabric 6.5,
        in order to use this API for seed nodes, please change the seed nodes to regular (non-seed)
        nodes and then invoke this API to remove the node state. If the cluster is running on Azure,
        after the seed node goes down, Service Fabric will try to change it to a non-seed node
        automatically. To make this happen, make sure the number of non-seed nodes in the primary node
        type is no less than the number of Down seed nodes. If necessary, add more nodes to the primary
        node type to achieve this. For standalone cluster, if the Down seed node is not expected to
        come back up with its state intact, please remove the node from the cluster, see
        https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-windows-server-add-remove-nodes.

        :param node_name: The name of the node.
        :type node_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_remove_node_state_request(
            node_name=node_name,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def restart_node(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        restart_node_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Restarts a Service Fabric cluster node.

        Restarts a Service Fabric cluster node that is already started.

        :param node_name: The name of the node.
        :type node_name: str
        :param restart_node_description: The instance of the node to be restarted and a flag indicating
         the need to take dump of the fabric process.
        :type restart_node_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                restart_node_description = {
                    "CreateFabricDump": "False",  # Optional. Default value is "False". Specify
                      True to create a dump of the fabric node process. This is case-sensitive. Known
                      values are: "False", "True". Default value: "False".
                    "NodeInstanceId": "0"  # Default value is "0". Required. The instance ID of
                      the target node. If instance ID is specified the node is restarted only if it
                      matches with the current instance of the node. A default value of "0" would match
                      any instance ID. The instance ID can be obtained using get node query.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = restart_node_description

        request = build_restart_node_request(
            node_name=node_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def remove_configuration_overrides(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Removes configuration overrides on the specified node.

        This api allows removing all existing configuration overrides on specified node.

        :param node_name: The name of the node.
        :type node_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '7.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "7.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "7.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_remove_configuration_overrides_request(
            node_name=node_name,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_configuration_overrides(
        self,
        node_name: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets the list of configuration overrides on the specified node.

        This api allows getting all existing configuration overrides on the specified node.

        :param node_name: The name of the node.
        :type node_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '7.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "7.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "ParameterName": "str",  # Required. Name of the parameter that has
                          been overridden.
                        "ParameterValue": "str",  # Required. Value of the overridden
                          parameter.
                        "PersistAcrossUpgrade": bool,  # Optional. A value that indicates
                          whether config override will be removed on upgrade or will still be
                          considered as valid.
                        "SectionName": "str",  # Required. Name of the section for the
                          parameter override.
                        "Timeout": "1 day, 0:00:00"  # Optional. The duration until config
                          override is considered as valid.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "7.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_configuration_overrides_request(
            node_name=node_name,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def add_configuration_parameter_overrides(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        config_parameter_override_list: List[JSON],
        *,
        force: Optional[bool] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Adds the list of configuration overrides on the specified node.

        This api allows adding all existing configuration overrides on the specified node.

        :param node_name: The name of the node.
        :type node_name: str
        :param config_parameter_override_list: Description for adding list of configuration overrides.
        :type config_parameter_override_list: list[JSON]
        :keyword force: Force adding configuration overrides on specified nodes. Default value is None.
        :paramtype force: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '7.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "7.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                config_parameter_override_list = [
                    {
                        "ParameterName": "str",  # Required. Name of the parameter that has
                          been overridden.
                        "ParameterValue": "str",  # Required. Value of the overridden
                          parameter.
                        "PersistAcrossUpgrade": bool,  # Optional. A value that indicates
                          whether config override will be removed on upgrade or will still be
                          considered as valid.
                        "SectionName": "str",  # Required. Name of the section for the
                          parameter override.
                        "Timeout": "1 day, 0:00:00"  # Optional. The duration until config
                          override is considered as valid.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "7.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = config_parameter_override_list

        request = build_add_configuration_parameter_overrides_request(
            node_name=node_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            force=force,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def remove_node_tags(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        node_tags: List[str],
        **kwargs: Any
    ) -> None:
        """Removes the list of tags from the specified node.

        This api allows removing set of tags from the specified node.

        :param node_name: The name of the node.
        :type node_name: str
        :param node_tags: Description for adding list of node tags.
        :type node_tags: list[str]
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '7.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "7.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                node_tags = [
                    "str"  # Optional.
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "7.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = node_tags

        request = build_remove_node_tags_request(
            node_name=node_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def add_node_tags(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        node_tags: List[str],
        **kwargs: Any
    ) -> None:
        """Adds the list of tags on the specified node.

        This api allows adding tags to the specified node.

        :param node_name: The name of the node.
        :type node_name: str
        :param node_tags: Description for adding list of node tags.
        :type node_tags: list[str]
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '7.2'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "7.2". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                node_tags = [
                    "str"  # Optional.
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "7.2"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = node_tags

        request = build_add_node_tags_request(
            node_name=node_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_application_type_info_list(
        self,
        *,
        application_type_definition_kind_filter: Optional[int] = 0,
        exclude_application_parameters: Optional[bool] = False,
        continuation_token_parameter: Optional[str] = None,
        max_results: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the list of application types in the Service Fabric cluster.

        Returns the information about the application types that are provisioned or in the process of
        being provisioned in the Service Fabric cluster. Each version of an application type is
        returned as one application type. The response includes the name, version, status, and other
        details about the application type. This is a paged query, meaning that if not all of the
        application types fit in a page, one page of results is returned as well as a continuation
        token, which can be used to get the next page. For example, if there are 10 application types
        but a page only fits the first three application types, or if max results is set to 3, then
        three is returned. To access the rest of the results, retrieve subsequent pages by using the
        returned continuation token in the next query. An empty continuation token is returned if there
        are no subsequent pages.

        :keyword application_type_definition_kind_filter: Used to filter on
         ApplicationTypeDefinitionKind which is the mechanism used to define a Service Fabric
         application type.


         * Default - Default value, which performs the same function as selecting "All". The value is
         0.
         * All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is
         65535.
         * ServiceFabricApplicationPackage - Filter that matches input with
         ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The value is 1.
         * Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The
         value is 2. Default value is 0.
        :paramtype application_type_definition_kind_filter: int
        :keyword exclude_application_parameters: The flag that specifies whether application parameters
         will be excluded from the result. Default value is False.
        :paramtype exclude_application_parameters: bool
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "ApplicationTypeDefinitionKind": "str",  # Optional. The
                              mechanism used to define a Service Fabric application type. Known values
                              are: "Invalid", "ServiceFabricApplicationPackage", "Compose".
                            "ApplicationTypeMetadata": {
                                "ApplicationTypeProvisionTimestamp": "str",  #
                                  Optional. The timestamp when the application type was provisioned.
                                "ArmMetadata": {
                                    "ArmResourceId": "str"  # Optional. A string
                                      containing the ArmResourceId.
                                }
                            },
                            "DefaultParameterList": [
                                {
                                    "Key": "str",  # Required. The name of the
                                      parameter.
                                    "Value": "str"  # Required. The value of the
                                      parameter.
                                }
                            ],
                            "Name": "str",  # Optional. The application type name as
                              defined in the application manifest.
                            "Status": "str",  # Optional. The status of the application
                              type. Known values are: "Invalid", "Provisioning", "Available",
                              "Unprovisioning", "Failed".
                            "StatusDetails": "str",  # Optional. Additional detailed
                              information about the status of the application type.
                            "Version": "str"  # Optional. The version of the application
                              type as defined in the application manifest.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_application_type_info_list_request(
            api_version=api_version,
            application_type_definition_kind_filter=application_type_definition_kind_filter,
            exclude_application_parameters=exclude_application_parameters,
            continuation_token_parameter=continuation_token_parameter,
            max_results=max_results,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_application_type_info_list_by_name(
        self,
        application_type_name: str,
        *,
        application_type_version: Optional[str] = None,
        exclude_application_parameters: Optional[bool] = False,
        continuation_token_parameter: Optional[str] = None,
        max_results: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the list of application types in the Service Fabric cluster matching exactly the specified
        name.

        Returns the information about the application types that are provisioned or in the process of
        being provisioned in the Service Fabric cluster. These results are of application types whose
        name match exactly the one specified as the parameter, and which comply with the given query
        parameters. All versions of the application type matching the application type name are
        returned, with each version returned as one application type. The response includes the name,
        version, status, and other details about the application type. This is a paged query, meaning
        that if not all of the application types fit in a page, one page of results is returned as well
        as a continuation token, which can be used to get the next page. For example, if there are 10
        application types but a page only fits the first three application types, or if max results is
        set to 3, then three is returned. To access the rest of the results, retrieve subsequent pages
        by using the returned continuation token in the next query. An empty continuation token is
        returned if there are no subsequent pages.

        :param application_type_name: The name of the application type.
        :type application_type_name: str
        :keyword application_type_version: The version of the application type. Default value is None.
        :paramtype application_type_version: str
        :keyword exclude_application_parameters: The flag that specifies whether application parameters
         will be excluded from the result. Default value is False.
        :paramtype exclude_application_parameters: bool
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "ApplicationTypeDefinitionKind": "str",  # Optional. The
                              mechanism used to define a Service Fabric application type. Known values
                              are: "Invalid", "ServiceFabricApplicationPackage", "Compose".
                            "ApplicationTypeMetadata": {
                                "ApplicationTypeProvisionTimestamp": "str",  #
                                  Optional. The timestamp when the application type was provisioned.
                                "ArmMetadata": {
                                    "ArmResourceId": "str"  # Optional. A string
                                      containing the ArmResourceId.
                                }
                            },
                            "DefaultParameterList": [
                                {
                                    "Key": "str",  # Required. The name of the
                                      parameter.
                                    "Value": "str"  # Required. The value of the
                                      parameter.
                                }
                            ],
                            "Name": "str",  # Optional. The application type name as
                              defined in the application manifest.
                            "Status": "str",  # Optional. The status of the application
                              type. Known values are: "Invalid", "Provisioning", "Available",
                              "Unprovisioning", "Failed".
                            "StatusDetails": "str",  # Optional. Additional detailed
                              information about the status of the application type.
                            "Version": "str"  # Optional. The version of the application
                              type as defined in the application manifest.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_application_type_info_list_by_name_request(
            application_type_name=application_type_name,
            api_version=api_version,
            application_type_version=application_type_version,
            exclude_application_parameters=exclude_application_parameters,
            continuation_token_parameter=continuation_token_parameter,
            max_results=max_results,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def provision_application_type(  # pylint: disable=inconsistent-return-statements
        self,
        provision_application_type_description_base_required_body_param: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Provisions or registers a Service Fabric application type with the cluster using the '.sfpkg'
        package in the external store or using the application package in the image store.

        Provisions a Service Fabric application type with the cluster. The provision is required before
        any new applications can be instantiated.
        The provision operation can be performed either on the application package specified by the
        relativePathInImageStore, or by using the URI of the external '.sfpkg'.

        :param provision_application_type_description_base_required_body_param: The base type of
         provision application type description which supports either image store-based provision or
         external store-based provision.
        :type provision_application_type_description_base_required_body_param: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.2'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.2". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                kind = 'ExternalStoreProvisionApplicationTypeDescription' or
                  'ProvisionApplicationTypeDescription'

                # JSON input template you can fill out and use as your body input.
                provision_application_type_description_base_required_body_param = {
                    "Async": bool,  # Required. Indicates whether or not provisioning should
                      occur asynchronously. When set to true, the provision operation returns when the
                      request is accepted by the system, and the provision operation continues without
                      any timeout limit. The default value is false. For large application packages, we
                      recommend setting the value to true.
                    Kind: Kind
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.2"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = provision_application_type_description_base_required_body_param

        request = build_provision_application_type_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def unprovision_application_type(  # pylint: disable=inconsistent-return-statements
        self,
        application_type_name: str,
        unprovision_application_type_description_info: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Removes or unregisters a Service Fabric application type from the cluster.

        This operation can only be performed if all application instances of the application type have
        been deleted. Once the application type is unregistered, no new application instances can be
        created for this particular application type.

        :param application_type_name: The name of the application type.
        :type application_type_name: str
        :param unprovision_application_type_description_info: The relative path for the application
         package in the image store specified during the prior copy operation.
        :type unprovision_application_type_description_info: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                unprovision_application_type_description_info = {
                    "ApplicationTypeVersion": "str",  # Required. The version of the application
                      type as defined in the application manifest.
                    "Async": bool  # Optional. The flag indicating whether or not unprovision
                      should occur asynchronously. When set to true, the unprovision operation returns
                      when the request is accepted by the system, and the unprovision operation
                      continues without any timeout limit. The default value is false. However, we
                      recommend setting it to true for large application packages that were
                      provisioned.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = unprovision_application_type_description_info

        request = build_unprovision_application_type_request(
            application_type_name=application_type_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def update_application_type_arm_metadata(  # pylint: disable=inconsistent-return-statements
        self,
        application_type_name: str,
        application_type_arm_metadata_update_description: JSON,
        *,
        application_type_version: str,
        timeout: Optional[int] = 60,
        force: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Updates the Arm Metadata for a specific Application Type.

        Updates the Arm Metadata for a specific Application Type. Is able to be called immediately
        after the provision app type API is called.

        :param application_type_name: The name of the application type.
        :type application_type_name: str
        :param application_type_arm_metadata_update_description: The Arm metadata to be assocated with
         a specific application type.
        :type application_type_arm_metadata_update_description: JSON
        :keyword application_type_version: The version of the application type.
        :paramtype application_type_version: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword force: Force parameter used to prevent accidental Arm metadata update. Default value
         is None.
        :paramtype force: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '9.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "9.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                application_type_arm_metadata_update_description = {
                    "ArmResourceId": "str"  # Optional. A string containing the ArmResourceId.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = application_type_arm_metadata_update_description

        request = build_update_application_type_arm_metadata_request(
            application_type_name=application_type_name,
            api_version=api_version,
            content_type=content_type,
            application_type_version=application_type_version,
            json=_json,
            timeout=timeout,
            force=force,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_service_type_info_list(
        self,
        application_type_name: str,
        *,
        application_type_version: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets the list containing the information about service types that are supported by a
        provisioned application type in a Service Fabric cluster.

        Gets the list containing the information about service types that are supported by a
        provisioned application type in a Service Fabric cluster. The provided application type must
        exist. Otherwise, a 404 status is returned.

        :param application_type_name: The name of the application type.
        :type application_type_name: str
        :keyword application_type_version: The version of the application type.
        :paramtype application_type_version: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "IsServiceGroup": bool,  # Optional. Indicates whether the service is
                          a service group. If it is, the property value is true otherwise false.
                        "ServiceManifestName": "str",  # Optional. The name of the service
                          manifest in which this service type is defined.
                        "ServiceManifestVersion": "str",  # Optional. The version of the
                          service manifest in which this service type is defined.
                        "ServiceTypeDescription": {
                            "Extensions": [
                                {
                                    "Key": "str",  # Optional. The name of the
                                      extension.
                                    "Value": "str"  # Optional. The extension
                                      value.
                                }
                            ],
                            "IsStateful": bool,  # Optional. Indicates whether the
                              service type is a stateful service type or a stateless service type. This
                              property is true if the service type is a stateful service type, false
                              otherwise.
                            "LoadMetrics": [
                                {
                                    "AuxiliaryDefaultLoad": 0,  # Optional. Used
                                      only for Stateful services. The default amount of load, as a
                                      number, that this service creates for this metric when it is an
                                      Auxiliary replica.
                                    "DefaultLoad": 0,  # Optional. Used only for
                                      Stateless services. The default amount of load, as a number, that
                                      this service creates for this metric.
                                    "Name": "str",  # Required. The name of the
                                      metric. If the service chooses to report load during runtime, the
                                      load metric name should match the name that is specified in Name
                                      exactly. Note that metric names are case-sensitive.
                                    "PrimaryDefaultLoad": 0,  # Optional. Used
                                      only for Stateful services. The default amount of load, as a
                                      number, that this service creates for this metric when it is a
                                      Primary replica.
                                    "SecondaryDefaultLoad": 0,  # Optional. Used
                                      only for Stateful services. The default amount of load, as a
                                      number, that this service creates for this metric when it is a
                                      Secondary replica.
                                    "Weight": "str"  # Optional. The service load
                                      metric relative weight, compared to other metrics configured for
                                      this service, as a number. Known values are: "Zero", "Low",
                                      "Medium", "High".
                                }
                            ],
                            "PlacementConstraints": "str",  # Optional. The placement
                              constraint to be used when instantiating this service in a Service Fabric
                              cluster.
                            "ServicePlacementPolicies": [
                                {
                                    Type: Type
                                }
                            ],
                            "ServiceTypeName": "str",  # Optional. Name of the service
                              type as specified in the service manifest.
                            Kind: Kind
                        }
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_service_type_info_list_request(
            application_type_name=application_type_name,
            api_version=api_version,
            application_type_version=application_type_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_service_type_info_by_name(
        self,
        application_type_name: str,
        service_type_name: str,
        *,
        application_type_version: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Gets the information about a specific service type that is supported by a provisioned
        application type in a Service Fabric cluster.

        Gets the information about a specific service type that is supported by a provisioned
        application type in a Service Fabric cluster. The provided application type must exist.
        Otherwise, a 404 status is returned. A 204 response is returned if the specified service type
        is not found in the cluster.

        :param application_type_name: The name of the application type.
        :type application_type_name: str
        :param service_type_name: Specifies the name of a Service Fabric service type.
        :type service_type_name: str
        :keyword application_type_version: The version of the application type.
        :paramtype application_type_version: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "IsServiceGroup": bool,  # Optional. Indicates whether the service is a
                      service group. If it is, the property value is true otherwise false.
                    "ServiceManifestName": "str",  # Optional. The name of the service manifest
                      in which this service type is defined.
                    "ServiceManifestVersion": "str",  # Optional. The version of the service
                      manifest in which this service type is defined.
                    "ServiceTypeDescription": {
                        "Extensions": [
                            {
                                "Key": "str",  # Optional. The name of the extension.
                                "Value": "str"  # Optional. The extension value.
                            }
                        ],
                        "IsStateful": bool,  # Optional. Indicates whether the service type
                          is a stateful service type or a stateless service type. This property is true
                          if the service type is a stateful service type, false otherwise.
                        "LoadMetrics": [
                            {
                                "AuxiliaryDefaultLoad": 0,  # Optional. Used only for
                                  Stateful services. The default amount of load, as a number, that this
                                  service creates for this metric when it is an Auxiliary replica.
                                "DefaultLoad": 0,  # Optional. Used only for
                                  Stateless services. The default amount of load, as a number, that
                                  this service creates for this metric.
                                "Name": "str",  # Required. The name of the metric.
                                  If the service chooses to report load during runtime, the load metric
                                  name should match the name that is specified in Name exactly. Note
                                  that metric names are case-sensitive.
                                "PrimaryDefaultLoad": 0,  # Optional. Used only for
                                  Stateful services. The default amount of load, as a number, that this
                                  service creates for this metric when it is a Primary replica.
                                "SecondaryDefaultLoad": 0,  # Optional. Used only for
                                  Stateful services. The default amount of load, as a number, that this
                                  service creates for this metric when it is a Secondary replica.
                                "Weight": "str"  # Optional. The service load metric
                                  relative weight, compared to other metrics configured for this
                                  service, as a number. Known values are: "Zero", "Low", "Medium",
                                  "High".
                            }
                        ],
                        "PlacementConstraints": "str",  # Optional. The placement constraint
                          to be used when instantiating this service in a Service Fabric cluster.
                        "ServicePlacementPolicies": [
                            {
                                Type: Type
                            }
                        ],
                        "ServiceTypeName": "str",  # Optional. Name of the service type as
                          specified in the service manifest.
                        Kind: Kind
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_get_service_type_info_by_name_request(
            application_type_name=application_type_name,
            service_type_name=service_type_name,
            api_version=api_version,
            application_type_version=application_type_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get_service_manifest(
        self,
        application_type_name: str,
        *,
        application_type_version: str,
        service_manifest_name: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the manifest describing a service type.

        Gets the manifest describing a service type. The response contains the service manifest XML as
        a string.

        :param application_type_name: The name of the application type.
        :type application_type_name: str
        :keyword application_type_version: The version of the application type.
        :paramtype application_type_version: str
        :keyword service_manifest_name: The name of a service manifest registered as part of an
         application type in a Service Fabric cluster.
        :paramtype service_manifest_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Manifest": "str"  # Optional. The XML manifest as a string.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_service_manifest_request(
            application_type_name=application_type_name,
            api_version=api_version,
            application_type_version=application_type_version,
            service_manifest_name=service_manifest_name,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_deployed_service_type_info_list(
        self,
        node_name: str,
        application_id: str,
        *,
        service_manifest_name: Optional[str] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets the list containing the information about service types from the applications deployed on
        a node in a Service Fabric cluster.

        Gets the list containing the information about service types from the applications deployed on
        a node in a Service Fabric cluster. The response includes the name of the service type, its
        registration status, the code package that registered it and activation ID of the service
        package.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword service_manifest_name: The name of the service manifest to filter the list of deployed
         service type information. If specified, the response will only contain the information about
         service types that are defined in this service manifest. Default value is None.
        :paramtype service_manifest_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "CodePackageName": "str",  # Optional. The name of the code package
                          that registered the service type.
                        "ServiceManifestName": "str",  # Optional. The name of the service
                          manifest in which this service type is defined.
                        "ServicePackageActivationId": "str",  # Optional. The ActivationId of
                          a deployed service package. If ServicePackageActivationMode specified at the
                          time of creating the service"nis 'SharedProcess' (or if it is not specified,
                          in which case it defaults to 'SharedProcess'), then value of
                          ServicePackageActivationId"nis always an empty string.
                        "ServiceTypeName": "str",  # Optional. Name of the service type as
                          specified in the service manifest.
                        "Status": "str"  # Optional. The status of the service type
                          registration on the node. Known values are: "Invalid", "Disabled", "Enabled",
                          "Registered".
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_deployed_service_type_info_list_request(
            node_name=node_name,
            application_id=application_id,
            api_version=api_version,
            service_manifest_name=service_manifest_name,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_deployed_service_type_info_by_name(
        self,
        node_name: str,
        application_id: str,
        service_type_name: str,
        *,
        service_manifest_name: Optional[str] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> Optional[List[JSON]]:
        """Gets the information about a specified service type of the application deployed on a node in a
        Service Fabric cluster.

        Gets the list containing the information about a specific service type from the applications
        deployed on a node in a Service Fabric cluster. The response includes the name of the service
        type, its registration status, the code package that registered it and activation ID of the
        service package. Each entry represents one activation of a service type, differentiated by the
        activation ID.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param service_type_name: Specifies the name of a Service Fabric service type.
        :type service_type_name: str
        :keyword service_manifest_name: The name of the service manifest to filter the list of deployed
         service type information. If specified, the response will only contain the information about
         service types that are defined in this service manifest. Default value is None.
        :paramtype service_manifest_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON] or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "CodePackageName": "str",  # Optional. The name of the code package
                          that registered the service type.
                        "ServiceManifestName": "str",  # Optional. The name of the service
                          manifest in which this service type is defined.
                        "ServicePackageActivationId": "str",  # Optional. The ActivationId of
                          a deployed service package. If ServicePackageActivationMode specified at the
                          time of creating the service"nis 'SharedProcess' (or if it is not specified,
                          in which case it defaults to 'SharedProcess'), then value of
                          ServicePackageActivationId"nis always an empty string.
                        "ServiceTypeName": "str",  # Optional. Name of the service type as
                          specified in the service manifest.
                        "Status": "str"  # Optional. The status of the service type
                          registration on the node. Known values are: "Invalid", "Disabled", "Enabled",
                          "Registered".
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[List[JSON]]]

        
        request = build_get_deployed_service_type_info_by_name_request(
            node_name=node_name,
            application_id=application_id,
            service_type_name=service_type_name,
            api_version=api_version,
            service_manifest_name=service_manifest_name,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def create_application(  # pylint: disable=inconsistent-return-statements
        self,
        application_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Creates a Service Fabric application.

        Creates a Service Fabric application using the specified description.

        :param application_description: Description for creating an application.
        :type application_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                application_description = {
                    "ApplicationCapacity": {
                        "ApplicationMetrics": [
                            {
                                "MaximumCapacity": 0.0,  # Optional. The maximum node
                                  capacity for Service Fabric application."nThis is the maximum Load
                                  for an instance of this application on a single node. Even if the
                                  capacity of node is greater than this value, Service Fabric will
                                  limit the total load of services within the application on each node
                                  to this value."nIf set to zero, capacity for this metric is unlimited
                                  on each node."nWhen creating a new application with application
                                  capacity defined, the product of MaximumNodes and this value must
                                  always be smaller than or equal to TotalApplicationCapacity."nWhen
                                  updating existing application with application capacity, the product
                                  of MaximumNodes and this value must always be smaller than or equal
                                  to TotalApplicationCapacity.
                                "Name": "str",  # Optional. The name of the metric.
                                "ReservationCapacity": 0.0,  # Optional. The node
                                  reservation capacity for Service Fabric application."nThis is the
                                  amount of load which is reserved on nodes which have instances of
                                  this application."nIf MinimumNodes is specified, then the product of
                                  these values will be the capacity reserved in the cluster for the
                                  application."nIf set to zero, no capacity is reserved for this
                                  metric."nWhen setting application capacity or when updating
                                  application capacity; this value must be smaller than or equal to
                                  MaximumCapacity for each metric.
                                "TotalApplicationCapacity": 0.0  # Optional. The
                                  total metric capacity for Service Fabric application."nThis is the
                                  total metric capacity for this application in the cluster. Service
                                  Fabric will try to limit the sum of loads of services within the
                                  application to this value."nWhen creating a new application with
                                  application capacity defined, the product of MaximumNodes and
                                  MaximumCapacity must always be smaller than or equal to this value.
                            }
                        ],
                        "MaximumNodes": 0.0,  # Optional. The maximum number of nodes where
                          Service Fabric will reserve capacity for this application. Note that this
                          does not mean that the services of this application will be placed on all of
                          those nodes. By default, the value of this property is zero and it means that
                          the services can be placed on any node.
                        "MinimumNodes": 0.0  # Optional. The minimum number of nodes where
                          Service Fabric will reserve capacity for this application. Note that this
                          does not mean that the services of this application will be placed on all of
                          those nodes. If this property is set to zero, no capacity will be reserved.
                          The value of this property cannot be more than the value of the MaximumNodes
                          property.
                    },
                    "ManagedApplicationIdentity": {
                        "ManagedIdentities": [
                            {
                                "Name": "str",  # Required. The name of the identity.
                                "PrincipalId": "str"  # Optional. The identity's
                                  PrincipalId.
                            }
                        ],
                        "TokenServiceEndpoint": "str"  # Optional. Token service endpoint.
                    },
                    "Name": "str",  # Required. The name of the application, including the
                      'fabric:' URI scheme.
                    "ParameterList": [
                        {
                            "Key": "str",  # Required. The name of the parameter.
                            "Value": "str"  # Required. The value of the parameter.
                        }
                    ],
                    "TypeName": "str",  # Required. The application type name as defined in the
                      application manifest.
                    "TypeVersion": "str"  # Required. The version of the application type as
                      defined in the application manifest.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = application_description

        request = build_create_application_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def delete_application(  # pylint: disable=inconsistent-return-statements
        self,
        application_id: str,
        *,
        force_remove: Optional[bool] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Deletes an existing Service Fabric application.

        An application must be created before it can be deleted. Deleting an application will delete
        all services that are part of that application. By default, Service Fabric will try to close
        service replicas in a graceful manner and then delete the service. However, if a service is
        having issues closing the replica gracefully, the delete operation may take a long time or get
        stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully
        delete the application and all of its services.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword force_remove: Remove a Service Fabric application or service forcefully without going
         through the graceful shutdown sequence. This parameter can be used to forcefully delete an
         application or service for which delete is timing out due to issues in the service code that
         prevents graceful close of replicas. Default value is None.
        :paramtype force_remove: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_delete_application_request(
            application_id=application_id,
            api_version=api_version,
            force_remove=force_remove,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_application_load_info(
        self,
        application_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Gets load information about a Service Fabric application.

        Returns the load information about the application that was created or in the process of being
        created in the Service Fabric cluster and whose name matches the one specified as the
        parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes
        the application is occupying currently, and application load metric information about the
        application.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ApplicationLoadMetricInformation": [
                        {
                            "ApplicationCapacity": 0.0,  # Optional. Total capacity for
                              this metric in this application instance.
                            "ApplicationLoad": 0.0,  # Optional. Current load for this
                              metric in this application instance.
                            "Name": "str",  # Optional. The name of the metric.
                            "ReservationCapacity": 0.0  # Optional. This is the capacity
                              reserved in the cluster for the application."nIt's the product of
                              NodeReservationCapacity and MinimumNodes."nIf set to zero, no capacity is
                              reserved for this metric."nWhen setting application capacity or when
                              updating application capacity this value must be smaller than or equal to
                              MaximumCapacity for each metric.
                        }
                    ],
                    "Id": "str",  # Optional. The identity of the application. This is an encoded
                      representation of the application name. This is used in the REST APIs to identify
                      the application resource."nStarting in version 6.0, hierarchical names are
                      delimited with the "~" character. For example, if the application name is
                      "fabric:/myapp/app1","nthe application identity would be "myapp~app1" in 6.0+ and
                      "myapp/app1" in previous versions.
                    "MaximumNodes": 0.0,  # Optional. The maximum number of nodes where this
                      application can be instantiated."nIt is the number of nodes this application is
                      allowed to span."nFor applications that do not have application capacity defined
                      this value will be zero.
                    "MinimumNodes": 0.0,  # Optional. The minimum number of nodes for this
                      application."nIt is the number of nodes where Service Fabric will reserve
                      Capacity in the cluster which equals to ReservedLoad * MinimumNodes for this
                      Application instance."nFor applications that do not have application capacity
                      defined this value will be zero.
                    "NodeCount": 0.0  # Optional. The number of nodes on which this application
                      is instantiated."nFor applications that do not have application capacity defined
                      this value will be zero.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_get_application_load_info_request(
            application_id=application_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get_application_info_list(
        self,
        *,
        application_definition_kind_filter: Optional[int] = 0,
        application_type_name: Optional[str] = None,
        exclude_application_parameters: Optional[bool] = False,
        continuation_token_parameter: Optional[str] = None,
        max_results: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the list of applications created in the Service Fabric cluster that match the specified
        filters.

        Gets the information about the applications that were created or in the process of being
        created in the Service Fabric cluster and match the specified filters. The response includes
        the name, type, status, parameters, and other details about the application. If the
        applications do not fit in a page, one page of results is returned as well as a continuation
        token, which can be used to get the next page. Filters ApplicationTypeName and
        ApplicationDefinitionKindFilter cannot be specified at the same time.

        :keyword application_definition_kind_filter: Used to filter on ApplicationDefinitionKind, which
         is the mechanism used to define a Service Fabric application.


         * Default - Default value, which performs the same function as selecting "All". The value is
         0.
         * All - Filter that matches input with any ApplicationDefinitionKind value. The value is
         65535.
         * ServiceFabricApplicationDescription - Filter that matches input with
         ApplicationDefinitionKind value ServiceFabricApplicationDescription. The value is 1.
         * Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value
         is 2. Default value is 0.
        :paramtype application_definition_kind_filter: int
        :keyword application_type_name: The application type name used to filter the applications to
         query for. This value should not contain the application type version. Default value is None.
        :paramtype application_type_name: str
        :keyword exclude_application_parameters: The flag that specifies whether application parameters
         will be excluded from the result. Default value is False.
        :paramtype exclude_application_parameters: bool
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.1'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.1". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "ApplicationDefinitionKind": "str",  # Optional. The
                              mechanism used to define a Service Fabric application. Known values are:
                              "Invalid", "ServiceFabricApplicationDescription", "Compose".
                            "ApplicationMetadata": {
                                "ArmMetadata": {
                                    "ArmResourceId": "str"  # Optional. A string
                                      containing the ArmResourceId.
                                }
                            },
                            "HealthState": "str",  # Optional. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "Id": "str",  # Optional. The identity of the application.
                              This is an encoded representation of the application name. This is used
                              in the REST APIs to identify the application resource."nStarting in
                              version 6.0, hierarchical names are delimited with the "~" character. For
                              example, if the application name is "fabric:/myapp/app1","nthe
                              application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
                              previous versions.
                            "ManagedApplicationIdentity": {
                                "ManagedIdentities": [
                                    {
                                        "Name": "str",  # Required. The name
                                          of the identity.
                                        "PrincipalId": "str"  # Optional. The
                                          identity's PrincipalId.
                                    }
                                ],
                                "TokenServiceEndpoint": "str"  # Optional. Token
                                  service endpoint.
                            },
                            "Name": "str",  # Optional. The name of the application,
                              including the 'fabric:' URI scheme.
                            "Parameters": [
                                {
                                    "Key": "str",  # Required. The name of the
                                      parameter.
                                    "Value": "str"  # Required. The value of the
                                      parameter.
                                }
                            ],
                            "Status": "str",  # Optional. The status of the application.
                              Known values are: "Invalid", "Ready", "Upgrading", "Creating",
                              "Deleting", "Failed".
                            "TypeName": "str",  # Optional. The application type name as
                              defined in the application manifest.
                            "TypeVersion": "str"  # Optional. The version of the
                              application type as defined in the application manifest.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.1"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_application_info_list_request(
            api_version=api_version,
            application_definition_kind_filter=application_definition_kind_filter,
            application_type_name=application_type_name,
            exclude_application_parameters=exclude_application_parameters,
            continuation_token_parameter=continuation_token_parameter,
            max_results=max_results,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_application_info(
        self,
        application_id: str,
        *,
        exclude_application_parameters: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Gets information about a Service Fabric application.

        Returns the information about the application that was created or in the process of being
        created in the Service Fabric cluster and whose name matches the one specified as the
        parameter. The response includes the name, type, status, parameters, and other details about
        the application.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword exclude_application_parameters: The flag that specifies whether application parameters
         will be excluded from the result. Default value is False.
        :paramtype exclude_application_parameters: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ApplicationDefinitionKind": "str",  # Optional. The mechanism used to define
                      a Service Fabric application. Known values are: "Invalid",
                      "ServiceFabricApplicationDescription", "Compose".
                    "ApplicationMetadata": {
                        "ArmMetadata": {
                            "ArmResourceId": "str"  # Optional. A string containing the
                              ArmResourceId.
                        }
                    },
                    "HealthState": "str",  # Optional. The health state of a Service Fabric
                      entity such as Cluster, Node, Application, Service, Partition, Replica etc. Known
                      values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "Id": "str",  # Optional. The identity of the application. This is an encoded
                      representation of the application name. This is used in the REST APIs to identify
                      the application resource."nStarting in version 6.0, hierarchical names are
                      delimited with the "~" character. For example, if the application name is
                      "fabric:/myapp/app1","nthe application identity would be "myapp~app1" in 6.0+ and
                      "myapp/app1" in previous versions.
                    "ManagedApplicationIdentity": {
                        "ManagedIdentities": [
                            {
                                "Name": "str",  # Required. The name of the identity.
                                "PrincipalId": "str"  # Optional. The identity's
                                  PrincipalId.
                            }
                        ],
                        "TokenServiceEndpoint": "str"  # Optional. Token service endpoint.
                    },
                    "Name": "str",  # Optional. The name of the application, including the
                      'fabric:' URI scheme.
                    "Parameters": [
                        {
                            "Key": "str",  # Required. The name of the parameter.
                            "Value": "str"  # Required. The value of the parameter.
                        }
                    ],
                    "Status": "str",  # Optional. The status of the application. Known values
                      are: "Invalid", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                    "TypeName": "str",  # Optional. The application type name as defined in the
                      application manifest.
                    "TypeVersion": "str"  # Optional. The version of the application type as
                      defined in the application manifest.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_get_application_info_request(
            application_id=application_id,
            api_version=api_version,
            exclude_application_parameters=exclude_application_parameters,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get_application_health(
        self,
        application_id: str,
        *,
        events_health_state_filter: Optional[int] = 0,
        deployed_applications_health_state_filter: Optional[int] = 0,
        services_health_state_filter: Optional[int] = 0,
        exclude_health_statistics: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the health of the service fabric application.

        Returns the heath state of the service fabric application. The response reports either Ok,
        Error or Warning health state. If the entity is not found in the health store, it will return
        Error.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword deployed_applications_health_state_filter: Allows filtering of the deployed
         applications health state objects returned in the result of application health query based on
         their health state.
         The possible values for this parameter include integer value of one of the following health
         states. Only deployed applications that match the filter will be returned.
         All deployed applications are used to evaluate the aggregated health state. If not specified,
         all entries are returned.
         The state values are flag-based enumeration, so the value could be a combination of these
         values, obtained using bitwise 'OR' operator.
         For example, if the provided value is 6 then health state of deployed applications with
         HealthState value of OK (2) and Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype deployed_applications_health_state_filter: int
        :keyword services_health_state_filter: Allows filtering of the services health state objects
         returned in the result of services health query based on their health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only services that match the filter are returned. All services are used to evaluate the
         aggregated health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values,
         obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health
         state of services with HealthState value of OK (2) and Warning (4) will be returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype services_health_state_filter: int
        :keyword exclude_health_statistics: Indicates whether the health statistics should be returned
         as part of the query result. False by default.
         The statistics show the number of children entities in health state Ok, Warning, and Error.
         Default value is False.
        :paramtype exclude_health_statistics: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "DeployedApplicationHealthStates": [
                        {
                            "AggregatedHealthState": "str",  # Optional. The health state
                              of a Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "ApplicationName": "str",  # Optional. The name of the
                              application, including the 'fabric:' URI scheme.
                            "NodeName": "str"  # Optional. Name of the node on which the
                              service package is deployed.
                        }
                    ],
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "Name": "str",  # Optional. The name of the application, including the
                      'fabric:' URI scheme.
                    "ServiceHealthStates": [
                        {
                            "AggregatedHealthState": "str",  # Optional. The health state
                              of a Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "ServiceName": "str"  # Optional. Name of the service whose
                              health state is represented by this object.
                        }
                    ],
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_application_health_request(
            application_id=application_id,
            api_version=api_version,
            events_health_state_filter=events_health_state_filter,
            deployed_applications_health_state_filter=deployed_applications_health_state_filter,
            services_health_state_filter=services_health_state_filter,
            exclude_health_statistics=exclude_health_statistics,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_application_health_using_policy(
        self,
        application_id: str,
        application_health_policy: Optional[JSON] = None,
        *,
        events_health_state_filter: Optional[int] = 0,
        deployed_applications_health_state_filter: Optional[int] = 0,
        services_health_state_filter: Optional[int] = 0,
        exclude_health_statistics: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the health of a Service Fabric application using the specified policy.

        Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the
        collection of health events reported on the node based on the health state. Use
        ClusterHealthPolicies to override the health policies used to evaluate the health.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param application_health_policy: Describes the health policies used to evaluate the health of
         an application or one of its children.
         If not present, the health evaluation uses the health policy from application manifest or the
         default health policy. Default value is None.
        :type application_health_policy: JSON
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword deployed_applications_health_state_filter: Allows filtering of the deployed
         applications health state objects returned in the result of application health query based on
         their health state.
         The possible values for this parameter include integer value of one of the following health
         states. Only deployed applications that match the filter will be returned.
         All deployed applications are used to evaluate the aggregated health state. If not specified,
         all entries are returned.
         The state values are flag-based enumeration, so the value could be a combination of these
         values, obtained using bitwise 'OR' operator.
         For example, if the provided value is 6 then health state of deployed applications with
         HealthState value of OK (2) and Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype deployed_applications_health_state_filter: int
        :keyword services_health_state_filter: Allows filtering of the services health state objects
         returned in the result of services health query based on their health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only services that match the filter are returned. All services are used to evaluate the
         aggregated health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values,
         obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health
         state of services with HealthState value of OK (2) and Warning (4) will be returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype services_health_state_filter: int
        :keyword exclude_health_statistics: Indicates whether the health statistics should be returned
         as part of the query result. False by default.
         The statistics show the number of children entities in health state Ok, Warning, and Error.
         Default value is False.
        :paramtype exclude_health_statistics: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                application_health_policy = {
                    "ConsiderWarningAsError": bool,  # Optional. Indicates whether warnings are
                      treated with the same severity as errors.
                    "DefaultServiceTypeHealthPolicy": {
                        "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional. The
                          maximum allowed percentage of unhealthy partitions per service. Allowed
                          values are Byte values from zero to 100"n"nThe percentage represents the
                          maximum tolerated percentage of partitions that can be unhealthy before the
                          service is considered in error."nIf the percentage is respected but there is
                          at least one unhealthy partition, the health is evaluated as Warning."nThe
                          percentage is calculated by dividing the number of unhealthy partitions over
                          the total number of partitions in the service."nThe computation rounds up to
                          tolerate one failure on small numbers of partitions. Default percentage is
                          zero.
                        "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional. The
                          maximum allowed percentage of unhealthy replicas per partition. Allowed
                          values are Byte values from zero to 100."n"nThe percentage represents the
                          maximum tolerated percentage of replicas that can be unhealthy before the
                          partition is considered in error."nIf the percentage is respected but there
                          is at least one unhealthy replica, the health is evaluated as Warning."nThe
                          percentage is calculated by dividing the number of unhealthy replicas over
                          the total number of replicas in the partition."nThe computation rounds up to
                          tolerate one failure on small numbers of replicas. Default percentage is
                          zero.
                        "MaxPercentUnhealthyServices": 0  # Optional. The maximum allowed
                          percentage of unhealthy services. Allowed values are Byte values from zero to
                          100."n"nThe percentage represents the maximum tolerated percentage of
                          services that can be unhealthy before the application is considered in
                          error."nIf the percentage is respected but there is at least one unhealthy
                          service, the health is evaluated as Warning."nThis is calculated by dividing
                          the number of unhealthy services of the specific service type over the total
                          number of services of the specific service type."nThe computation rounds up
                          to tolerate one failure on small numbers of services. Default percentage is
                          zero.
                    },
                    "MaxPercentUnhealthyDeployedApplications": 0,  # Optional. The maximum
                      allowed percentage of unhealthy deployed applications. Allowed values are Byte
                      values from zero to 100."nThe percentage represents the maximum tolerated
                      percentage of deployed applications that can be unhealthy before the application
                      is considered in error."nThis is calculated by dividing the number of unhealthy
                      deployed applications over the number of nodes where the application is currently
                      deployed on in the cluster."nThe computation rounds up to tolerate one failure on
                      small numbers of nodes. Default percentage is zero.
                    "ServiceTypeHealthPolicyMap": [
                        {
                            "Key": "str",  # Required. The key of the service type health
                              policy map item. This is the name of the service type.
                            "Value": {
                                "MaxPercentUnhealthyPartitionsPerService": 0,  #
                                  Optional. The maximum allowed percentage of unhealthy partitions per
                                  service. Allowed values are Byte values from zero to 100"n"nThe
                                  percentage represents the maximum tolerated percentage of partitions
                                  that can be unhealthy before the service is considered in error."nIf
                                  the percentage is respected but there is at least one unhealthy
                                  partition, the health is evaluated as Warning."nThe percentage is
                                  calculated by dividing the number of unhealthy partitions over the
                                  total number of partitions in the service."nThe computation rounds up
                                  to tolerate one failure on small numbers of partitions. Default
                                  percentage is zero.
                                "MaxPercentUnhealthyReplicasPerPartition": 0,  #
                                  Optional. The maximum allowed percentage of unhealthy replicas per
                                  partition. Allowed values are Byte values from zero to 100."n"nThe
                                  percentage represents the maximum tolerated percentage of replicas
                                  that can be unhealthy before the partition is considered in
                                  error."nIf the percentage is respected but there is at least one
                                  unhealthy replica, the health is evaluated as Warning."nThe
                                  percentage is calculated by dividing the number of unhealthy replicas
                                  over the total number of replicas in the partition."nThe computation
                                  rounds up to tolerate one failure on small numbers of replicas.
                                  Default percentage is zero.
                                "MaxPercentUnhealthyServices": 0  # Optional. The
                                  maximum allowed percentage of unhealthy services. Allowed values are
                                  Byte values from zero to 100."n"nThe percentage represents the
                                  maximum tolerated percentage of services that can be unhealthy before
                                  the application is considered in error."nIf the percentage is
                                  respected but there is at least one unhealthy service, the health is
                                  evaluated as Warning."nThis is calculated by dividing the number of
                                  unhealthy services of the specific service type over the total number
                                  of services of the specific service type."nThe computation rounds up
                                  to tolerate one failure on small numbers of services. Default
                                  percentage is zero.
                            }
                        }
                    ]
                }

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "DeployedApplicationHealthStates": [
                        {
                            "AggregatedHealthState": "str",  # Optional. The health state
                              of a Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "ApplicationName": "str",  # Optional. The name of the
                              application, including the 'fabric:' URI scheme.
                            "NodeName": "str"  # Optional. Name of the node on which the
                              service package is deployed.
                        }
                    ],
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "Name": "str",  # Optional. The name of the application, including the
                      'fabric:' URI scheme.
                    "ServiceHealthStates": [
                        {
                            "AggregatedHealthState": "str",  # Optional. The health state
                              of a Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "ServiceName": "str"  # Optional. Name of the service whose
                              health state is represented by this object.
                        }
                    ],
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        if application_health_policy is not None:
            _json = application_health_policy
        else:
            _json = None

        request = build_get_application_health_using_policy_request(
            application_id=application_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            events_health_state_filter=events_health_state_filter,
            deployed_applications_health_state_filter=deployed_applications_health_state_filter,
            services_health_state_filter=services_health_state_filter,
            exclude_health_statistics=exclude_health_statistics,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def report_application_health(  # pylint: disable=inconsistent-return-statements
        self,
        application_id: str,
        health_information: JSON,
        *,
        immediate: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Sends a health report on the Service Fabric application.

        Reports health state of the specified Service Fabric application. The report must contain the
        information about the source of the health report and property on which it is reported.
        The report is sent to a Service Fabric gateway Application, which forwards to the health store.
        The report may be accepted by the gateway, but rejected by the health store after extra
        validation.
        For example, the health store may reject the report because of an invalid parameter, like a
        stale sequence number.
        To see whether the report was applied in the health store, get application health and check
        that the report appears in the HealthEvents section.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param health_information: Describes the health information for the health report. This
         information needs to be present in all of the health reports sent to the health manager.
        :type health_information: JSON
        :keyword immediate: A flag that indicates whether the report should be sent immediately.
         A health report is sent to a Service Fabric gateway Application, which forwards to the health
         store.
         If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
         store, regardless of the fabric client settings that the HTTP Gateway Application is using.
         This is useful for critical reports that should be sent as soon as possible.
         Depending on timing and other conditions, sending the report may still fail, for example if
         the HTTP Gateway is closed or the message doesn't reach the Gateway.
         If Immediate is set to false, the report is sent based on the health client settings from the
         HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
         configuration.
         This is the recommended setting because it allows the health client to optimize health
         reporting messages to health store as well as health report processing.
         By default, reports are not sent immediately. Default value is False.
        :paramtype immediate: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                health_information = {
                    "Description": "str",  # Optional. The description of the health information.
                      It represents free text used to add human readable information about the
                      report."nThe maximum string length for the description is 4096 characters."nIf
                      the provided string is longer, it will be automatically truncated."nWhen
                      truncated, the last characters of the description contain a marker "[Truncated]",
                      and total string size is 4096 characters."nThe presence of the marker indicates
                      to users that truncation occurred."nNote that when truncated, the description has
                      less than 4096 characters from the original string.
                    "HealthReportId": "str",  # Optional. A health report ID which identifies the
                      health report and can be used to find more detailed information about a specific
                      health event at"naka.ms/sfhealthid.
                    "HealthState": "str",  # Required. The health state of a Service Fabric
                      entity such as Cluster, Node, Application, Service, Partition, Replica etc. Known
                      values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "Property": "str",  # Required. The property of the health information. An
                      entity can have health reports for different properties."nThe property is a
                      string and not a fixed enumeration to allow the reporter flexibility to
                      categorize the state condition that triggers the report."nFor example, a reporter
                      with SourceId "LocalWatchdog" can monitor the state of the available disk on a
                      node,"nso it can report "AvailableDisk" property on that node."nThe same reporter
                      can monitor the node connectivity, so it can report a property "Connectivity" on
                      the same node."nIn the health store, these reports are treated as separate health
                      events for the specified node."n"nTogether with the SourceId, the property
                      uniquely identifies the health information.
                    "RemoveWhenExpired": bool,  # Optional. Value that indicates whether the
                      report is removed from health store when it expires."nIf set to true, the report
                      is removed from the health store after it expires."nIf set to false, the report
                      is treated as an error when expired. The value of this property is false by
                      default."nWhen clients report periodically, they should set RemoveWhenExpired
                      false (default)."nThis way, if the reporter has issues (e.g. deadlock) and can't
                      report, the entity is evaluated at error when the health report expires."nThis
                      flags the entity as being in Error health state.
                    "SequenceNumber": "str",  # Optional. The sequence number for this health
                      report as a numeric string."nThe report sequence number is used by the health
                      store to detect stale reports."nIf not specified, a sequence number is
                      auto-generated by the health client when a report is added.
                    "SourceId": "str",  # Required. The source name that identifies the
                      client/watchdog/system component that generated the health information.
                    "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The duration for
                      which this health report is valid. This field uses ISO8601 format for specifying
                      the duration."nWhen clients report periodically, they should send reports with
                      higher frequency than time to live."nIf clients report on transition, they can
                      set the time to live to infinite."nWhen time to live expires, the health event
                      that contains the health information"nis either removed from health store, if
                      RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                      false."n"nIf not specified, time to live defaults to infinite value.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = health_information

        request = build_report_application_health_request(
            application_id=application_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            immediate=immediate,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def start_application_upgrade(  # pylint: disable=inconsistent-return-statements
        self,
        application_id: str,
        application_upgrade_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Starts upgrading an application in the Service Fabric cluster.

        Validates the supplied application upgrade parameters and starts upgrading the application if
        the parameters are valid.
        Note, `ApplicationParameter
        <https://docs.microsoft.com/dotnet/api/system.fabric.description.applicationdescription.applicationparameters>`_\
        s are not preserved across an application upgrade.
        In order to preserve current application parameters, the user should get the parameters using
        `GetApplicationInfo <./GetApplicationInfo.md>`_ operation first and pass them into the upgrade
        API call as shown in the example.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param application_upgrade_description: Parameters for an application upgrade.
        :type application_upgrade_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                application_upgrade_description = {
                    "ApplicationHealthPolicy": {
                        "ConsiderWarningAsError": bool,  # Optional. Indicates whether
                          warnings are treated with the same severity as errors.
                        "DefaultServiceTypeHealthPolicy": {
                            "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional.
                              The maximum allowed percentage of unhealthy partitions per service.
                              Allowed values are Byte values from zero to 100"n"nThe percentage
                              represents the maximum tolerated percentage of partitions that can be
                              unhealthy before the service is considered in error."nIf the percentage
                              is respected but there is at least one unhealthy partition, the health is
                              evaluated as Warning."nThe percentage is calculated by dividing the
                              number of unhealthy partitions over the total number of partitions in the
                              service."nThe computation rounds up to tolerate one failure on small
                              numbers of partitions. Default percentage is zero.
                            "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional.
                              The maximum allowed percentage of unhealthy replicas per partition.
                              Allowed values are Byte values from zero to 100."n"nThe percentage
                              represents the maximum tolerated percentage of replicas that can be
                              unhealthy before the partition is considered in error."nIf the percentage
                              is respected but there is at least one unhealthy replica, the health is
                              evaluated as Warning."nThe percentage is calculated by dividing the
                              number of unhealthy replicas over the total number of replicas in the
                              partition."nThe computation rounds up to tolerate one failure on small
                              numbers of replicas. Default percentage is zero.
                            "MaxPercentUnhealthyServices": 0  # Optional. The maximum
                              allowed percentage of unhealthy services. Allowed values are Byte values
                              from zero to 100."n"nThe percentage represents the maximum tolerated
                              percentage of services that can be unhealthy before the application is
                              considered in error."nIf the percentage is respected but there is at
                              least one unhealthy service, the health is evaluated as Warning."nThis is
                              calculated by dividing the number of unhealthy services of the specific
                              service type over the total number of services of the specific service
                              type."nThe computation rounds up to tolerate one failure on small numbers
                              of services. Default percentage is zero.
                        },
                        "MaxPercentUnhealthyDeployedApplications": 0,  # Optional. The
                          maximum allowed percentage of unhealthy deployed applications. Allowed values
                          are Byte values from zero to 100."nThe percentage represents the maximum
                          tolerated percentage of deployed applications that can be unhealthy before
                          the application is considered in error."nThis is calculated by dividing the
                          number of unhealthy deployed applications over the number of nodes where the
                          application is currently deployed on in the cluster."nThe computation rounds
                          up to tolerate one failure on small numbers of nodes. Default percentage is
                          zero.
                        "ServiceTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the service
                                  type health policy map item. This is the name of the service type.
                                "Value": {
                                    "MaxPercentUnhealthyPartitionsPerService": 0,
                                      # Optional. The maximum allowed percentage of unhealthy
                                      partitions per service. Allowed values are Byte values from zero
                                      to 100"n"nThe percentage represents the maximum tolerated
                                      percentage of partitions that can be unhealthy before the service
                                      is considered in error."nIf the percentage is respected but there
                                      is at least one unhealthy partition, the health is evaluated as
                                      Warning."nThe percentage is calculated by dividing the number of
                                      unhealthy partitions over the total number of partitions in the
                                      service."nThe computation rounds up to tolerate one failure on
                                      small numbers of partitions. Default percentage is zero.
                                    "MaxPercentUnhealthyReplicasPerPartition": 0,
                                      # Optional. The maximum allowed percentage of unhealthy replicas
                                      per partition. Allowed values are Byte values from zero to
                                      100."n"nThe percentage represents the maximum tolerated
                                      percentage of replicas that can be unhealthy before the partition
                                      is considered in error."nIf the percentage is respected but there
                                      is at least one unhealthy replica, the health is evaluated as
                                      Warning."nThe percentage is calculated by dividing the number of
                                      unhealthy replicas over the total number of replicas in the
                                      partition."nThe computation rounds up to tolerate one failure on
                                      small numbers of replicas. Default percentage is zero.
                                    "MaxPercentUnhealthyServices": 0  # Optional.
                                      The maximum allowed percentage of unhealthy services. Allowed
                                      values are Byte values from zero to 100."n"nThe percentage
                                      represents the maximum tolerated percentage of services that can
                                      be unhealthy before the application is considered in error."nIf
                                      the percentage is respected but there is at least one unhealthy
                                      service, the health is evaluated as Warning."nThis is calculated
                                      by dividing the number of unhealthy services of the specific
                                      service type over the total number of services of the specific
                                      service type."nThe computation rounds up to tolerate one failure
                                      on small numbers of services. Default percentage is zero.
                                }
                            }
                        ]
                    },
                    "ForceRestart": bool,  # Optional. If true, then processes are forcefully
                      restarted during upgrade even when the code version has not changed (the upgrade
                      only changes configuration or data).
                    "InstanceCloseDelayDurationInSeconds": 4294967295,  # Optional. Default value
                      is 4294967295. Duration in seconds, to wait before a stateless instance is
                      closed, to allow the active requests to drain gracefully. This would be effective
                      when the instance is closing during the application/cluster"nupgrade, only for
                      those instances which have a non-zero delay duration configured in the service
                      description. See InstanceCloseDelayDurationSeconds property in $ref:
                      "#/definitions/StatelessServiceDescription.yaml" for details."nNote, the default
                      value of InstanceCloseDelayDurationInSeconds is 4294967295, which indicates that
                      the behavior will entirely depend on the delay configured in the stateless
                      service description.
                    "ManagedApplicationIdentity": {
                        "ManagedIdentities": [
                            {
                                "Name": "str",  # Required. The name of the identity.
                                "PrincipalId": "str"  # Optional. The identity's
                                  PrincipalId.
                            }
                        ],
                        "TokenServiceEndpoint": "str"  # Optional. Token service endpoint.
                    },
                    "MonitoringPolicy": {
                        "FailureAction": "str",  # Optional. The compensating action to
                          perform when a Monitored upgrade encounters monitoring policy or health
                          policy violations."nInvalid indicates the failure action is invalid. Rollback
                          specifies that the upgrade will start rolling back automatically."nManual
                          indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
                          Known values are: "Invalid", "Rollback", "Manual".
                        "HealthCheckRetryTimeoutInMilliseconds": "PT0H10M0S",  # Optional.
                          Default value is "PT0H10M0S". The amount of time to retry health evaluation
                          when the application or cluster is unhealthy before FailureAction is
                          executed. It is first interpreted as a string representing an ISO 8601
                          duration. If that fails, then it is interpreted as a number representing the
                          total number of milliseconds.
                        "HealthCheckStableDurationInMilliseconds": "PT0H2M0S",  # Optional.
                          Default value is "PT0H2M0S". The amount of time that the application or
                          cluster must remain healthy before the upgrade proceeds to the next upgrade
                          domain. It is first interpreted as a string representing an ISO 8601
                          duration. If that fails, then it is interpreted as a number representing the
                          total number of milliseconds.
                        "HealthCheckWaitDurationInMilliseconds": "0",  # Optional. Default
                          value is "0". The amount of time to wait after completing an upgrade domain
                          before applying health policies. It is first interpreted as a string
                          representing an ISO 8601 duration. If that fails, then it is interpreted as a
                          number representing the total number of milliseconds.
                        "UpgradeDomainTimeoutInMilliseconds": "P10675199DT02H48M05.4775807S",
                          # Optional. Default value is "P10675199DT02H48M05.4775807S". The amount of
                          time each upgrade domain has to complete before FailureAction is executed. It
                          is first interpreted as a string representing an ISO 8601 duration. If that
                          fails, then it is interpreted as a number representing the total number of
                          milliseconds.
                        "UpgradeTimeoutInMilliseconds": "P10675199DT02H48M05.4775807S"  #
                          Optional. Default value is "P10675199DT02H48M05.4775807S". The amount of time
                          the overall upgrade has to complete before FailureAction is executed. It is
                          first interpreted as a string representing an ISO 8601 duration. If that
                          fails, then it is interpreted as a number representing the total number of
                          milliseconds.
                    },
                    "Name": "str",  # Required. The name of the target application, including the
                      'fabric:' URI scheme.
                    "Parameters": [
                        {
                            "Key": "str",  # Required. The name of the parameter.
                            "Value": "str"  # Required. The value of the parameter.
                        }
                    ],
                    "RollingUpgradeMode": "UnmonitoredAuto",  # Optional. Default value is
                      "UnmonitoredAuto". The mode used to monitor health during a rolling upgrade. The
                      values are UnmonitoredAuto, UnmonitoredManual, Monitored, and
                      UnmonitoredDeferred. Known values are: "Invalid", "UnmonitoredAuto",
                      "UnmonitoredManual", "Monitored", "UnmonitoredDeferred". Default value:
                      "UnmonitoredAuto".
                    "SortOrder": "Default",  # Optional. Default value is "Default". Defines the
                      order in which an upgrade proceeds through the cluster. Known values are:
                      "Invalid", "Default", "Numeric", "Lexicographical", "ReverseNumeric",
                      "ReverseLexicographical". Default value: "Default".
                    "TargetApplicationTypeVersion": "str",  # Required. The target application
                      type version (found in the application manifest) for the application upgrade.
                    "UpgradeKind": "Rolling",  # Default value is "Rolling". Required. The kind
                      of upgrade out of the following possible values. Known values are: "Invalid",
                      "Rolling". Default value: "Rolling".
                    "UpgradeReplicaSetCheckTimeoutInSeconds": 42949672925  # Optional. Default
                      value is 42949672925. The maximum amount of time to block processing of an
                      upgrade domain and prevent loss of availability when there are unexpected issues.
                      When this timeout expires, processing of the upgrade domain will proceed
                      regardless of availability loss issues. The timeout is reset at the start of each
                      upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
                      32-bit integer).
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = application_upgrade_description

        request = build_start_application_upgrade_request(
            application_id=application_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_application_upgrade(
        self,
        application_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets details for the latest upgrade performed on this application.

        Returns information about the state of the latest application upgrade along with details to aid
        debugging application health issues.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "CurrentUpgradeDomainProgress": {
                        "DomainName": "str",  # Optional. The name of the upgrade domain.
                        "NodeUpgradeProgressList": [
                            {
                                "NodeName": "str",  # Optional. The name of a Service
                                  Fabric node.
                                "PendingSafetyChecks": [
                                    {
                                        "SafetyCheck": {
                                            Kind: Kind
                                        }
                                    }
                                ],
                                "UpgradeDuration": "str",  # Optional. The estimated
                                  time spent processing the node since it was deactivated during a
                                  node-by-node upgrade.
                                "UpgradePhase": "str"  # Optional. The state of the
                                  upgrading node. Known values are: "Invalid", "PreUpgradeSafetyCheck",
                                  "Upgrading", "PostUpgradeSafetyCheck".
                            }
                        ]
                    },
                    "CurrentUpgradeUnitsProgress": {
                        "DomainName": "str",  # Optional. The name of the upgrade domain. Not
                          applicable to node-by-node upgrades.
                        "NodeUpgradeProgressList": [
                            {
                                "NodeName": "str",  # Optional. The name of a Service
                                  Fabric node.
                                "PendingSafetyChecks": [
                                    {
                                        "SafetyCheck": {
                                            Kind: Kind
                                        }
                                    }
                                ],
                                "UpgradeDuration": "str",  # Optional. The estimated
                                  time spent processing the node since it was deactivated during a
                                  node-by-node upgrade.
                                "UpgradePhase": "str"  # Optional. The state of the
                                  upgrading node. Known values are: "Invalid", "PreUpgradeSafetyCheck",
                                  "Upgrading", "PostUpgradeSafetyCheck".
                            }
                        ]
                    },
                    "FailureReason": "str",  # Optional. The cause of an upgrade failure that
                      resulted in FailureAction being executed. Known values are: "None",
                      "Interrupted", "HealthCheck", "UpgradeDomainTimeout", "OverallUpgradeTimeout".
                    "FailureTimestampUtc": "str",  # Optional. The estimated UTC datetime when
                      the upgrade failed and FailureAction was executed.
                    "IsNodeByNode": bool,  # Optional. Indicates whether this upgrade is
                      node-by-node.
                    "Name": "str",  # Optional. The name of the target application, including the
                      'fabric:' URI scheme.
                    "NextUpgradeDomain": "str",  # Optional. The name of the next upgrade domain
                      to be processed. Not applicable to node-by-node upgrades.
                    "RollingUpgradeMode": "UnmonitoredAuto",  # Optional. Default value is
                      "UnmonitoredAuto". The mode used to monitor health during a rolling upgrade. The
                      values are UnmonitoredAuto, UnmonitoredManual, Monitored, and
                      UnmonitoredDeferred. Known values are: "Invalid", "UnmonitoredAuto",
                      "UnmonitoredManual", "Monitored", "UnmonitoredDeferred". Default value:
                      "UnmonitoredAuto".
                    "StartTimestampUtc": "str",  # Optional. The estimated UTC datetime when the
                      upgrade started.
                    "TargetApplicationTypeVersion": "str",  # Optional. The target application
                      type version (found in the application manifest) for the application upgrade.
                    "TypeName": "str",  # Optional. The application type name as defined in the
                      application manifest.
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ],
                    "UpgradeDescription": {
                        "ApplicationHealthPolicy": {
                            "ConsiderWarningAsError": bool,  # Optional. Indicates
                              whether warnings are treated with the same severity as errors.
                            "DefaultServiceTypeHealthPolicy": {
                                "MaxPercentUnhealthyPartitionsPerService": 0,  #
                                  Optional. The maximum allowed percentage of unhealthy partitions per
                                  service. Allowed values are Byte values from zero to 100"n"nThe
                                  percentage represents the maximum tolerated percentage of partitions
                                  that can be unhealthy before the service is considered in error."nIf
                                  the percentage is respected but there is at least one unhealthy
                                  partition, the health is evaluated as Warning."nThe percentage is
                                  calculated by dividing the number of unhealthy partitions over the
                                  total number of partitions in the service."nThe computation rounds up
                                  to tolerate one failure on small numbers of partitions. Default
                                  percentage is zero.
                                "MaxPercentUnhealthyReplicasPerPartition": 0,  #
                                  Optional. The maximum allowed percentage of unhealthy replicas per
                                  partition. Allowed values are Byte values from zero to 100."n"nThe
                                  percentage represents the maximum tolerated percentage of replicas
                                  that can be unhealthy before the partition is considered in
                                  error."nIf the percentage is respected but there is at least one
                                  unhealthy replica, the health is evaluated as Warning."nThe
                                  percentage is calculated by dividing the number of unhealthy replicas
                                  over the total number of replicas in the partition."nThe computation
                                  rounds up to tolerate one failure on small numbers of replicas.
                                  Default percentage is zero.
                                "MaxPercentUnhealthyServices": 0  # Optional. The
                                  maximum allowed percentage of unhealthy services. Allowed values are
                                  Byte values from zero to 100."n"nThe percentage represents the
                                  maximum tolerated percentage of services that can be unhealthy before
                                  the application is considered in error."nIf the percentage is
                                  respected but there is at least one unhealthy service, the health is
                                  evaluated as Warning."nThis is calculated by dividing the number of
                                  unhealthy services of the specific service type over the total number
                                  of services of the specific service type."nThe computation rounds up
                                  to tolerate one failure on small numbers of services. Default
                                  percentage is zero.
                            },
                            "MaxPercentUnhealthyDeployedApplications": 0,  # Optional.
                              The maximum allowed percentage of unhealthy deployed applications.
                              Allowed values are Byte values from zero to 100."nThe percentage
                              represents the maximum tolerated percentage of deployed applications that
                              can be unhealthy before the application is considered in error."nThis is
                              calculated by dividing the number of unhealthy deployed applications over
                              the number of nodes where the application is currently deployed on in the
                              cluster."nThe computation rounds up to tolerate one failure on small
                              numbers of nodes. Default percentage is zero.
                            "ServiceTypeHealthPolicyMap": [
                                {
                                    "Key": "str",  # Required. The key of the
                                      service type health policy map item. This is the name of the
                                      service type.
                                    "Value": {
                "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional.
                                          The maximum allowed percentage of unhealthy partitions per
                                          service. Allowed values are Byte values from zero to
                                          100"n"nThe percentage represents the maximum tolerated
                                          percentage of partitions that can be unhealthy before the
                                          service is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy partition, the
                                          health is evaluated as Warning."nThe percentage is calculated
                                          by dividing the number of unhealthy partitions over the total
                                          number of partitions in the service."nThe computation rounds
                                          up to tolerate one failure on small numbers of partitions.
                                          Default percentage is zero.
                "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional.
                                          The maximum allowed percentage of unhealthy replicas per
                                          partition. Allowed values are Byte values from zero to
                                          100."n"nThe percentage represents the maximum tolerated
                                          percentage of replicas that can be unhealthy before the
                                          partition is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy replica, the
                                          health is evaluated as Warning."nThe percentage is calculated
                                          by dividing the number of unhealthy replicas over the total
                                          number of replicas in the partition."nThe computation rounds
                                          up to tolerate one failure on small numbers of replicas.
                                          Default percentage is zero.
                                        "MaxPercentUnhealthyServices": 0  #
                                          Optional. The maximum allowed percentage of unhealthy
                                          services. Allowed values are Byte values from zero to
                                          100."n"nThe percentage represents the maximum tolerated
                                          percentage of services that can be unhealthy before the
                                          application is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy service, the
                                          health is evaluated as Warning."nThis is calculated by
                                          dividing the number of unhealthy services of the specific
                                          service type over the total number of services of the
                                          specific service type."nThe computation rounds up to tolerate
                                          one failure on small numbers of services. Default percentage
                                          is zero.
                                    }
                                }
                            ]
                        },
                        "ForceRestart": bool,  # Optional. If true, then processes are
                          forcefully restarted during upgrade even when the code version has not
                          changed (the upgrade only changes configuration or data).
                        "InstanceCloseDelayDurationInSeconds": 4294967295,  # Optional.
                          Default value is 4294967295. Duration in seconds, to wait before a stateless
                          instance is closed, to allow the active requests to drain gracefully. This
                          would be effective when the instance is closing during the
                          application/cluster"nupgrade, only for those instances which have a non-zero
                          delay duration configured in the service description. See
                          InstanceCloseDelayDurationSeconds property in $ref:
                          "#/definitions/StatelessServiceDescription.yaml" for details."nNote, the
                          default value of InstanceCloseDelayDurationInSeconds is 4294967295, which
                          indicates that the behavior will entirely depend on the delay configured in
                          the stateless service description.
                        "ManagedApplicationIdentity": {
                            "ManagedIdentities": [
                                {
                                    "Name": "str",  # Required. The name of the
                                      identity.
                                    "PrincipalId": "str"  # Optional. The
                                      identity's PrincipalId.
                                }
                            ],
                            "TokenServiceEndpoint": "str"  # Optional. Token service
                              endpoint.
                        },
                        "MonitoringPolicy": {
                            "FailureAction": "str",  # Optional. The compensating action
                              to perform when a Monitored upgrade encounters monitoring policy or
                              health policy violations."nInvalid indicates the failure action is
                              invalid. Rollback specifies that the upgrade will start rolling back
                              automatically."nManual indicates that the upgrade will switch to
                              UnmonitoredManual upgrade mode. Known values are: "Invalid", "Rollback",
                              "Manual".
                            "HealthCheckRetryTimeoutInMilliseconds": "PT0H10M0S",  #
                              Optional. Default value is "PT0H10M0S". The amount of time to retry
                              health evaluation when the application or cluster is unhealthy before
                              FailureAction is executed. It is first interpreted as a string
                              representing an ISO 8601 duration. If that fails, then it is interpreted
                              as a number representing the total number of milliseconds.
                            "HealthCheckStableDurationInMilliseconds": "PT0H2M0S",  #
                              Optional. Default value is "PT0H2M0S". The amount of time that the
                              application or cluster must remain healthy before the upgrade proceeds to
                              the next upgrade domain. It is first interpreted as a string representing
                              an ISO 8601 duration. If that fails, then it is interpreted as a number
                              representing the total number of milliseconds.
                            "HealthCheckWaitDurationInMilliseconds": "0",  # Optional.
                              Default value is "0". The amount of time to wait after completing an
                              upgrade domain before applying health policies. It is first interpreted
                              as a string representing an ISO 8601 duration. If that fails, then it is
                              interpreted as a number representing the total number of milliseconds.
                            "UpgradeDomainTimeoutInMilliseconds":
                              "P10675199DT02H48M05.4775807S",  # Optional. Default value is
                              "P10675199DT02H48M05.4775807S". The amount of time each upgrade domain
                              has to complete before FailureAction is executed. It is first interpreted
                              as a string representing an ISO 8601 duration. If that fails, then it is
                              interpreted as a number representing the total number of milliseconds.
                            "UpgradeTimeoutInMilliseconds":
                              "P10675199DT02H48M05.4775807S"  # Optional. Default value is
                              "P10675199DT02H48M05.4775807S". The amount of time the overall upgrade
                              has to complete before FailureAction is executed. It is first interpreted
                              as a string representing an ISO 8601 duration. If that fails, then it is
                              interpreted as a number representing the total number of milliseconds.
                        },
                        "Name": "str",  # Required. The name of the target application,
                          including the 'fabric:' URI scheme.
                        "Parameters": [
                            {
                                "Key": "str",  # Required. The name of the parameter.
                                "Value": "str"  # Required. The value of the
                                  parameter.
                            }
                        ],
                        "RollingUpgradeMode": "UnmonitoredAuto",  # Optional. Default value
                          is "UnmonitoredAuto". The mode used to monitor health during a rolling
                          upgrade. The values are UnmonitoredAuto, UnmonitoredManual, Monitored, and
                          UnmonitoredDeferred. Known values are: "Invalid", "UnmonitoredAuto",
                          "UnmonitoredManual", "Monitored", "UnmonitoredDeferred". Default value:
                          "UnmonitoredAuto".
                        "SortOrder": "Default",  # Optional. Default value is "Default".
                          Defines the order in which an upgrade proceeds through the cluster. Known
                          values are: "Invalid", "Default", "Numeric", "Lexicographical",
                          "ReverseNumeric", "ReverseLexicographical". Default value: "Default".
                        "TargetApplicationTypeVersion": "str",  # Required. The target
                          application type version (found in the application manifest) for the
                          application upgrade.
                        "UpgradeKind": "Rolling",  # Default value is "Rolling". Required.
                          The kind of upgrade out of the following possible values. Known values are:
                          "Invalid", "Rolling". Default value: "Rolling".
                        "UpgradeReplicaSetCheckTimeoutInSeconds": 42949672925  # Optional.
                          Default value is 42949672925. The maximum amount of time to block processing
                          of an upgrade domain and prevent loss of availability when there are
                          unexpected issues. When this timeout expires, processing of the upgrade
                          domain will proceed regardless of availability loss issues. The timeout is
                          reset at the start of each upgrade domain. Valid values are between 0 and
                          42949672925 inclusive. (unsigned 32-bit integer).
                    },
                    "UpgradeDomainDurationInMilliseconds": "str",  # Optional. The estimated
                      total amount of time spent processing the current upgrade domain.
                    "UpgradeDomainProgressAtFailure": {
                        "DomainName": "str",  # Optional. The name of the upgrade domain.
                        "NodeUpgradeProgressList": [
                            {
                                "NodeName": "str",  # Optional. The name of a Service
                                  Fabric node.
                                "PendingSafetyChecks": [
                                    {
                                        "SafetyCheck": {
                                            Kind: Kind
                                        }
                                    }
                                ],
                                "UpgradeDuration": "str",  # Optional. The estimated
                                  time spent processing the node since it was deactivated during a
                                  node-by-node upgrade.
                                "UpgradePhase": "str"  # Optional. The state of the
                                  upgrading node. Known values are: "Invalid", "PreUpgradeSafetyCheck",
                                  "Upgrading", "PostUpgradeSafetyCheck".
                            }
                        ]
                    },
                    "UpgradeDomains": [
                        {
                            "Name": "str",  # Optional. The name of the upgrade domain.
                            "State": "str"  # Optional. The state of the upgrade domain.
                              Known values are: "Invalid", "Pending", "InProgress", "Completed".
                        }
                    ],
                    "UpgradeDurationInMilliseconds": "str",  # Optional. The estimated total
                      amount of time spent processing the overall upgrade.
                    "UpgradeState": "str",  # Optional. The state of the upgrade domain. Known
                      values are: "Invalid", "RollingBackInProgress", "RollingBackCompleted",
                      "RollingForwardPending", "RollingForwardInProgress", "RollingForwardCompleted",
                      "Failed".
                    "UpgradeStatusDetails": "str",  # Optional. Additional detailed information
                      about the status of the pending upgrade.
                    "UpgradeUnits": [
                        {
                            "Name": "str",  # Optional. The name of the upgrade unit.
                            "State": "str"  # Optional. The state of the upgrade unit.
                              Known values are: "Invalid", "Pending", "InProgress", "Completed",
                              "Failed".
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_application_upgrade_request(
            application_id=application_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def update_application_upgrade(  # pylint: disable=inconsistent-return-statements
        self,
        application_id: str,
        application_upgrade_update_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Updates an ongoing application upgrade in the Service Fabric cluster.

        Updates the parameters of an ongoing application upgrade from the ones specified at the time of
        starting the application upgrade. This may be required to mitigate stuck application upgrades
        due to incorrect parameters or issues in the application to make progress.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param application_upgrade_update_description: Parameters for updating an existing application
         upgrade.
        :type application_upgrade_update_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                application_upgrade_update_description = {
                    "ApplicationHealthPolicy": {
                        "ConsiderWarningAsError": bool,  # Optional. Indicates whether
                          warnings are treated with the same severity as errors.
                        "DefaultServiceTypeHealthPolicy": {
                            "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional.
                              The maximum allowed percentage of unhealthy partitions per service.
                              Allowed values are Byte values from zero to 100"n"nThe percentage
                              represents the maximum tolerated percentage of partitions that can be
                              unhealthy before the service is considered in error."nIf the percentage
                              is respected but there is at least one unhealthy partition, the health is
                              evaluated as Warning."nThe percentage is calculated by dividing the
                              number of unhealthy partitions over the total number of partitions in the
                              service."nThe computation rounds up to tolerate one failure on small
                              numbers of partitions. Default percentage is zero.
                            "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional.
                              The maximum allowed percentage of unhealthy replicas per partition.
                              Allowed values are Byte values from zero to 100."n"nThe percentage
                              represents the maximum tolerated percentage of replicas that can be
                              unhealthy before the partition is considered in error."nIf the percentage
                              is respected but there is at least one unhealthy replica, the health is
                              evaluated as Warning."nThe percentage is calculated by dividing the
                              number of unhealthy replicas over the total number of replicas in the
                              partition."nThe computation rounds up to tolerate one failure on small
                              numbers of replicas. Default percentage is zero.
                            "MaxPercentUnhealthyServices": 0  # Optional. The maximum
                              allowed percentage of unhealthy services. Allowed values are Byte values
                              from zero to 100."n"nThe percentage represents the maximum tolerated
                              percentage of services that can be unhealthy before the application is
                              considered in error."nIf the percentage is respected but there is at
                              least one unhealthy service, the health is evaluated as Warning."nThis is
                              calculated by dividing the number of unhealthy services of the specific
                              service type over the total number of services of the specific service
                              type."nThe computation rounds up to tolerate one failure on small numbers
                              of services. Default percentage is zero.
                        },
                        "MaxPercentUnhealthyDeployedApplications": 0,  # Optional. The
                          maximum allowed percentage of unhealthy deployed applications. Allowed values
                          are Byte values from zero to 100."nThe percentage represents the maximum
                          tolerated percentage of deployed applications that can be unhealthy before
                          the application is considered in error."nThis is calculated by dividing the
                          number of unhealthy deployed applications over the number of nodes where the
                          application is currently deployed on in the cluster."nThe computation rounds
                          up to tolerate one failure on small numbers of nodes. Default percentage is
                          zero.
                        "ServiceTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the service
                                  type health policy map item. This is the name of the service type.
                                "Value": {
                                    "MaxPercentUnhealthyPartitionsPerService": 0,
                                      # Optional. The maximum allowed percentage of unhealthy
                                      partitions per service. Allowed values are Byte values from zero
                                      to 100"n"nThe percentage represents the maximum tolerated
                                      percentage of partitions that can be unhealthy before the service
                                      is considered in error."nIf the percentage is respected but there
                                      is at least one unhealthy partition, the health is evaluated as
                                      Warning."nThe percentage is calculated by dividing the number of
                                      unhealthy partitions over the total number of partitions in the
                                      service."nThe computation rounds up to tolerate one failure on
                                      small numbers of partitions. Default percentage is zero.
                                    "MaxPercentUnhealthyReplicasPerPartition": 0,
                                      # Optional. The maximum allowed percentage of unhealthy replicas
                                      per partition. Allowed values are Byte values from zero to
                                      100."n"nThe percentage represents the maximum tolerated
                                      percentage of replicas that can be unhealthy before the partition
                                      is considered in error."nIf the percentage is respected but there
                                      is at least one unhealthy replica, the health is evaluated as
                                      Warning."nThe percentage is calculated by dividing the number of
                                      unhealthy replicas over the total number of replicas in the
                                      partition."nThe computation rounds up to tolerate one failure on
                                      small numbers of replicas. Default percentage is zero.
                                    "MaxPercentUnhealthyServices": 0  # Optional.
                                      The maximum allowed percentage of unhealthy services. Allowed
                                      values are Byte values from zero to 100."n"nThe percentage
                                      represents the maximum tolerated percentage of services that can
                                      be unhealthy before the application is considered in error."nIf
                                      the percentage is respected but there is at least one unhealthy
                                      service, the health is evaluated as Warning."nThis is calculated
                                      by dividing the number of unhealthy services of the specific
                                      service type over the total number of services of the specific
                                      service type."nThe computation rounds up to tolerate one failure
                                      on small numbers of services. Default percentage is zero.
                                }
                            }
                        ]
                    },
                    "Name": "str",  # Required. The name of the application, including the
                      'fabric:' URI scheme.
                    "UpdateDescription": {
                        "FailureAction": "str",  # Optional. The compensating action to
                          perform when a Monitored upgrade encounters monitoring policy or health
                          policy violations."nInvalid indicates the failure action is invalid. Rollback
                          specifies that the upgrade will start rolling back automatically."nManual
                          indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
                          Known values are: "Invalid", "Rollback", "Manual".
                        "ForceRestart": bool,  # Optional. If true, then processes are
                          forcefully restarted during upgrade even when the code version has not
                          changed (the upgrade only changes configuration or data).
                        "HealthCheckRetryTimeoutInMilliseconds": "PT0H10M0S",  # Optional.
                          Default value is "PT0H10M0S". The amount of time to retry health evaluation
                          when the application or cluster is unhealthy before FailureAction is
                          executed. It is first interpreted as a string representing an ISO 8601
                          duration. If that fails, then it is interpreted as a number representing the
                          total number of milliseconds.
                        "HealthCheckStableDurationInMilliseconds": "PT0H2M0S",  # Optional.
                          Default value is "PT0H2M0S". The amount of time that the application or
                          cluster must remain healthy before the upgrade proceeds to the next upgrade
                          domain. It is first interpreted as a string representing an ISO 8601
                          duration. If that fails, then it is interpreted as a number representing the
                          total number of milliseconds.
                        "HealthCheckWaitDurationInMilliseconds": "0",  # Optional. Default
                          value is "0". The amount of time to wait after completing an upgrade domain
                          before applying health policies. It is first interpreted as a string
                          representing an ISO 8601 duration. If that fails, then it is interpreted as a
                          number representing the total number of milliseconds.
                        "InstanceCloseDelayDurationInSeconds": 4294967295,  # Optional.
                          Default value is 4294967295. Duration in seconds, to wait before a stateless
                          instance is closed, to allow the active requests to drain gracefully. This
                          would be effective when the instance is closing during the
                          application/cluster"nupgrade, only for those instances which have a non-zero
                          delay duration configured in the service description. See
                          InstanceCloseDelayDurationSeconds property in $ref:
                          "#/definitions/StatelessServiceDescription.yaml" for details."nNote, the
                          default value of InstanceCloseDelayDurationInSeconds is 4294967295, which
                          indicates that the behavior will entirely depend on the delay configured in
                          the stateless service description.
                        "ReplicaSetCheckTimeoutInMilliseconds": 42949672925,  # Optional.
                          Default value is 42949672925. The maximum amount of time to block processing
                          of an upgrade domain and prevent loss of availability when there are
                          unexpected issues. When this timeout expires, processing of the upgrade
                          domain will proceed regardless of availability loss issues. The timeout is
                          reset at the start of each upgrade domain. Valid values are between 0 and
                          42949672925 inclusive. (unsigned 32-bit integer).
                        "RollingUpgradeMode": "UnmonitoredAuto",  # Default value is
                          "UnmonitoredAuto". Required. The mode used to monitor health during a rolling
                          upgrade. The values are UnmonitoredAuto, UnmonitoredManual, Monitored, and
                          UnmonitoredDeferred. Known values are: "Invalid", "UnmonitoredAuto",
                          "UnmonitoredManual", "Monitored", "UnmonitoredDeferred". Default value:
                          "UnmonitoredAuto".
                        "UpgradeDomainTimeoutInMilliseconds": "P10675199DT02H48M05.4775807S",
                          # Optional. Default value is "P10675199DT02H48M05.4775807S". The amount of
                          time each upgrade domain has to complete before FailureAction is executed. It
                          is first interpreted as a string representing an ISO 8601 duration. If that
                          fails, then it is interpreted as a number representing the total number of
                          milliseconds.
                        "UpgradeTimeoutInMilliseconds": "P10675199DT02H48M05.4775807S"  #
                          Optional. Default value is "P10675199DT02H48M05.4775807S". The amount of time
                          the overall upgrade has to complete before FailureAction is executed. It is
                          first interpreted as a string representing an ISO 8601 duration. If that
                          fails, then it is interpreted as a number representing the total number of
                          milliseconds.
                    },
                    "UpgradeKind": "Rolling"  # Default value is "Rolling". Required. The kind of
                      upgrade out of the following possible values. Known values are: "Invalid",
                      "Rolling". Default value: "Rolling".
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = application_upgrade_update_description

        request = build_update_application_upgrade_request(
            application_id=application_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def update_application(  # pylint: disable=inconsistent-return-statements
        self,
        application_id: str,
        application_update_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Updates a Service Fabric application.

        Updates a Service Fabric application instance. The set of properties that can be updated are a
        subset of the properties that were specified at the time of creating the application.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param application_update_description: Parameters for updating an existing application
         instance.
        :type application_update_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '8.1'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "8.1". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                application_update_description = {
                    "ApplicationMetrics": [
                        {
                            "MaximumCapacity": 0.0,  # Optional. The maximum node
                              capacity for Service Fabric application."nThis is the maximum Load for an
                              instance of this application on a single node. Even if the capacity of
                              node is greater than this value, Service Fabric will limit the total load
                              of services within the application on each node to this value."nIf set to
                              zero, capacity for this metric is unlimited on each node."nWhen creating
                              a new application with application capacity defined, the product of
                              MaximumNodes and this value must always be smaller than or equal to
                              TotalApplicationCapacity."nWhen updating existing application with
                              application capacity, the product of MaximumNodes and this value must
                              always be smaller than or equal to TotalApplicationCapacity.
                            "Name": "str",  # Optional. The name of the metric.
                            "ReservationCapacity": 0.0,  # Optional. The node reservation
                              capacity for Service Fabric application."nThis is the amount of load
                              which is reserved on nodes which have instances of this application."nIf
                              MinimumNodes is specified, then the product of these values will be the
                              capacity reserved in the cluster for the application."nIf set to zero, no
                              capacity is reserved for this metric."nWhen setting application capacity
                              or when updating application capacity; this value must be smaller than or
                              equal to MaximumCapacity for each metric.
                            "TotalApplicationCapacity": 0.0  # Optional. The total metric
                              capacity for Service Fabric application."nThis is the total metric
                              capacity for this application in the cluster. Service Fabric will try to
                              limit the sum of loads of services within the application to this
                              value."nWhen creating a new application with application capacity
                              defined, the product of MaximumNodes and MaximumCapacity must always be
                              smaller than or equal to this value.
                        }
                    ],
                    "Flags": "str",  # Optional. Flags indicating whether other properties are
                      set. Each of the associated properties corresponds to a flag, specified below,
                      which, if set, indicate that the property is specified."nIf flags are not
                      specified for a certain property, the property will not be updated even if the
                      new value is provided."nThis property can be a combination of those flags
                      obtained using bitwise 'OR' operator. Exception is RemoveApplicationCapacity
                      which cannot be specified along with other parameters."nFor example, if the
                      provided value is 3 then the flags for MinimumNodes (1) and MaximumNodes (2) are
                      set."n"n"n* None - Does not indicate any other properties are set. The value is
                      0."n* MinimumNodes - Indicates whether the MinimumNodes property is set. The
                      value is 1."n* MaximumNodes - Indicates whether the MinimumNodes property is set.
                      The value is  2."n* ApplicationMetrics - Indicates whether the ApplicationMetrics
                      property is set. The value is 4.
                    "MaximumNodes": 0.0,  # Optional. The maximum number of nodes where Service
                      Fabric will reserve capacity for this application. Note that this does not mean
                      that the services of this application will be placed on all of those nodes. By
                      default, the value of this property is zero and it means that the services can be
                      placed on any node.
                    "MinimumNodes": 0.0,  # Optional. The minimum number of nodes where Service
                      Fabric will reserve capacity for this application. Note that this does not mean
                      that the services of this application will be placed on all of those nodes. If
                      this property is set to zero, no capacity will be reserved. The value of this
                      property cannot be more than the value of the MaximumNodes property.
                    "RemoveApplicationCapacity": bool  # Optional. Used to clear all parameters
                      related to Application Capacity for this application. |"nIt is not possible to
                      specify this parameter together with other Application Capacity parameters.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "8.1"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = application_update_description

        request = build_update_application_request(
            application_id=application_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def resume_application_upgrade(  # pylint: disable=inconsistent-return-statements
        self,
        application_id: str,
        resume_application_upgrade_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Resumes upgrading an application in the Service Fabric cluster.

        Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one
        upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an
        upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param resume_application_upgrade_description: Describes the parameters for resuming an
         application upgrade.
        :type resume_application_upgrade_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resume_application_upgrade_description = {
                    "UpgradeDomainName": "str"  # Required. The name of the upgrade domain in
                      which to resume the upgrade.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = resume_application_upgrade_description

        request = build_resume_application_upgrade_request(
            application_id=application_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def rollback_application_upgrade(  # pylint: disable=inconsistent-return-statements
        self,
        application_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Starts rolling back the currently on-going upgrade of an application in the Service Fabric
        cluster.

        Starts rolling back the current application upgrade to the previous version. This API can only
        be used to roll back the current in-progress upgrade that is rolling forward to new version. If
        the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it
        to desired version, including rolling back to a previous version.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_rollback_application_upgrade_request(
            application_id=application_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_deployed_application_info_list(
        self,
        node_name: str,
        *,
        timeout: Optional[int] = 60,
        include_health_state: Optional[bool] = False,
        continuation_token_parameter: Optional[str] = None,
        max_results: Optional[int] = 0,
        **kwargs: Any
    ) -> JSON:
        """Gets the list of applications deployed on a Service Fabric node.

        Gets the list of applications deployed on a Service Fabric node. The results do not include
        information about deployed system applications unless explicitly queried for by ID. Results
        encompass deployed applications in active, activating, and downloading states. This query
        requires that the node name corresponds to a node on the cluster. The query fails if the
        provided node name does not point to any active Service Fabric nodes on the cluster.

        :param node_name: The name of the node.
        :type node_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword include_health_state: Include the health state of an entity.
         If this parameter is false or not specified, then the health state returned is "Unknown".
         When set to true, the query goes in parallel to the node and the health system service before
         the results are merged.
         As a result, the query is more expensive and may take a longer time. Default value is False.
        :paramtype include_health_state: bool
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.1'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.1". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "HealthState": "str",  # Optional. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "Id": "str",  # Optional. The identity of the application.
                              This is an encoded representation of the application name. This is used
                              in the REST APIs to identify the application resource."nStarting in
                              version 6.0, hierarchical names are delimited with the "~" character. For
                              example, if the application name is "fabric:/myapp/app1","nthe
                              application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in
                              previous versions.
                            "LogDirectory": "str",  # Optional. The log directory of the
                              application on the node. The log directory can be used to store
                              application logs.
                            "Name": "str",  # Optional. The name of the application,
                              including the 'fabric:' URI scheme.
                            "Status": "str",  # Optional. The status of the application
                              deployed on the node. Following are the possible values. Known values
                              are: "Invalid", "Downloading", "Activating", "Active", "Upgrading",
                              "Deactivating".
                            "TempDirectory": "str",  # Optional. The temp directory of
                              the application on the node. The code packages belonging to the
                              application are forked with this directory set as their temporary
                              directory.
                            "TypeName": "str",  # Optional. The application type name as
                              defined in the application manifest.
                            "TypeVersion": "str",  # Optional. The version of the
                              application type as defined in the application manifest.
                            "WorkDirectory": "str"  # Optional. The work directory of the
                              application on the node. The work directory can be used to store
                              application data.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.1"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_deployed_application_info_list_request(
            node_name=node_name,
            api_version=api_version,
            timeout=timeout,
            include_health_state=include_health_state,
            continuation_token_parameter=continuation_token_parameter,
            max_results=max_results,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_deployed_application_info(
        self,
        node_name: str,
        application_id: str,
        *,
        timeout: Optional[int] = 60,
        include_health_state: Optional[bool] = False,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Gets the information about an application deployed on a Service Fabric node.

        This query returns system application information if the application ID provided is for system
        application. Results encompass deployed applications in active, activating, and downloading
        states. This query requires that the node name corresponds to a node on the cluster. The query
        fails if the provided node name does not point to any active Service Fabric nodes on the
        cluster.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword include_health_state: Include the health state of an entity.
         If this parameter is false or not specified, then the health state returned is "Unknown".
         When set to true, the query goes in parallel to the node and the health system service before
         the results are merged.
         As a result, the query is more expensive and may take a longer time. Default value is False.
        :paramtype include_health_state: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.1'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.1". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "HealthState": "str",  # Optional. The health state of a Service Fabric
                      entity such as Cluster, Node, Application, Service, Partition, Replica etc. Known
                      values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "Id": "str",  # Optional. The identity of the application. This is an encoded
                      representation of the application name. This is used in the REST APIs to identify
                      the application resource."nStarting in version 6.0, hierarchical names are
                      delimited with the "~" character. For example, if the application name is
                      "fabric:/myapp/app1","nthe application identity would be "myapp~app1" in 6.0+ and
                      "myapp/app1" in previous versions.
                    "LogDirectory": "str",  # Optional. The log directory of the application on
                      the node. The log directory can be used to store application logs.
                    "Name": "str",  # Optional. The name of the application, including the
                      'fabric:' URI scheme.
                    "Status": "str",  # Optional. The status of the application deployed on the
                      node. Following are the possible values. Known values are: "Invalid",
                      "Downloading", "Activating", "Active", "Upgrading", "Deactivating".
                    "TempDirectory": "str",  # Optional. The temp directory of the application on
                      the node. The code packages belonging to the application are forked with this
                      directory set as their temporary directory.
                    "TypeName": "str",  # Optional. The application type name as defined in the
                      application manifest.
                    "TypeVersion": "str",  # Optional. The version of the application type as
                      defined in the application manifest.
                    "WorkDirectory": "str"  # Optional. The work directory of the application on
                      the node. The work directory can be used to store application data.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.1"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_get_deployed_application_info_request(
            node_name=node_name,
            application_id=application_id,
            api_version=api_version,
            timeout=timeout,
            include_health_state=include_health_state,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get_deployed_application_health(
        self,
        node_name: str,
        application_id: str,
        *,
        events_health_state_filter: Optional[int] = 0,
        deployed_service_packages_health_state_filter: Optional[int] = 0,
        exclude_health_statistics: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the information about health of an application deployed on a Service Fabric node.

        Gets the information about health of an application deployed on a Service Fabric node. Use
        EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported
        on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter
        to optionally filter for DeployedServicePackageHealth children based on health state.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword deployed_service_packages_health_state_filter: Allows filtering of the deployed
         service package health state objects returned in the result of deployed application health
         query based on their health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only deployed service packages that match the filter are returned. All deployed service
         packages are used to evaluate the aggregated health state of the deployed application.
         If not specified, all entries are returned.
         The state values are flag-based enumeration, so the value can be a combination of these
         values, obtained using the bitwise 'OR' operator.
         For example, if the provided value is 6 then health state of service packages with HealthState
         value of OK (2) and Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype deployed_service_packages_health_state_filter: int
        :keyword exclude_health_statistics: Indicates whether the health statistics should be returned
         as part of the query result. False by default.
         The statistics show the number of children entities in health state Ok, Warning, and Error.
         Default value is False.
        :paramtype exclude_health_statistics: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "DeployedServicePackageHealthStates": [
                        {
                            "AggregatedHealthState": "str",  # Optional. The health state
                              of a Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "ApplicationName": "str",  # Optional. The name of the
                              application, including the 'fabric:' URI scheme.
                            "NodeName": "str",  # Optional. Name of the node on which the
                              service package is deployed.
                            "ServiceManifestName": "str",  # Optional. Name of the
                              manifest describing the service package.
                            "ServicePackageActivationId": "str"  # Optional. The
                              ActivationId of a deployed service package. If
                              ServicePackageActivationMode specified at the time of creating the
                              service"nis 'SharedProcess' (or if it is not specified, in which case it
                              defaults to 'SharedProcess'), then value of
                              ServicePackageActivationId"nis always an empty string.
                        }
                    ],
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "Name": "str",  # Optional. Name of the application deployed on the node
                      whose health information is described by this object.
                    "NodeName": "str",  # Optional. Name of the node where this application is
                      deployed.
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_deployed_application_health_request(
            node_name=node_name,
            application_id=application_id,
            api_version=api_version,
            events_health_state_filter=events_health_state_filter,
            deployed_service_packages_health_state_filter=deployed_service_packages_health_state_filter,
            exclude_health_statistics=exclude_health_statistics,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_deployed_application_health_using_policy(
        self,
        node_name: str,
        application_id: str,
        application_health_policy: Optional[JSON] = None,
        *,
        events_health_state_filter: Optional[int] = 0,
        deployed_service_packages_health_state_filter: Optional[int] = 0,
        exclude_health_statistics: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the information about health of an application deployed on a Service Fabric node. using
        the specified policy.

        Gets the information about health of an application deployed on a Service Fabric node using the
        specified policy. Use EventsHealthStateFilter to optionally filter for the collection of
        HealthEvent objects reported on the deployed application based on health state. Use
        DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth
        children based on health state. Use ApplicationHealthPolicy to optionally override the health
        policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the
        ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the
        deployed application.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param application_health_policy: Describes the health policies used to evaluate the health of
         an application or one of its children.
         If not present, the health evaluation uses the health policy from application manifest or the
         default health policy. Default value is None.
        :type application_health_policy: JSON
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword deployed_service_packages_health_state_filter: Allows filtering of the deployed
         service package health state objects returned in the result of deployed application health
         query based on their health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only deployed service packages that match the filter are returned. All deployed service
         packages are used to evaluate the aggregated health state of the deployed application.
         If not specified, all entries are returned.
         The state values are flag-based enumeration, so the value can be a combination of these
         values, obtained using the bitwise 'OR' operator.
         For example, if the provided value is 6 then health state of service packages with HealthState
         value of OK (2) and Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype deployed_service_packages_health_state_filter: int
        :keyword exclude_health_statistics: Indicates whether the health statistics should be returned
         as part of the query result. False by default.
         The statistics show the number of children entities in health state Ok, Warning, and Error.
         Default value is False.
        :paramtype exclude_health_statistics: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                application_health_policy = {
                    "ConsiderWarningAsError": bool,  # Optional. Indicates whether warnings are
                      treated with the same severity as errors.
                    "DefaultServiceTypeHealthPolicy": {
                        "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional. The
                          maximum allowed percentage of unhealthy partitions per service. Allowed
                          values are Byte values from zero to 100"n"nThe percentage represents the
                          maximum tolerated percentage of partitions that can be unhealthy before the
                          service is considered in error."nIf the percentage is respected but there is
                          at least one unhealthy partition, the health is evaluated as Warning."nThe
                          percentage is calculated by dividing the number of unhealthy partitions over
                          the total number of partitions in the service."nThe computation rounds up to
                          tolerate one failure on small numbers of partitions. Default percentage is
                          zero.
                        "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional. The
                          maximum allowed percentage of unhealthy replicas per partition. Allowed
                          values are Byte values from zero to 100."n"nThe percentage represents the
                          maximum tolerated percentage of replicas that can be unhealthy before the
                          partition is considered in error."nIf the percentage is respected but there
                          is at least one unhealthy replica, the health is evaluated as Warning."nThe
                          percentage is calculated by dividing the number of unhealthy replicas over
                          the total number of replicas in the partition."nThe computation rounds up to
                          tolerate one failure on small numbers of replicas. Default percentage is
                          zero.
                        "MaxPercentUnhealthyServices": 0  # Optional. The maximum allowed
                          percentage of unhealthy services. Allowed values are Byte values from zero to
                          100."n"nThe percentage represents the maximum tolerated percentage of
                          services that can be unhealthy before the application is considered in
                          error."nIf the percentage is respected but there is at least one unhealthy
                          service, the health is evaluated as Warning."nThis is calculated by dividing
                          the number of unhealthy services of the specific service type over the total
                          number of services of the specific service type."nThe computation rounds up
                          to tolerate one failure on small numbers of services. Default percentage is
                          zero.
                    },
                    "MaxPercentUnhealthyDeployedApplications": 0,  # Optional. The maximum
                      allowed percentage of unhealthy deployed applications. Allowed values are Byte
                      values from zero to 100."nThe percentage represents the maximum tolerated
                      percentage of deployed applications that can be unhealthy before the application
                      is considered in error."nThis is calculated by dividing the number of unhealthy
                      deployed applications over the number of nodes where the application is currently
                      deployed on in the cluster."nThe computation rounds up to tolerate one failure on
                      small numbers of nodes. Default percentage is zero.
                    "ServiceTypeHealthPolicyMap": [
                        {
                            "Key": "str",  # Required. The key of the service type health
                              policy map item. This is the name of the service type.
                            "Value": {
                                "MaxPercentUnhealthyPartitionsPerService": 0,  #
                                  Optional. The maximum allowed percentage of unhealthy partitions per
                                  service. Allowed values are Byte values from zero to 100"n"nThe
                                  percentage represents the maximum tolerated percentage of partitions
                                  that can be unhealthy before the service is considered in error."nIf
                                  the percentage is respected but there is at least one unhealthy
                                  partition, the health is evaluated as Warning."nThe percentage is
                                  calculated by dividing the number of unhealthy partitions over the
                                  total number of partitions in the service."nThe computation rounds up
                                  to tolerate one failure on small numbers of partitions. Default
                                  percentage is zero.
                                "MaxPercentUnhealthyReplicasPerPartition": 0,  #
                                  Optional. The maximum allowed percentage of unhealthy replicas per
                                  partition. Allowed values are Byte values from zero to 100."n"nThe
                                  percentage represents the maximum tolerated percentage of replicas
                                  that can be unhealthy before the partition is considered in
                                  error."nIf the percentage is respected but there is at least one
                                  unhealthy replica, the health is evaluated as Warning."nThe
                                  percentage is calculated by dividing the number of unhealthy replicas
                                  over the total number of replicas in the partition."nThe computation
                                  rounds up to tolerate one failure on small numbers of replicas.
                                  Default percentage is zero.
                                "MaxPercentUnhealthyServices": 0  # Optional. The
                                  maximum allowed percentage of unhealthy services. Allowed values are
                                  Byte values from zero to 100."n"nThe percentage represents the
                                  maximum tolerated percentage of services that can be unhealthy before
                                  the application is considered in error."nIf the percentage is
                                  respected but there is at least one unhealthy service, the health is
                                  evaluated as Warning."nThis is calculated by dividing the number of
                                  unhealthy services of the specific service type over the total number
                                  of services of the specific service type."nThe computation rounds up
                                  to tolerate one failure on small numbers of services. Default
                                  percentage is zero.
                            }
                        }
                    ]
                }

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "DeployedServicePackageHealthStates": [
                        {
                            "AggregatedHealthState": "str",  # Optional. The health state
                              of a Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "ApplicationName": "str",  # Optional. The name of the
                              application, including the 'fabric:' URI scheme.
                            "NodeName": "str",  # Optional. Name of the node on which the
                              service package is deployed.
                            "ServiceManifestName": "str",  # Optional. Name of the
                              manifest describing the service package.
                            "ServicePackageActivationId": "str"  # Optional. The
                              ActivationId of a deployed service package. If
                              ServicePackageActivationMode specified at the time of creating the
                              service"nis 'SharedProcess' (or if it is not specified, in which case it
                              defaults to 'SharedProcess'), then value of
                              ServicePackageActivationId"nis always an empty string.
                        }
                    ],
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "Name": "str",  # Optional. Name of the application deployed on the node
                      whose health information is described by this object.
                    "NodeName": "str",  # Optional. Name of the node where this application is
                      deployed.
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        if application_health_policy is not None:
            _json = application_health_policy
        else:
            _json = None

        request = build_get_deployed_application_health_using_policy_request(
            node_name=node_name,
            application_id=application_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            events_health_state_filter=events_health_state_filter,
            deployed_service_packages_health_state_filter=deployed_service_packages_health_state_filter,
            exclude_health_statistics=exclude_health_statistics,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def report_deployed_application_health(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        application_id: str,
        health_information: JSON,
        *,
        immediate: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Sends a health report on the Service Fabric application deployed on a Service Fabric node.

        Reports health state of the application deployed on a Service Fabric node. The report must
        contain the information about the source of the health report and property on which it is
        reported.
        The report is sent to a Service Fabric gateway Service, which forwards to the health store.
        The report may be accepted by the gateway, but rejected by the health store after extra
        validation.
        For example, the health store may reject the report because of an invalid parameter, like a
        stale sequence number.
        To see whether the report was applied in the health store, get deployed application health and
        check that the report appears in the HealthEvents section.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param health_information: Describes the health information for the health report. This
         information needs to be present in all of the health reports sent to the health manager.
        :type health_information: JSON
        :keyword immediate: A flag that indicates whether the report should be sent immediately.
         A health report is sent to a Service Fabric gateway Application, which forwards to the health
         store.
         If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
         store, regardless of the fabric client settings that the HTTP Gateway Application is using.
         This is useful for critical reports that should be sent as soon as possible.
         Depending on timing and other conditions, sending the report may still fail, for example if
         the HTTP Gateway is closed or the message doesn't reach the Gateway.
         If Immediate is set to false, the report is sent based on the health client settings from the
         HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
         configuration.
         This is the recommended setting because it allows the health client to optimize health
         reporting messages to health store as well as health report processing.
         By default, reports are not sent immediately. Default value is False.
        :paramtype immediate: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                health_information = {
                    "Description": "str",  # Optional. The description of the health information.
                      It represents free text used to add human readable information about the
                      report."nThe maximum string length for the description is 4096 characters."nIf
                      the provided string is longer, it will be automatically truncated."nWhen
                      truncated, the last characters of the description contain a marker "[Truncated]",
                      and total string size is 4096 characters."nThe presence of the marker indicates
                      to users that truncation occurred."nNote that when truncated, the description has
                      less than 4096 characters from the original string.
                    "HealthReportId": "str",  # Optional. A health report ID which identifies the
                      health report and can be used to find more detailed information about a specific
                      health event at"naka.ms/sfhealthid.
                    "HealthState": "str",  # Required. The health state of a Service Fabric
                      entity such as Cluster, Node, Application, Service, Partition, Replica etc. Known
                      values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "Property": "str",  # Required. The property of the health information. An
                      entity can have health reports for different properties."nThe property is a
                      string and not a fixed enumeration to allow the reporter flexibility to
                      categorize the state condition that triggers the report."nFor example, a reporter
                      with SourceId "LocalWatchdog" can monitor the state of the available disk on a
                      node,"nso it can report "AvailableDisk" property on that node."nThe same reporter
                      can monitor the node connectivity, so it can report a property "Connectivity" on
                      the same node."nIn the health store, these reports are treated as separate health
                      events for the specified node."n"nTogether with the SourceId, the property
                      uniquely identifies the health information.
                    "RemoveWhenExpired": bool,  # Optional. Value that indicates whether the
                      report is removed from health store when it expires."nIf set to true, the report
                      is removed from the health store after it expires."nIf set to false, the report
                      is treated as an error when expired. The value of this property is false by
                      default."nWhen clients report periodically, they should set RemoveWhenExpired
                      false (default)."nThis way, if the reporter has issues (e.g. deadlock) and can't
                      report, the entity is evaluated at error when the health report expires."nThis
                      flags the entity as being in Error health state.
                    "SequenceNumber": "str",  # Optional. The sequence number for this health
                      report as a numeric string."nThe report sequence number is used by the health
                      store to detect stale reports."nIf not specified, a sequence number is
                      auto-generated by the health client when a report is added.
                    "SourceId": "str",  # Required. The source name that identifies the
                      client/watchdog/system component that generated the health information.
                    "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The duration for
                      which this health report is valid. This field uses ISO8601 format for specifying
                      the duration."nWhen clients report periodically, they should send reports with
                      higher frequency than time to live."nIf clients report on transition, they can
                      set the time to live to infinite."nWhen time to live expires, the health event
                      that contains the health information"nis either removed from health store, if
                      RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                      false."n"nIf not specified, time to live defaults to infinite value.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = health_information

        request = build_report_deployed_application_health_request(
            node_name=node_name,
            application_id=application_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            immediate=immediate,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_application_manifest(
        self,
        application_type_name: str,
        *,
        application_type_version: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the manifest describing an application type.

        The response contains the application manifest XML as a string.

        :param application_type_name: The name of the application type.
        :type application_type_name: str
        :keyword application_type_version: The version of the application type.
        :paramtype application_type_version: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Manifest": "str"  # Optional. The XML manifest as a string.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_application_manifest_request(
            application_type_name=application_type_name,
            api_version=api_version,
            application_type_version=application_type_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def update_application_arm_metadata(  # pylint: disable=inconsistent-return-statements
        self,
        application_id: str,
        application_arm_metadata_update_description: JSON,
        *,
        timeout: Optional[int] = 60,
        force: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Updates the Arm Metadata for a specific Application.

        Updates the Arm Metadata for a specific Application. Is able to be called immediately after the
        create app API is called.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param application_arm_metadata_update_description: The Arm metadata to be assocated with a
         specific application.
        :type application_arm_metadata_update_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword force: Force parameter used to prevent accidental Arm metadata update. Default value
         is None.
        :paramtype force: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '9.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "9.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                application_arm_metadata_update_description = {
                    "ArmResourceId": "str"  # Optional. A string containing the ArmResourceId.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = application_arm_metadata_update_description

        request = build_update_application_arm_metadata_request(
            application_id=application_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            force=force,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_service_info_list(
        self,
        application_id: str,
        *,
        service_type_name: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the information about all services belonging to the application specified by the
        application ID.

        Returns the information about all services belonging to the application specified by the
        application ID.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword service_type_name: The service type name used to filter the services to query for.
         Default value is None.
        :paramtype service_type_name: str
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "HealthState": "str",  # Optional. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "Id": "str",  # Optional. The identity of the service. This
                              ID is an encoded representation of the service name. This is used in the
                              REST APIs to identify the service resource."nStarting in version 6.0,
                              hierarchical names are delimited with the "~" character. For example, if
                              the service name is "fabric:/myapp/app1/svc1","nthe service identity
                              would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous
                              versions.
                            "IsServiceGroup": bool,  # Optional. Whether the service is
                              in a service group.
                            "ManifestVersion": "str",  # Optional. The version of the
                              service manifest.
                            "Name": "str",  # Optional. The full name of the service with
                              'fabric:' URI scheme.
                            "ServiceMetadata": {
                                "ArmMetadata": {
                                    "ArmResourceId": "str"  # Optional. A string
                                      containing the ArmResourceId.
                                }
                            },
                            "ServiceStatus": "str",  # Optional. The status of the
                              application. Known values are: "Unknown", "Active", "Upgrading",
                              "Deleting", "Creating", "Failed".
                            "TypeName": "str",  # Optional. Name of the service type as
                              specified in the service manifest.
                            ServiceKind: ServiceKind
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_service_info_list_request(
            application_id=application_id,
            api_version=api_version,
            service_type_name=service_type_name,
            continuation_token_parameter=continuation_token_parameter,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_service_info(
        self,
        application_id: str,
        service_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Gets the information about the specific service belonging to the Service Fabric application.

        Returns the information about the specified service belonging to the specified Service Fabric
        application.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "HealthState": "str",  # Optional. The health state of a Service Fabric
                      entity such as Cluster, Node, Application, Service, Partition, Replica etc. Known
                      values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "Id": "str",  # Optional. The identity of the service. This ID is an encoded
                      representation of the service name. This is used in the REST APIs to identify the
                      service resource."nStarting in version 6.0, hierarchical names are delimited with
                      the "~" character. For example, if the service name is
                      "fabric:/myapp/app1/svc1","nthe service identity would be "myapp~app1~svc1" in
                      6.0+ and "myapp/app1/svc1" in previous versions.
                    "IsServiceGroup": bool,  # Optional. Whether the service is in a service
                      group.
                    "ManifestVersion": "str",  # Optional. The version of the service manifest.
                    "Name": "str",  # Optional. The full name of the service with 'fabric:' URI
                      scheme.
                    "ServiceMetadata": {
                        "ArmMetadata": {
                            "ArmResourceId": "str"  # Optional. A string containing the
                              ArmResourceId.
                        }
                    },
                    "ServiceStatus": "str",  # Optional. The status of the application. Known
                      values are: "Unknown", "Active", "Upgrading", "Deleting", "Creating", "Failed".
                    "TypeName": "str",  # Optional. Name of the service type as specified in the
                      service manifest.
                    ServiceKind: ServiceKind
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_get_service_info_request(
            application_id=application_id,
            service_id=service_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get_application_name_info(
        self,
        service_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the name of the Service Fabric application for a service.

        Gets the name of the application for the specified service. A 404
        FABRIC_E_SERVICE_DOES_NOT_EXIST error is returned if a service with the provided service ID
        does not exist.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Id": "str",  # Optional. The identity of the application. This is an encoded
                      representation of the application name. This is used in the REST APIs to identify
                      the application resource."nStarting in version 6.0, hierarchical names are
                      delimited with the "~" character. For example, if the application name is
                      "fabric:/myapp/app1","nthe application identity would be "myapp~app1" in 6.0+ and
                      "myapp/app1" in previous versions.
                    "Name": "str"  # Optional. The name of the application, including the
                      'fabric:' URI scheme.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_application_name_info_request(
            service_id=service_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def create_service(  # pylint: disable=inconsistent-return-statements
        self,
        application_id: str,
        service_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Creates the specified Service Fabric service.

        This api allows creating a new Service Fabric stateless or stateful service under a specified
        Service Fabric application. The description for creating the service includes partitioning
        information and optional properties for placement and load balancing. Some of the properties
        can later be modified using ``UpdateService`` API.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param service_description: The information necessary to create a service.
        :type service_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                service_kind = 'StatefulServiceDescription' or 'StatelessServiceDescription'


                # JSON input template you can fill out and use as your body input.
                service_description = {
                    "ApplicationName": "str",  # Optional. The name of the application, including
                      the 'fabric:' URI scheme.
                    "CorrelationScheme": [
                        {
                            "Scheme": "str",  # Required. The ServiceCorrelationScheme
                              which describes the relationship between this service and the service
                              specified via ServiceName. Known values are: "Invalid", "Affinity",
                              "AlignedAffinity", "NonAlignedAffinity".
                            "ServiceName": "str"  # Required. The name of the service
                              that the correlation relationship is established with.
                        }
                    ],
                    "DefaultMoveCost": "str",  # Optional. The move cost for the service. Known
                      values are: "Zero", "Low", "Medium", "High", "VeryHigh".
                    "InitializationData": [
                        0  # Optional. The initialization data as an array of bytes.
                          Initialization data is passed to service instances or replicas when they are
                          created.
                    ],
                    "IsDefaultMoveCostSpecified": bool,  # Optional. Indicates if the
                      DefaultMoveCost property is specified.
                    "PartitionDescription": {
                        PartitionScheme: PartitionScheme
                    },
                    "PlacementConstraints": "str",  # Optional. The placement constraints as a
                      string. Placement constraints are boolean expressions on node properties and
                      allow for restricting a service to particular nodes based on the service
                      requirements. For example, to place a service on nodes where NodeType is blue
                      specify the following: "NodeColor == blue)".
                    "ScalingPolicies": [
                        {
                            "ScalingMechanism": {
                                Kind: Kind
                            },
                            "ScalingTrigger": {
                                Kind: Kind
                            }
                        }
                    ],
                    "ServiceDnsName": "str",  # Optional. The DNS name of the service. It
                      requires the DNS system service to be enabled in Service Fabric cluster.
                    "ServiceLoadMetrics": [
                        {
                            "AuxiliaryDefaultLoad": 0,  # Optional. Used only for
                              Stateful services. The default amount of load, as a number, that this
                              service creates for this metric when it is an Auxiliary replica.
                            "DefaultLoad": 0,  # Optional. Used only for Stateless
                              services. The default amount of load, as a number, that this service
                              creates for this metric.
                            "Name": "str",  # Required. The name of the metric. If the
                              service chooses to report load during runtime, the load metric name
                              should match the name that is specified in Name exactly. Note that metric
                              names are case-sensitive.
                            "PrimaryDefaultLoad": 0,  # Optional. Used only for Stateful
                              services. The default amount of load, as a number, that this service
                              creates for this metric when it is a Primary replica.
                            "SecondaryDefaultLoad": 0,  # Optional. Used only for
                              Stateful services. The default amount of load, as a number, that this
                              service creates for this metric when it is a Secondary replica.
                            "Weight": "str"  # Optional. The service load metric relative
                              weight, compared to other metrics configured for this service, as a
                              number. Known values are: "Zero", "Low", "Medium", "High".
                        }
                    ],
                    "ServiceName": "str",  # Required. The full name of the service with
                      'fabric:' URI scheme.
                    "ServicePackageActivationMode": "str",  # Optional. The activation mode of
                      service package to be used for a service. Known values are: "SharedProcess",
                      "ExclusiveProcess".
                    "ServicePlacementPolicies": [
                        {
                            Type: Type
                        }
                    ],
                    "ServiceTypeName": "str",  # Required. Name of the service type as specified
                      in the service manifest.
                    "TagsRequiredToPlace": {
                        "Count": 0,  # Required. The number of tags.
                        "Tags": [
                            "str"  # Required. A set of tags. Array of size specified by
                              the "u2018Count"u2019 parameter, for the placement tags of the service.
                        ]
                    },
                    "TagsRequiredToRun": {
                        "Count": 0,  # Required. The number of tags.
                        "Tags": [
                            "str"  # Required. A set of tags. Array of size specified by
                              the "u2018Count"u2019 parameter, for the placement tags of the service.
                        ]
                    },
                    ServiceKind: ServiceKind
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = service_description

        request = build_create_service_request(
            application_id=application_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def create_service_from_template(  # pylint: disable=inconsistent-return-statements
        self,
        application_id: str,
        service_from_template_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Creates a Service Fabric service from the service template.

        Creates a Service Fabric service from the service template defined in the application manifest.
        A service template contains the properties that will be same for the service instance of the
        same type. The API allows overriding the properties that are usually different for different
        services of the same service type.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param service_from_template_description: Describes the service that needs to be created from
         the template defined in the application manifest.
        :type service_from_template_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                service_from_template_description = {
                    "ApplicationName": "str",  # Required. The name of the application, including
                      the 'fabric:' URI scheme.
                    "InitializationData": [
                        0  # Optional. The initialization data for the newly created service
                          instance.
                    ],
                    "ServiceDnsName": "str",  # Optional. The DNS name of the service. It
                      requires the DNS system service to be enabled in Service Fabric cluster.
                    "ServiceName": "str",  # Required. The full name of the service with
                      'fabric:' URI scheme.
                    "ServicePackageActivationMode": "str",  # Optional. The activation mode of
                      service package to be used for a service. Known values are: "SharedProcess",
                      "ExclusiveProcess".
                    "ServiceTypeName": "str"  # Required. Name of the service type as specified
                      in the service manifest.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = service_from_template_description

        request = build_create_service_from_template_request(
            application_id=application_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def delete_service(  # pylint: disable=inconsistent-return-statements
        self,
        service_id: str,
        *,
        force_remove: Optional[bool] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Deletes an existing Service Fabric service.

        A service must be created before it can be deleted. By default, Service Fabric will try to
        close service replicas in a graceful manner and then delete the service. However, if the
        service is having issues closing the replica gracefully, the delete operation may take a long
        time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and
        forcefully delete the service.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :keyword force_remove: Remove a Service Fabric application or service forcefully without going
         through the graceful shutdown sequence. This parameter can be used to forcefully delete an
         application or service for which delete is timing out due to issues in the service code that
         prevents graceful close of replicas. Default value is None.
        :paramtype force_remove: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_delete_service_request(
            service_id=service_id,
            api_version=api_version,
            force_remove=force_remove,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def update_service(  # pylint: disable=inconsistent-return-statements
        self,
        service_id: str,
        service_update_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Updates a Service Fabric service using the specified update description.

        This API allows updating properties of a running Service Fabric service. The set of properties
        that can be updated are a subset of the properties that were specified at the time of creating
        the service. The current set of properties can be obtained using ``GetServiceDescription`` API.
        Note that updating the properties of a running service is different than upgrading your
        application using ``StartApplicationUpgrade`` API. The upgrade is a long running background
        operation that involves moving the application from one version to another, one upgrade domain
        at a time, whereas update applies the new properties immediately to the service.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :param service_update_description: The information necessary to update a service.
        :type service_update_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                service_kind = 'StatefulServiceUpdateDescription' or
                  'StatelessServiceUpdateDescription'

                # JSON input template you can fill out and use as your body input.
                service_update_description = {
                    "CorrelationScheme": [
                        {
                            "Scheme": "str",  # Required. The ServiceCorrelationScheme
                              which describes the relationship between this service and the service
                              specified via ServiceName. Known values are: "Invalid", "Affinity",
                              "AlignedAffinity", "NonAlignedAffinity".
                            "ServiceName": "str"  # Required. The name of the service
                              that the correlation relationship is established with.
                        }
                    ],
                    "DefaultMoveCost": "str",  # Optional. The move cost for the service. Known
                      values are: "Zero", "Low", "Medium", "High", "VeryHigh".
                    "Flags": "str",  # Optional. Flags indicating whether other properties are
                      set. Each of the associated properties corresponds to a flag, specified below,
                      which, if set, indicate that the property is specified."nThis property can be a
                      combination of those flags obtained using bitwise 'OR' operator."nFor example, if
                      the provided value is 6 then the flags for ReplicaRestartWaitDuration (2) and
                      QuorumLossWaitDuration (4) are set."n"n"n* None - Does not indicate any other
                      properties are set. The value is zero."n* TargetReplicaSetSize/InstanceCount -
                      Indicates whether the TargetReplicaSetSize property (for Stateful services) or
                      the InstanceCount property (for Stateless services) is set. The value is 1."n*
                      ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is
                      set. The value is  2."n* QuorumLossWaitDuration - Indicates the
                      QuorumLossWaitDuration property is set. The value is 4."n*
                      StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is
                      set. The value is 8."n* MinReplicaSetSize - Indicates the MinReplicaSetSize
                      property is set. The value is 16."n* PlacementConstraints - Indicates the
                      PlacementConstraints property is set. The value is 32."n* PlacementPolicyList -
                      Indicates the ServicePlacementPolicies property is set. The value is 64."n*
                      Correlation - Indicates the CorrelationScheme property is set. The value is
                      128."n* Metrics - Indicates the ServiceLoadMetrics property is set. The value is
                      256."n* DefaultMoveCost - Indicates the DefaultMoveCost property is set. The
                      value is 512."n* ScalingPolicy - Indicates the ScalingPolicies property is set.
                      The value is 1024."n* ServicePlacementTimeLimit - Indicates the
                      ServicePlacementTimeLimit property is set. The value is 2048."n* MinInstanceCount
                      - Indicates the MinInstanceCount property is set. The value is 4096."n*
                      MinInstancePercentage - Indicates the MinInstancePercentage property is set. The
                      value is 8192."n* InstanceCloseDelayDuration - Indicates the
                      InstanceCloseDelayDuration property is set. The value is 16384."n*
                      InstanceRestartWaitDuration - Indicates the InstanceCloseDelayDuration property
                      is set. The value is 32768."n* DropSourceReplicaOnMove - Indicates the
                      DropSourceReplicaOnMove property is set. The value is 65536."n* ServiceDnsName -
                      Indicates the ServiceDnsName property is set. The value is 131072."n*
                      TagsForPlacement - Indicates the TagsForPlacement property is set. The value is
                      1048576."n* TagsForRunning - Indicates the TagsForRunning property is set. The
                      value is 2097152.
                    "LoadMetrics": [
                        {
                            "AuxiliaryDefaultLoad": 0,  # Optional. Used only for
                              Stateful services. The default amount of load, as a number, that this
                              service creates for this metric when it is an Auxiliary replica.
                            "DefaultLoad": 0,  # Optional. Used only for Stateless
                              services. The default amount of load, as a number, that this service
                              creates for this metric.
                            "Name": "str",  # Required. The name of the metric. If the
                              service chooses to report load during runtime, the load metric name
                              should match the name that is specified in Name exactly. Note that metric
                              names are case-sensitive.
                            "PrimaryDefaultLoad": 0,  # Optional. Used only for Stateful
                              services. The default amount of load, as a number, that this service
                              creates for this metric when it is a Primary replica.
                            "SecondaryDefaultLoad": 0,  # Optional. Used only for
                              Stateful services. The default amount of load, as a number, that this
                              service creates for this metric when it is a Secondary replica.
                            "Weight": "str"  # Optional. The service load metric relative
                              weight, compared to other metrics configured for this service, as a
                              number. Known values are: "Zero", "Low", "Medium", "High".
                        }
                    ],
                    "PlacementConstraints": "str",  # Optional. The placement constraints as a
                      string. Placement constraints are boolean expressions on node properties and
                      allow for restricting a service to particular nodes based on the service
                      requirements. For example, to place a service on nodes where NodeType is blue
                      specify the following: "NodeColor == blue)".
                    "ScalingPolicies": [
                        {
                            "ScalingMechanism": {
                                Kind: Kind
                            },
                            "ScalingTrigger": {
                                Kind: Kind
                            }
                        }
                    ],
                    "ServiceDnsName": "str",  # Optional. The DNS name of the service.
                    "ServicePlacementPolicies": [
                        {
                            Type: Type
                        }
                    ],
                    "TagsForPlacement": {
                        "Count": 0,  # Required. The number of tags.
                        "Tags": [
                            "str"  # Required. A set of tags. Array of size specified by
                              the "u2018Count"u2019 parameter, for the placement tags of the service.
                        ]
                    },
                    "TagsForRunning": {
                        "Count": 0,  # Required. The number of tags.
                        "Tags": [
                            "str"  # Required. A set of tags. Array of size specified by
                              the "u2018Count"u2019 parameter, for the placement tags of the service.
                        ]
                    },
                    ServiceKind: ServiceKind
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = service_update_description

        request = build_update_service_request(
            service_id=service_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_service_description(
        self,
        service_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the description of an existing Service Fabric service.

        Gets the description of an existing Service Fabric service. A service must be created before
        its description can be obtained.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ApplicationName": "str",  # Optional. The name of the application, including
                      the 'fabric:' URI scheme.
                    "CorrelationScheme": [
                        {
                            "Scheme": "str",  # Required. The ServiceCorrelationScheme
                              which describes the relationship between this service and the service
                              specified via ServiceName. Known values are: "Invalid", "Affinity",
                              "AlignedAffinity", "NonAlignedAffinity".
                            "ServiceName": "str"  # Required. The name of the service
                              that the correlation relationship is established with.
                        }
                    ],
                    "DefaultMoveCost": "str",  # Optional. The move cost for the service. Known
                      values are: "Zero", "Low", "Medium", "High", "VeryHigh".
                    "InitializationData": [
                        0  # Optional. The initialization data as an array of bytes.
                          Initialization data is passed to service instances or replicas when they are
                          created.
                    ],
                    "IsDefaultMoveCostSpecified": bool,  # Optional. Indicates if the
                      DefaultMoveCost property is specified.
                    "PartitionDescription": {
                        PartitionScheme: PartitionScheme
                    },
                    "PlacementConstraints": "str",  # Optional. The placement constraints as a
                      string. Placement constraints are boolean expressions on node properties and
                      allow for restricting a service to particular nodes based on the service
                      requirements. For example, to place a service on nodes where NodeType is blue
                      specify the following: "NodeColor == blue)".
                    "ScalingPolicies": [
                        {
                            "ScalingMechanism": {
                                Kind: Kind
                            },
                            "ScalingTrigger": {
                                Kind: Kind
                            }
                        }
                    ],
                    "ServiceDnsName": "str",  # Optional. The DNS name of the service. It
                      requires the DNS system service to be enabled in Service Fabric cluster.
                    "ServiceLoadMetrics": [
                        {
                            "AuxiliaryDefaultLoad": 0,  # Optional. Used only for
                              Stateful services. The default amount of load, as a number, that this
                              service creates for this metric when it is an Auxiliary replica.
                            "DefaultLoad": 0,  # Optional. Used only for Stateless
                              services. The default amount of load, as a number, that this service
                              creates for this metric.
                            "Name": "str",  # Required. The name of the metric. If the
                              service chooses to report load during runtime, the load metric name
                              should match the name that is specified in Name exactly. Note that metric
                              names are case-sensitive.
                            "PrimaryDefaultLoad": 0,  # Optional. Used only for Stateful
                              services. The default amount of load, as a number, that this service
                              creates for this metric when it is a Primary replica.
                            "SecondaryDefaultLoad": 0,  # Optional. Used only for
                              Stateful services. The default amount of load, as a number, that this
                              service creates for this metric when it is a Secondary replica.
                            "Weight": "str"  # Optional. The service load metric relative
                              weight, compared to other metrics configured for this service, as a
                              number. Known values are: "Zero", "Low", "Medium", "High".
                        }
                    ],
                    "ServiceName": "str",  # Required. The full name of the service with
                      'fabric:' URI scheme.
                    "ServicePackageActivationMode": "str",  # Optional. The activation mode of
                      service package to be used for a service. Known values are: "SharedProcess",
                      "ExclusiveProcess".
                    "ServicePlacementPolicies": [
                        {
                            Type: Type
                        }
                    ],
                    "ServiceTypeName": "str",  # Required. Name of the service type as specified
                      in the service manifest.
                    "TagsRequiredToPlace": {
                        "Count": 0,  # Required. The number of tags.
                        "Tags": [
                            "str"  # Required. A set of tags. Array of size specified by
                              the "u2018Count"u2019 parameter, for the placement tags of the service.
                        ]
                    },
                    "TagsRequiredToRun": {
                        "Count": 0,  # Required. The number of tags.
                        "Tags": [
                            "str"  # Required. A set of tags. Array of size specified by
                              the "u2018Count"u2019 parameter, for the placement tags of the service.
                        ]
                    },
                    ServiceKind: ServiceKind
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_service_description_request(
            service_id=service_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_service_health(
        self,
        service_id: str,
        *,
        events_health_state_filter: Optional[int] = 0,
        partitions_health_state_filter: Optional[int] = 0,
        exclude_health_statistics: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the health of the specified Service Fabric service.

        Gets the health information of the specified service.
        Use EventsHealthStateFilter to filter the collection of health events reported on the service
        based on the health state.
        Use PartitionsHealthStateFilter to filter the collection of partitions returned.
        If you specify a service that does not exist in the health store, this request returns an
        error.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword partitions_health_state_filter: Allows filtering of the partitions health state
         objects returned in the result of service health query based on their health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only partitions that match the filter are returned. All partitions are used to evaluate the
         aggregated health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these value
         obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health
         state of partitions with HealthState value of OK (2) and Warning (4) will be returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype partitions_health_state_filter: int
        :keyword exclude_health_statistics: Indicates whether the health statistics should be returned
         as part of the query result. False by default.
         The statistics show the number of children entities in health state Ok, Warning, and Error.
         Default value is False.
        :paramtype exclude_health_statistics: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "Name": "str",  # Optional. The name of the service whose health information
                      is described by this object.
                    "PartitionHealthStates": [
                        {
                            "AggregatedHealthState": "str",  # Optional. The health state
                              of a Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "PartitionId": str  # Optional. Id of the partition whose
                              health state is described by this object.
                        }
                    ],
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_service_health_request(
            service_id=service_id,
            api_version=api_version,
            events_health_state_filter=events_health_state_filter,
            partitions_health_state_filter=partitions_health_state_filter,
            exclude_health_statistics=exclude_health_statistics,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_service_health_using_policy(
        self,
        service_id: str,
        application_health_policy: Optional[JSON] = None,
        *,
        events_health_state_filter: Optional[int] = 0,
        partitions_health_state_filter: Optional[int] = 0,
        exclude_health_statistics: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the health of the specified Service Fabric service, by using the specified health policy.

        Gets the health information of the specified service.
        If the application health policy is specified, the health evaluation uses it to get the
        aggregated health state.
        If the policy is not specified, the health evaluation uses the application health policy
        defined in the application manifest, or the default health policy, if no policy is defined in
        the manifest.
        Use EventsHealthStateFilter to filter the collection of health events reported on the service
        based on the health state.
        Use PartitionsHealthStateFilter to filter the collection of partitions returned.
        If you specify a service that does not exist in the health store, this request returns an
        error.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :param application_health_policy: Describes the health policies used to evaluate the health of
         an application or one of its children.
         If not present, the health evaluation uses the health policy from application manifest or the
         default health policy. Default value is None.
        :type application_health_policy: JSON
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword partitions_health_state_filter: Allows filtering of the partitions health state
         objects returned in the result of service health query based on their health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only partitions that match the filter are returned. All partitions are used to evaluate the
         aggregated health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these value
         obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health
         state of partitions with HealthState value of OK (2) and Warning (4) will be returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype partitions_health_state_filter: int
        :keyword exclude_health_statistics: Indicates whether the health statistics should be returned
         as part of the query result. False by default.
         The statistics show the number of children entities in health state Ok, Warning, and Error.
         Default value is False.
        :paramtype exclude_health_statistics: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                application_health_policy = {
                    "ConsiderWarningAsError": bool,  # Optional. Indicates whether warnings are
                      treated with the same severity as errors.
                    "DefaultServiceTypeHealthPolicy": {
                        "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional. The
                          maximum allowed percentage of unhealthy partitions per service. Allowed
                          values are Byte values from zero to 100"n"nThe percentage represents the
                          maximum tolerated percentage of partitions that can be unhealthy before the
                          service is considered in error."nIf the percentage is respected but there is
                          at least one unhealthy partition, the health is evaluated as Warning."nThe
                          percentage is calculated by dividing the number of unhealthy partitions over
                          the total number of partitions in the service."nThe computation rounds up to
                          tolerate one failure on small numbers of partitions. Default percentage is
                          zero.
                        "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional. The
                          maximum allowed percentage of unhealthy replicas per partition. Allowed
                          values are Byte values from zero to 100."n"nThe percentage represents the
                          maximum tolerated percentage of replicas that can be unhealthy before the
                          partition is considered in error."nIf the percentage is respected but there
                          is at least one unhealthy replica, the health is evaluated as Warning."nThe
                          percentage is calculated by dividing the number of unhealthy replicas over
                          the total number of replicas in the partition."nThe computation rounds up to
                          tolerate one failure on small numbers of replicas. Default percentage is
                          zero.
                        "MaxPercentUnhealthyServices": 0  # Optional. The maximum allowed
                          percentage of unhealthy services. Allowed values are Byte values from zero to
                          100."n"nThe percentage represents the maximum tolerated percentage of
                          services that can be unhealthy before the application is considered in
                          error."nIf the percentage is respected but there is at least one unhealthy
                          service, the health is evaluated as Warning."nThis is calculated by dividing
                          the number of unhealthy services of the specific service type over the total
                          number of services of the specific service type."nThe computation rounds up
                          to tolerate one failure on small numbers of services. Default percentage is
                          zero.
                    },
                    "MaxPercentUnhealthyDeployedApplications": 0,  # Optional. The maximum
                      allowed percentage of unhealthy deployed applications. Allowed values are Byte
                      values from zero to 100."nThe percentage represents the maximum tolerated
                      percentage of deployed applications that can be unhealthy before the application
                      is considered in error."nThis is calculated by dividing the number of unhealthy
                      deployed applications over the number of nodes where the application is currently
                      deployed on in the cluster."nThe computation rounds up to tolerate one failure on
                      small numbers of nodes. Default percentage is zero.
                    "ServiceTypeHealthPolicyMap": [
                        {
                            "Key": "str",  # Required. The key of the service type health
                              policy map item. This is the name of the service type.
                            "Value": {
                                "MaxPercentUnhealthyPartitionsPerService": 0,  #
                                  Optional. The maximum allowed percentage of unhealthy partitions per
                                  service. Allowed values are Byte values from zero to 100"n"nThe
                                  percentage represents the maximum tolerated percentage of partitions
                                  that can be unhealthy before the service is considered in error."nIf
                                  the percentage is respected but there is at least one unhealthy
                                  partition, the health is evaluated as Warning."nThe percentage is
                                  calculated by dividing the number of unhealthy partitions over the
                                  total number of partitions in the service."nThe computation rounds up
                                  to tolerate one failure on small numbers of partitions. Default
                                  percentage is zero.
                                "MaxPercentUnhealthyReplicasPerPartition": 0,  #
                                  Optional. The maximum allowed percentage of unhealthy replicas per
                                  partition. Allowed values are Byte values from zero to 100."n"nThe
                                  percentage represents the maximum tolerated percentage of replicas
                                  that can be unhealthy before the partition is considered in
                                  error."nIf the percentage is respected but there is at least one
                                  unhealthy replica, the health is evaluated as Warning."nThe
                                  percentage is calculated by dividing the number of unhealthy replicas
                                  over the total number of replicas in the partition."nThe computation
                                  rounds up to tolerate one failure on small numbers of replicas.
                                  Default percentage is zero.
                                "MaxPercentUnhealthyServices": 0  # Optional. The
                                  maximum allowed percentage of unhealthy services. Allowed values are
                                  Byte values from zero to 100."n"nThe percentage represents the
                                  maximum tolerated percentage of services that can be unhealthy before
                                  the application is considered in error."nIf the percentage is
                                  respected but there is at least one unhealthy service, the health is
                                  evaluated as Warning."nThis is calculated by dividing the number of
                                  unhealthy services of the specific service type over the total number
                                  of services of the specific service type."nThe computation rounds up
                                  to tolerate one failure on small numbers of services. Default
                                  percentage is zero.
                            }
                        }
                    ]
                }

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "Name": "str",  # Optional. The name of the service whose health information
                      is described by this object.
                    "PartitionHealthStates": [
                        {
                            "AggregatedHealthState": "str",  # Optional. The health state
                              of a Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "PartitionId": str  # Optional. Id of the partition whose
                              health state is described by this object.
                        }
                    ],
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        if application_health_policy is not None:
            _json = application_health_policy
        else:
            _json = None

        request = build_get_service_health_using_policy_request(
            service_id=service_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            events_health_state_filter=events_health_state_filter,
            partitions_health_state_filter=partitions_health_state_filter,
            exclude_health_statistics=exclude_health_statistics,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def report_service_health(  # pylint: disable=inconsistent-return-statements
        self,
        service_id: str,
        health_information: JSON,
        *,
        immediate: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Sends a health report on the Service Fabric service.

        Reports health state of the specified Service Fabric service. The report must contain the
        information about the source of the health report and property on which it is reported.
        The report is sent to a Service Fabric gateway Service, which forwards to the health store.
        The report may be accepted by the gateway, but rejected by the health store after extra
        validation.
        For example, the health store may reject the report because of an invalid parameter, like a
        stale sequence number.
        To see whether the report was applied in the health store, run GetServiceHealth and check that
        the report appears in the HealthEvents section.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :param health_information: Describes the health information for the health report. This
         information needs to be present in all of the health reports sent to the health manager.
        :type health_information: JSON
        :keyword immediate: A flag that indicates whether the report should be sent immediately.
         A health report is sent to a Service Fabric gateway Application, which forwards to the health
         store.
         If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
         store, regardless of the fabric client settings that the HTTP Gateway Application is using.
         This is useful for critical reports that should be sent as soon as possible.
         Depending on timing and other conditions, sending the report may still fail, for example if
         the HTTP Gateway is closed or the message doesn't reach the Gateway.
         If Immediate is set to false, the report is sent based on the health client settings from the
         HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
         configuration.
         This is the recommended setting because it allows the health client to optimize health
         reporting messages to health store as well as health report processing.
         By default, reports are not sent immediately. Default value is False.
        :paramtype immediate: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                health_information = {
                    "Description": "str",  # Optional. The description of the health information.
                      It represents free text used to add human readable information about the
                      report."nThe maximum string length for the description is 4096 characters."nIf
                      the provided string is longer, it will be automatically truncated."nWhen
                      truncated, the last characters of the description contain a marker "[Truncated]",
                      and total string size is 4096 characters."nThe presence of the marker indicates
                      to users that truncation occurred."nNote that when truncated, the description has
                      less than 4096 characters from the original string.
                    "HealthReportId": "str",  # Optional. A health report ID which identifies the
                      health report and can be used to find more detailed information about a specific
                      health event at"naka.ms/sfhealthid.
                    "HealthState": "str",  # Required. The health state of a Service Fabric
                      entity such as Cluster, Node, Application, Service, Partition, Replica etc. Known
                      values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "Property": "str",  # Required. The property of the health information. An
                      entity can have health reports for different properties."nThe property is a
                      string and not a fixed enumeration to allow the reporter flexibility to
                      categorize the state condition that triggers the report."nFor example, a reporter
                      with SourceId "LocalWatchdog" can monitor the state of the available disk on a
                      node,"nso it can report "AvailableDisk" property on that node."nThe same reporter
                      can monitor the node connectivity, so it can report a property "Connectivity" on
                      the same node."nIn the health store, these reports are treated as separate health
                      events for the specified node."n"nTogether with the SourceId, the property
                      uniquely identifies the health information.
                    "RemoveWhenExpired": bool,  # Optional. Value that indicates whether the
                      report is removed from health store when it expires."nIf set to true, the report
                      is removed from the health store after it expires."nIf set to false, the report
                      is treated as an error when expired. The value of this property is false by
                      default."nWhen clients report periodically, they should set RemoveWhenExpired
                      false (default)."nThis way, if the reporter has issues (e.g. deadlock) and can't
                      report, the entity is evaluated at error when the health report expires."nThis
                      flags the entity as being in Error health state.
                    "SequenceNumber": "str",  # Optional. The sequence number for this health
                      report as a numeric string."nThe report sequence number is used by the health
                      store to detect stale reports."nIf not specified, a sequence number is
                      auto-generated by the health client when a report is added.
                    "SourceId": "str",  # Required. The source name that identifies the
                      client/watchdog/system component that generated the health information.
                    "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The duration for
                      which this health report is valid. This field uses ISO8601 format for specifying
                      the duration."nWhen clients report periodically, they should send reports with
                      higher frequency than time to live."nIf clients report on transition, they can
                      set the time to live to infinite."nWhen time to live expires, the health event
                      that contains the health information"nis either removed from health store, if
                      RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                      false."n"nIf not specified, time to live defaults to infinite value.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = health_information

        request = build_report_service_health_request(
            service_id=service_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            immediate=immediate,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def resolve_service(
        self,
        service_id: str,
        *,
        partition_key_type: Optional[int] = None,
        partition_key_value: Optional[str] = None,
        previous_rsp_version: Optional[str] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Resolve a Service Fabric partition.

        Resolve a Service Fabric service partition to get the endpoints of the service replicas.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :keyword partition_key_type: Key type for the partition. This parameter is required if the
         partition scheme for the service is Int64Range or Named. The possible values are following.


         * None (1) - Indicates that the PartitionKeyValue parameter is not specified. This is valid
         for the partitions with partitioning scheme as Singleton. This is the default value. The value
         is 1.
         * Int64Range (2) - Indicates that the PartitionKeyValue parameter is an int64 partition key.
         This is valid for the partitions with partitioning scheme as Int64Range. The value is 2.
         * Named (3) - Indicates that the PartitionKeyValue parameter is a name of the partition. This
         is valid for the partitions with partitioning scheme as Named. The value is 3. Default value is
         None.
        :paramtype partition_key_type: int
        :keyword partition_key_value: Partition key. This is required if the partition scheme for the
         service is Int64Range or Named.
         This is not the partition ID, but rather, either the integer key value, or the name of the
         partition ID.
         For example, if your service is using ranged partitions from 0 to 10, then they
         PartitionKeyValue would be an
         integer in that range. Query service description to see the range or name. Default value is
         None.
        :paramtype partition_key_value: str
        :keyword previous_rsp_version: The value in the Version field of the response that was received
         previously. This is required if the user knows that the result that was gotten previously is
         stale. Default value is None.
        :paramtype previous_rsp_version: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Endpoints": [
                        {
                            "Address": "str",  # Optional. The address of the endpoint.
                              If the endpoint has multiple listeners the address is a JSON object with
                              one property per listener with the value as the address of that listener.
                            "Kind": "str"  # Optional. The role of the replica where the
                              endpoint is reported. Known values are: "Invalid", "Stateless",
                              "StatefulPrimary", "StatefulSecondary".
                        }
                    ],
                    "Name": "str",  # Required. The full name of the service with 'fabric:' URI
                      scheme.
                    "PartitionInformation": {
                        "Id": str,  # Optional. An internal ID used by Service Fabric to
                          uniquely identify a partition. This is a randomly generated GUID when the
                          service was created. The partition ID is unique and does not change for the
                          lifetime of the service. If the same service was deleted and recreated the
                          IDs of its partitions would be different.
                        ServicePartitionKind: ServicePartitionKind
                    },
                    "Version": "str"  # Required. The version of this resolved service partition
                      result. This version should be passed in the next time the ResolveService call is
                      made via the PreviousRspVersion query parameter.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_resolve_service_request(
            service_id=service_id,
            api_version=api_version,
            partition_key_type=partition_key_type,
            partition_key_value=partition_key_value,
            previous_rsp_version=previous_rsp_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_unplaced_replica_information(
        self,
        service_id: str,
        *,
        partition_id: Optional[str] = None,
        only_query_primaries: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the information about unplaced replica of the service.

        Returns the information about the unplaced replicas of the service.
        If PartitionId is specified, then result will contain information only about unplaced replicas
        for that partition.
        If PartitionId is not specified, then result will contain information about unplaced replicas
        for all partitions of that service.
        If OnlyQueryPrimaries is set to true, then result will contain information only about primary
        replicas, and will ignore unplaced secondary replicas.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :keyword partition_id: The identity of the partition. Default value is None.
        :paramtype partition_id: str
        :keyword only_query_primaries: Indicates that unplaced replica information will be queries only
         for primary replicas. Default value is False.
        :paramtype only_query_primaries: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "PartitionId": str,  # Optional. The ID of the partition.
                    "ServiceName": "str",  # Optional. The name of the service.
                    "UnplacedReplicaDetails": [
                        "str"  # Optional. List of reasons due to which a replica cannot be
                          placed.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_unplaced_replica_information_request(
            service_id=service_id,
            api_version=api_version,
            partition_id=partition_id,
            only_query_primaries=only_query_primaries,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def update_service_arm_metadata(  # pylint: disable=inconsistent-return-statements
        self,
        service_id: str,
        service_arm_metadata_update_description: JSON,
        *,
        timeout: Optional[int] = 60,
        force: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Updates the Arm Metadata for a specific service.

        Updates the Arm Metadata for a specific service.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :param service_arm_metadata_update_description: The Arm metadata to be assocated with a
         specific service.
        :type service_arm_metadata_update_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword force: Force parameter used to prevent accidental Arm metadata update. Default value
         is None.
        :paramtype force: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '9.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "9.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                service_arm_metadata_update_description = {
                    "ArmResourceId": "str"  # Optional. A string containing the ArmResourceId.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = service_arm_metadata_update_description

        request = build_update_service_arm_metadata_request(
            service_id=service_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            force=force,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_loaded_partition_info_list(
        self,
        *,
        metric_name: str,
        service_name: Optional[str] = None,
        ordering: Optional[str] = None,
        max_results: Optional[int] = 0,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Gets ordered list of partitions.

        Retrieves partitions which are most/least loaded according to specified metric.

        :keyword metric_name: Name of the metric based on which to get ordered list of partitions.
        :paramtype metric_name: str
        :keyword service_name: The name of a service. Default value is None.
        :paramtype service_name: str
        :keyword ordering: Ordering of partitions' load. Known values are: "Desc" or "Asc". Default
         value is None.
        :paramtype ordering: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '8.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "8.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "Load": 0.0,  # Required. Load for metric.
                            "MetricName": "str",  # Required. Name of the metric for
                              which this information is provided.
                            "PartitionId": str,  # Required. Id of the partition.
                            "ServiceName": "str"  # Required. Name of the service this
                              partition belongs to.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "8.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_loaded_partition_info_list_request(
            api_version=api_version,
            metric_name=metric_name,
            service_name=service_name,
            ordering=ordering,
            max_results=max_results,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_partition_info_list(
        self,
        service_id: str,
        *,
        continuation_token_parameter: Optional[str] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the list of partitions of a Service Fabric service.

        The response includes the partition ID, partitioning scheme information, keys supported by the
        partition, status, health, and other details about the partition.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "HealthState": "str",  # Optional. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "PartitionInformation": {
                                "Id": str,  # Optional. An internal ID used by
                                  Service Fabric to uniquely identify a partition. This is a randomly
                                  generated GUID when the service was created. The partition ID is
                                  unique and does not change for the lifetime of the service. If the
                                  same service was deleted and recreated the IDs of its partitions
                                  would be different.
                                ServicePartitionKind: ServicePartitionKind
                            },
                            "PartitionStatus": "str",  # Optional. The status of the
                              service fabric service partition. Known values are: "Invalid", "Ready",
                              "NotReady", "InQuorumLoss", "Reconfiguring", "Deleting".
                            ServiceKind: ServiceKind
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_partition_info_list_request(
            service_id=service_id,
            api_version=api_version,
            continuation_token_parameter=continuation_token_parameter,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_partition_info(
        self,
        partition_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Gets the information about a Service Fabric partition.

        Gets the information about the specified partition. The response includes the partition ID,
        partitioning scheme information, keys supported by the partition, status, health, and other
        details about the partition.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "HealthState": "str",  # Optional. The health state of a Service Fabric
                      entity such as Cluster, Node, Application, Service, Partition, Replica etc. Known
                      values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "PartitionInformation": {
                        "Id": str,  # Optional. An internal ID used by Service Fabric to
                          uniquely identify a partition. This is a randomly generated GUID when the
                          service was created. The partition ID is unique and does not change for the
                          lifetime of the service. If the same service was deleted and recreated the
                          IDs of its partitions would be different.
                        ServicePartitionKind: ServicePartitionKind
                    },
                    "PartitionStatus": "str",  # Optional. The status of the service fabric
                      service partition. Known values are: "Invalid", "Ready", "NotReady",
                      "InQuorumLoss", "Reconfiguring", "Deleting".
                    ServiceKind: ServiceKind
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_get_partition_info_request(
            partition_id=partition_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get_service_name_info(
        self,
        partition_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the name of the Service Fabric service for a partition.

        Gets name of the service for the specified partition. A 404 error is returned if the partition
        ID does not exist in the cluster.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Id": "str",  # Optional. The identity of the service. This ID is an encoded
                      representation of the service name. This is used in the REST APIs to identify the
                      service resource."nStarting in version 6.0, hierarchical names are delimited with
                      the "~" character. For example, if the service name is
                      "fabric:/myapp/app1/svc1","nthe service identity would be "myapp~app1~svc1" in
                      6.0+ and "myapp/app1/svc1" in previous versions.
                    "Name": "str"  # Optional. The full name of the service with 'fabric:' URI
                      scheme.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_service_name_info_request(
            partition_id=partition_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_partition_health(
        self,
        partition_id: str,
        *,
        events_health_state_filter: Optional[int] = 0,
        replicas_health_state_filter: Optional[int] = 0,
        exclude_health_statistics: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the health of the specified Service Fabric partition.

        Use EventsHealthStateFilter to filter the collection of health events reported on the service
        based on the health state.
        Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the
        partition.
        If you specify a partition that does not exist in the health store, this request returns an
        error.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword replicas_health_state_filter: Allows filtering the collection of ReplicaHealthState
         objects on the partition. The value can be obtained from members or bitwise operations on
         members of HealthStateFilter. Only replicas that match the filter will be returned. All
         replicas will be used to evaluate the aggregated health state. If not specified, all entries
         will be returned.The state values are flag-based enumeration, so the value could be a
         combination of these values obtained using bitwise 'OR' operator. For example, If the provided
         value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be
         returned. The possible values for this parameter include integer value of one of the following
         health states.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype replicas_health_state_filter: int
        :keyword exclude_health_statistics: Indicates whether the health statistics should be returned
         as part of the query result. False by default.
         The statistics show the number of children entities in health state Ok, Warning, and Error.
         Default value is False.
        :paramtype exclude_health_statistics: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "PartitionId": str,  # Optional. ID of the partition whose health information
                      is described by this object.
                    "ReplicaHealthStates": [
                        {
                            "AggregatedHealthState": "str",  # Optional. The health state
                              of a Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "PartitionId": str,  # Optional. The ID of the partition to
                              which this replica belongs.
                            ServiceKind: ReplicaHealthState
                        }
                    ],
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_partition_health_request(
            partition_id=partition_id,
            api_version=api_version,
            events_health_state_filter=events_health_state_filter,
            replicas_health_state_filter=replicas_health_state_filter,
            exclude_health_statistics=exclude_health_statistics,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_partition_health_using_policy(
        self,
        partition_id: str,
        application_health_policy: Optional[JSON] = None,
        *,
        events_health_state_filter: Optional[int] = 0,
        replicas_health_state_filter: Optional[int] = 0,
        exclude_health_statistics: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the health of the specified Service Fabric partition, by using the specified health
        policy.

        Gets the health information of the specified partition.
        If the application health policy is specified, the health evaluation uses it to get the
        aggregated health state.
        If the policy is not specified, the health evaluation uses the application health policy
        defined in the application manifest, or the default health policy, if no policy is defined in
        the manifest.
        Use EventsHealthStateFilter to filter the collection of health events reported on the partition
        based on the health state.
        Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the
        partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to
        evaluate the health.
        If you specify a partition that does not exist in the health store, this request returns an
        error.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :param application_health_policy: Describes the health policies used to evaluate the health of
         an application or one of its children.
         If not present, the health evaluation uses the health policy from application manifest or the
         default health policy. Default value is None.
        :type application_health_policy: JSON
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword replicas_health_state_filter: Allows filtering the collection of ReplicaHealthState
         objects on the partition. The value can be obtained from members or bitwise operations on
         members of HealthStateFilter. Only replicas that match the filter will be returned. All
         replicas will be used to evaluate the aggregated health state. If not specified, all entries
         will be returned.The state values are flag-based enumeration, so the value could be a
         combination of these values obtained using bitwise 'OR' operator. For example, If the provided
         value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be
         returned. The possible values for this parameter include integer value of one of the following
         health states.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype replicas_health_state_filter: int
        :keyword exclude_health_statistics: Indicates whether the health statistics should be returned
         as part of the query result. False by default.
         The statistics show the number of children entities in health state Ok, Warning, and Error.
         Default value is False.
        :paramtype exclude_health_statistics: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                application_health_policy = {
                    "ConsiderWarningAsError": bool,  # Optional. Indicates whether warnings are
                      treated with the same severity as errors.
                    "DefaultServiceTypeHealthPolicy": {
                        "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional. The
                          maximum allowed percentage of unhealthy partitions per service. Allowed
                          values are Byte values from zero to 100"n"nThe percentage represents the
                          maximum tolerated percentage of partitions that can be unhealthy before the
                          service is considered in error."nIf the percentage is respected but there is
                          at least one unhealthy partition, the health is evaluated as Warning."nThe
                          percentage is calculated by dividing the number of unhealthy partitions over
                          the total number of partitions in the service."nThe computation rounds up to
                          tolerate one failure on small numbers of partitions. Default percentage is
                          zero.
                        "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional. The
                          maximum allowed percentage of unhealthy replicas per partition. Allowed
                          values are Byte values from zero to 100."n"nThe percentage represents the
                          maximum tolerated percentage of replicas that can be unhealthy before the
                          partition is considered in error."nIf the percentage is respected but there
                          is at least one unhealthy replica, the health is evaluated as Warning."nThe
                          percentage is calculated by dividing the number of unhealthy replicas over
                          the total number of replicas in the partition."nThe computation rounds up to
                          tolerate one failure on small numbers of replicas. Default percentage is
                          zero.
                        "MaxPercentUnhealthyServices": 0  # Optional. The maximum allowed
                          percentage of unhealthy services. Allowed values are Byte values from zero to
                          100."n"nThe percentage represents the maximum tolerated percentage of
                          services that can be unhealthy before the application is considered in
                          error."nIf the percentage is respected but there is at least one unhealthy
                          service, the health is evaluated as Warning."nThis is calculated by dividing
                          the number of unhealthy services of the specific service type over the total
                          number of services of the specific service type."nThe computation rounds up
                          to tolerate one failure on small numbers of services. Default percentage is
                          zero.
                    },
                    "MaxPercentUnhealthyDeployedApplications": 0,  # Optional. The maximum
                      allowed percentage of unhealthy deployed applications. Allowed values are Byte
                      values from zero to 100."nThe percentage represents the maximum tolerated
                      percentage of deployed applications that can be unhealthy before the application
                      is considered in error."nThis is calculated by dividing the number of unhealthy
                      deployed applications over the number of nodes where the application is currently
                      deployed on in the cluster."nThe computation rounds up to tolerate one failure on
                      small numbers of nodes. Default percentage is zero.
                    "ServiceTypeHealthPolicyMap": [
                        {
                            "Key": "str",  # Required. The key of the service type health
                              policy map item. This is the name of the service type.
                            "Value": {
                                "MaxPercentUnhealthyPartitionsPerService": 0,  #
                                  Optional. The maximum allowed percentage of unhealthy partitions per
                                  service. Allowed values are Byte values from zero to 100"n"nThe
                                  percentage represents the maximum tolerated percentage of partitions
                                  that can be unhealthy before the service is considered in error."nIf
                                  the percentage is respected but there is at least one unhealthy
                                  partition, the health is evaluated as Warning."nThe percentage is
                                  calculated by dividing the number of unhealthy partitions over the
                                  total number of partitions in the service."nThe computation rounds up
                                  to tolerate one failure on small numbers of partitions. Default
                                  percentage is zero.
                                "MaxPercentUnhealthyReplicasPerPartition": 0,  #
                                  Optional. The maximum allowed percentage of unhealthy replicas per
                                  partition. Allowed values are Byte values from zero to 100."n"nThe
                                  percentage represents the maximum tolerated percentage of replicas
                                  that can be unhealthy before the partition is considered in
                                  error."nIf the percentage is respected but there is at least one
                                  unhealthy replica, the health is evaluated as Warning."nThe
                                  percentage is calculated by dividing the number of unhealthy replicas
                                  over the total number of replicas in the partition."nThe computation
                                  rounds up to tolerate one failure on small numbers of replicas.
                                  Default percentage is zero.
                                "MaxPercentUnhealthyServices": 0  # Optional. The
                                  maximum allowed percentage of unhealthy services. Allowed values are
                                  Byte values from zero to 100."n"nThe percentage represents the
                                  maximum tolerated percentage of services that can be unhealthy before
                                  the application is considered in error."nIf the percentage is
                                  respected but there is at least one unhealthy service, the health is
                                  evaluated as Warning."nThis is calculated by dividing the number of
                                  unhealthy services of the specific service type over the total number
                                  of services of the specific service type."nThe computation rounds up
                                  to tolerate one failure on small numbers of services. Default
                                  percentage is zero.
                            }
                        }
                    ]
                }

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "PartitionId": str,  # Optional. ID of the partition whose health information
                      is described by this object.
                    "ReplicaHealthStates": [
                        {
                            "AggregatedHealthState": "str",  # Optional. The health state
                              of a Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "PartitionId": str,  # Optional. The ID of the partition to
                              which this replica belongs.
                            ServiceKind: ReplicaHealthState
                        }
                    ],
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        if application_health_policy is not None:
            _json = application_health_policy
        else:
            _json = None

        request = build_get_partition_health_using_policy_request(
            partition_id=partition_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            events_health_state_filter=events_health_state_filter,
            replicas_health_state_filter=replicas_health_state_filter,
            exclude_health_statistics=exclude_health_statistics,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def report_partition_health(  # pylint: disable=inconsistent-return-statements
        self,
        partition_id: str,
        health_information: JSON,
        *,
        immediate: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Sends a health report on the Service Fabric partition.

        Reports health state of the specified Service Fabric partition. The report must contain the
        information about the source of the health report and property on which it is reported.
        The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
        The report may be accepted by the gateway, but rejected by the health store after extra
        validation.
        For example, the health store may reject the report because of an invalid parameter, like a
        stale sequence number.
        To see whether the report was applied in the health store, run GetPartitionHealth and check
        that the report appears in the HealthEvents section.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :param health_information: Describes the health information for the health report. This
         information needs to be present in all of the health reports sent to the health manager.
        :type health_information: JSON
        :keyword immediate: A flag that indicates whether the report should be sent immediately.
         A health report is sent to a Service Fabric gateway Application, which forwards to the health
         store.
         If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
         store, regardless of the fabric client settings that the HTTP Gateway Application is using.
         This is useful for critical reports that should be sent as soon as possible.
         Depending on timing and other conditions, sending the report may still fail, for example if
         the HTTP Gateway is closed or the message doesn't reach the Gateway.
         If Immediate is set to false, the report is sent based on the health client settings from the
         HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
         configuration.
         This is the recommended setting because it allows the health client to optimize health
         reporting messages to health store as well as health report processing.
         By default, reports are not sent immediately. Default value is False.
        :paramtype immediate: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                health_information = {
                    "Description": "str",  # Optional. The description of the health information.
                      It represents free text used to add human readable information about the
                      report."nThe maximum string length for the description is 4096 characters."nIf
                      the provided string is longer, it will be automatically truncated."nWhen
                      truncated, the last characters of the description contain a marker "[Truncated]",
                      and total string size is 4096 characters."nThe presence of the marker indicates
                      to users that truncation occurred."nNote that when truncated, the description has
                      less than 4096 characters from the original string.
                    "HealthReportId": "str",  # Optional. A health report ID which identifies the
                      health report and can be used to find more detailed information about a specific
                      health event at"naka.ms/sfhealthid.
                    "HealthState": "str",  # Required. The health state of a Service Fabric
                      entity such as Cluster, Node, Application, Service, Partition, Replica etc. Known
                      values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "Property": "str",  # Required. The property of the health information. An
                      entity can have health reports for different properties."nThe property is a
                      string and not a fixed enumeration to allow the reporter flexibility to
                      categorize the state condition that triggers the report."nFor example, a reporter
                      with SourceId "LocalWatchdog" can monitor the state of the available disk on a
                      node,"nso it can report "AvailableDisk" property on that node."nThe same reporter
                      can monitor the node connectivity, so it can report a property "Connectivity" on
                      the same node."nIn the health store, these reports are treated as separate health
                      events for the specified node."n"nTogether with the SourceId, the property
                      uniquely identifies the health information.
                    "RemoveWhenExpired": bool,  # Optional. Value that indicates whether the
                      report is removed from health store when it expires."nIf set to true, the report
                      is removed from the health store after it expires."nIf set to false, the report
                      is treated as an error when expired. The value of this property is false by
                      default."nWhen clients report periodically, they should set RemoveWhenExpired
                      false (default)."nThis way, if the reporter has issues (e.g. deadlock) and can't
                      report, the entity is evaluated at error when the health report expires."nThis
                      flags the entity as being in Error health state.
                    "SequenceNumber": "str",  # Optional. The sequence number for this health
                      report as a numeric string."nThe report sequence number is used by the health
                      store to detect stale reports."nIf not specified, a sequence number is
                      auto-generated by the health client when a report is added.
                    "SourceId": "str",  # Required. The source name that identifies the
                      client/watchdog/system component that generated the health information.
                    "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The duration for
                      which this health report is valid. This field uses ISO8601 format for specifying
                      the duration."nWhen clients report periodically, they should send reports with
                      higher frequency than time to live."nIf clients report on transition, they can
                      set the time to live to infinite."nWhen time to live expires, the health event
                      that contains the health information"nis either removed from health store, if
                      RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                      false."n"nIf not specified, time to live defaults to infinite value.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = health_information

        request = build_report_partition_health_request(
            partition_id=partition_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            immediate=immediate,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_partition_load_information(
        self,
        partition_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the load information of the specified Service Fabric partition.

        Returns information about the load of a specified partition.
        The response includes a list of load reports for a Service Fabric partition.
        Each report includes the load metric name, value, and last reported time in UTC.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "AuxiliaryLoadMetricReports": [
                        {
                            "CurrentValue": "str",  # Optional. The value of the load
                              metric.
                            "LastReportedUtc": "2020-02-20 00:00:00",  # Optional. Gets
                              the UTC time when the load was reported.
                            "Name": "str",  # Optional. The name of the load metric.
                            "Value": "str"  # Optional. The value of the load metric. In
                              future releases of Service Fabric this parameter will be deprecated in
                              favor of CurrentValue.
                        }
                    ],
                    "PartitionId": str,  # Optional. Id of the partition.
                    "PrimaryLoadMetricReports": [
                        {
                            "CurrentValue": "str",  # Optional. The value of the load
                              metric.
                            "LastReportedUtc": "2020-02-20 00:00:00",  # Optional. Gets
                              the UTC time when the load was reported.
                            "Name": "str",  # Optional. The name of the load metric.
                            "Value": "str"  # Optional. The value of the load metric. In
                              future releases of Service Fabric this parameter will be deprecated in
                              favor of CurrentValue.
                        }
                    ],
                    "SecondaryLoadMetricReports": [
                        {
                            "CurrentValue": "str",  # Optional. The value of the load
                              metric.
                            "LastReportedUtc": "2020-02-20 00:00:00",  # Optional. Gets
                              the UTC time when the load was reported.
                            "Name": "str",  # Optional. The name of the load metric.
                            "Value": "str"  # Optional. The value of the load metric. In
                              future releases of Service Fabric this parameter will be deprecated in
                              favor of CurrentValue.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_partition_load_information_request(
            partition_id=partition_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def reset_partition_load(  # pylint: disable=inconsistent-return-statements
        self,
        partition_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Resets the current load of a Service Fabric partition.

        Resets the current load of a Service Fabric partition to the default load for the service.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_reset_partition_load_request(
            partition_id=partition_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def recover_partition(  # pylint: disable=inconsistent-return-statements
        self,
        partition_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Indicates to the Service Fabric cluster that it should attempt to recover a specific partition
        that is currently stuck in quorum loss.

        This operation should only be performed if it is known that the replicas that are down cannot
        be recovered. Incorrect use of this API can cause potential data loss.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_recover_partition_request(
            partition_id=partition_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def recover_service_partitions(  # pylint: disable=inconsistent-return-statements
        self,
        service_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Indicates to the Service Fabric cluster that it should attempt to recover the specified service
        that is currently stuck in quorum loss.

        Indicates to the Service Fabric cluster that it should attempt to recover the specified service
        that is currently stuck in quorum loss. This operation should only be performed if it is known
        that the replicas that are down cannot be recovered. Incorrect use of this API can cause
        potential data loss.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_recover_service_partitions_request(
            service_id=service_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def recover_system_partitions(  # pylint: disable=inconsistent-return-statements
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Indicates to the Service Fabric cluster that it should attempt to recover the system services
        that are currently stuck in quorum loss.

        Indicates to the Service Fabric cluster that it should attempt to recover the system services
        that are currently stuck in quorum loss. This operation should only be performed if it is known
        that the replicas that are down cannot be recovered. Incorrect use of this API can cause
        potential data loss.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_recover_system_partitions_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def recover_all_partitions(  # pylint: disable=inconsistent-return-statements
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Indicates to the Service Fabric cluster that it should attempt to recover any services
        (including system services) which are currently stuck in quorum loss.

        This operation should only be performed if it is known that the replicas that are down cannot
        be recovered. Incorrect use of this API can cause potential data loss.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_recover_all_partitions_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def move_primary_replica(  # pylint: disable=inconsistent-return-statements
        self,
        partition_id: str,
        *,
        node_name: Optional[str] = None,
        ignore_constraints: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Moves the primary replica of a partition of a stateful service.

        This command moves the primary replica of a partition of a stateful service, respecting all
        constraints.
        If NodeName parameter is specified, primary will be moved to the specified node (if constraints
        allow it).
        If NodeName parameter is not specified, primary replica will be moved to a random node in the
        cluster.
        If IgnoreConstraints parameter is specified and set to true, then primary will be moved
        regardless of the constraints.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword node_name: The name of the node. Default value is None.
        :paramtype node_name: str
        :keyword ignore_constraints: Ignore constraints when moving a replica or instance. If this
         parameter is not specified, all constraints are honored. Default value is False.
        :paramtype ignore_constraints: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.5'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.5". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.5"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_move_primary_replica_request(
            partition_id=partition_id,
            api_version=api_version,
            node_name=node_name,
            ignore_constraints=ignore_constraints,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def move_secondary_replica(  # pylint: disable=inconsistent-return-statements
        self,
        partition_id: str,
        *,
        current_node_name: str,
        new_node_name: Optional[str] = None,
        ignore_constraints: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Moves the secondary replica of a partition of a stateful service.

        This command moves the secondary replica of a partition of a stateful service, respecting all
        constraints.
        CurrentNodeName parameter must be specified to identify the replica that is moved.
        Source node name must be specified, but new node name can be omitted, and in that case replica
        is moved to a random node.
        If IgnoreConstraints parameter is specified and set to true, then secondary will be moved
        regardless of the constraints.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword current_node_name: The name of the source node for secondary replica move.
        :paramtype current_node_name: str
        :keyword new_node_name: The name of the target node for secondary replica or instance move. If
         not specified, replica or instance is moved to a random node. Default value is None.
        :paramtype new_node_name: str
        :keyword ignore_constraints: Ignore constraints when moving a replica or instance. If this
         parameter is not specified, all constraints are honored. Default value is False.
        :paramtype ignore_constraints: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.5'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.5". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.5"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_move_secondary_replica_request(
            partition_id=partition_id,
            api_version=api_version,
            current_node_name=current_node_name,
            new_node_name=new_node_name,
            ignore_constraints=ignore_constraints,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def update_partition_load(
        self,
        partition_metric_load_description_list: List[JSON],
        *,
        continuation_token_parameter: Optional[str] = None,
        max_results: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Update the loads of provided partitions for specific metrics.

        Updates the load value and predicted load value for all the partitions provided for specified
        metrics.

        :param partition_metric_load_description_list: Description of updating load for list of
         partitions.
        :type partition_metric_load_description_list: list[JSON]
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '7.2'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "7.2". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                partition_metric_load_description_list = [
                    {
                        "AuxiliaryReplicaLoadEntriesPerNode": [
                            {
                                "NodeName": "str",  # Optional. Node name of a
                                  specific secondary replica or instance.
                                "ReplicaOrInstanceLoadEntries": [
                                    {
                                        "CurrentLoad": 0.0,  # Optional. The
                                          current value of the metric load.
                                        "MetricName": "str",  # Optional. The
                                          name of the reported metric.
                                        "PredictedLoad": 0.0  # Optional. The
                                          predicted value of the metric load. Predicted metric load
                                          values is currently a preview feature. It allows predicted
                                          load values to be reported and used at the Service Fabric
                                          side, but that feature is currently not enabled.
                                    }
                                ]
                            }
                        ],
                        "AuxiliaryReplicasLoadEntries": [
                            {
                                "CurrentLoad": 0.0,  # Optional. The current value of
                                  the metric load.
                                "MetricName": "str",  # Optional. The name of the
                                  reported metric.
                                "PredictedLoad": 0.0  # Optional. The predicted value
                                  of the metric load. Predicted metric load values is currently a
                                  preview feature. It allows predicted load values to be reported and
                                  used at the Service Fabric side, but that feature is currently not
                                  enabled.
                            }
                        ],
                        "PartitionId": str,  # Optional. Id of the partition.
                        "PrimaryReplicaLoadEntries": [
                            {
                                "CurrentLoad": 0.0,  # Optional. The current value of
                                  the metric load.
                                "MetricName": "str",  # Optional. The name of the
                                  reported metric.
                                "PredictedLoad": 0.0  # Optional. The predicted value
                                  of the metric load. Predicted metric load values is currently a
                                  preview feature. It allows predicted load values to be reported and
                                  used at the Service Fabric side, but that feature is currently not
                                  enabled.
                            }
                        ],
                        "SecondaryReplicaOrInstanceLoadEntriesPerNode": [
                            {
                                "NodeName": "str",  # Optional. Node name of a
                                  specific secondary replica or instance.
                                "ReplicaOrInstanceLoadEntries": [
                                    {
                                        "CurrentLoad": 0.0,  # Optional. The
                                          current value of the metric load.
                                        "MetricName": "str",  # Optional. The
                                          name of the reported metric.
                                        "PredictedLoad": 0.0  # Optional. The
                                          predicted value of the metric load. Predicted metric load
                                          values is currently a preview feature. It allows predicted
                                          load values to be reported and used at the Service Fabric
                                          side, but that feature is currently not enabled.
                                    }
                                ]
                            }
                        ],
                        "SecondaryReplicasOrInstancesLoadEntries": [
                            {
                                "CurrentLoad": 0.0,  # Optional. The current value of
                                  the metric load.
                                "MetricName": "str",  # Optional. The name of the
                                  reported metric.
                                "PredictedLoad": 0.0  # Optional. The predicted value
                                  of the metric load. Predicted metric load values is currently a
                                  preview feature. It allows predicted load values to be reported and
                                  used at the Service Fabric side, but that feature is currently not
                                  enabled.
                            }
                        ]
                    }
                ]

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "PartitionErrorCode": 0,  # Optional. If OperationState is
                              Completed - this is 0.  If OperationState is Faulted - this is an error
                              code indicating the reason.
                            "PartitionId": str  # Optional. Id of the partition.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "7.2"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = partition_metric_load_description_list

        request = build_update_partition_load_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            continuation_token_parameter=continuation_token_parameter,
            max_results=max_results,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def move_instance(  # pylint: disable=inconsistent-return-statements
        self,
        service_id: str,
        partition_id: str,
        *,
        current_node_name: Optional[str] = None,
        new_node_name: Optional[str] = None,
        ignore_constraints: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Moves the instance of a partition of a stateless service.

        This command moves the instance of a partition of a stateless service, respecting all
        constraints.
        Partition id and service name must be specified to be able to move the instance.
        CurrentNodeName when specified identifies the instance that is moved. If not specified, random
        instance will be moved
        New node name can be omitted, and in that case instance is moved to a random node.
        If IgnoreConstraints parameter is specified and set to true, then instance will be moved
        regardless of the constraints.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword current_node_name: The name of the source node for instance move. If not specified,
         instance is moved from a random node. Default value is None.
        :paramtype current_node_name: str
        :keyword new_node_name: The name of the target node for secondary replica or instance move. If
         not specified, replica or instance is moved to a random node. Default value is None.
        :paramtype new_node_name: str
        :keyword ignore_constraints: Ignore constraints when moving a replica or instance. If this
         parameter is not specified, all constraints are honored. Default value is False.
        :paramtype ignore_constraints: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '8.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "8.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "8.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_move_instance_request(
            service_id=service_id,
            partition_id=partition_id,
            api_version=api_version,
            current_node_name=current_node_name,
            new_node_name=new_node_name,
            ignore_constraints=ignore_constraints,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def move_auxiliary_replica(  # pylint: disable=inconsistent-return-statements
        self,
        service_id: str,
        partition_id: str,
        *,
        current_node_name: Optional[str] = None,
        new_node_name: Optional[str] = None,
        ignore_constraints: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Moves the auxiliary replica of a partition of a stateful service.

        This command moves the auxiliary replica of a partition of a stateful service, respecting all
        constraints.
        CurrentNodeName can be omitted, and in that case a random auxiliary replica is chosen.
        NewNodeName can be omitted, and in that case the auxiliary replica is moved to a random node.
        If IgnoreConstraints parameter is specified and set to true, then auxiliary will be moved
        regardless of the constraints.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword current_node_name: The name of the source node for instance move. If not specified,
         instance is moved from a random node. Default value is None.
        :paramtype current_node_name: str
        :keyword new_node_name: The name of the target node for secondary replica or instance move. If
         not specified, replica or instance is moved to a random node. Default value is None.
        :paramtype new_node_name: str
        :keyword ignore_constraints: Ignore constraints when moving a replica or instance. If this
         parameter is not specified, all constraints are honored. Default value is False.
        :paramtype ignore_constraints: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '8.1'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "8.1". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "8.1"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_move_auxiliary_replica_request(
            service_id=service_id,
            partition_id=partition_id,
            api_version=api_version,
            current_node_name=current_node_name,
            new_node_name=new_node_name,
            ignore_constraints=ignore_constraints,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def create_repair_task(
        self,
        repair_task: JSON,
        **kwargs: Any
    ) -> JSON:
        """Creates a new repair task.

        For clusters that have the Repair Manager Service configured,
        this API provides a way to create repair tasks that run automatically or manually.
        For repair tasks that run automatically, an appropriate repair executor
        must be running for each repair action to run automatically.
        These are currently only available in specially-configured Azure Cloud Services.

        To create a manual repair task, provide the set of impacted node names and the
        expected impact. When the state of the created repair task changes to approved,
        you can safely perform repair actions on those nodes.

        This API supports the Service Fabric platform; it is not meant to be used directly from your
        code.

        :param repair_task: Describes the repair task to be created or updated.
        :type repair_task: JSON
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python


                # JSON input template you can fill out and use as your body input.
                repair_task = {
                    "Action": "str",  # Required. The requested repair action. Must be specified
                      when the repair task is created, and is immutable once set.
                    "Description": "str",  # Optional. A description of the purpose of the repair
                      task, or other informational details."nMay be set when the repair task is
                      created, and is immutable once set.
                    "Executor": "str",  # Optional. The name of the repair executor. Must be
                      specified in Claimed and later states, and is immutable once set.
                    "ExecutorData": "str",  # Optional. A data string that the repair executor
                      can use to store its internal state.
                    "Flags": 0,  # Optional. A bitwise-OR of the following values, which gives
                      additional details about the status of the repair task."n"n"n* 1 - Cancellation
                      of the repair has been requested"n* 2 - Abort of the repair has been requested"n*
                      4 - Approval of the repair was forced via client request.
                    "History": {
                        "ApprovedUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The time
                          when the repair task entered the Approved state.
                        "ClaimedUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The time
                          when the repair task entered the Claimed state.
                        "CompletedUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The time
                          when the repair task entered the Completed state.
                        "CreatedUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The time
                          when the repair task entered the Created state.
                        "ExecutingUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The time
                          when the repair task entered the Executing state.
                        "PreparingHealthCheckEndUtcTimestamp": "2020-02-20 00:00:00",  #
                          Optional. The time when the repair task completed the health check in the
                          Preparing state.
                        "PreparingHealthCheckStartUtcTimestamp": "2020-02-20 00:00:00",  #
                          Optional. The time when the repair task started the health check in the
                          Preparing state.
                        "PreparingUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The time
                          when the repair task entered the Preparing state.
                        "RestoringHealthCheckEndUtcTimestamp": "2020-02-20 00:00:00",  #
                          Optional. The time when the repair task completed the health check in the
                          Restoring state.
                        "RestoringHealthCheckStartUtcTimestamp": "2020-02-20 00:00:00",  #
                          Optional. The time when the repair task started the health check in the
                          Restoring state.
                        "RestoringUtcTimestamp": "2020-02-20 00:00:00"  # Optional. The time
                          when the repair task entered the Restoring state.
                    },
                    "Impact": {
                        Kind: Kind
                    },
                    "PerformPreparingHealthCheck": bool,  # Optional. A value to determine if
                      health checks will be performed when the repair task enters the Preparing state.
                    "PerformRestoringHealthCheck": bool,  # Optional. A value to determine if
                      health checks will be performed when the repair task enters the Restoring state.
                    "PreparingHealthCheckState": "str",  # Optional. The workflow state of the
                      health check when the repair task is in the Preparing state. Known values are:
                      "NotStarted", "InProgress", "Succeeded", "Skipped", "TimedOut".
                    "RestoringHealthCheckState": "str",  # Optional. The workflow state of the
                      health check when the repair task is in the Restoring state. Known values are:
                      "NotStarted", "InProgress", "Succeeded", "Skipped", "TimedOut".
                    "ResultCode": 0,  # Optional. A numeric value providing additional details
                      about the result of the repair task execution."nMay be specified in the Restoring
                      and later states, and is immutable once set.
                    "ResultDetails": "str",  # Optional. A string providing additional details
                      about the result of the repair task execution."nMay be specified in the Restoring
                      and later states, and is immutable once set.
                    "ResultStatus": "str",  # Optional. A value describing the overall result of
                      the repair task execution. Must be specified in the Restoring and later states,
                      and is immutable once set. Known values are: "Invalid", "Succeeded", "Cancelled",
                      "Interrupted", "Failed", "Pending".
                    "State": "str",  # Required. The workflow state of the repair task. Valid
                      initial states are Created, Claimed, and Preparing. Known values are: "Invalid",
                      "Created", "Claimed", "Preparing", "Approved", "Executing", "Restoring",
                      "Completed".
                    "Target": {
                        Kind: Kind
                    },
                    "TaskId": "str",  # Required. The ID of the repair task.
                    "Version": "str"  # Optional. The version of the repair task."nWhen creating
                      a new repair task, the version must be set to zero.  When updating a repair
                      task,"nthe version is used for optimistic concurrency checks.  If the version
                      is"nset to zero, the update will not check for write conflicts.  If the version
                      is set to a non-zero value, then the"nupdate will only succeed if the actual
                      current version of the repair task matches this value.
                }

                # response body for status code(s): 200
                response.json() == {
                    "Version": "str"  # Required. The new version of the repair task.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = repair_task

        request = build_create_repair_task_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def cancel_repair_task(
        self,
        repair_task_cancel_description: JSON,
        **kwargs: Any
    ) -> JSON:
        """Requests the cancellation of the given repair task.

        This API supports the Service Fabric platform; it is not meant to be used directly from your
        code.

        :param repair_task_cancel_description: Describes the repair task to be cancelled.
        :type repair_task_cancel_description: JSON
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                repair_task_cancel_description = {
                    "RequestAbort": bool,  # Optional. *True* if the repair should be stopped as
                      soon as possible even if it has already started executing. *False* if the repair
                      should be cancelled only if execution has not yet started.
                    "TaskId": "str",  # Required. The ID of the repair task.
                    "Version": "str"  # Optional. The current version number of the repair task.
                      If non-zero, then the request will only succeed if this value matches the actual
                      current version of the repair task. If zero, then no version check is performed.
                }

                # response body for status code(s): 200
                response.json() == {
                    "Version": "str"  # Required. The new version of the repair task.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = repair_task_cancel_description

        request = build_cancel_repair_task_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def delete_repair_task(  # pylint: disable=inconsistent-return-statements
        self,
        repair_task_delete_description: JSON,
        **kwargs: Any
    ) -> None:
        """Deletes a completed repair task.

        This API supports the Service Fabric platform; it is not meant to be used directly from your
        code.

        :param repair_task_delete_description: Describes the repair task to be deleted.
        :type repair_task_delete_description: JSON
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                repair_task_delete_description = {
                    "TaskId": "str",  # Required. The ID of the completed repair task to be
                      deleted.
                    "Version": "str"  # Optional. The current version number of the repair task.
                      If non-zero, then the request will only succeed if this value matches the actual
                      current version of the repair task. If zero, then no version check is performed.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = repair_task_delete_description

        request = build_delete_repair_task_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_repair_task_list(
        self,
        *,
        task_id_filter: Optional[str] = None,
        state_filter: Optional[int] = None,
        executor_filter: Optional[str] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets a list of repair tasks matching the given filters.

        This API supports the Service Fabric platform; it is not meant to be used directly from your
        code.

        :keyword task_id_filter: The repair task ID prefix to be matched. Default value is None.
        :paramtype task_id_filter: str
        :keyword state_filter: A bitwise-OR of the following values, specifying which task states
         should be included in the result list.


         * 1 - Created
         * 2 - Claimed
         * 4 - Preparing
         * 8 - Approved
         * 16 - Executing
         * 32 - Restoring
         * 64 - Completed. Default value is None.
        :paramtype state_filter: int
        :keyword executor_filter: The name of the repair executor whose claimed tasks should be
         included in the list. Default value is None.
        :paramtype executor_filter: str
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "Action": "str",  # Required. The requested repair action. Must be
                          specified when the repair task is created, and is immutable once set.
                        "Description": "str",  # Optional. A description of the purpose of
                          the repair task, or other informational details."nMay be set when the repair
                          task is created, and is immutable once set.
                        "Executor": "str",  # Optional. The name of the repair executor. Must
                          be specified in Claimed and later states, and is immutable once set.
                        "ExecutorData": "str",  # Optional. A data string that the repair
                          executor can use to store its internal state.
                        "Flags": 0,  # Optional. A bitwise-OR of the following values, which
                          gives additional details about the status of the repair task."n"n"n* 1 -
                          Cancellation of the repair has been requested"n* 2 - Abort of the repair has
                          been requested"n* 4 - Approval of the repair was forced via client request.
                        "History": {
                            "ApprovedUtcTimestamp": "2020-02-20 00:00:00",  # Optional.
                              The time when the repair task entered the Approved state.
                            "ClaimedUtcTimestamp": "2020-02-20 00:00:00",  # Optional.
                              The time when the repair task entered the Claimed state.
                            "CompletedUtcTimestamp": "2020-02-20 00:00:00",  # Optional.
                              The time when the repair task entered the Completed state.
                            "CreatedUtcTimestamp": "2020-02-20 00:00:00",  # Optional.
                              The time when the repair task entered the Created state.
                            "ExecutingUtcTimestamp": "2020-02-20 00:00:00",  # Optional.
                              The time when the repair task entered the Executing state.
                            "PreparingHealthCheckEndUtcTimestamp": "2020-02-20 00:00:00",
                              # Optional. The time when the repair task completed the health check in
                              the Preparing state.
                            "PreparingHealthCheckStartUtcTimestamp": "2020-02-20
                              00:00:00",  # Optional. The time when the repair task started the health
                              check in the Preparing state.
                            "PreparingUtcTimestamp": "2020-02-20 00:00:00",  # Optional.
                              The time when the repair task entered the Preparing state.
                            "RestoringHealthCheckEndUtcTimestamp": "2020-02-20 00:00:00",
                              # Optional. The time when the repair task completed the health check in
                              the Restoring state.
                            "RestoringHealthCheckStartUtcTimestamp": "2020-02-20
                              00:00:00",  # Optional. The time when the repair task started the health
                              check in the Restoring state.
                            "RestoringUtcTimestamp": "2020-02-20 00:00:00"  # Optional.
                              The time when the repair task entered the Restoring state.
                        },
                        "Impact": {
                            Kind: Kind
                        },
                        "PerformPreparingHealthCheck": bool,  # Optional. A value to
                          determine if health checks will be performed when the repair task enters the
                          Preparing state.
                        "PerformRestoringHealthCheck": bool,  # Optional. A value to
                          determine if health checks will be performed when the repair task enters the
                          Restoring state.
                        "PreparingHealthCheckState": "str",  # Optional. The workflow state
                          of the health check when the repair task is in the Preparing state. Known
                          values are: "NotStarted", "InProgress", "Succeeded", "Skipped", "TimedOut".
                        "RestoringHealthCheckState": "str",  # Optional. The workflow state
                          of the health check when the repair task is in the Restoring state. Known
                          values are: "NotStarted", "InProgress", "Succeeded", "Skipped", "TimedOut".
                        "ResultCode": 0,  # Optional. A numeric value providing additional
                          details about the result of the repair task execution."nMay be specified in
                          the Restoring and later states, and is immutable once set.
                        "ResultDetails": "str",  # Optional. A string providing additional
                          details about the result of the repair task execution."nMay be specified in
                          the Restoring and later states, and is immutable once set.
                        "ResultStatus": "str",  # Optional. A value describing the overall
                          result of the repair task execution. Must be specified in the Restoring and
                          later states, and is immutable once set. Known values are: "Invalid",
                          "Succeeded", "Cancelled", "Interrupted", "Failed", "Pending".
                        "State": "str",  # Required. The workflow state of the repair task.
                          Valid initial states are Created, Claimed, and Preparing. Known values are:
                          "Invalid", "Created", "Claimed", "Preparing", "Approved", "Executing",
                          "Restoring", "Completed".
                        "Target": {
                            Kind: Kind
                        },
                        "TaskId": "str",  # Required. The ID of the repair task.
                        "Version": "str"  # Optional. The version of the repair task."nWhen
                          creating a new repair task, the version must be set to zero.  When updating a
                          repair task,"nthe version is used for optimistic concurrency checks.  If the
                          version is"nset to zero, the update will not check for write conflicts.  If
                          the version is set to a non-zero value, then the"nupdate will only succeed if
                          the actual current version of the repair task matches this value.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_repair_task_list_request(
            api_version=api_version,
            task_id_filter=task_id_filter,
            state_filter=state_filter,
            executor_filter=executor_filter,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def force_approve_repair_task(
        self,
        repair_task_approve_description: JSON,
        **kwargs: Any
    ) -> JSON:
        """Forces the approval of the given repair task.

        This API supports the Service Fabric platform; it is not meant to be used directly from your
        code.

        :param repair_task_approve_description: Describes the repair task to be approved.
        :type repair_task_approve_description: JSON
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                repair_task_approve_description = {
                    "TaskId": "str",  # Required. The ID of the repair task.
                    "Version": "str"  # Optional. The current version number of the repair task.
                      If non-zero, then the request will only succeed if this value matches the actual
                      current version of the repair task. If zero, then no version check is performed.
                }

                # response body for status code(s): 200
                response.json() == {
                    "Version": "str"  # Required. The new version of the repair task.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = repair_task_approve_description

        request = build_force_approve_repair_task_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def update_repair_task_health_policy(
        self,
        repair_task_update_health_policy_description: JSON,
        **kwargs: Any
    ) -> JSON:
        """Updates the health policy of the given repair task.

        This API supports the Service Fabric platform; it is not meant to be used directly from your
        code.

        :param repair_task_update_health_policy_description: Describes the repair task healthy policy
         to be updated.
        :type repair_task_update_health_policy_description: JSON
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                repair_task_update_health_policy_description = {
                    "PerformPreparingHealthCheck": bool,  # Optional. A boolean indicating if
                      health check is to be performed in the Preparing stage of the repair task. If not
                      specified the existing value should not be altered. Otherwise, specify the
                      desired new value.
                    "PerformRestoringHealthCheck": bool,  # Optional. A boolean indicating if
                      health check is to be performed in the Restoring stage of the repair task. If not
                      specified the existing value should not be altered. Otherwise, specify the
                      desired new value.
                    "TaskId": "str",  # Required. The ID of the repair task to be updated.
                    "Version": "str"  # Optional. The current version number of the repair task.
                      If non-zero, then the request will only succeed if this value matches the actual
                      current value of the repair task. If zero, then no version check is performed.
                }

                # response body for status code(s): 200
                response.json() == {
                    "Version": "str"  # Required. The new version of the repair task.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = repair_task_update_health_policy_description

        request = build_update_repair_task_health_policy_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def update_repair_execution_state(
        self,
        repair_task: JSON,
        **kwargs: Any
    ) -> JSON:
        """Updates the execution state of a repair task.

        This API supports the Service Fabric platform; it is not meant to be used directly from your
        code.

        :param repair_task: Describes the repair task to be created or updated.
        :type repair_task: JSON
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python


                # JSON input template you can fill out and use as your body input.
                repair_task = {
                    "Action": "str",  # Required. The requested repair action. Must be specified
                      when the repair task is created, and is immutable once set.
                    "Description": "str",  # Optional. A description of the purpose of the repair
                      task, or other informational details."nMay be set when the repair task is
                      created, and is immutable once set.
                    "Executor": "str",  # Optional. The name of the repair executor. Must be
                      specified in Claimed and later states, and is immutable once set.
                    "ExecutorData": "str",  # Optional. A data string that the repair executor
                      can use to store its internal state.
                    "Flags": 0,  # Optional. A bitwise-OR of the following values, which gives
                      additional details about the status of the repair task."n"n"n* 1 - Cancellation
                      of the repair has been requested"n* 2 - Abort of the repair has been requested"n*
                      4 - Approval of the repair was forced via client request.
                    "History": {
                        "ApprovedUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The time
                          when the repair task entered the Approved state.
                        "ClaimedUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The time
                          when the repair task entered the Claimed state.
                        "CompletedUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The time
                          when the repair task entered the Completed state.
                        "CreatedUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The time
                          when the repair task entered the Created state.
                        "ExecutingUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The time
                          when the repair task entered the Executing state.
                        "PreparingHealthCheckEndUtcTimestamp": "2020-02-20 00:00:00",  #
                          Optional. The time when the repair task completed the health check in the
                          Preparing state.
                        "PreparingHealthCheckStartUtcTimestamp": "2020-02-20 00:00:00",  #
                          Optional. The time when the repair task started the health check in the
                          Preparing state.
                        "PreparingUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The time
                          when the repair task entered the Preparing state.
                        "RestoringHealthCheckEndUtcTimestamp": "2020-02-20 00:00:00",  #
                          Optional. The time when the repair task completed the health check in the
                          Restoring state.
                        "RestoringHealthCheckStartUtcTimestamp": "2020-02-20 00:00:00",  #
                          Optional. The time when the repair task started the health check in the
                          Restoring state.
                        "RestoringUtcTimestamp": "2020-02-20 00:00:00"  # Optional. The time
                          when the repair task entered the Restoring state.
                    },
                    "Impact": {
                        Kind: Kind
                    },
                    "PerformPreparingHealthCheck": bool,  # Optional. A value to determine if
                      health checks will be performed when the repair task enters the Preparing state.
                    "PerformRestoringHealthCheck": bool,  # Optional. A value to determine if
                      health checks will be performed when the repair task enters the Restoring state.
                    "PreparingHealthCheckState": "str",  # Optional. The workflow state of the
                      health check when the repair task is in the Preparing state. Known values are:
                      "NotStarted", "InProgress", "Succeeded", "Skipped", "TimedOut".
                    "RestoringHealthCheckState": "str",  # Optional. The workflow state of the
                      health check when the repair task is in the Restoring state. Known values are:
                      "NotStarted", "InProgress", "Succeeded", "Skipped", "TimedOut".
                    "ResultCode": 0,  # Optional. A numeric value providing additional details
                      about the result of the repair task execution."nMay be specified in the Restoring
                      and later states, and is immutable once set.
                    "ResultDetails": "str",  # Optional. A string providing additional details
                      about the result of the repair task execution."nMay be specified in the Restoring
                      and later states, and is immutable once set.
                    "ResultStatus": "str",  # Optional. A value describing the overall result of
                      the repair task execution. Must be specified in the Restoring and later states,
                      and is immutable once set. Known values are: "Invalid", "Succeeded", "Cancelled",
                      "Interrupted", "Failed", "Pending".
                    "State": "str",  # Required. The workflow state of the repair task. Valid
                      initial states are Created, Claimed, and Preparing. Known values are: "Invalid",
                      "Created", "Claimed", "Preparing", "Approved", "Executing", "Restoring",
                      "Completed".
                    "Target": {
                        Kind: Kind
                    },
                    "TaskId": "str",  # Required. The ID of the repair task.
                    "Version": "str"  # Optional. The version of the repair task."nWhen creating
                      a new repair task, the version must be set to zero.  When updating a repair
                      task,"nthe version is used for optimistic concurrency checks.  If the version
                      is"nset to zero, the update will not check for write conflicts.  If the version
                      is set to a non-zero value, then the"nupdate will only succeed if the actual
                      current version of the repair task matches this value.
                }

                # response body for status code(s): 200
                response.json() == {
                    "Version": "str"  # Required. The new version of the repair task.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = repair_task

        request = build_update_repair_execution_state_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_replica_info_list(
        self,
        partition_id: str,
        *,
        continuation_token_parameter: Optional[str] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the information about replicas of a Service Fabric service partition.

        The GetReplicas endpoint returns information about the replicas of the specified partition. The
        response includes the ID, role, status, health, node name, uptime, and other details about the
        replica.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "Address": "str",  # Optional. The address the replica is
                              listening on.
                            "HealthState": "str",  # Optional. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "LastInBuildDurationInSeconds": "str",  # Optional. The last
                              in build duration of the replica in seconds.
                            "NodeName": "str",  # Optional. The name of a Service Fabric
                              node.
                            "ReplicaStatus": "str",  # Optional. The status of a replica
                              of a service. Known values are: "Invalid", "InBuild", "Standby", "Ready",
                              "Down", "Dropped".
                            ServiceKind: ServiceKind
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_replica_info_list_request(
            partition_id=partition_id,
            api_version=api_version,
            continuation_token_parameter=continuation_token_parameter,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_replica_info(
        self,
        partition_id: str,
        replica_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Gets the information about a replica of a Service Fabric partition.

        The response includes the ID, role, status, health, node name, uptime, and other details about
        the replica.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :param replica_id: The identifier of the replica.
        :type replica_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Address": "str",  # Optional. The address the replica is listening on.
                    "HealthState": "str",  # Optional. The health state of a Service Fabric
                      entity such as Cluster, Node, Application, Service, Partition, Replica etc. Known
                      values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "LastInBuildDurationInSeconds": "str",  # Optional. The last in build
                      duration of the replica in seconds.
                    "NodeName": "str",  # Optional. The name of a Service Fabric node.
                    "ReplicaStatus": "str",  # Optional. The status of a replica of a service.
                      Known values are: "Invalid", "InBuild", "Standby", "Ready", "Down", "Dropped".
                    ServiceKind: ServiceKind
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_get_replica_info_request(
            partition_id=partition_id,
            replica_id=replica_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get_replica_health(
        self,
        partition_id: str,
        replica_id: str,
        *,
        events_health_state_filter: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the health of a Service Fabric stateful service replica or stateless service instance.

        Gets the health of a Service Fabric replica.
        Use EventsHealthStateFilter to filter the collection of health events reported on the replica
        based on the health state.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :param replica_id: The identifier of the replica.
        :type replica_id: str
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "PartitionId": str,  # Optional. Id of the partition to which this replica
                      belongs.
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ],
                    ServiceKind: ReplicaHealth
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_replica_health_request(
            partition_id=partition_id,
            replica_id=replica_id,
            api_version=api_version,
            events_health_state_filter=events_health_state_filter,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_replica_health_using_policy(
        self,
        partition_id: str,
        replica_id: str,
        application_health_policy: Optional[JSON] = None,
        *,
        events_health_state_filter: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the health of a Service Fabric stateful service replica or stateless service instance
        using the specified policy.

        Gets the health of a Service Fabric stateful service replica or stateless service instance.
        Use EventsHealthStateFilter to filter the collection of health events reported on the cluster
        based on the health state.
        Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the
        health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The
        rest of the fields are ignored while evaluating the health of the replica.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :param replica_id: The identifier of the replica.
        :type replica_id: str
        :param application_health_policy: Describes the health policies used to evaluate the health of
         an application or one of its children.
         If not present, the health evaluation uses the health policy from application manifest or the
         default health policy. Default value is None.
        :type application_health_policy: JSON
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                application_health_policy = {
                    "ConsiderWarningAsError": bool,  # Optional. Indicates whether warnings are
                      treated with the same severity as errors.
                    "DefaultServiceTypeHealthPolicy": {
                        "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional. The
                          maximum allowed percentage of unhealthy partitions per service. Allowed
                          values are Byte values from zero to 100"n"nThe percentage represents the
                          maximum tolerated percentage of partitions that can be unhealthy before the
                          service is considered in error."nIf the percentage is respected but there is
                          at least one unhealthy partition, the health is evaluated as Warning."nThe
                          percentage is calculated by dividing the number of unhealthy partitions over
                          the total number of partitions in the service."nThe computation rounds up to
                          tolerate one failure on small numbers of partitions. Default percentage is
                          zero.
                        "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional. The
                          maximum allowed percentage of unhealthy replicas per partition. Allowed
                          values are Byte values from zero to 100."n"nThe percentage represents the
                          maximum tolerated percentage of replicas that can be unhealthy before the
                          partition is considered in error."nIf the percentage is respected but there
                          is at least one unhealthy replica, the health is evaluated as Warning."nThe
                          percentage is calculated by dividing the number of unhealthy replicas over
                          the total number of replicas in the partition."nThe computation rounds up to
                          tolerate one failure on small numbers of replicas. Default percentage is
                          zero.
                        "MaxPercentUnhealthyServices": 0  # Optional. The maximum allowed
                          percentage of unhealthy services. Allowed values are Byte values from zero to
                          100."n"nThe percentage represents the maximum tolerated percentage of
                          services that can be unhealthy before the application is considered in
                          error."nIf the percentage is respected but there is at least one unhealthy
                          service, the health is evaluated as Warning."nThis is calculated by dividing
                          the number of unhealthy services of the specific service type over the total
                          number of services of the specific service type."nThe computation rounds up
                          to tolerate one failure on small numbers of services. Default percentage is
                          zero.
                    },
                    "MaxPercentUnhealthyDeployedApplications": 0,  # Optional. The maximum
                      allowed percentage of unhealthy deployed applications. Allowed values are Byte
                      values from zero to 100."nThe percentage represents the maximum tolerated
                      percentage of deployed applications that can be unhealthy before the application
                      is considered in error."nThis is calculated by dividing the number of unhealthy
                      deployed applications over the number of nodes where the application is currently
                      deployed on in the cluster."nThe computation rounds up to tolerate one failure on
                      small numbers of nodes. Default percentage is zero.
                    "ServiceTypeHealthPolicyMap": [
                        {
                            "Key": "str",  # Required. The key of the service type health
                              policy map item. This is the name of the service type.
                            "Value": {
                                "MaxPercentUnhealthyPartitionsPerService": 0,  #
                                  Optional. The maximum allowed percentage of unhealthy partitions per
                                  service. Allowed values are Byte values from zero to 100"n"nThe
                                  percentage represents the maximum tolerated percentage of partitions
                                  that can be unhealthy before the service is considered in error."nIf
                                  the percentage is respected but there is at least one unhealthy
                                  partition, the health is evaluated as Warning."nThe percentage is
                                  calculated by dividing the number of unhealthy partitions over the
                                  total number of partitions in the service."nThe computation rounds up
                                  to tolerate one failure on small numbers of partitions. Default
                                  percentage is zero.
                                "MaxPercentUnhealthyReplicasPerPartition": 0,  #
                                  Optional. The maximum allowed percentage of unhealthy replicas per
                                  partition. Allowed values are Byte values from zero to 100."n"nThe
                                  percentage represents the maximum tolerated percentage of replicas
                                  that can be unhealthy before the partition is considered in
                                  error."nIf the percentage is respected but there is at least one
                                  unhealthy replica, the health is evaluated as Warning."nThe
                                  percentage is calculated by dividing the number of unhealthy replicas
                                  over the total number of replicas in the partition."nThe computation
                                  rounds up to tolerate one failure on small numbers of replicas.
                                  Default percentage is zero.
                                "MaxPercentUnhealthyServices": 0  # Optional. The
                                  maximum allowed percentage of unhealthy services. Allowed values are
                                  Byte values from zero to 100."n"nThe percentage represents the
                                  maximum tolerated percentage of services that can be unhealthy before
                                  the application is considered in error."nIf the percentage is
                                  respected but there is at least one unhealthy service, the health is
                                  evaluated as Warning."nThis is calculated by dividing the number of
                                  unhealthy services of the specific service type over the total number
                                  of services of the specific service type."nThe computation rounds up
                                  to tolerate one failure on small numbers of services. Default
                                  percentage is zero.
                            }
                        }
                    ]
                }

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "PartitionId": str,  # Optional. Id of the partition to which this replica
                      belongs.
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ],
                    ServiceKind: ReplicaHealth
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        if application_health_policy is not None:
            _json = application_health_policy
        else:
            _json = None

        request = build_get_replica_health_using_policy_request(
            partition_id=partition_id,
            replica_id=replica_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            events_health_state_filter=events_health_state_filter,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def report_replica_health(  # pylint: disable=inconsistent-return-statements
        self,
        partition_id: str,
        replica_id: str,
        health_information: JSON,
        *,
        service_kind: str = "Stateful",
        immediate: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Sends a health report on the Service Fabric replica.

        Reports health state of the specified Service Fabric replica. The report must contain the
        information about the source of the health report and property on which it is reported.
        The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
        The report may be accepted by the gateway, but rejected by the health store after extra
        validation.
        For example, the health store may reject the report because of an invalid parameter, like a
        stale sequence number.
        To see whether the report was applied in the health store, run GetReplicaHealth and check that
        the report appears in the HealthEvents section.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :param replica_id: The identifier of the replica.
        :type replica_id: str
        :param health_information: Describes the health information for the health report. This
         information needs to be present in all of the health reports sent to the health manager.
        :type health_information: JSON
        :keyword service_kind: The kind of service replica (Stateless or Stateful) for which the health
         is being reported. Following are the possible values. Known values are: "Stateless" or
         "Stateful". Default value is "Stateful".
        :paramtype service_kind: str
        :keyword immediate: A flag that indicates whether the report should be sent immediately.
         A health report is sent to a Service Fabric gateway Application, which forwards to the health
         store.
         If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
         store, regardless of the fabric client settings that the HTTP Gateway Application is using.
         This is useful for critical reports that should be sent as soon as possible.
         Depending on timing and other conditions, sending the report may still fail, for example if
         the HTTP Gateway is closed or the message doesn't reach the Gateway.
         If Immediate is set to false, the report is sent based on the health client settings from the
         HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
         configuration.
         This is the recommended setting because it allows the health client to optimize health
         reporting messages to health store as well as health report processing.
         By default, reports are not sent immediately. Default value is False.
        :paramtype immediate: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                health_information = {
                    "Description": "str",  # Optional. The description of the health information.
                      It represents free text used to add human readable information about the
                      report."nThe maximum string length for the description is 4096 characters."nIf
                      the provided string is longer, it will be automatically truncated."nWhen
                      truncated, the last characters of the description contain a marker "[Truncated]",
                      and total string size is 4096 characters."nThe presence of the marker indicates
                      to users that truncation occurred."nNote that when truncated, the description has
                      less than 4096 characters from the original string.
                    "HealthReportId": "str",  # Optional. A health report ID which identifies the
                      health report and can be used to find more detailed information about a specific
                      health event at"naka.ms/sfhealthid.
                    "HealthState": "str",  # Required. The health state of a Service Fabric
                      entity such as Cluster, Node, Application, Service, Partition, Replica etc. Known
                      values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "Property": "str",  # Required. The property of the health information. An
                      entity can have health reports for different properties."nThe property is a
                      string and not a fixed enumeration to allow the reporter flexibility to
                      categorize the state condition that triggers the report."nFor example, a reporter
                      with SourceId "LocalWatchdog" can monitor the state of the available disk on a
                      node,"nso it can report "AvailableDisk" property on that node."nThe same reporter
                      can monitor the node connectivity, so it can report a property "Connectivity" on
                      the same node."nIn the health store, these reports are treated as separate health
                      events for the specified node."n"nTogether with the SourceId, the property
                      uniquely identifies the health information.
                    "RemoveWhenExpired": bool,  # Optional. Value that indicates whether the
                      report is removed from health store when it expires."nIf set to true, the report
                      is removed from the health store after it expires."nIf set to false, the report
                      is treated as an error when expired. The value of this property is false by
                      default."nWhen clients report periodically, they should set RemoveWhenExpired
                      false (default)."nThis way, if the reporter has issues (e.g. deadlock) and can't
                      report, the entity is evaluated at error when the health report expires."nThis
                      flags the entity as being in Error health state.
                    "SequenceNumber": "str",  # Optional. The sequence number for this health
                      report as a numeric string."nThe report sequence number is used by the health
                      store to detect stale reports."nIf not specified, a sequence number is
                      auto-generated by the health client when a report is added.
                    "SourceId": "str",  # Required. The source name that identifies the
                      client/watchdog/system component that generated the health information.
                    "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The duration for
                      which this health report is valid. This field uses ISO8601 format for specifying
                      the duration."nWhen clients report periodically, they should send reports with
                      higher frequency than time to live."nIf clients report on transition, they can
                      set the time to live to infinite."nWhen time to live expires, the health event
                      that contains the health information"nis either removed from health store, if
                      RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                      false."n"nIf not specified, time to live defaults to infinite value.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = health_information

        request = build_report_replica_health_request(
            partition_id=partition_id,
            replica_id=replica_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            service_kind=service_kind,
            immediate=immediate,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_deployed_service_replica_info_list(
        self,
        node_name: str,
        application_id: str,
        *,
        partition_id: Optional[str] = None,
        service_manifest_name: Optional[str] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> Optional[List[JSON]]:
        """Gets the list of replicas deployed on a Service Fabric node.

        Gets the list containing the information about replicas deployed on a Service Fabric node. The
        information include partition ID, replica ID, status of the replica, name of the service, name
        of the service type, and other information. Use PartitionId or ServiceManifestName query
        parameters to return information about the deployed replicas matching the specified values for
        those parameters.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword partition_id: The identity of the partition. Default value is None.
        :paramtype partition_id: str
        :keyword service_manifest_name: The name of a service manifest registered as part of an
         application type in a Service Fabric cluster. Default value is None.
        :paramtype service_manifest_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON] or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "Address": "str",  # Optional. The last address returned by the
                          replica in Open or ChangeRole.
                        "CodePackageName": "str",  # Optional. The name of the code package
                          that hosts this replica.
                        "HostProcessId": "str",  # Optional. Host process ID of the process
                          that is hosting the replica. This will be zero if the replica is down. In
                          hyper-v containers this host process ID will be from different kernel.
                        "PartitionId": str,  # Optional. An internal ID used by Service
                          Fabric to uniquely identify a partition. This is a randomly generated GUID
                          when the service was created. The partition ID is unique and does not change
                          for the lifetime of the service. If the same service was deleted and
                          recreated the IDs of its partitions would be different.
                        "ReplicaStatus": "str",  # Optional. The status of a replica of a
                          service. Known values are: "Invalid", "InBuild", "Standby", "Ready", "Down",
                          "Dropped".
                        "ServiceManifestName": "str",  # Optional. The name of the service
                          manifest in which this service type is defined.
                        "ServiceName": "str",  # Optional. The full name of the service with
                          'fabric:' URI scheme.
                        "ServicePackageActivationId": "str",  # Optional. The ActivationId of
                          a deployed service package. If ServicePackageActivationMode specified at the
                          time of creating the service"nis 'SharedProcess' (or if it is not specified,
                          in which case it defaults to 'SharedProcess'), then value of
                          ServicePackageActivationId"nis always an empty string.
                        "ServiceTypeName": "str",  # Optional. Name of the service type as
                          specified in the service manifest.
                        ServiceKind: ServiceKind
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[List[JSON]]]

        
        request = build_get_deployed_service_replica_info_list_request(
            node_name=node_name,
            application_id=application_id,
            api_version=api_version,
            partition_id=partition_id,
            service_manifest_name=service_manifest_name,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get_deployed_service_replica_detail_info(
        self,
        node_name: str,
        partition_id: str,
        replica_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the details of replica deployed on a Service Fabric node.

        Gets the details of the replica deployed on a Service Fabric node. The information includes
        service kind, service name, current service operation, current service operation start date
        time, partition ID, replica/instance ID, reported load, and other information.

        :param node_name: The name of the node.
        :type node_name: str
        :param partition_id: The identity of the partition.
        :type partition_id: str
        :param replica_id: The identifier of the replica.
        :type replica_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "CurrentServiceOperation": "str",  # Optional. Specifies the current active
                      life-cycle operation on a stateful service replica or stateless service instance.
                      Known values are: "Unknown", "None", "Open", "ChangeRole", "Close", "Abort".
                    "CurrentServiceOperationStartTimeUtc": "2020-02-20 00:00:00",  # Optional.
                      The start time of the current service operation in UTC format.
                    "PartitionId": str,  # Optional. An internal ID used by Service Fabric to
                      uniquely identify a partition. This is a randomly generated GUID when the service
                      was created. The partition ID is unique and does not change for the lifetime of
                      the service. If the same service was deleted and recreated the IDs of its
                      partitions would be different.
                    "ReportedLoad": [
                        {
                            "CurrentValue": "str",  # Optional. The double value of the
                              load for the metric.
                            "LastReportedUtc": "2020-02-20 00:00:00",  # Optional. The
                              UTC time when the load is reported.
                            "Name": "str",  # Optional. The name of the metric.
                            "Value": 0  # Optional. The value of the load for the metric.
                              In future releases of Service Fabric this parameter will be deprecated in
                              favor of CurrentValue.
                        }
                    ],
                    "ServiceName": "str",  # Optional. Full hierarchical name of the service in
                      URI format starting with ``fabric:``.
                    ServiceKind: ServiceKind
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_deployed_service_replica_detail_info_request(
            node_name=node_name,
            partition_id=partition_id,
            replica_id=replica_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_deployed_service_replica_detail_info_by_partition_id(
        self,
        node_name: str,
        partition_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the details of replica deployed on a Service Fabric node.

        Gets the details of the replica deployed on a Service Fabric node. The information includes
        service kind, service name, current service operation, current service operation start date
        time, partition ID, replica/instance ID, reported load, and other information.

        :param node_name: The name of the node.
        :type node_name: str
        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "CurrentServiceOperation": "str",  # Optional. Specifies the current active
                      life-cycle operation on a stateful service replica or stateless service instance.
                      Known values are: "Unknown", "None", "Open", "ChangeRole", "Close", "Abort".
                    "CurrentServiceOperationStartTimeUtc": "2020-02-20 00:00:00",  # Optional.
                      The start time of the current service operation in UTC format.
                    "PartitionId": str,  # Optional. An internal ID used by Service Fabric to
                      uniquely identify a partition. This is a randomly generated GUID when the service
                      was created. The partition ID is unique and does not change for the lifetime of
                      the service. If the same service was deleted and recreated the IDs of its
                      partitions would be different.
                    "ReportedLoad": [
                        {
                            "CurrentValue": "str",  # Optional. The double value of the
                              load for the metric.
                            "LastReportedUtc": "2020-02-20 00:00:00",  # Optional. The
                              UTC time when the load is reported.
                            "Name": "str",  # Optional. The name of the metric.
                            "Value": 0  # Optional. The value of the load for the metric.
                              In future releases of Service Fabric this parameter will be deprecated in
                              favor of CurrentValue.
                        }
                    ],
                    "ServiceName": "str",  # Optional. Full hierarchical name of the service in
                      URI format starting with ``fabric:``.
                    ServiceKind: ServiceKind
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_deployed_service_replica_detail_info_by_partition_id_request(
            node_name=node_name,
            partition_id=partition_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def restart_replica(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        partition_id: str,
        replica_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Restarts a service replica of a persisted service running on a node.

        Restarts a service replica of a persisted service running on a node. Warning - There are no
        safety checks performed when this API is used. Incorrect use of this API can lead to
        availability loss for stateful services.

        :param node_name: The name of the node.
        :type node_name: str
        :param partition_id: The identity of the partition.
        :type partition_id: str
        :param replica_id: The identifier of the replica.
        :type replica_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_restart_replica_request(
            node_name=node_name,
            partition_id=partition_id,
            replica_id=replica_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def remove_replica(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        partition_id: str,
        replica_id: str,
        *,
        force_remove: Optional[bool] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Removes a service replica running on a node.

        This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric
        cluster. The removal closes the replica, transitions the replica to the role None, and then
        removes all of the state information of the replica from the cluster. This API tests the
        replica state removal path, and simulates the report fault permanent path through client APIs.
        Warning - There are no safety checks performed when this API is used. Incorrect use of this API
        can lead to data loss for stateful services. In addition, the forceRemove flag impacts all
        other replicas hosted in the same process.

        :param node_name: The name of the node.
        :type node_name: str
        :param partition_id: The identity of the partition.
        :type partition_id: str
        :param replica_id: The identifier of the replica.
        :type replica_id: str
        :keyword force_remove: Remove a Service Fabric application or service forcefully without going
         through the graceful shutdown sequence. This parameter can be used to forcefully delete an
         application or service for which delete is timing out due to issues in the service code that
         prevents graceful close of replicas. Default value is None.
        :paramtype force_remove: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_remove_replica_request(
            node_name=node_name,
            partition_id=partition_id,
            replica_id=replica_id,
            api_version=api_version,
            force_remove=force_remove,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_deployed_service_package_info_list(
        self,
        node_name: str,
        application_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets the list of service packages deployed on a Service Fabric node.

        Returns the information about the service packages deployed on a Service Fabric node for the
        given application.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "Name": "str",  # Optional. The name of the service package as
                          specified in the service manifest.
                        "ServicePackageActivationId": "str",  # Optional. The ActivationId of
                          a deployed service package. If ServicePackageActivationMode specified at the
                          time of creating the service"nis 'SharedProcess' (or if it is not specified,
                          in which case it defaults to 'SharedProcess'), then value of
                          ServicePackageActivationId"nis always an empty string.
                        "Status": "str",  # Optional. Specifies the status of a deployed
                          application or service package on a Service Fabric node. Known values are:
                          "Invalid", "Downloading", "Activating", "Active", "Upgrading",
                          "Deactivating", "RanToCompletion", "Failed".
                        "Version": "str"  # Optional. The version of the service package
                          specified in service manifest.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_deployed_service_package_info_list_request(
            node_name=node_name,
            application_id=application_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_deployed_service_package_info_list_by_name(
        self,
        node_name: str,
        application_id: str,
        service_package_name: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> Optional[List[JSON]]:
        """Gets the list of service packages deployed on a Service Fabric node matching exactly the
        specified name.

        Returns the information about the service packages deployed on a Service Fabric node for the
        given application. These results are of service packages whose name match exactly the service
        package name specified as the parameter.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param service_package_name: The name of the service package.
        :type service_package_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON] or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "Name": "str",  # Optional. The name of the service package as
                          specified in the service manifest.
                        "ServicePackageActivationId": "str",  # Optional. The ActivationId of
                          a deployed service package. If ServicePackageActivationMode specified at the
                          time of creating the service"nis 'SharedProcess' (or if it is not specified,
                          in which case it defaults to 'SharedProcess'), then value of
                          ServicePackageActivationId"nis always an empty string.
                        "Status": "str",  # Optional. Specifies the status of a deployed
                          application or service package on a Service Fabric node. Known values are:
                          "Invalid", "Downloading", "Activating", "Active", "Upgrading",
                          "Deactivating", "RanToCompletion", "Failed".
                        "Version": "str"  # Optional. The version of the service package
                          specified in service manifest.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[List[JSON]]]

        
        request = build_get_deployed_service_package_info_list_by_name_request(
            node_name=node_name,
            application_id=application_id,
            service_package_name=service_package_name,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get_deployed_service_package_health(
        self,
        node_name: str,
        application_id: str,
        service_package_name: str,
        *,
        events_health_state_filter: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the information about health of a service package for a specific application deployed for
        a Service Fabric node and application.

        Gets the information about health of a service package for a specific application deployed on a
        Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of
        HealthEvent objects reported on the deployed service package based on health state.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param service_package_name: The name of the service package.
        :type service_package_name: str
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "ApplicationName": "str",  # Optional. The name of the application, including
                      the 'fabric:' URI scheme.
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "NodeName": "str",  # Optional. Name of the node where this service package
                      is deployed.
                    "ServiceManifestName": "str",  # Optional. Name of the service manifest.
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_deployed_service_package_health_request(
            node_name=node_name,
            application_id=application_id,
            service_package_name=service_package_name,
            api_version=api_version,
            events_health_state_filter=events_health_state_filter,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_deployed_service_package_health_using_policy(
        self,
        node_name: str,
        application_id: str,
        service_package_name: str,
        application_health_policy: Optional[JSON] = None,
        *,
        events_health_state_filter: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the information about health of service package for a specific application deployed on a
        Service Fabric node using the specified policy.

        Gets the information about health of a service package for a specific application deployed on a
        Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally
        filter for the collection of HealthEvent objects reported on the deployed service package based
        on health state. Use ApplicationHealthPolicy to optionally override the health policies used to
        evaluate the health. This API only uses 'ConsiderWarningAsError' field of the
        ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the
        deployed service package.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param service_package_name: The name of the service package.
        :type service_package_name: str
        :param application_health_policy: Describes the health policies used to evaluate the health of
         an application or one of its children.
         If not present, the health evaluation uses the health policy from application manifest or the
         default health policy. Default value is None.
        :type application_health_policy: JSON
        :keyword events_health_state_filter: Allows filtering the collection of HealthEvent objects
         returned based on health state.
         The possible values for this parameter include integer value of one of the following health
         states.
         Only events that match the filter are returned. All events are used to evaluate the aggregated
         health state.
         If not specified, all entries are returned. The state values are flag-based enumeration, so
         the value could be a combination of these values, obtained using the bitwise 'OR' operator. For
         example, If the provided value is 6 then all of the events with HealthState value of OK (2) and
         Warning (4) are returned.


         * Default - Default value. Matches any HealthState. The value is zero.
         * None - Filter that doesn't match any HealthState value. Used in order to return no results
         on a given collection of states. The value is 1.
         * Ok - Filter that matches input with HealthState value Ok. The value is 2.
         * Warning - Filter that matches input with HealthState value Warning. The value is 4.
         * Error - Filter that matches input with HealthState value Error. The value is 8.
         * All - Filter that matches input with any HealthState value. The value is 65535. Default
         value is 0.
        :paramtype events_health_state_filter: int
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                application_health_policy = {
                    "ConsiderWarningAsError": bool,  # Optional. Indicates whether warnings are
                      treated with the same severity as errors.
                    "DefaultServiceTypeHealthPolicy": {
                        "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional. The
                          maximum allowed percentage of unhealthy partitions per service. Allowed
                          values are Byte values from zero to 100"n"nThe percentage represents the
                          maximum tolerated percentage of partitions that can be unhealthy before the
                          service is considered in error."nIf the percentage is respected but there is
                          at least one unhealthy partition, the health is evaluated as Warning."nThe
                          percentage is calculated by dividing the number of unhealthy partitions over
                          the total number of partitions in the service."nThe computation rounds up to
                          tolerate one failure on small numbers of partitions. Default percentage is
                          zero.
                        "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional. The
                          maximum allowed percentage of unhealthy replicas per partition. Allowed
                          values are Byte values from zero to 100."n"nThe percentage represents the
                          maximum tolerated percentage of replicas that can be unhealthy before the
                          partition is considered in error."nIf the percentage is respected but there
                          is at least one unhealthy replica, the health is evaluated as Warning."nThe
                          percentage is calculated by dividing the number of unhealthy replicas over
                          the total number of replicas in the partition."nThe computation rounds up to
                          tolerate one failure on small numbers of replicas. Default percentage is
                          zero.
                        "MaxPercentUnhealthyServices": 0  # Optional. The maximum allowed
                          percentage of unhealthy services. Allowed values are Byte values from zero to
                          100."n"nThe percentage represents the maximum tolerated percentage of
                          services that can be unhealthy before the application is considered in
                          error."nIf the percentage is respected but there is at least one unhealthy
                          service, the health is evaluated as Warning."nThis is calculated by dividing
                          the number of unhealthy services of the specific service type over the total
                          number of services of the specific service type."nThe computation rounds up
                          to tolerate one failure on small numbers of services. Default percentage is
                          zero.
                    },
                    "MaxPercentUnhealthyDeployedApplications": 0,  # Optional. The maximum
                      allowed percentage of unhealthy deployed applications. Allowed values are Byte
                      values from zero to 100."nThe percentage represents the maximum tolerated
                      percentage of deployed applications that can be unhealthy before the application
                      is considered in error."nThis is calculated by dividing the number of unhealthy
                      deployed applications over the number of nodes where the application is currently
                      deployed on in the cluster."nThe computation rounds up to tolerate one failure on
                      small numbers of nodes. Default percentage is zero.
                    "ServiceTypeHealthPolicyMap": [
                        {
                            "Key": "str",  # Required. The key of the service type health
                              policy map item. This is the name of the service type.
                            "Value": {
                                "MaxPercentUnhealthyPartitionsPerService": 0,  #
                                  Optional. The maximum allowed percentage of unhealthy partitions per
                                  service. Allowed values are Byte values from zero to 100"n"nThe
                                  percentage represents the maximum tolerated percentage of partitions
                                  that can be unhealthy before the service is considered in error."nIf
                                  the percentage is respected but there is at least one unhealthy
                                  partition, the health is evaluated as Warning."nThe percentage is
                                  calculated by dividing the number of unhealthy partitions over the
                                  total number of partitions in the service."nThe computation rounds up
                                  to tolerate one failure on small numbers of partitions. Default
                                  percentage is zero.
                                "MaxPercentUnhealthyReplicasPerPartition": 0,  #
                                  Optional. The maximum allowed percentage of unhealthy replicas per
                                  partition. Allowed values are Byte values from zero to 100."n"nThe
                                  percentage represents the maximum tolerated percentage of replicas
                                  that can be unhealthy before the partition is considered in
                                  error."nIf the percentage is respected but there is at least one
                                  unhealthy replica, the health is evaluated as Warning."nThe
                                  percentage is calculated by dividing the number of unhealthy replicas
                                  over the total number of replicas in the partition."nThe computation
                                  rounds up to tolerate one failure on small numbers of replicas.
                                  Default percentage is zero.
                                "MaxPercentUnhealthyServices": 0  # Optional. The
                                  maximum allowed percentage of unhealthy services. Allowed values are
                                  Byte values from zero to 100."n"nThe percentage represents the
                                  maximum tolerated percentage of services that can be unhealthy before
                                  the application is considered in error."nIf the percentage is
                                  respected but there is at least one unhealthy service, the health is
                                  evaluated as Warning."nThis is calculated by dividing the number of
                                  unhealthy services of the specific service type over the total number
                                  of services of the specific service type."nThe computation rounds up
                                  to tolerate one failure on small numbers of services. Default
                                  percentage is zero.
                            }
                        }
                    ]
                }

                # response body for status code(s): 200
                response.json() == {
                    "AggregatedHealthState": "str",  # Optional. The HealthState representing the
                      aggregated health state of the entity computed by Health Manager."nThe health
                      evaluation of the entity reflects all events reported on the entity and its
                      children (if any)."nThe aggregation is done by applying the desired health
                      policy. Known values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "ApplicationName": "str",  # Optional. The name of the application, including
                      the 'fabric:' URI scheme.
                    "HealthEvents": [
                        {
                            "Description": "str",  # Optional. The description of the
                              health information. It represents free text used to add human readable
                              information about the report."nThe maximum string length for the
                              description is 4096 characters."nIf the provided string is longer, it
                              will be automatically truncated."nWhen truncated, the last characters of
                              the description contain a marker "[Truncated]", and total string size is
                              4096 characters."nThe presence of the marker indicates to users that
                              truncation occurred."nNote that when truncated, the description has less
                              than 4096 characters from the original string.
                            "HealthReportId": "str",  # Optional. A health report ID
                              which identifies the health report and can be used to find more detailed
                              information about a specific health event at"naka.ms/sfhealthid.
                            "HealthState": "str",  # Required. The health state of a
                              Service Fabric entity such as Cluster, Node, Application, Service,
                              Partition, Replica etc. Known values are: "Invalid", "Ok", "Warning",
                              "Error", "Unknown".
                            "IsExpired": bool,  # Optional. Returns true if the health
                              event is expired, otherwise false.
                            "LastErrorTransitionAt": "2020-02-20 00:00:00",  # Optional.
                              If the current health state is 'Error', this property returns the time at
                              which the health report was first reported with 'Error'. For periodic
                              reporting, many reports with the same state may have been generated
                              however, this property returns only the date and time at the first
                              'Error' health report was received."n"nIf the current health state is
                              'Ok' or 'Warning', returns the date and time at which the health state
                              was last in 'Error', before transitioning to a different state."n"nIf the
                              health state was never 'Error', the value will be zero date-time.
                            "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                              Optional. The date and time when the health report was last modified by
                              the health store.
                            "LastOkTransitionAt": "2020-02-20 00:00:00",  # Optional. If
                              the current health state is 'Ok', this property returns the time at which
                              the health report was first reported with 'Ok'."nFor periodic reporting,
                              many reports with the same state may have been generated."nThis property
                              returns the date and time when the first 'Ok' health report was
                              received."n"nIf the current health state is 'Error' or 'Warning', returns
                              the date and time at which the health state was last in 'Ok', before
                              transitioning to a different state."n"nIf the health state was never
                              'Ok', the value will be zero date-time.
                            "LastWarningTransitionAt": "2020-02-20 00:00:00",  #
                              Optional. If the current health state is 'Warning', this property returns
                              the time at which the health report was first reported with 'Warning'.
                              For periodic reporting, many reports with the same state may have been
                              generated however, this property returns only the date and time at the
                              first 'Warning' health report was received."n"nIf the current health
                              state is 'Ok' or 'Error', returns the date and time at which the health
                              state was last in 'Warning', before transitioning to a different
                              state."n"nIf the health state was never 'Warning', the value will be zero
                              date-time.
                            "Property": "str",  # Required. The property of the health
                              information. An entity can have health reports for different
                              properties."nThe property is a string and not a fixed enumeration to
                              allow the reporter flexibility to categorize the state condition that
                              triggers the report."nFor example, a reporter with SourceId
                              "LocalWatchdog" can monitor the state of the available disk on a
                              node,"nso it can report "AvailableDisk" property on that node."nThe same
                              reporter can monitor the node connectivity, so it can report a property
                              "Connectivity" on the same node."nIn the health store, these reports are
                              treated as separate health events for the specified node."n"nTogether
                              with the SourceId, the property uniquely identifies the health
                              information.
                            "RemoveWhenExpired": bool,  # Optional. Value that indicates
                              whether the report is removed from health store when it expires."nIf set
                              to true, the report is removed from the health store after it
                              expires."nIf set to false, the report is treated as an error when
                              expired. The value of this property is false by default."nWhen clients
                              report periodically, they should set RemoveWhenExpired false
                              (default)."nThis way, if the reporter has issues (e.g. deadlock) and
                              can't report, the entity is evaluated at error when the health report
                              expires."nThis flags the entity as being in Error health state.
                            "SequenceNumber": "str",  # Optional. The sequence number for
                              this health report as a numeric string."nThe report sequence number is
                              used by the health store to detect stale reports."nIf not specified, a
                              sequence number is auto-generated by the health client when a report is
                              added.
                            "SourceId": "str",  # Required. The source name that
                              identifies the client/watchdog/system component that generated the health
                              information.
                            "SourceUtcTimestamp": "2020-02-20 00:00:00",  # Optional. The
                              date and time when the health report was sent by the source.
                            "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The
                              duration for which this health report is valid. This field uses ISO8601
                              format for specifying the duration."nWhen clients report periodically,
                              they should send reports with higher frequency than time to live."nIf
                              clients report on transition, they can set the time to live to
                              infinite."nWhen time to live expires, the health event that contains the
                              health information"nis either removed from health store, if
                              RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                              false."n"nIf not specified, time to live defaults to infinite value.
                        }
                    ],
                    "HealthStatistics": {
                        "HealthStateCountList": [
                            {
                                "EntityKind": "str",  # Optional. The entity kind for
                                  which health states are evaluated. Known values are: "Invalid",
                                  "Node", "Partition", "Service", "Application", "Replica",
                                  "DeployedApplication", "DeployedServicePackage", "Cluster".
                                "HealthStateCount": {
                                    "ErrorCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Error.
                                    "OkCount": 0.0,  # Optional. The number of
                                      health entities with aggregated health state Ok.
                                    "WarningCount": 0.0  # Optional. The number
                                      of health entities with aggregated health state Warning.
                                }
                            }
                        ]
                    },
                    "NodeName": "str",  # Optional. Name of the node where this service package
                      is deployed.
                    "ServiceManifestName": "str",  # Optional. Name of the service manifest.
                    "UnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        if application_health_policy is not None:
            _json = application_health_policy
        else:
            _json = None

        request = build_get_deployed_service_package_health_using_policy_request(
            node_name=node_name,
            application_id=application_id,
            service_package_name=service_package_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            events_health_state_filter=events_health_state_filter,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def report_deployed_service_package_health(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        application_id: str,
        service_package_name: str,
        health_information: JSON,
        *,
        immediate: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Sends a health report on the Service Fabric deployed service package.

        Reports health state of the service package of the application deployed on a Service Fabric
        node. The report must contain the information about the source of the health report and
        property on which it is reported.
        The report is sent to a Service Fabric gateway Service, which forwards to the health store.
        The report may be accepted by the gateway, but rejected by the health store after extra
        validation.
        For example, the health store may reject the report because of an invalid parameter, like a
        stale sequence number.
        To see whether the report was applied in the health store, get deployed service package health
        and check that the report appears in the HealthEvents section.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param service_package_name: The name of the service package.
        :type service_package_name: str
        :param health_information: Describes the health information for the health report. This
         information needs to be present in all of the health reports sent to the health manager.
        :type health_information: JSON
        :keyword immediate: A flag that indicates whether the report should be sent immediately.
         A health report is sent to a Service Fabric gateway Application, which forwards to the health
         store.
         If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
         store, regardless of the fabric client settings that the HTTP Gateway Application is using.
         This is useful for critical reports that should be sent as soon as possible.
         Depending on timing and other conditions, sending the report may still fail, for example if
         the HTTP Gateway is closed or the message doesn't reach the Gateway.
         If Immediate is set to false, the report is sent based on the health client settings from the
         HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
         configuration.
         This is the recommended setting because it allows the health client to optimize health
         reporting messages to health store as well as health report processing.
         By default, reports are not sent immediately. Default value is False.
        :paramtype immediate: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                health_information = {
                    "Description": "str",  # Optional. The description of the health information.
                      It represents free text used to add human readable information about the
                      report."nThe maximum string length for the description is 4096 characters."nIf
                      the provided string is longer, it will be automatically truncated."nWhen
                      truncated, the last characters of the description contain a marker "[Truncated]",
                      and total string size is 4096 characters."nThe presence of the marker indicates
                      to users that truncation occurred."nNote that when truncated, the description has
                      less than 4096 characters from the original string.
                    "HealthReportId": "str",  # Optional. A health report ID which identifies the
                      health report and can be used to find more detailed information about a specific
                      health event at"naka.ms/sfhealthid.
                    "HealthState": "str",  # Required. The health state of a Service Fabric
                      entity such as Cluster, Node, Application, Service, Partition, Replica etc. Known
                      values are: "Invalid", "Ok", "Warning", "Error", "Unknown".
                    "Property": "str",  # Required. The property of the health information. An
                      entity can have health reports for different properties."nThe property is a
                      string and not a fixed enumeration to allow the reporter flexibility to
                      categorize the state condition that triggers the report."nFor example, a reporter
                      with SourceId "LocalWatchdog" can monitor the state of the available disk on a
                      node,"nso it can report "AvailableDisk" property on that node."nThe same reporter
                      can monitor the node connectivity, so it can report a property "Connectivity" on
                      the same node."nIn the health store, these reports are treated as separate health
                      events for the specified node."n"nTogether with the SourceId, the property
                      uniquely identifies the health information.
                    "RemoveWhenExpired": bool,  # Optional. Value that indicates whether the
                      report is removed from health store when it expires."nIf set to true, the report
                      is removed from the health store after it expires."nIf set to false, the report
                      is treated as an error when expired. The value of this property is false by
                      default."nWhen clients report periodically, they should set RemoveWhenExpired
                      false (default)."nThis way, if the reporter has issues (e.g. deadlock) and can't
                      report, the entity is evaluated at error when the health report expires."nThis
                      flags the entity as being in Error health state.
                    "SequenceNumber": "str",  # Optional. The sequence number for this health
                      report as a numeric string."nThe report sequence number is used by the health
                      store to detect stale reports."nIf not specified, a sequence number is
                      auto-generated by the health client when a report is added.
                    "SourceId": "str",  # Required. The source name that identifies the
                      client/watchdog/system component that generated the health information.
                    "TimeToLiveInMilliSeconds": "1 day, 0:00:00"  # Optional. The duration for
                      which this health report is valid. This field uses ISO8601 format for specifying
                      the duration."nWhen clients report periodically, they should send reports with
                      higher frequency than time to live."nIf clients report on transition, they can
                      set the time to live to infinite."nWhen time to live expires, the health event
                      that contains the health information"nis either removed from health store, if
                      RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired
                      false."n"nIf not specified, time to live defaults to infinite value.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = health_information

        request = build_report_deployed_service_package_health_request(
            node_name=node_name,
            application_id=application_id,
            service_package_name=service_package_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            immediate=immediate,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def deploy_service_package_to_node(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        deploy_service_package_to_node_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Downloads all of the code packages associated with specified service manifest on the specified
        node.

        This API provides a way to download code packages including the container images on a specific
        node outside of the normal application deployment and upgrade path. This is useful for the
        large code packages and container images to be present on the node before the actual
        application deployment and upgrade, thus significantly reducing the total time required for the
        deployment or upgrade.

        :param node_name: The name of the node.
        :type node_name: str
        :param deploy_service_package_to_node_description: Describes information for deploying a
         service package to a Service Fabric node.
        :type deploy_service_package_to_node_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                deploy_service_package_to_node_description = {
                    "ApplicationTypeName": "str",  # Required. The application type name as
                      defined in the application manifest.
                    "ApplicationTypeVersion": "str",  # Required. The version of the application
                      type as defined in the application manifest.
                    "NodeName": "str",  # Required. The name of a Service Fabric node.
                    "PackageSharingPolicy": [
                        {
                            "PackageSharingScope": "str",  # Optional. Represents the
                              scope for PackageSharingPolicy. This is specified during
                              DeployServicePackageToNode operation. Known values are: "None", "All",
                              "Code", "Config", "Data".
                            "SharedPackageName": "str"  # Optional. The name of code,
                              configuration or data package that should be shared.
                        }
                    ],
                    "ServiceManifestName": "str"  # Required. The name of service manifest whose
                      packages need to be downloaded.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = deploy_service_package_to_node_description

        request = build_deploy_service_package_to_node_request(
            node_name=node_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_deployed_code_package_info_list(
        self,
        node_name: str,
        application_id: str,
        *,
        service_manifest_name: Optional[str] = None,
        code_package_name: Optional[str] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets the list of code packages deployed on a Service Fabric node.

        Gets the list of code packages deployed on a Service Fabric node for the given application.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword service_manifest_name: The name of a service manifest registered as part of an
         application type in a Service Fabric cluster. Default value is None.
        :paramtype service_manifest_name: str
        :keyword code_package_name: The name of code package specified in service manifest registered
         as part of an application type in a Service Fabric cluster. Default value is None.
        :paramtype code_package_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "HostIsolationMode": "str",  # Optional. Specifies the isolation mode
                          of main entry point of a code package when it's host type is ContainerHost.
                          This is specified as part of container host policies in application manifest
                          while importing service manifest. Known values are: "None", "Process",
                          "HyperV".
                        "HostType": "str",  # Optional. Specifies the type of host for main
                          entry point of a code package as specified in service manifest. Known values
                          are: "Invalid", "ExeHost", "ContainerHost".
                        "MainEntryPoint": {
                            "CodePackageEntryPointStatistics": {
                                "ActivationCount": "str",  # Optional. Number of
                                  times the entry point has run.
                                "ActivationFailureCount": "str",  # Optional. Number
                                  of times the entry point failed to run.
                                "ContinuousActivationFailureCount": "str",  #
                                  Optional. Number of times the entry point continuously failed to run.
                                "ContinuousExitFailureCount": "str",  # Optional.
                                  Number of times the entry point continuously failed to exit
                                  gracefully.
                                "ExitCount": "str",  # Optional. Number of times the
                                  entry point finished running.
                                "ExitFailureCount": "str",  # Optional. Number of
                                  times the entry point failed to exit gracefully.
                                "LastActivationTime": "2020-02-20 00:00:00",  #
                                  Optional. The last time (in UTC) when Service Fabric attempted to run
                                  the entry point.
                                "LastExitCode": "str",  # Optional. The last exit
                                  code of the entry point.
                                "LastExitTime": "2020-02-20 00:00:00",  # Optional.
                                  The last time (in UTC) when the entry point finished running.
                                "LastSuccessfulActivationTime": "2020-02-20
                                  00:00:00",  # Optional. The last time (in UTC) when the entry point
                                  ran successfully.
                                "LastSuccessfulExitTime": "2020-02-20 00:00:00"  #
                                  Optional. The last time (in UTC) when the entry point finished
                                  running gracefully.
                            },
                            "ContainerId": "str",  # Optional. The container ID of the
                              entry point. Only valid for container hosts.
                            "EntryPointLocation": "str",  # Optional. The location of
                              entry point executable on the node.
                            "InstanceId": "str",  # Optional. The instance ID for current
                              running entry point. For a code package setup entry point (if specified)
                              runs first and after it finishes main entry point is started. Each time
                              entry point executable is run, its instance id will change.
                            "NextActivationTime": "2020-02-20 00:00:00",  # Optional. The
                              time (in UTC) when the entry point executable will be run next.
                            "ProcessId": "str",  # Optional. The process ID of the entry
                              point.
                            "RunAsUserName": "str",  # Optional. The user name under
                              which entry point executable is run on the node.
                            "Status": "str"  # Optional. Specifies the status of the code
                              package entry point deployed on a Service Fabric node. Known values are:
                              "Invalid", "Pending", "Starting", "Started", "Stopping", "Stopped".
                        },
                        "Name": "str",  # Optional. The name of the code package.
                        "RunFrequencyInterval": "str",  # Optional. The interval at which
                          code package is run. This is used for periodic code package.
                        "ServiceManifestName": "str",  # Optional. The name of service
                          manifest that specified this code package.
                        "ServicePackageActivationId": "str",  # Optional. The ActivationId of
                          a deployed service package. If ServicePackageActivationMode specified at the
                          time of creating the service"nis 'SharedProcess' (or if it is not specified,
                          in which case it defaults to 'SharedProcess'), then value of
                          ServicePackageActivationId"nis always an empty string.
                        "SetupEntryPoint": {
                            "CodePackageEntryPointStatistics": {
                                "ActivationCount": "str",  # Optional. Number of
                                  times the entry point has run.
                                "ActivationFailureCount": "str",  # Optional. Number
                                  of times the entry point failed to run.
                                "ContinuousActivationFailureCount": "str",  #
                                  Optional. Number of times the entry point continuously failed to run.
                                "ContinuousExitFailureCount": "str",  # Optional.
                                  Number of times the entry point continuously failed to exit
                                  gracefully.
                                "ExitCount": "str",  # Optional. Number of times the
                                  entry point finished running.
                                "ExitFailureCount": "str",  # Optional. Number of
                                  times the entry point failed to exit gracefully.
                                "LastActivationTime": "2020-02-20 00:00:00",  #
                                  Optional. The last time (in UTC) when Service Fabric attempted to run
                                  the entry point.
                                "LastExitCode": "str",  # Optional. The last exit
                                  code of the entry point.
                                "LastExitTime": "2020-02-20 00:00:00",  # Optional.
                                  The last time (in UTC) when the entry point finished running.
                                "LastSuccessfulActivationTime": "2020-02-20
                                  00:00:00",  # Optional. The last time (in UTC) when the entry point
                                  ran successfully.
                                "LastSuccessfulExitTime": "2020-02-20 00:00:00"  #
                                  Optional. The last time (in UTC) when the entry point finished
                                  running gracefully.
                            },
                            "ContainerId": "str",  # Optional. The container ID of the
                              entry point. Only valid for container hosts.
                            "EntryPointLocation": "str",  # Optional. The location of
                              entry point executable on the node.
                            "InstanceId": "str",  # Optional. The instance ID for current
                              running entry point. For a code package setup entry point (if specified)
                              runs first and after it finishes main entry point is started. Each time
                              entry point executable is run, its instance id will change.
                            "NextActivationTime": "2020-02-20 00:00:00",  # Optional. The
                              time (in UTC) when the entry point executable will be run next.
                            "ProcessId": "str",  # Optional. The process ID of the entry
                              point.
                            "RunAsUserName": "str",  # Optional. The user name under
                              which entry point executable is run on the node.
                            "Status": "str"  # Optional. Specifies the status of the code
                              package entry point deployed on a Service Fabric node. Known values are:
                              "Invalid", "Pending", "Starting", "Started", "Stopping", "Stopped".
                        },
                        "Status": "str",  # Optional. Specifies the status of a deployed
                          application or service package on a Service Fabric node. Known values are:
                          "Invalid", "Downloading", "Activating", "Active", "Upgrading",
                          "Deactivating", "RanToCompletion", "Failed".
                        "Version": "str"  # Optional. The version of the code package
                          specified in service manifest.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_deployed_code_package_info_list_request(
            node_name=node_name,
            application_id=application_id,
            api_version=api_version,
            service_manifest_name=service_manifest_name,
            code_package_name=code_package_name,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def restart_deployed_code_package(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        application_id: str,
        restart_deployed_code_package_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Restarts a code package deployed on a Service Fabric node in a cluster.

        Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code
        package process, which will restart all the user service replicas hosted in that process.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param restart_deployed_code_package_description: Describes the deployed code package on
         Service Fabric node to restart.
        :type restart_deployed_code_package_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                restart_deployed_code_package_description = {
                    "CodePackageInstanceId": "str",  # Required. The instance ID for currently
                      running entry point. For a code package setup entry point (if specified) runs
                      first and after it finishes main entry point is started."nEach time entry point
                      executable is run, its instance ID will change. If 0 is passed in as the code
                      package instance ID, the API will restart the code package with whatever instance
                      ID it is currently running."nIf an instance ID other than 0 is passed in, the API
                      will restart the code package only if the current Instance ID matches the passed
                      in instance ID."nNote, passing in the exact instance ID (not 0) in the API is
                      safer, because if ensures at most one restart of the code package.
                    "CodePackageName": "str",  # Required. The name of the code package defined
                      in the service manifest.
                    "ServiceManifestName": "str",  # Required. The name of service manifest that
                      specified this code package.
                    "ServicePackageActivationId": "str"  # Optional. The ActivationId of a
                      deployed service package. If ServicePackageActivationMode specified at the time
                      of creating the service"nis 'SharedProcess' (or if it is not specified, in which
                      case it defaults to 'SharedProcess'), then value of
                      ServicePackageActivationId"nis always an empty string.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = restart_deployed_code_package_description

        request = build_restart_deployed_code_package_request(
            node_name=node_name,
            application_id=application_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_container_logs_deployed_on_node(
        self,
        node_name: str,
        application_id: str,
        *,
        service_manifest_name: str,
        code_package_name: str,
        tail: Optional[str] = None,
        previous: Optional[bool] = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the container logs for container deployed on a Service Fabric node.

        Gets the container logs for container deployed on a Service Fabric node for the given code
        package.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword service_manifest_name: The name of a service manifest registered as part of an
         application type in a Service Fabric cluster.
        :paramtype service_manifest_name: str
        :keyword code_package_name: The name of code package specified in service manifest registered
         as part of an application type in a Service Fabric cluster.
        :paramtype code_package_name: str
        :keyword tail: Number of lines to show from the end of the logs. Default is 100. 'all' to show
         the complete logs.
        :paramtype tail: str
        :keyword previous: Specifies whether to get container logs from exited/dead containers of the
         code package instance. Default value is False.
        :paramtype previous: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.2'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.2". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Content": "str"  # Optional. Container logs.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.2"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_container_logs_deployed_on_node_request(
            node_name=node_name,
            application_id=application_id,
            api_version=api_version,
            service_manifest_name=service_manifest_name,
            code_package_name=code_package_name,
            tail=tail,
            previous=previous,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def invoke_container_api(
        self,
        node_name: str,
        application_id: str,
        container_api_request_body: JSON,
        *,
        service_manifest_name: str,
        code_package_name: str,
        code_package_instance_id: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Invoke container API on a container deployed on a Service Fabric node.

        Invoke container API on a container deployed on a Service Fabric node for the given code
        package.

        :param node_name: The name of the node.
        :type node_name: str
        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param container_api_request_body: Parameters for making container API call.
        :type container_api_request_body: JSON
        :keyword service_manifest_name: The name of a service manifest registered as part of an
         application type in a Service Fabric cluster.
        :paramtype service_manifest_name: str
        :keyword code_package_name: The name of code package specified in service manifest registered
         as part of an application type in a Service Fabric cluster.
        :paramtype code_package_name: str
        :keyword code_package_instance_id: ID that uniquely identifies a code package instance deployed
         on a service fabric node.
        :paramtype code_package_instance_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.2'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.2". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                container_api_request_body = {
                    "Body": "str",  # Optional. HTTP request body of container REST API.
                    "Content-Type": "str",  # Optional. Content type of container REST API
                      request, defaults to "application/json".
                    "HttpVerb": "str",  # Optional. HTTP verb of container REST API, defaults to
                      "GET".
                    "UriPath": "str"  # Required. URI path of container REST API.
                }

                # response body for status code(s): 200
                response.json() == {
                    "ContainerApiResult": {
                        "Body": "str",  # Optional. container API result body.
                        "Content-Encoding": "str",  # Optional. HTTP content encoding.
                        "Content-Type": "str",  # Optional. HTTP content type.
                        "Status": 0  # Required. HTTP status code returned by the target
                          container API.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.2"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = container_api_request_body

        request = build_invoke_container_api_request(
            node_name=node_name,
            application_id=application_id,
            api_version=api_version,
            content_type=content_type,
            service_manifest_name=service_manifest_name,
            code_package_name=code_package_name,
            code_package_instance_id=code_package_instance_id,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def create_compose_deployment(  # pylint: disable=inconsistent-return-statements
        self,
        create_compose_deployment_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Creates a Service Fabric compose deployment.

        Compose is a file format that describes multi-container applications. This API allows deploying
        container based applications defined in compose format in a Service Fabric cluster. Once the
        deployment is created, its status can be tracked via the ``GetComposeDeploymentStatus`` API.

        :param create_compose_deployment_description: Describes the compose deployment that needs to be
         created.
        :type create_compose_deployment_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '"6.0-preview'. Default value is "6.0-preview". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                create_compose_deployment_description = {
                    "ComposeFileContent": "str",  # Required. The content of the compose file
                      that describes the deployment to create.
                    "DeploymentName": "str",  # Required. The name of the deployment.
                    "RegistryCredential": {
                        "PasswordEncrypted": bool,  # Optional. Indicates that supplied
                          container registry password is encrypted.
                        "RegistryPassword": "str",  # Optional. The password for supplied
                          username to connect to container registry.
                        "RegistryUserName": "str"  # Optional. The user name to connect to
                          container registry.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0-preview"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = create_compose_deployment_description

        request = build_create_compose_deployment_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_compose_deployment_status(
        self,
        deployment_name: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets information about a Service Fabric compose deployment.

        Returns the status of the compose deployment that was created or in the process of being
        created in the Service Fabric cluster and whose name matches the one specified as the
        parameter. The response includes the name, status, and other details about the deployment.

        :param deployment_name: The identity of the deployment.
        :type deployment_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '"6.0-preview'. Default value is "6.0-preview". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ApplicationName": "str",  # Optional. The name of the application, including
                      the 'fabric:' URI scheme.
                    "Name": "str",  # Optional. The name of the deployment.
                    "Status": "str",  # Optional. The status of the compose deployment. Known
                      values are: "Invalid", "Provisioning", "Creating", "Ready", "Unprovisioning",
                      "Deleting", "Failed", "Upgrading".
                    "StatusDetails": "str"  # Optional. The status details of compose deployment
                      including failure message.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_compose_deployment_status_request(
            deployment_name=deployment_name,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_compose_deployment_status_list(
        self,
        *,
        continuation_token_parameter: Optional[str] = None,
        max_results: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the list of compose deployments created in the Service Fabric cluster.

        Gets the status about the compose deployments that were created or in the process of being
        created in the Service Fabric cluster. The response includes the name, status, and other
        details about the compose deployments. If the list of deployments do not fit in a page, one
        page of results is returned as well as a continuation token, which can be used to get the next
        page.

        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '"6.0-preview'. Default value is "6.0-preview". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "ApplicationName": "str",  # Optional. The name of the
                              application, including the 'fabric:' URI scheme.
                            "Name": "str",  # Optional. The name of the deployment.
                            "Status": "str",  # Optional. The status of the compose
                              deployment. Known values are: "Invalid", "Provisioning", "Creating",
                              "Ready", "Unprovisioning", "Deleting", "Failed", "Upgrading".
                            "StatusDetails": "str"  # Optional. The status details of
                              compose deployment including failure message.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_compose_deployment_status_list_request(
            api_version=api_version,
            continuation_token_parameter=continuation_token_parameter,
            max_results=max_results,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_compose_deployment_upgrade_progress(
        self,
        deployment_name: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets details for the latest upgrade performed on this Service Fabric compose deployment.

        Returns the information about the state of the compose deployment upgrade along with details to
        aid debugging application health issues.

        :param deployment_name: The identity of the deployment.
        :type deployment_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '"6.0-preview'. Default value is "6.0-preview". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ApplicationHealthPolicy": {
                        "ConsiderWarningAsError": bool,  # Optional. Indicates whether
                          warnings are treated with the same severity as errors.
                        "DefaultServiceTypeHealthPolicy": {
                            "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional.
                              The maximum allowed percentage of unhealthy partitions per service.
                              Allowed values are Byte values from zero to 100"n"nThe percentage
                              represents the maximum tolerated percentage of partitions that can be
                              unhealthy before the service is considered in error."nIf the percentage
                              is respected but there is at least one unhealthy partition, the health is
                              evaluated as Warning."nThe percentage is calculated by dividing the
                              number of unhealthy partitions over the total number of partitions in the
                              service."nThe computation rounds up to tolerate one failure on small
                              numbers of partitions. Default percentage is zero.
                            "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional.
                              The maximum allowed percentage of unhealthy replicas per partition.
                              Allowed values are Byte values from zero to 100."n"nThe percentage
                              represents the maximum tolerated percentage of replicas that can be
                              unhealthy before the partition is considered in error."nIf the percentage
                              is respected but there is at least one unhealthy replica, the health is
                              evaluated as Warning."nThe percentage is calculated by dividing the
                              number of unhealthy replicas over the total number of replicas in the
                              partition."nThe computation rounds up to tolerate one failure on small
                              numbers of replicas. Default percentage is zero.
                            "MaxPercentUnhealthyServices": 0  # Optional. The maximum
                              allowed percentage of unhealthy services. Allowed values are Byte values
                              from zero to 100."n"nThe percentage represents the maximum tolerated
                              percentage of services that can be unhealthy before the application is
                              considered in error."nIf the percentage is respected but there is at
                              least one unhealthy service, the health is evaluated as Warning."nThis is
                              calculated by dividing the number of unhealthy services of the specific
                              service type over the total number of services of the specific service
                              type."nThe computation rounds up to tolerate one failure on small numbers
                              of services. Default percentage is zero.
                        },
                        "MaxPercentUnhealthyDeployedApplications": 0,  # Optional. The
                          maximum allowed percentage of unhealthy deployed applications. Allowed values
                          are Byte values from zero to 100."nThe percentage represents the maximum
                          tolerated percentage of deployed applications that can be unhealthy before
                          the application is considered in error."nThis is calculated by dividing the
                          number of unhealthy deployed applications over the number of nodes where the
                          application is currently deployed on in the cluster."nThe computation rounds
                          up to tolerate one failure on small numbers of nodes. Default percentage is
                          zero.
                        "ServiceTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the service
                                  type health policy map item. This is the name of the service type.
                                "Value": {
                                    "MaxPercentUnhealthyPartitionsPerService": 0,
                                      # Optional. The maximum allowed percentage of unhealthy
                                      partitions per service. Allowed values are Byte values from zero
                                      to 100"n"nThe percentage represents the maximum tolerated
                                      percentage of partitions that can be unhealthy before the service
                                      is considered in error."nIf the percentage is respected but there
                                      is at least one unhealthy partition, the health is evaluated as
                                      Warning."nThe percentage is calculated by dividing the number of
                                      unhealthy partitions over the total number of partitions in the
                                      service."nThe computation rounds up to tolerate one failure on
                                      small numbers of partitions. Default percentage is zero.
                                    "MaxPercentUnhealthyReplicasPerPartition": 0,
                                      # Optional. The maximum allowed percentage of unhealthy replicas
                                      per partition. Allowed values are Byte values from zero to
                                      100."n"nThe percentage represents the maximum tolerated
                                      percentage of replicas that can be unhealthy before the partition
                                      is considered in error."nIf the percentage is respected but there
                                      is at least one unhealthy replica, the health is evaluated as
                                      Warning."nThe percentage is calculated by dividing the number of
                                      unhealthy replicas over the total number of replicas in the
                                      partition."nThe computation rounds up to tolerate one failure on
                                      small numbers of replicas. Default percentage is zero.
                                    "MaxPercentUnhealthyServices": 0  # Optional.
                                      The maximum allowed percentage of unhealthy services. Allowed
                                      values are Byte values from zero to 100."n"nThe percentage
                                      represents the maximum tolerated percentage of services that can
                                      be unhealthy before the application is considered in error."nIf
                                      the percentage is respected but there is at least one unhealthy
                                      service, the health is evaluated as Warning."nThis is calculated
                                      by dividing the number of unhealthy services of the specific
                                      service type over the total number of services of the specific
                                      service type."nThe computation rounds up to tolerate one failure
                                      on small numbers of services. Default percentage is zero.
                                }
                            }
                        ]
                    },
                    "ApplicationName": "str",  # Optional. The name of the target application,
                      including the 'fabric:' URI scheme.
                    "ApplicationUnhealthyEvaluations": [
                        {
                            "HealthEvaluation": {
                                "AggregatedHealthState": "str",  # Optional. The
                                  health state of a Service Fabric entity such as Cluster, Node,
                                  Application, Service, Partition, Replica etc. Known values are:
                                  "Invalid", "Ok", "Warning", "Error", "Unknown".
                                "Description": "str",  # Optional. Description of the
                                  health evaluation, which represents a summary of the evaluation
                                  process.
                                Kind: Kind
                            }
                        }
                    ],
                    "ApplicationUpgradeStatusDetails": "str",  # Optional. Additional details of
                      application upgrade including failure message.
                    "CurrentUpgradeDomainDuration": "PT0H2M0S",  # Optional. Default value is
                      "PT0H2M0S". The estimated amount of time spent processing current Upgrade Domain.
                      It is first interpreted as a string representing an ISO 8601 duration. If that
                      fails, then it is interpreted as a number representing the total number of
                      milliseconds.
                    "CurrentUpgradeDomainProgress": {
                        "DomainName": "str",  # Optional. The name of the upgrade domain.
                        "NodeUpgradeProgressList": [
                            {
                                "NodeName": "str",  # Optional. The name of a Service
                                  Fabric node.
                                "PendingSafetyChecks": [
                                    {
                                        "SafetyCheck": {
                                            Kind: Kind
                                        }
                                    }
                                ],
                                "UpgradeDuration": "str",  # Optional. The estimated
                                  time spent processing the node since it was deactivated during a
                                  node-by-node upgrade.
                                "UpgradePhase": "str"  # Optional. The state of the
                                  upgrading node. Known values are: "Invalid", "PreUpgradeSafetyCheck",
                                  "Upgrading", "PostUpgradeSafetyCheck".
                            }
                        ]
                    },
                    "DeploymentName": "str",  # Optional. The name of the target deployment.
                    "FailureReason": "str",  # Optional. The cause of an upgrade failure that
                      resulted in FailureAction being executed. Known values are: "None",
                      "Interrupted", "HealthCheck", "UpgradeDomainTimeout", "OverallUpgradeTimeout".
                    "FailureTimestampUtc": "str",  # Optional. The estimated UTC datetime when
                      the upgrade failed and FailureAction was executed.
                    "ForceRestart": bool,  # Optional. If true, then processes are forcefully
                      restarted during upgrade even when the code version has not changed (the upgrade
                      only changes configuration or data).
                    "MonitoringPolicy": {
                        "FailureAction": "str",  # Optional. The compensating action to
                          perform when a Monitored upgrade encounters monitoring policy or health
                          policy violations."nInvalid indicates the failure action is invalid. Rollback
                          specifies that the upgrade will start rolling back automatically."nManual
                          indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
                          Known values are: "Invalid", "Rollback", "Manual".
                        "HealthCheckRetryTimeoutInMilliseconds": "PT0H10M0S",  # Optional.
                          Default value is "PT0H10M0S". The amount of time to retry health evaluation
                          when the application or cluster is unhealthy before FailureAction is
                          executed. It is first interpreted as a string representing an ISO 8601
                          duration. If that fails, then it is interpreted as a number representing the
                          total number of milliseconds.
                        "HealthCheckStableDurationInMilliseconds": "PT0H2M0S",  # Optional.
                          Default value is "PT0H2M0S". The amount of time that the application or
                          cluster must remain healthy before the upgrade proceeds to the next upgrade
                          domain. It is first interpreted as a string representing an ISO 8601
                          duration. If that fails, then it is interpreted as a number representing the
                          total number of milliseconds.
                        "HealthCheckWaitDurationInMilliseconds": "0",  # Optional. Default
                          value is "0". The amount of time to wait after completing an upgrade domain
                          before applying health policies. It is first interpreted as a string
                          representing an ISO 8601 duration. If that fails, then it is interpreted as a
                          number representing the total number of milliseconds.
                        "UpgradeDomainTimeoutInMilliseconds": "P10675199DT02H48M05.4775807S",
                          # Optional. Default value is "P10675199DT02H48M05.4775807S". The amount of
                          time each upgrade domain has to complete before FailureAction is executed. It
                          is first interpreted as a string representing an ISO 8601 duration. If that
                          fails, then it is interpreted as a number representing the total number of
                          milliseconds.
                        "UpgradeTimeoutInMilliseconds": "P10675199DT02H48M05.4775807S"  #
                          Optional. Default value is "P10675199DT02H48M05.4775807S". The amount of time
                          the overall upgrade has to complete before FailureAction is executed. It is
                          first interpreted as a string representing an ISO 8601 duration. If that
                          fails, then it is interpreted as a number representing the total number of
                          milliseconds.
                    },
                    "RollingUpgradeMode": "UnmonitoredAuto",  # Optional. Default value is
                      "UnmonitoredAuto". The mode used to monitor health during a rolling upgrade. The
                      values are UnmonitoredAuto, UnmonitoredManual, Monitored, and
                      UnmonitoredDeferred. Known values are: "Invalid", "UnmonitoredAuto",
                      "UnmonitoredManual", "Monitored", "UnmonitoredDeferred". Default value:
                      "UnmonitoredAuto".
                    "StartTimestampUtc": "str",  # Optional. The estimated UTC datetime when the
                      upgrade started.
                    "TargetApplicationTypeVersion": "str",  # Optional. The target application
                      type version (found in the application manifest) for the application upgrade.
                    "UpgradeDomainProgressAtFailure": {
                        "DomainName": "str",  # Optional. The name of the upgrade domain.
                        "NodeUpgradeProgressList": [
                            {
                                "NodeName": "str",  # Optional. The name of a Service
                                  Fabric node.
                                "PendingSafetyChecks": [
                                    {
                                        "SafetyCheck": {
                                            Kind: Kind
                                        }
                                    }
                                ],
                                "UpgradeDuration": "str",  # Optional. The estimated
                                  time spent processing the node since it was deactivated during a
                                  node-by-node upgrade.
                                "UpgradePhase": "str"  # Optional. The state of the
                                  upgrading node. Known values are: "Invalid", "PreUpgradeSafetyCheck",
                                  "Upgrading", "PostUpgradeSafetyCheck".
                            }
                        ]
                    },
                    "UpgradeDuration": "PT0H2M0S",  # Optional. Default value is "PT0H2M0S". The
                      estimated amount of time that the overall upgrade elapsed. It is first
                      interpreted as a string representing an ISO 8601 duration. If that fails, then it
                      is interpreted as a number representing the total number of milliseconds.
                    "UpgradeKind": "Rolling",  # Optional. Default value is "Rolling". The kind
                      of upgrade out of the following possible values. Known values are: "Invalid",
                      "Rolling". Default value: "Rolling".
                    "UpgradeReplicaSetCheckTimeoutInSeconds": 42949672925,  # Optional. Default
                      value is 42949672925. The maximum amount of time to block processing of an
                      upgrade domain and prevent loss of availability when there are unexpected issues.
                      When this timeout expires, processing of the upgrade domain will proceed
                      regardless of availability loss issues. The timeout is reset at the start of each
                      upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
                      32-bit integer).
                    "UpgradeState": "str",  # Optional. The state of the compose deployment
                      upgrade. Known values are: "Invalid", "ProvisioningTarget",
                      "RollingForwardInProgress", "RollingForwardPending", "UnprovisioningCurrent",
                      "RollingForwardCompleted", "RollingBackInProgress", "UnprovisioningTarget",
                      "RollingBackCompleted", "Failed".
                    "UpgradeStatusDetails": "str"  # Optional. Additional detailed information
                      about the status of the pending upgrade.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_compose_deployment_upgrade_progress_request(
            deployment_name=deployment_name,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def remove_compose_deployment(  # pylint: disable=inconsistent-return-statements
        self,
        deployment_name: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Deletes an existing Service Fabric compose deployment from cluster.

        Deletes an existing Service Fabric compose deployment.

        :param deployment_name: The identity of the deployment.
        :type deployment_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '"6.0-preview'. Default value is "6.0-preview". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_remove_compose_deployment_request(
            deployment_name=deployment_name,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def start_compose_deployment_upgrade(  # pylint: disable=inconsistent-return-statements
        self,
        deployment_name: str,
        compose_deployment_upgrade_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Starts upgrading a compose deployment in the Service Fabric cluster.

        Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters
        are valid.

        :param deployment_name: The identity of the deployment.
        :type deployment_name: str
        :param compose_deployment_upgrade_description: Parameters for upgrading compose deployment.
        :type compose_deployment_upgrade_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '"6.0-preview'. Default value is "6.0-preview". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                compose_deployment_upgrade_description = {
                    "ApplicationHealthPolicy": {
                        "ConsiderWarningAsError": bool,  # Optional. Indicates whether
                          warnings are treated with the same severity as errors.
                        "DefaultServiceTypeHealthPolicy": {
                            "MaxPercentUnhealthyPartitionsPerService": 0,  # Optional.
                              The maximum allowed percentage of unhealthy partitions per service.
                              Allowed values are Byte values from zero to 100"n"nThe percentage
                              represents the maximum tolerated percentage of partitions that can be
                              unhealthy before the service is considered in error."nIf the percentage
                              is respected but there is at least one unhealthy partition, the health is
                              evaluated as Warning."nThe percentage is calculated by dividing the
                              number of unhealthy partitions over the total number of partitions in the
                              service."nThe computation rounds up to tolerate one failure on small
                              numbers of partitions. Default percentage is zero.
                            "MaxPercentUnhealthyReplicasPerPartition": 0,  # Optional.
                              The maximum allowed percentage of unhealthy replicas per partition.
                              Allowed values are Byte values from zero to 100."n"nThe percentage
                              represents the maximum tolerated percentage of replicas that can be
                              unhealthy before the partition is considered in error."nIf the percentage
                              is respected but there is at least one unhealthy replica, the health is
                              evaluated as Warning."nThe percentage is calculated by dividing the
                              number of unhealthy replicas over the total number of replicas in the
                              partition."nThe computation rounds up to tolerate one failure on small
                              numbers of replicas. Default percentage is zero.
                            "MaxPercentUnhealthyServices": 0  # Optional. The maximum
                              allowed percentage of unhealthy services. Allowed values are Byte values
                              from zero to 100."n"nThe percentage represents the maximum tolerated
                              percentage of services that can be unhealthy before the application is
                              considered in error."nIf the percentage is respected but there is at
                              least one unhealthy service, the health is evaluated as Warning."nThis is
                              calculated by dividing the number of unhealthy services of the specific
                              service type over the total number of services of the specific service
                              type."nThe computation rounds up to tolerate one failure on small numbers
                              of services. Default percentage is zero.
                        },
                        "MaxPercentUnhealthyDeployedApplications": 0,  # Optional. The
                          maximum allowed percentage of unhealthy deployed applications. Allowed values
                          are Byte values from zero to 100."nThe percentage represents the maximum
                          tolerated percentage of deployed applications that can be unhealthy before
                          the application is considered in error."nThis is calculated by dividing the
                          number of unhealthy deployed applications over the number of nodes where the
                          application is currently deployed on in the cluster."nThe computation rounds
                          up to tolerate one failure on small numbers of nodes. Default percentage is
                          zero.
                        "ServiceTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the service
                                  type health policy map item. This is the name of the service type.
                                "Value": {
                                    "MaxPercentUnhealthyPartitionsPerService": 0,
                                      # Optional. The maximum allowed percentage of unhealthy
                                      partitions per service. Allowed values are Byte values from zero
                                      to 100"n"nThe percentage represents the maximum tolerated
                                      percentage of partitions that can be unhealthy before the service
                                      is considered in error."nIf the percentage is respected but there
                                      is at least one unhealthy partition, the health is evaluated as
                                      Warning."nThe percentage is calculated by dividing the number of
                                      unhealthy partitions over the total number of partitions in the
                                      service."nThe computation rounds up to tolerate one failure on
                                      small numbers of partitions. Default percentage is zero.
                                    "MaxPercentUnhealthyReplicasPerPartition": 0,
                                      # Optional. The maximum allowed percentage of unhealthy replicas
                                      per partition. Allowed values are Byte values from zero to
                                      100."n"nThe percentage represents the maximum tolerated
                                      percentage of replicas that can be unhealthy before the partition
                                      is considered in error."nIf the percentage is respected but there
                                      is at least one unhealthy replica, the health is evaluated as
                                      Warning."nThe percentage is calculated by dividing the number of
                                      unhealthy replicas over the total number of replicas in the
                                      partition."nThe computation rounds up to tolerate one failure on
                                      small numbers of replicas. Default percentage is zero.
                                    "MaxPercentUnhealthyServices": 0  # Optional.
                                      The maximum allowed percentage of unhealthy services. Allowed
                                      values are Byte values from zero to 100."n"nThe percentage
                                      represents the maximum tolerated percentage of services that can
                                      be unhealthy before the application is considered in error."nIf
                                      the percentage is respected but there is at least one unhealthy
                                      service, the health is evaluated as Warning."nThis is calculated
                                      by dividing the number of unhealthy services of the specific
                                      service type over the total number of services of the specific
                                      service type."nThe computation rounds up to tolerate one failure
                                      on small numbers of services. Default percentage is zero.
                                }
                            }
                        ]
                    },
                    "ComposeFileContent": "str",  # Required. The content of the compose file
                      that describes the deployment to create.
                    "DeploymentName": "str",  # Required. The name of the deployment.
                    "ForceRestart": bool,  # Optional. If true, then processes are forcefully
                      restarted during upgrade even when the code version has not changed (the upgrade
                      only changes configuration or data).
                    "MonitoringPolicy": {
                        "FailureAction": "str",  # Optional. The compensating action to
                          perform when a Monitored upgrade encounters monitoring policy or health
                          policy violations."nInvalid indicates the failure action is invalid. Rollback
                          specifies that the upgrade will start rolling back automatically."nManual
                          indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
                          Known values are: "Invalid", "Rollback", "Manual".
                        "HealthCheckRetryTimeoutInMilliseconds": "PT0H10M0S",  # Optional.
                          Default value is "PT0H10M0S". The amount of time to retry health evaluation
                          when the application or cluster is unhealthy before FailureAction is
                          executed. It is first interpreted as a string representing an ISO 8601
                          duration. If that fails, then it is interpreted as a number representing the
                          total number of milliseconds.
                        "HealthCheckStableDurationInMilliseconds": "PT0H2M0S",  # Optional.
                          Default value is "PT0H2M0S". The amount of time that the application or
                          cluster must remain healthy before the upgrade proceeds to the next upgrade
                          domain. It is first interpreted as a string representing an ISO 8601
                          duration. If that fails, then it is interpreted as a number representing the
                          total number of milliseconds.
                        "HealthCheckWaitDurationInMilliseconds": "0",  # Optional. Default
                          value is "0". The amount of time to wait after completing an upgrade domain
                          before applying health policies. It is first interpreted as a string
                          representing an ISO 8601 duration. If that fails, then it is interpreted as a
                          number representing the total number of milliseconds.
                        "UpgradeDomainTimeoutInMilliseconds": "P10675199DT02H48M05.4775807S",
                          # Optional. Default value is "P10675199DT02H48M05.4775807S". The amount of
                          time each upgrade domain has to complete before FailureAction is executed. It
                          is first interpreted as a string representing an ISO 8601 duration. If that
                          fails, then it is interpreted as a number representing the total number of
                          milliseconds.
                        "UpgradeTimeoutInMilliseconds": "P10675199DT02H48M05.4775807S"  #
                          Optional. Default value is "P10675199DT02H48M05.4775807S". The amount of time
                          the overall upgrade has to complete before FailureAction is executed. It is
                          first interpreted as a string representing an ISO 8601 duration. If that
                          fails, then it is interpreted as a number representing the total number of
                          milliseconds.
                    },
                    "RegistryCredential": {
                        "PasswordEncrypted": bool,  # Optional. Indicates that supplied
                          container registry password is encrypted.
                        "RegistryPassword": "str",  # Optional. The password for supplied
                          username to connect to container registry.
                        "RegistryUserName": "str"  # Optional. The user name to connect to
                          container registry.
                    },
                    "RollingUpgradeMode": "UnmonitoredAuto",  # Optional. Default value is
                      "UnmonitoredAuto". The mode used to monitor health during a rolling upgrade. The
                      values are UnmonitoredAuto, UnmonitoredManual, Monitored, and
                      UnmonitoredDeferred. Known values are: "Invalid", "UnmonitoredAuto",
                      "UnmonitoredManual", "Monitored", "UnmonitoredDeferred". Default value:
                      "UnmonitoredAuto".
                    "UpgradeKind": "Rolling",  # Default value is "Rolling". Required. The kind
                      of upgrade out of the following possible values. Known values are: "Invalid",
                      "Rolling". Default value: "Rolling".
                    "UpgradeReplicaSetCheckTimeoutInSeconds": 42949672925  # Optional. Default
                      value is 42949672925. The maximum amount of time to block processing of an
                      upgrade domain and prevent loss of availability when there are unexpected issues.
                      When this timeout expires, processing of the upgrade domain will proceed
                      regardless of availability loss issues. The timeout is reset at the start of each
                      upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
                      32-bit integer).
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0-preview"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = compose_deployment_upgrade_description

        request = build_start_compose_deployment_upgrade_request(
            deployment_name=deployment_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def start_rollback_compose_deployment_upgrade(  # pylint: disable=inconsistent-return-statements
        self,
        deployment_name: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Starts rolling back a compose deployment upgrade in the Service Fabric cluster.

        Rollback a service fabric compose deployment upgrade.

        :param deployment_name: The identity of the deployment.
        :type deployment_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_start_rollback_compose_deployment_upgrade_request(
            deployment_name=deployment_name,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_chaos(
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Get the status of Chaos.

        Get the status of Chaos indicating whether or not Chaos is running, the Chaos parameters used
        for running Chaos and the status of the Chaos Schedule.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.2'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.2". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ChaosParameters": {
                        "ChaosTargetFilter": {
                            "ApplicationInclusionList": [
                                "str"  # Optional. A list of application URIs to
                                  include in Chaos faults."nAll replicas belonging to services of these
                                  applications are amenable to replica faults (restart replica, remove
                                  replica, move primary, and move secondary) by Chaos."nChaos may
                                  restart a code package only if the code package hosts replicas of
                                  these applications only."nIf an application does not appear in this
                                  list, it can still be faulted in some Chaos iteration if the
                                  application ends up on a node of a node type that is included in
                                  NodeTypeInclusionList."nHowever, if applicationX is tied to nodeTypeY
                                  through placement constraints and applicationX is absent from
                                  ApplicationInclusionList and nodeTypeY is absent from
                                  NodeTypeInclusionList, then applicationX will never be faulted."nAt
                                  most 1000 application names can be included in this list, to increase
                                  this number, a config upgrade is required for
                                  MaxNumberOfApplicationsInChaosEntityFilter configuration.
                            ],
                            "NodeTypeInclusionList": [
                                "str"  # Optional. A list of node types to include in
                                  Chaos faults."nAll types of faults (restart node, restart code
                                  package, remove replica, restart replica, move primary, and move
                                  secondary) are enabled for the nodes of these node types."nIf a node
                                  type (say NodeTypeX) does not appear in the NodeTypeInclusionList,
                                  then node level faults (like NodeRestart) will never be enabled for
                                  the nodes of"nNodeTypeX, but code package and replica faults can
                                  still be enabled for NodeTypeX if an application in the
                                  ApplicationInclusionList."nhappens to reside on a node of
                                  NodeTypeX."nAt most 100 node type names can be included in this list,
                                  to increase this number, a config upgrade is required for
                                  MaxNumberOfNodeTypesInChaosEntityFilter configuration.
                            ]
                        },
                        "ClusterHealthPolicy": {
                            "ApplicationTypeHealthPolicyMap": [
                                {
                                    "Key": "str",  # Required. The key of the
                                      application type health policy map item. This is the name of the
                                      application type.
                                    "Value": 0  # Required. The value of the
                                      application type health policy map item."nThe max percent
                                      unhealthy applications allowed for the application type. Must be
                                      between zero and 100.
                                }
                            ],
                            "ConsiderWarningAsError": bool,  # Optional. Indicates
                              whether warnings are treated with the same severity as errors.
                            "MaxPercentUnhealthyApplications": 0,  # Optional. The
                              maximum allowed percentage of unhealthy applications before reporting an
                              error. For example, to allow 10% of applications to be unhealthy, this
                              value would be 10."n"nThe percentage represents the maximum tolerated
                              percentage of applications that can be unhealthy before the cluster is
                              considered in error."nIf the percentage is respected but there is at
                              least one unhealthy application, the health is evaluated as
                              Warning."nThis is calculated by dividing the number of unhealthy
                              applications over the total number of application instances in the
                              cluster, excluding applications of application types that are included in
                              the ApplicationTypeHealthPolicyMap."nThe computation rounds up to
                              tolerate one failure on small numbers of applications. Default percentage
                              is zero.
                            "MaxPercentUnhealthyNodes": 0,  # Optional. The maximum
                              allowed percentage of unhealthy nodes before reporting an error. For
                              example, to allow 10% of nodes to be unhealthy, this value would be
                              10."n"nThe percentage represents the maximum tolerated percentage of
                              nodes that can be unhealthy before the cluster is considered in
                              error."nIf the percentage is respected but there is at least one
                              unhealthy node, the health is evaluated as Warning."nThe percentage is
                              calculated by dividing the number of unhealthy nodes over the total
                              number of nodes in the cluster."nThe computation rounds up to tolerate
                              one failure on small numbers of nodes. Default percentage is zero."n"nIn
                              large clusters, some nodes will always be down or out for repairs, so
                              this percentage should be configured to tolerate that.
                            "NodeTypeHealthPolicyMap": [
                                {
                                    "Key": "str",  # Required. The key of the
                                      node type health policy map item. This is the name of the node
                                      type.
                                    "Value": 0  # Required. The value of the node
                                      type health policy map item."nIf the percentage is respected but
                                      there is at least one unhealthy node in the node type, the health
                                      is evaluated as Warning. "nThe percentage is calculated by
                                      dividing the number of unhealthy nodes over the total number of
                                      nodes in the node type. "nThe computation rounds up to tolerate
                                      one failure on small numbers of nodes."nThe max percent unhealthy
                                      nodes allowed for the node type. Must be between zero and 100.
                                }
                            ]
                        },
                        "Context": {
                            "Map": {
                                "str": "str"  # Optional. Describes a map that
                                  contains a collection of ChaosContextMapItem's.
                            }
                        },
                        "EnableMoveReplicaFaults": True,  # Optional. Default value is True.
                          Enables or disables the move primary and move secondary faults.
                        "MaxClusterStabilizationTimeoutInSeconds": 60,  # Optional. Default
                          value is 60. The maximum amount of time to wait for all cluster entities to
                          become stable and healthy. Chaos executes in iterations and at the start of
                          each iteration it validates the health of cluster entities."nDuring
                          validation if a cluster entity is not stable and healthy within
                          MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed
                          event.
                        "MaxConcurrentFaults": 1,  # Optional. Default value is 1.
                          MaxConcurrentFaults is the maximum number of concurrent faults induced per
                          iteration."nChaos executes in iterations and two consecutive iterations are
                          separated by a validation phase."nThe higher the concurrency, the more
                          aggressive the injection of faults, leading to inducing more complex series
                          of states to uncover bugs."nThe recommendation is to start with a value of 2
                          or 3 and to exercise caution while moving up.
                        "TimeToRunInSeconds": "4294967295",  # Optional. Default value is
                          "4294967295". Total time (in seconds) for which Chaos will run before
                          automatically stopping. The maximum allowed value is 4,294,967,295
                          (System.UInt32.MaxValue).
                        "WaitTimeBetweenFaultsInSeconds": 20,  # Optional. Default value is
                          20. Wait time (in seconds) between consecutive faults within a single
                          iteration."nThe larger the value, the lower the overlapping between faults
                          and the simpler the sequence of state transitions that the cluster goes
                          through."nThe recommendation is to start with a value between 1 and 5 and
                          exercise caution while moving up.
                        "WaitTimeBetweenIterationsInSeconds": 30  # Optional. Default value
                          is 30. Time-separation (in seconds) between two consecutive iterations of
                          Chaos."nThe larger the value, the lower the fault injection rate.
                    },
                    "ScheduleStatus": "str",  # Optional. Current status of the schedule. Known
                      values are: "Invalid", "Stopped", "Active", "Expired", "Pending".
                    "Status": "str"  # Optional. Current status of the Chaos run. Known values
                      are: "Invalid", "Running", "Stopped".
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.2"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_chaos_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def start_chaos(  # pylint: disable=inconsistent-return-statements
        self,
        chaos_parameters: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Starts Chaos in the cluster.

        If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos
        parameters.
        If Chaos is already running when this call is made, the call fails with the error code
        FABRIC_E_CHAOS_ALREADY_RUNNING.
        Refer to the article `Induce controlled Chaos in Service Fabric clusters
        <https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos>`_ for more
        details.

        :param chaos_parameters: Describes all the parameters to configure a Chaos run.
        :type chaos_parameters: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                chaos_parameters = {
                    "ChaosTargetFilter": {
                        "ApplicationInclusionList": [
                            "str"  # Optional. A list of application URIs to include in
                              Chaos faults."nAll replicas belonging to services of these applications
                              are amenable to replica faults (restart replica, remove replica, move
                              primary, and move secondary) by Chaos."nChaos may restart a code package
                              only if the code package hosts replicas of these applications only."nIf
                              an application does not appear in this list, it can still be faulted in
                              some Chaos iteration if the application ends up on a node of a node type
                              that is included in NodeTypeInclusionList."nHowever, if applicationX is
                              tied to nodeTypeY through placement constraints and applicationX is
                              absent from ApplicationInclusionList and nodeTypeY is absent from
                              NodeTypeInclusionList, then applicationX will never be faulted."nAt most
                              1000 application names can be included in this list, to increase this
                              number, a config upgrade is required for
                              MaxNumberOfApplicationsInChaosEntityFilter configuration.
                        ],
                        "NodeTypeInclusionList": [
                            "str"  # Optional. A list of node types to include in Chaos
                              faults."nAll types of faults (restart node, restart code package, remove
                              replica, restart replica, move primary, and move secondary) are enabled
                              for the nodes of these node types."nIf a node type (say NodeTypeX) does
                              not appear in the NodeTypeInclusionList, then node level faults (like
                              NodeRestart) will never be enabled for the nodes of"nNodeTypeX, but code
                              package and replica faults can still be enabled for NodeTypeX if an
                              application in the ApplicationInclusionList."nhappens to reside on a node
                              of NodeTypeX."nAt most 100 node type names can be included in this list,
                              to increase this number, a config upgrade is required for
                              MaxNumberOfNodeTypesInChaosEntityFilter configuration.
                        ]
                    },
                    "ClusterHealthPolicy": {
                        "ApplicationTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the application
                                  type health policy map item. This is the name of the application
                                  type.
                                "Value": 0  # Required. The value of the application
                                  type health policy map item."nThe max percent unhealthy applications
                                  allowed for the application type. Must be between zero and 100.
                            }
                        ],
                        "ConsiderWarningAsError": bool,  # Optional. Indicates whether
                          warnings are treated with the same severity as errors.
                        "MaxPercentUnhealthyApplications": 0,  # Optional. The maximum
                          allowed percentage of unhealthy applications before reporting an error. For
                          example, to allow 10% of applications to be unhealthy, this value would be
                          10."n"nThe percentage represents the maximum tolerated percentage of
                          applications that can be unhealthy before the cluster is considered in
                          error."nIf the percentage is respected but there is at least one unhealthy
                          application, the health is evaluated as Warning."nThis is calculated by
                          dividing the number of unhealthy applications over the total number of
                          application instances in the cluster, excluding applications of application
                          types that are included in the ApplicationTypeHealthPolicyMap."nThe
                          computation rounds up to tolerate one failure on small numbers of
                          applications. Default percentage is zero.
                        "MaxPercentUnhealthyNodes": 0,  # Optional. The maximum allowed
                          percentage of unhealthy nodes before reporting an error. For example, to
                          allow 10% of nodes to be unhealthy, this value would be 10."n"nThe percentage
                          represents the maximum tolerated percentage of nodes that can be unhealthy
                          before the cluster is considered in error."nIf the percentage is respected
                          but there is at least one unhealthy node, the health is evaluated as
                          Warning."nThe percentage is calculated by dividing the number of unhealthy
                          nodes over the total number of nodes in the cluster."nThe computation rounds
                          up to tolerate one failure on small numbers of nodes. Default percentage is
                          zero."n"nIn large clusters, some nodes will always be down or out for
                          repairs, so this percentage should be configured to tolerate that.
                        "NodeTypeHealthPolicyMap": [
                            {
                                "Key": "str",  # Required. The key of the node type
                                  health policy map item. This is the name of the node type.
                                "Value": 0  # Required. The value of the node type
                                  health policy map item."nIf the percentage is respected but there is
                                  at least one unhealthy node in the node type, the health is evaluated
                                  as Warning. "nThe percentage is calculated by dividing the number of
                                  unhealthy nodes over the total number of nodes in the node type.
                                  "nThe computation rounds up to tolerate one failure on small numbers
                                  of nodes."nThe max percent unhealthy nodes allowed for the node type.
                                  Must be between zero and 100.
                            }
                        ]
                    },
                    "Context": {
                        "Map": {
                            "str": "str"  # Optional. Describes a map that contains a
                              collection of ChaosContextMapItem's.
                        }
                    },
                    "EnableMoveReplicaFaults": True,  # Optional. Default value is True. Enables
                      or disables the move primary and move secondary faults.
                    "MaxClusterStabilizationTimeoutInSeconds": 60,  # Optional. Default value is
                      60. The maximum amount of time to wait for all cluster entities to become stable
                      and healthy. Chaos executes in iterations and at the start of each iteration it
                      validates the health of cluster entities."nDuring validation if a cluster entity
                      is not stable and healthy within MaxClusterStabilizationTimeoutInSeconds, Chaos
                      generates a validation failed event.
                    "MaxConcurrentFaults": 1,  # Optional. Default value is 1.
                      MaxConcurrentFaults is the maximum number of concurrent faults induced per
                      iteration."nChaos executes in iterations and two consecutive iterations are
                      separated by a validation phase."nThe higher the concurrency, the more aggressive
                      the injection of faults, leading to inducing more complex series of states to
                      uncover bugs."nThe recommendation is to start with a value of 2 or 3 and to
                      exercise caution while moving up.
                    "TimeToRunInSeconds": "4294967295",  # Optional. Default value is
                      "4294967295". Total time (in seconds) for which Chaos will run before
                      automatically stopping. The maximum allowed value is 4,294,967,295
                      (System.UInt32.MaxValue).
                    "WaitTimeBetweenFaultsInSeconds": 20,  # Optional. Default value is 20. Wait
                      time (in seconds) between consecutive faults within a single iteration."nThe
                      larger the value, the lower the overlapping between faults and the simpler the
                      sequence of state transitions that the cluster goes through."nThe recommendation
                      is to start with a value between 1 and 5 and exercise caution while moving up.
                    "WaitTimeBetweenIterationsInSeconds": 30  # Optional. Default value is 30.
                      Time-separation (in seconds) between two consecutive iterations of Chaos."nThe
                      larger the value, the lower the fault injection rate.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = chaos_parameters

        request = build_start_chaos_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def stop_chaos(  # pylint: disable=inconsistent-return-statements
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Stops Chaos if it is running in the cluster and put the Chaos Schedule in a stopped state.

        Stops Chaos from executing new faults. In-flight faults will continue to execute until they are
        complete. The current Chaos Schedule is put into a stopped state.
        Once a schedule is stopped, it will stay in the stopped state and not be used to Chaos Schedule
        new runs of Chaos. A new Chaos Schedule must be set in order to resume scheduling.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_stop_chaos_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_chaos_events(
        self,
        *,
        continuation_token_parameter: Optional[str] = None,
        start_time_utc: Optional[str] = None,
        end_time_utc: Optional[str] = None,
        max_results: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the next segment of the Chaos events based on the continuation token or the time range.

        To get the next segment of the Chaos events, you can specify the ContinuationToken. To get the
        start of a new segment of Chaos events, you can specify the time range
        through StartTimeUtc and EndTimeUtc. You cannot specify both the ContinuationToken and the time
        range in the same call.
        When there are more than 100 Chaos events, the Chaos events are returned in multiple segments
        where a segment contains no more than 100 Chaos events and to get the next segment you make a
        call to this API with the continuation token.

        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword start_time_utc: The Windows file time representing the start time of the time range
         for which a Chaos report is to be generated. Consult `DateTime.ToFileTimeUtc Method
         <https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110>`_.aspx) for
         details. Default value is None.
        :paramtype start_time_utc: str
        :keyword end_time_utc: The Windows file time representing the end time of the time range for
         which a Chaos report is to be generated. Consult `DateTime.ToFileTimeUtc Method
         <https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110>`_.aspx) for
         details. Default value is None.
        :paramtype end_time_utc: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.2'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.2". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "History": [
                        {
                            "ChaosEvent": {
                                "TimeStampUtc": "2020-02-20 00:00:00",  # Required.
                                  The UTC timestamp when this Chaos event was generated.
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.2"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_chaos_events_request(
            api_version=api_version,
            continuation_token_parameter=continuation_token_parameter,
            start_time_utc=start_time_utc,
            end_time_utc=end_time_utc,
            max_results=max_results,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_chaos_schedule(
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Get the Chaos Schedule defining when and how to run Chaos.

        Gets the version of the Chaos Schedule in use and the Chaos Schedule that defines when and how
        to run Chaos.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.2'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.2". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Schedule": {
                        "ChaosParametersDictionary": [
                            {
                                "Key": "str",  # Required. The key identifying the
                                  Chaos Parameter in the dictionary. This key is referenced by Chaos
                                  Schedule Jobs.
                                "Value": {
                                    "ChaosTargetFilter": {
                                        "ApplicationInclusionList": [
                                            "str"  # Optional. A list of
                                              application URIs to include in Chaos faults."nAll
                                              replicas belonging to services of these applications are
                                              amenable to replica faults (restart replica, remove
                                              replica, move primary, and move secondary) by
                                              Chaos."nChaos may restart a code package only if the code
                                              package hosts replicas of these applications only."nIf an
                                              application does not appear in this list, it can still be
                                              faulted in some Chaos iteration if the application ends
                                              up on a node of a node type that is included in
                                              NodeTypeInclusionList."nHowever, if applicationX is tied
                                              to nodeTypeY through placement constraints and
                                              applicationX is absent from ApplicationInclusionList and
                                              nodeTypeY is absent from NodeTypeInclusionList, then
                                              applicationX will never be faulted."nAt most 1000
                                              application names can be included in this list, to
                                              increase this number, a config upgrade is required for
                                              MaxNumberOfApplicationsInChaosEntityFilter configuration.
                                        ],
                                        "NodeTypeInclusionList": [
                                            "str"  # Optional. A list of
                                              node types to include in Chaos faults."nAll types of
                                              faults (restart node, restart code package, remove
                                              replica, restart replica, move primary, and move
                                              secondary) are enabled for the nodes of these node
                                              types."nIf a node type (say NodeTypeX) does not appear in
                                              the NodeTypeInclusionList, then node level faults (like
                                              NodeRestart) will never be enabled for the nodes
                                              of"nNodeTypeX, but code package and replica faults can
                                              still be enabled for NodeTypeX if an application in the
                                              ApplicationInclusionList."nhappens to reside on a node of
                                              NodeTypeX."nAt most 100 node type names can be included
                                              in this list, to increase this number, a config upgrade
                                              is required for MaxNumberOfNodeTypesInChaosEntityFilter
                                              configuration.
                                        ]
                                    },
                                    "ClusterHealthPolicy": {
                                        "ApplicationTypeHealthPolicyMap": [
                                            {
                                                "Key": "str",  #
                                                  Required. The key of the application type health
                                                  policy map item. This is the name of the application
                                                  type.
                                                "Value": 0  #
                                                  Required. The value of the application type health
                                                  policy map item."nThe max percent unhealthy
                                                  applications allowed for the application type. Must
                                                  be between zero and 100.
                                            }
                                        ],
                                        "ConsiderWarningAsError": bool,  #
                                          Optional. Indicates whether warnings are treated with the
                                          same severity as errors.
                                        "MaxPercentUnhealthyApplications": 0,
                                          # Optional. The maximum allowed percentage of unhealthy
                                          applications before reporting an error. For example, to allow
                                          10% of applications to be unhealthy, this value would be
                                          10."n"nThe percentage represents the maximum tolerated
                                          percentage of applications that can be unhealthy before the
                                          cluster is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy application,
                                          the health is evaluated as Warning."nThis is calculated by
                                          dividing the number of unhealthy applications over the total
                                          number of application instances in the cluster, excluding
                                          applications of application types that are included in the
                                          ApplicationTypeHealthPolicyMap."nThe computation rounds up to
                                          tolerate one failure on small numbers of applications.
                                          Default percentage is zero.
                                        "MaxPercentUnhealthyNodes": 0,  #
                                          Optional. The maximum allowed percentage of unhealthy nodes
                                          before reporting an error. For example, to allow 10% of nodes
                                          to be unhealthy, this value would be 10."n"nThe percentage
                                          represents the maximum tolerated percentage of nodes that can
                                          be unhealthy before the cluster is considered in error."nIf
                                          the percentage is respected but there is at least one
                                          unhealthy node, the health is evaluated as Warning."nThe
                                          percentage is calculated by dividing the number of unhealthy
                                          nodes over the total number of nodes in the cluster."nThe
                                          computation rounds up to tolerate one failure on small
                                          numbers of nodes. Default percentage is zero."n"nIn large
                                          clusters, some nodes will always be down or out for repairs,
                                          so this percentage should be configured to tolerate that.
                                        "NodeTypeHealthPolicyMap": [
                                            {
                                                "Key": "str",  #
                                                  Required. The key of the node type health policy map
                                                  item. This is the name of the node type.
                                                "Value": 0  #
                                                  Required. The value of the node type health policy
                                                  map item."nIf the percentage is respected but there
                                                  is at least one unhealthy node in the node type, the
                                                  health is evaluated as Warning. "nThe percentage is
                                                  calculated by dividing the number of unhealthy nodes
                                                  over the total number of nodes in the node type.
                                                  "nThe computation rounds up to tolerate one failure
                                                  on small numbers of nodes."nThe max percent unhealthy
                                                  nodes allowed for the node type. Must be between zero
                                                  and 100.
                                            }
                                        ]
                                    },
                                    "Context": {
                                        "Map": {
                                            "str": "str"  # Optional.
                                              Describes a map that contains a collection of
                                              ChaosContextMapItem's.
                                        }
                                    },
                                    "EnableMoveReplicaFaults": True,  # Optional.
                                      Default value is True. Enables or disables the move primary and
                                      move secondary faults.
                                    "MaxClusterStabilizationTimeoutInSeconds":
                                      60,  # Optional. Default value is 60. The maximum amount of time
                                      to wait for all cluster entities to become stable and healthy.
                                      Chaos executes in iterations and at the start of each iteration
                                      it validates the health of cluster entities."nDuring validation
                                      if a cluster entity is not stable and healthy within
                                      MaxClusterStabilizationTimeoutInSeconds, Chaos generates a
                                      validation failed event.
                                    "MaxConcurrentFaults": 1,  # Optional.
                                      Default value is 1. MaxConcurrentFaults is the maximum number of
                                      concurrent faults induced per iteration."nChaos executes in
                                      iterations and two consecutive iterations are separated by a
                                      validation phase."nThe higher the concurrency, the more
                                      aggressive the injection of faults, leading to inducing more
                                      complex series of states to uncover bugs."nThe recommendation is
                                      to start with a value of 2 or 3 and to exercise caution while
                                      moving up.
                                    "TimeToRunInSeconds": "4294967295",  #
                                      Optional. Default value is "4294967295". Total time (in seconds)
                                      for which Chaos will run before automatically stopping. The
                                      maximum allowed value is 4,294,967,295 (System.UInt32.MaxValue).
                                    "WaitTimeBetweenFaultsInSeconds": 20,  #
                                      Optional. Default value is 20. Wait time (in seconds) between
                                      consecutive faults within a single iteration."nThe larger the
                                      value, the lower the overlapping between faults and the simpler
                                      the sequence of state transitions that the cluster goes
                                      through."nThe recommendation is to start with a value between 1
                                      and 5 and exercise caution while moving up.
                                    "WaitTimeBetweenIterationsInSeconds": 30  #
                                      Optional. Default value is 30. Time-separation (in seconds)
                                      between two consecutive iterations of Chaos."nThe larger the
                                      value, the lower the fault injection rate.
                                }
                            }
                        ],
                        "ExpiryDate": "9999-12-31T23:59:59.999Z",  # Optional. Default value
                          is "9999-12-31T23:59:59.999Z". The date and time Chaos will continue to use
                          this schedule until.
                        "Jobs": [
                            {
                                "ChaosParameters": "str",  # Optional. A reference to
                                  which Chaos Parameters of the Chaos Schedule to use.
                                "Days": {
                                    "Friday": bool,  # Optional. Indicates if the
                                      Chaos Schedule Job will run on Friday.
                                    "Monday": bool,  # Optional. Indicates if the
                                      Chaos Schedule Job will run on Monday.
                                    "Saturday": bool,  # Optional. Indicates if
                                      the Chaos Schedule Job will run on Saturday.
                                    "Sunday": bool,  # Optional. Indicates if the
                                      Chaos Schedule Job will run on Sunday.
                                    "Thursday": bool,  # Optional. Indicates if
                                      the Chaos Schedule Job will run on Thursday.
                                    "Tuesday": bool,  # Optional. Indicates if
                                      the Chaos Schedule Job will run on Tuesday.
                                    "Wednesday": bool  # Optional. Indicates if
                                      the Chaos Schedule Job will run on Wednesday.
                                },
                                "Times": [
                                    {
                                        "EndTime": {
                                            "Hour": 0,  # Optional.
                                              Represents the hour of the day. Value must be between 0
                                              and 23 inclusive.
                                            "Minute": 0  # Optional.
                                              Represents the minute of the hour. Value must be between
                                              0 to 59 inclusive.
                                        },
                                        "StartTime": {
                                            "Hour": 0,  # Optional.
                                              Represents the hour of the day. Value must be between 0
                                              and 23 inclusive.
                                            "Minute": 0  # Optional.
                                              Represents the minute of the hour. Value must be between
                                              0 to 59 inclusive.
                                        }
                                    }
                                ]
                            }
                        ],
                        "StartDate": "1601-01-01T00:00:00Z"  # Optional. Default value is
                          "1601-01-01T00:00:00Z". The date and time Chaos will start using this
                          schedule.
                    },
                    "Version": 0  # Optional. The version number of the Schedule.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.2"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_chaos_schedule_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def post_chaos_schedule(  # pylint: disable=inconsistent-return-statements
        self,
        chaos_schedule: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Set the schedule used by Chaos.

        Chaos will automatically schedule runs based on the Chaos Schedule.
        The Chaos Schedule will be updated if the provided version matches the version on the server.
        When updating the Chaos Schedule, the version on the server is incremented by 1.
        The version on the server will wrap back to 0 after reaching a large number.
        If Chaos is running when this call is made, the call will fail.

        :param chaos_schedule: Describes the schedule used by Chaos.
        :type chaos_schedule: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.2'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.2". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                chaos_schedule = {
                    "Schedule": {
                        "ChaosParametersDictionary": [
                            {
                                "Key": "str",  # Required. The key identifying the
                                  Chaos Parameter in the dictionary. This key is referenced by Chaos
                                  Schedule Jobs.
                                "Value": {
                                    "ChaosTargetFilter": {
                                        "ApplicationInclusionList": [
                                            "str"  # Optional. A list of
                                              application URIs to include in Chaos faults."nAll
                                              replicas belonging to services of these applications are
                                              amenable to replica faults (restart replica, remove
                                              replica, move primary, and move secondary) by
                                              Chaos."nChaos may restart a code package only if the code
                                              package hosts replicas of these applications only."nIf an
                                              application does not appear in this list, it can still be
                                              faulted in some Chaos iteration if the application ends
                                              up on a node of a node type that is included in
                                              NodeTypeInclusionList."nHowever, if applicationX is tied
                                              to nodeTypeY through placement constraints and
                                              applicationX is absent from ApplicationInclusionList and
                                              nodeTypeY is absent from NodeTypeInclusionList, then
                                              applicationX will never be faulted."nAt most 1000
                                              application names can be included in this list, to
                                              increase this number, a config upgrade is required for
                                              MaxNumberOfApplicationsInChaosEntityFilter configuration.
                                        ],
                                        "NodeTypeInclusionList": [
                                            "str"  # Optional. A list of
                                              node types to include in Chaos faults."nAll types of
                                              faults (restart node, restart code package, remove
                                              replica, restart replica, move primary, and move
                                              secondary) are enabled for the nodes of these node
                                              types."nIf a node type (say NodeTypeX) does not appear in
                                              the NodeTypeInclusionList, then node level faults (like
                                              NodeRestart) will never be enabled for the nodes
                                              of"nNodeTypeX, but code package and replica faults can
                                              still be enabled for NodeTypeX if an application in the
                                              ApplicationInclusionList."nhappens to reside on a node of
                                              NodeTypeX."nAt most 100 node type names can be included
                                              in this list, to increase this number, a config upgrade
                                              is required for MaxNumberOfNodeTypesInChaosEntityFilter
                                              configuration.
                                        ]
                                    },
                                    "ClusterHealthPolicy": {
                                        "ApplicationTypeHealthPolicyMap": [
                                            {
                                                "Key": "str",  #
                                                  Required. The key of the application type health
                                                  policy map item. This is the name of the application
                                                  type.
                                                "Value": 0  #
                                                  Required. The value of the application type health
                                                  policy map item."nThe max percent unhealthy
                                                  applications allowed for the application type. Must
                                                  be between zero and 100.
                                            }
                                        ],
                                        "ConsiderWarningAsError": bool,  #
                                          Optional. Indicates whether warnings are treated with the
                                          same severity as errors.
                                        "MaxPercentUnhealthyApplications": 0,
                                          # Optional. The maximum allowed percentage of unhealthy
                                          applications before reporting an error. For example, to allow
                                          10% of applications to be unhealthy, this value would be
                                          10."n"nThe percentage represents the maximum tolerated
                                          percentage of applications that can be unhealthy before the
                                          cluster is considered in error."nIf the percentage is
                                          respected but there is at least one unhealthy application,
                                          the health is evaluated as Warning."nThis is calculated by
                                          dividing the number of unhealthy applications over the total
                                          number of application instances in the cluster, excluding
                                          applications of application types that are included in the
                                          ApplicationTypeHealthPolicyMap."nThe computation rounds up to
                                          tolerate one failure on small numbers of applications.
                                          Default percentage is zero.
                                        "MaxPercentUnhealthyNodes": 0,  #
                                          Optional. The maximum allowed percentage of unhealthy nodes
                                          before reporting an error. For example, to allow 10% of nodes
                                          to be unhealthy, this value would be 10."n"nThe percentage
                                          represents the maximum tolerated percentage of nodes that can
                                          be unhealthy before the cluster is considered in error."nIf
                                          the percentage is respected but there is at least one
                                          unhealthy node, the health is evaluated as Warning."nThe
                                          percentage is calculated by dividing the number of unhealthy
                                          nodes over the total number of nodes in the cluster."nThe
                                          computation rounds up to tolerate one failure on small
                                          numbers of nodes. Default percentage is zero."n"nIn large
                                          clusters, some nodes will always be down or out for repairs,
                                          so this percentage should be configured to tolerate that.
                                        "NodeTypeHealthPolicyMap": [
                                            {
                                                "Key": "str",  #
                                                  Required. The key of the node type health policy map
                                                  item. This is the name of the node type.
                                                "Value": 0  #
                                                  Required. The value of the node type health policy
                                                  map item."nIf the percentage is respected but there
                                                  is at least one unhealthy node in the node type, the
                                                  health is evaluated as Warning. "nThe percentage is
                                                  calculated by dividing the number of unhealthy nodes
                                                  over the total number of nodes in the node type.
                                                  "nThe computation rounds up to tolerate one failure
                                                  on small numbers of nodes."nThe max percent unhealthy
                                                  nodes allowed for the node type. Must be between zero
                                                  and 100.
                                            }
                                        ]
                                    },
                                    "Context": {
                                        "Map": {
                                            "str": "str"  # Optional.
                                              Describes a map that contains a collection of
                                              ChaosContextMapItem's.
                                        }
                                    },
                                    "EnableMoveReplicaFaults": True,  # Optional.
                                      Default value is True. Enables or disables the move primary and
                                      move secondary faults.
                                    "MaxClusterStabilizationTimeoutInSeconds":
                                      60,  # Optional. Default value is 60. The maximum amount of time
                                      to wait for all cluster entities to become stable and healthy.
                                      Chaos executes in iterations and at the start of each iteration
                                      it validates the health of cluster entities."nDuring validation
                                      if a cluster entity is not stable and healthy within
                                      MaxClusterStabilizationTimeoutInSeconds, Chaos generates a
                                      validation failed event.
                                    "MaxConcurrentFaults": 1,  # Optional.
                                      Default value is 1. MaxConcurrentFaults is the maximum number of
                                      concurrent faults induced per iteration."nChaos executes in
                                      iterations and two consecutive iterations are separated by a
                                      validation phase."nThe higher the concurrency, the more
                                      aggressive the injection of faults, leading to inducing more
                                      complex series of states to uncover bugs."nThe recommendation is
                                      to start with a value of 2 or 3 and to exercise caution while
                                      moving up.
                                    "TimeToRunInSeconds": "4294967295",  #
                                      Optional. Default value is "4294967295". Total time (in seconds)
                                      for which Chaos will run before automatically stopping. The
                                      maximum allowed value is 4,294,967,295 (System.UInt32.MaxValue).
                                    "WaitTimeBetweenFaultsInSeconds": 20,  #
                                      Optional. Default value is 20. Wait time (in seconds) between
                                      consecutive faults within a single iteration."nThe larger the
                                      value, the lower the overlapping between faults and the simpler
                                      the sequence of state transitions that the cluster goes
                                      through."nThe recommendation is to start with a value between 1
                                      and 5 and exercise caution while moving up.
                                    "WaitTimeBetweenIterationsInSeconds": 30  #
                                      Optional. Default value is 30. Time-separation (in seconds)
                                      between two consecutive iterations of Chaos."nThe larger the
                                      value, the lower the fault injection rate.
                                }
                            }
                        ],
                        "ExpiryDate": "9999-12-31T23:59:59.999Z",  # Optional. Default value
                          is "9999-12-31T23:59:59.999Z". The date and time Chaos will continue to use
                          this schedule until.
                        "Jobs": [
                            {
                                "ChaosParameters": "str",  # Optional. A reference to
                                  which Chaos Parameters of the Chaos Schedule to use.
                                "Days": {
                                    "Friday": bool,  # Optional. Indicates if the
                                      Chaos Schedule Job will run on Friday.
                                    "Monday": bool,  # Optional. Indicates if the
                                      Chaos Schedule Job will run on Monday.
                                    "Saturday": bool,  # Optional. Indicates if
                                      the Chaos Schedule Job will run on Saturday.
                                    "Sunday": bool,  # Optional. Indicates if the
                                      Chaos Schedule Job will run on Sunday.
                                    "Thursday": bool,  # Optional. Indicates if
                                      the Chaos Schedule Job will run on Thursday.
                                    "Tuesday": bool,  # Optional. Indicates if
                                      the Chaos Schedule Job will run on Tuesday.
                                    "Wednesday": bool  # Optional. Indicates if
                                      the Chaos Schedule Job will run on Wednesday.
                                },
                                "Times": [
                                    {
                                        "EndTime": {
                                            "Hour": 0,  # Optional.
                                              Represents the hour of the day. Value must be between 0
                                              and 23 inclusive.
                                            "Minute": 0  # Optional.
                                              Represents the minute of the hour. Value must be between
                                              0 to 59 inclusive.
                                        },
                                        "StartTime": {
                                            "Hour": 0,  # Optional.
                                              Represents the hour of the day. Value must be between 0
                                              and 23 inclusive.
                                            "Minute": 0  # Optional.
                                              Represents the minute of the hour. Value must be between
                                              0 to 59 inclusive.
                                        }
                                    }
                                ]
                            }
                        ],
                        "StartDate": "1601-01-01T00:00:00Z"  # Optional. Default value is
                          "1601-01-01T00:00:00Z". The date and time Chaos will start using this
                          schedule.
                    },
                    "Version": 0  # Optional. The version number of the Schedule.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.2"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = chaos_schedule

        request = build_post_chaos_schedule_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def upload_file(  # pylint: disable=inconsistent-return-statements
        self,
        content_path: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Uploads contents of the file to the image store.

        Uploads contents of the file to the image store. Use this API if the file is small enough to
        upload again if the connection fails. The file's data needs to be added to the request body.
        The contents will be uploaded to the specified path. Image store service uses a mark file to
        indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark
        file is generated by the image store service when all files in a folder are uploaded. When
        using File-by-File approach to upload application package in REST, the image store service
        isn't aware of the file hierarchy of the application package; you need to create a mark file
        per folder and upload it last, to let the image store service know that the folder is complete.

        :param content_path: Relative path to file or folder in the image store from its root.
        :type content_path: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_upload_file_request(
            content_path=content_path,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_image_store_content(
        self,
        content_path: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the image store content information.

        Returns the information about the image store content at the specified contentPath. The
        contentPath is relative to the root of the image store.

        :param content_path: Relative path to file or folder in the image store from its root.
        :type content_path: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.2'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.2". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "StoreFiles": [
                        {
                            "FileSize": "str",  # Optional. The size of file in bytes.
                            "FileVersion": {
                                "EpochConfigurationNumber": "str",  # Optional. The
                                  epoch configuration version number of the image store replica when
                                  this file entry was created or updated.
                                "EpochDataLossNumber": "str",  # Optional. The epoch
                                  data loss number of image store replica when this file entry was
                                  updated or created.
                                "VersionNumber": "str"  # Optional. The current image
                                  store version number for the file is used in image store for checking
                                  whether it need to be updated.
                            },
                            "ModifiedDate": "2020-02-20 00:00:00",  # Optional. The date
                              and time when the image store file was last modified.
                            "StoreRelativePath": "str"  # Optional. The file path
                              relative to the image store root path.
                        }
                    ],
                    "StoreFolders": [
                        {
                            "FileCount": "str",  # Optional. The number of files from
                              within the image store folder.
                            "StoreRelativePath": "str"  # Optional. The remote location
                              within image store. This path is relative to the image store root.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.2"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_image_store_content_request(
            content_path=content_path,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def delete_image_store_content(  # pylint: disable=inconsistent-return-statements
        self,
        content_path: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Deletes existing image store content.

        Deletes existing image store content being found within the given image store relative path.
        This command can be used to delete uploaded application packages once they are provisioned.

        :param content_path: Relative path to file or folder in the image store from its root.
        :type content_path: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_delete_image_store_content_request(
            content_path=content_path,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_image_store_root_content(
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the content information at the root of the image store.

        Returns the information about the image store content at the root of the image store.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "StoreFiles": [
                        {
                            "FileSize": "str",  # Optional. The size of file in bytes.
                            "FileVersion": {
                                "EpochConfigurationNumber": "str",  # Optional. The
                                  epoch configuration version number of the image store replica when
                                  this file entry was created or updated.
                                "EpochDataLossNumber": "str",  # Optional. The epoch
                                  data loss number of image store replica when this file entry was
                                  updated or created.
                                "VersionNumber": "str"  # Optional. The current image
                                  store version number for the file is used in image store for checking
                                  whether it need to be updated.
                            },
                            "ModifiedDate": "2020-02-20 00:00:00",  # Optional. The date
                              and time when the image store file was last modified.
                            "StoreRelativePath": "str"  # Optional. The file path
                              relative to the image store root path.
                        }
                    ],
                    "StoreFolders": [
                        {
                            "FileCount": "str",  # Optional. The number of files from
                              within the image store folder.
                            "StoreRelativePath": "str"  # Optional. The remote location
                              within image store. This path is relative to the image store root.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_image_store_root_content_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def copy_image_store_content(  # pylint: disable=inconsistent-return-statements
        self,
        image_store_copy_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Copies image store content internally.

        Copies the image store content from the source image store relative path to the destination
        image store relative path.

        :param image_store_copy_description: Describes the copy description for the image store.
        :type image_store_copy_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                image_store_copy_description = {
                    "CheckMarkFile": bool,  # Optional. Indicates whether to check mark file
                      during copying. The property is true if checking mark file is required, false
                      otherwise. The mark file is used to check whether the folder is well constructed.
                      If the property is true and mark file does not exist, the copy is skipped.
                    "RemoteDestination": "str",  # Required. The relative path of destination
                      image store content to be copied to.
                    "RemoteSource": "str",  # Required. The relative path of source image store
                      content to be copied from.
                    "SkipFiles": [
                        "str"  # Optional. The list of the file names to be skipped for
                          copying.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = image_store_copy_description

        request = build_copy_image_store_content_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def delete_image_store_upload_session(  # pylint: disable=inconsistent-return-statements
        self,
        *,
        session_id: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Cancels an image store upload session.

        The DELETE request will cause the existing upload session to expire and remove any previously
        uploaded file chunks.

        :keyword session_id: A GUID generated by the user for a file uploading. It identifies an image
         store upload session which keeps track of all file chunks until it is committed.
        :paramtype session_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_delete_image_store_upload_session_request(
            api_version=api_version,
            session_id=session_id,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def commit_image_store_upload_session(  # pylint: disable=inconsistent-return-statements
        self,
        *,
        session_id: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Commit an image store upload session.

        When all file chunks have been uploaded, the upload session needs to be committed explicitly to
        complete the upload. Image store preserves the upload session until the expiration time, which
        is 30 minutes after the last chunk received.

        :keyword session_id: A GUID generated by the user for a file uploading. It identifies an image
         store upload session which keeps track of all file chunks until it is committed.
        :paramtype session_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_commit_image_store_upload_session_request(
            api_version=api_version,
            session_id=session_id,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_image_store_upload_session_by_id(
        self,
        *,
        session_id: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Get the image store upload session by ID.

        Gets the image store upload session identified by the given ID. User can query the upload
        session at any time during uploading.

        :keyword session_id: A GUID generated by the user for a file uploading. It identifies an image
         store upload session which keeps track of all file chunks until it is committed.
        :paramtype session_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "UploadSessions": [
                        {
                            "ExpectedRanges": [
                                {
                                    "EndPosition": "str",  # Optional. The end
                                      position of the portion of the file. It's represented by the
                                      number of bytes.
                                    "StartPosition": "str"  # Optional. The start
                                      position of the portion of the file. It's represented by the
                                      number of bytes.
                                }
                            ],
                            "FileSize": "str",  # Optional. The size in bytes of the
                              uploading file.
                            "ModifiedDate": "2020-02-20 00:00:00",  # Optional. The date
                              and time when the upload session was last modified.
                            "SessionId": str,  # Optional. A unique ID of the upload
                              session. A session ID can be reused only if the session was committed or
                              removed.
                            "StoreRelativePath": "str"  # Optional. The remote location
                              within image store. This path is relative to the image store root.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_image_store_upload_session_by_id_request(
            api_version=api_version,
            session_id=session_id,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_image_store_upload_session_by_path(
        self,
        content_path: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Get the image store upload session by relative path.

        Gets the image store upload session associated with the given image store relative path. User
        can query the upload session at any time during uploading.

        :param content_path: Relative path to file or folder in the image store from its root.
        :type content_path: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "UploadSessions": [
                        {
                            "ExpectedRanges": [
                                {
                                    "EndPosition": "str",  # Optional. The end
                                      position of the portion of the file. It's represented by the
                                      number of bytes.
                                    "StartPosition": "str"  # Optional. The start
                                      position of the portion of the file. It's represented by the
                                      number of bytes.
                                }
                            ],
                            "FileSize": "str",  # Optional. The size in bytes of the
                              uploading file.
                            "ModifiedDate": "2020-02-20 00:00:00",  # Optional. The date
                              and time when the upload session was last modified.
                            "SessionId": str,  # Optional. A unique ID of the upload
                              session. A session ID can be reused only if the session was committed or
                              removed.
                            "StoreRelativePath": "str"  # Optional. The remote location
                              within image store. This path is relative to the image store root.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_image_store_upload_session_by_path_request(
            content_path=content_path,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def upload_file_chunk(  # pylint: disable=inconsistent-return-statements
        self,
        content_path: str,
        *,
        session_id: str,
        content_range: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Uploads a file chunk to the image store relative path.

        Uploads a file chunk to the image store with the specified upload session ID and image store
        relative path. This API allows user to resume the file upload operation. user doesn't have to
        restart the file upload from scratch whenever there is a network interruption. Use this option
        if the file size is large.

        To perform a resumable file upload, user need to break the file into multiple chunks and upload
        these chunks to the image store one-by-one. Chunks don't have to be uploaded in order. If the
        file represented by the image store relative path already exists, it will be overwritten when
        the upload session commits.

        :param content_path: Relative path to file or folder in the image store from its root.
        :type content_path: str
        :keyword session_id: A GUID generated by the user for a file uploading. It identifies an image
         store upload session which keeps track of all file chunks until it is committed.
        :paramtype session_id: str
        :keyword content_range: When uploading file chunks to the image store, the Content-Range header
         field need to be configured and sent with a request. The format should looks like "bytes
         {First-Byte-Position}-{Last-Byte-Position}/{File-Length}". For example, Content-Range:bytes
         300-5000/20000 indicates that user is sending bytes 300 through 5,000 and the total file length
         is 20,000 bytes.
        :paramtype content_range: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_upload_file_chunk_request(
            content_path=content_path,
            api_version=api_version,
            session_id=session_id,
            content_range=content_range,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_image_store_root_folder_size(
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Get the folder size at the root of the image store.

        Returns the total size of files at the root and children folders in image store.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.5'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.5". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "FolderSize": "str",  # Optional. The size of folder in bytes.
                    "StoreRelativePath": "str"  # Optional. The remote location within image
                      store. This path is relative to the image store root.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.5"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_image_store_root_folder_size_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_image_store_folder_size(
        self,
        content_path: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Get the size of a folder in image store.

        Gets the total size of file under a image store folder, specified by contentPath. The
        contentPath is relative to the root of the image store.

        :param content_path: Relative path to file or folder in the image store from its root.
        :type content_path: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.5'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.5". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "FolderSize": "str",  # Optional. The size of folder in bytes.
                    "StoreRelativePath": "str"  # Optional. The remote location within image
                      store. This path is relative to the image store root.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.5"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_image_store_folder_size_request(
            content_path=content_path,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_image_store_info(
        self,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the overall ImageStore information.

        Returns information about the primary ImageStore replica, such as disk capacity and available
        disk space at the node it is on, and several categories of the ImageStore's file system usage.

        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.5'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.5". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "DiskInfo": {
                        "AvailableSpace": "str",  # Optional. the available disk space in
                          bytes.
                        "Capacity": "str"  # Optional. the disk size in bytes.
                    },
                    "UsedByCopy": {
                        "FileCount": "str",  # Optional. the number of all files in this
                          category.
                        "UsedSpace": "str"  # Optional. the size of all files in this
                          category.
                    },
                    "UsedByMetadata": {
                        "FileCount": "str",  # Optional. the number of all files in this
                          category.
                        "UsedSpace": "str"  # Optional. the size of all files in this
                          category.
                    },
                    "UsedByRegister": {
                        "FileCount": "str",  # Optional. the number of all files in this
                          category.
                        "UsedSpace": "str"  # Optional. the size of all files in this
                          category.
                    },
                    "UsedByStaging": {
                        "FileCount": "str",  # Optional. the number of all files in this
                          category.
                        "UsedSpace": "str"  # Optional. the size of all files in this
                          category.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.5"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_image_store_info_request(
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def invoke_infrastructure_command(
        self,
        *,
        command: str,
        service_id: Optional[str] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> str:
        """Invokes an administrative command on the given Infrastructure Service instance.

        For clusters that have one or more instances of the Infrastructure Service configured,
        this API provides a way to send infrastructure-specific commands to a particular
        instance of the Infrastructure Service.

        Available commands and their corresponding response formats vary depending upon
        the infrastructure on which the cluster is running.

        This API supports the Service Fabric platform; it is not meant to be used directly from your
        code.

        :keyword command: The text of the command to be invoked. The content of the command is
         infrastructure-specific.
        :paramtype command: str
        :keyword service_id: The identity of the infrastructure service. This is the full name of the
         infrastructure service without the 'fabric:' URI scheme. This parameter required only for the
         cluster that has more than one instance of infrastructure service running. Default value is
         None.
        :paramtype service_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: str
        :rtype: str
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[str]

        
        request = build_invoke_infrastructure_command_request(
            api_version=api_version,
            command=command,
            service_id=service_id,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(str, deserialized), {})

        return cast(str, deserialized)



    @distributed_trace_async
    async def invoke_infrastructure_query(
        self,
        *,
        command: str,
        service_id: Optional[str] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> str:
        """Invokes a read-only query on the given infrastructure service instance.

        For clusters that have one or more instances of the Infrastructure Service configured,
        this API provides a way to send infrastructure-specific queries to a particular
        instance of the Infrastructure Service.

        Available commands and their corresponding response formats vary depending upon
        the infrastructure on which the cluster is running.

        This API supports the Service Fabric platform; it is not meant to be used directly from your
        code.

        :keyword command: The text of the command to be invoked. The content of the command is
         infrastructure-specific.
        :paramtype command: str
        :keyword service_id: The identity of the infrastructure service. This is the full name of the
         infrastructure service without the 'fabric:' URI scheme. This parameter required only for the
         cluster that has more than one instance of infrastructure service running. Default value is
         None.
        :paramtype service_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: str
        :rtype: str
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[str]

        
        request = build_invoke_infrastructure_query_request(
            api_version=api_version,
            command=command,
            service_id=service_id,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(str, deserialized), {})

        return cast(str, deserialized)



    @distributed_trace_async
    async def start_data_loss(  # pylint: disable=inconsistent-return-statements
        self,
        service_id: str,
        partition_id: str,
        *,
        operation_id: str,
        data_loss_mode: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """This API will induce data loss for the specified partition. It will trigger a call to the
        OnDataLossAsync API of the partition.

        This API will induce data loss for the specified partition. It will trigger a call to the
        OnDataLoss API of the partition.
        Actual data loss will depend on the specified DataLossMode.


        * PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the
        partition but actual data loss depends on the presence of in-flight replication.
        * FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.

        This API should only be called with a stateful service as the target.

        Calling this API with a system service as the target is not advised.

        Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only
        stop execution and clean up internal system state.
        It will not restore data if the command has progressed far enough to cause data loss.

        Call the GetDataLossProgress API with the same OperationId to return information on the
        operation started with this API.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword operation_id: A GUID that identifies a call of this API.  This is passed into the
         corresponding GetProgress API.
        :paramtype operation_id: str
        :keyword data_loss_mode: This enum is passed to the StartDataLoss API to indicate what type of
         data loss to induce. Known values are: "Invalid", "PartialDataLoss", and "FullDataLoss".
        :paramtype data_loss_mode: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_start_data_loss_request(
            service_id=service_id,
            partition_id=partition_id,
            api_version=api_version,
            operation_id=operation_id,
            data_loss_mode=data_loss_mode,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_data_loss_progress(
        self,
        service_id: str,
        partition_id: str,
        *,
        operation_id: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the progress of a partition data loss operation started using the StartDataLoss API.

        Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword operation_id: A GUID that identifies a call of this API.  This is passed into the
         corresponding GetProgress API.
        :paramtype operation_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "InvokeDataLossResult": {
                        "ErrorCode": 0,  # Optional. If OperationState is Completed, this is
                          0.  If OperationState is Faulted, this is an error code indicating the
                          reason.
                        "SelectedPartition": {
                            "PartitionId": str,  # Optional. An internal ID used by
                              Service Fabric to uniquely identify a partition. This is a randomly
                              generated GUID when the service was created. The partition ID is unique
                              and does not change for the lifetime of the service. If the same service
                              was deleted and recreated the IDs of its partitions would be different.
                            "ServiceName": "str"  # Optional. The name of the service the
                              partition belongs to.
                        }
                    },
                    "State": "str"  # Optional. The state of the operation. Known values are:
                      "Invalid", "Running", "RollingBack", "Completed", "Faulted", "Cancelled",
                      "ForceCancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_data_loss_progress_request(
            service_id=service_id,
            partition_id=partition_id,
            api_version=api_version,
            operation_id=operation_id,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def start_quorum_loss(  # pylint: disable=inconsistent-return-statements
        self,
        service_id: str,
        partition_id: str,
        *,
        operation_id: str,
        quorum_loss_mode: str,
        quorum_loss_duration: int,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Induces quorum loss for a given stateful service partition.

        This API is useful for a temporary quorum loss situation on your service.

        Call the GetQuorumLossProgress API with the same OperationId to return information on the
        operation started with this API.

        This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use
        this API on stateless services or stateful in-memory only services.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword operation_id: A GUID that identifies a call of this API.  This is passed into the
         corresponding GetProgress API.
        :paramtype operation_id: str
        :keyword quorum_loss_mode: This enum is passed to the StartQuorumLoss API to indicate what type
         of quorum loss to induce. Known values are: "Invalid", "QuorumReplicas", and "AllReplicas".
        :paramtype quorum_loss_mode: str
        :keyword quorum_loss_duration: The amount of time for which the partition will be kept in
         quorum loss.  This must be specified in seconds.
        :paramtype quorum_loss_duration: int
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_start_quorum_loss_request(
            service_id=service_id,
            partition_id=partition_id,
            api_version=api_version,
            operation_id=operation_id,
            quorum_loss_mode=quorum_loss_mode,
            quorum_loss_duration=quorum_loss_duration,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_quorum_loss_progress(
        self,
        service_id: str,
        partition_id: str,
        *,
        operation_id: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the progress of a quorum loss operation on a partition started using the StartQuorumLoss
        API.

        Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided
        OperationId.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword operation_id: A GUID that identifies a call of this API.  This is passed into the
         corresponding GetProgress API.
        :paramtype operation_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "InvokeQuorumLossResult": {
                        "ErrorCode": 0,  # Optional. If OperationState is Completed, this is
                          0.  If OperationState is Faulted, this is an error code indicating the
                          reason.
                        "SelectedPartition": {
                            "PartitionId": str,  # Optional. An internal ID used by
                              Service Fabric to uniquely identify a partition. This is a randomly
                              generated GUID when the service was created. The partition ID is unique
                              and does not change for the lifetime of the service. If the same service
                              was deleted and recreated the IDs of its partitions would be different.
                            "ServiceName": "str"  # Optional. The name of the service the
                              partition belongs to.
                        }
                    },
                    "State": "str"  # Optional. The state of the operation. Known values are:
                      "Invalid", "Running", "RollingBack", "Completed", "Faulted", "Cancelled",
                      "ForceCancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_quorum_loss_progress_request(
            service_id=service_id,
            partition_id=partition_id,
            api_version=api_version,
            operation_id=operation_id,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def start_partition_restart(  # pylint: disable=inconsistent-return-statements
        self,
        service_id: str,
        partition_id: str,
        *,
        operation_id: str,
        restart_partition_mode: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """This API will restart some or all replicas or instances of the specified partition.

        This API is useful for testing failover.

        If used to target a stateless service partition, RestartPartitionMode must be
        AllReplicasOrInstances.

        Call the GetPartitionRestartProgress API using the same OperationId to get the progress.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword operation_id: A GUID that identifies a call of this API.  This is passed into the
         corresponding GetProgress API.
        :paramtype operation_id: str
        :keyword restart_partition_mode: Describe which partitions to restart. Known values are:
         "Invalid", "AllReplicasOrInstances", and "OnlyActiveSecondaries".
        :paramtype restart_partition_mode: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_start_partition_restart_request(
            service_id=service_id,
            partition_id=partition_id,
            api_version=api_version,
            operation_id=operation_id,
            restart_partition_mode=restart_partition_mode,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_partition_restart_progress(
        self,
        service_id: str,
        partition_id: str,
        *,
        operation_id: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the progress of a PartitionRestart operation started using StartPartitionRestart.

        Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided
        OperationId.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword operation_id: A GUID that identifies a call of this API.  This is passed into the
         corresponding GetProgress API.
        :paramtype operation_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "RestartPartitionResult": {
                        "ErrorCode": 0,  # Optional. If OperationState is Completed, this is
                          0.  If OperationState is Faulted, this is an error code indicating the
                          reason.
                        "SelectedPartition": {
                            "PartitionId": str,  # Optional. An internal ID used by
                              Service Fabric to uniquely identify a partition. This is a randomly
                              generated GUID when the service was created. The partition ID is unique
                              and does not change for the lifetime of the service. If the same service
                              was deleted and recreated the IDs of its partitions would be different.
                            "ServiceName": "str"  # Optional. The name of the service the
                              partition belongs to.
                        }
                    },
                    "State": "str"  # Optional. The state of the operation. Known values are:
                      "Invalid", "Running", "RollingBack", "Completed", "Faulted", "Cancelled",
                      "ForceCancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_partition_restart_progress_request(
            service_id=service_id,
            partition_id=partition_id,
            api_version=api_version,
            operation_id=operation_id,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def start_node_transition(  # pylint: disable=inconsistent-return-statements
        self,
        node_name: str,
        *,
        operation_id: str,
        node_transition_type: str,
        node_instance_id: str,
        stop_duration_in_seconds: int,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Starts or stops a cluster node.

        Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To
        start a node, pass in "Start" for the NodeTransitionType parameter.
        To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the
        operation - when the API returns the node may not have finished transitioning yet.
        Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.

        :param node_name: The name of the node.
        :type node_name: str
        :keyword operation_id: A GUID that identifies a call of this API.  This is passed into the
         corresponding GetProgress API.
        :paramtype operation_id: str
        :keyword node_transition_type: Indicates the type of transition to perform.
         NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node
         that is up. Known values are: "Invalid", "Start", and "Stop".
        :paramtype node_transition_type: str
        :keyword node_instance_id: The node instance ID of the target node.  This can be determined
         through GetNodeInfo API.
        :paramtype node_instance_id: str
        :keyword stop_duration_in_seconds: The duration, in seconds, to keep the node stopped.  The
         minimum value is 600, the maximum is 14400.  After this time expires, the node will
         automatically come back up.
        :paramtype stop_duration_in_seconds: int
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_start_node_transition_request(
            node_name=node_name,
            api_version=api_version,
            operation_id=operation_id,
            node_transition_type=node_transition_type,
            node_instance_id=node_instance_id,
            stop_duration_in_seconds=stop_duration_in_seconds,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_node_transition_progress(
        self,
        node_name: str,
        *,
        operation_id: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the progress of an operation started using StartNodeTransition.

        Gets the progress of an operation started with StartNodeTransition using the provided
        OperationId.

        :param node_name: The name of the node.
        :type node_name: str
        :keyword operation_id: A GUID that identifies a call of this API.  This is passed into the
         corresponding GetProgress API.
        :paramtype operation_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "NodeTransitionResult": {
                        "ErrorCode": 0,  # Optional. If OperationState is Completed, this is
                          0.  If OperationState is Faulted, this is an error code indicating the
                          reason.
                        "NodeResult": {
                            "NodeInstanceId": "str",  # Optional. The node instance id.
                            "NodeName": "str"  # Optional. The name of a Service Fabric
                              node.
                        }
                    },
                    "State": "str"  # Optional. The state of the operation. Known values are:
                      "Invalid", "Running", "RollingBack", "Completed", "Faulted", "Cancelled",
                      "ForceCancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_node_transition_progress_request(
            node_name=node_name,
            api_version=api_version,
            operation_id=operation_id,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_fault_operation_list(
        self,
        *,
        type_filter: int = 65535,
        state_filter: int = 65535,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets a list of user-induced fault operations filtered by provided input.

        Gets the list of user-induced fault operations filtered by provided input.

        :keyword type_filter: Used to filter on OperationType for user-induced operations.


         * 65535 - select all
         * 1 - select PartitionDataLoss.
         * 2 - select PartitionQuorumLoss.
         * 4 - select PartitionRestart.
         * 8 - select NodeTransition. Default value is 65535.
        :paramtype type_filter: int
        :keyword state_filter: Used to filter on OperationState's for user-induced operations.


         * 65535 - select All
         * 1 - select Running
         * 2 - select RollingBack
         * 8 - select Completed
         * 16 - select Faulted
         * 32 - select Cancelled
         * 64 - select ForceCancelled. Default value is 65535.
        :paramtype state_filter: int
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "OperationId": str,  # Optional. A GUID that identifies a call to
                          this API.  This is also passed into the corresponding GetProgress API.
                        "State": "str",  # Optional. The state of the operation. Known values
                          are: "Invalid", "Running", "RollingBack", "Completed", "Faulted",
                          "Cancelled", "ForceCancelled".
                        "Type": "str"  # Optional. The type of the operation. Known values
                          are: "Invalid", "PartitionDataLoss", "PartitionQuorumLoss",
                          "PartitionRestart", "NodeTransition".
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_fault_operation_list_request(
            api_version=api_version,
            type_filter=type_filter,
            state_filter=state_filter,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def cancel_operation(  # pylint: disable=inconsistent-return-statements
        self,
        *,
        operation_id: str,
        force: bool = False,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Cancels a user-induced fault operation.

        The following APIs start fault operations that may be cancelled by using CancelOperation:
        StartDataLoss, StartQuorumLoss, StartPartitionRestart, StartNodeTransition.

        If force is false, then the specified user-induced operation will be gracefully stopped and
        cleaned up.  If force is true, the command will be aborted, and some internal state
        may be left behind.  Specifying force as true should be used with care.  Calling this API with
        force set to true is not allowed until this API has already
        been called on the same test command with force set to false first, or unless the test command
        already has an OperationState of OperationState.RollingBack.
        Clarification: OperationState.RollingBack means that the system will be/is cleaning up internal
        system state caused by executing the command.  It will not restore data if the
        test command was to cause data loss.  For example, if you call StartDataLoss then call this
        API, the system will only clean up internal state from running the command.
        It will not restore the target partition's data, if the command progressed far enough to cause
        data loss.

        Important note:  if this API is invoked with force==true, internal state may be left behind.

        :keyword operation_id: A GUID that identifies a call of this API.  This is passed into the
         corresponding GetProgress API.
        :paramtype operation_id: str
        :keyword force: Indicates whether to gracefully roll back and clean up internal system state
         modified by executing the user-induced operation. Default value is False.
        :paramtype force: bool
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_cancel_operation_request(
            api_version=api_version,
            operation_id=operation_id,
            force=force,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def create_backup_policy(  # pylint: disable=inconsistent-return-statements
        self,
        backup_policy_description: JSON,
        *,
        timeout: Optional[int] = 60,
        validate_connection: Optional[bool] = False,
        **kwargs: Any
    ) -> None:
        """Creates a backup policy.

        Creates a backup policy which can be associated later with a Service Fabric application,
        service or a partition for periodic backup.

        :param backup_policy_description: Describes the backup policy.
        :type backup_policy_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword validate_connection: Specifies whether to validate the storage connection and
         credentials before creating or updating the backup policies. Default value is False.
        :paramtype validate_connection: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python


                # JSON input template you can fill out and use as your body input.
                backup_policy_description = {
                    "AutoRestoreOnDataLoss": bool,  # Required. Specifies whether to trigger
                      restore automatically using the latest available backup in case the partition
                      experiences a data loss event.
                    "MaxIncrementalBackups": 0,  # Required. Defines the maximum number of
                      incremental backups to be taken between two full backups. This is just the upper
                      limit. A full backup may be taken before specified number of incremental backups
                      are completed in one of the following conditions"n"n"n* The replica has never
                      taken a full backup since it has become primary,"n* Some of the log records since
                      the last backup has been truncated, or"n* Replica passed the
                      MaxAccumulatedBackupLogSizeInMB limit.
                    "Name": "str",  # Required. The unique name identifying this backup policy.
                    "RetentionPolicy": {
                        RetentionPolicyType: RetentionPolicyType
                    },
                    "Schedule": {
                        ScheduleKind: ScheduleKind
                    },
                    "Storage": {
                        "FriendlyName": "str",  # Optional. Friendly name for this backup
                          storage.
                        StorageKind: StorageKind
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = backup_policy_description

        request = build_create_backup_policy_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            validate_connection=validate_connection,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def delete_backup_policy(  # pylint: disable=inconsistent-return-statements
        self,
        backup_policy_name: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Deletes the backup policy.

        Deletes an existing backup policy. A backup policy must be created before it can be deleted. A
        currently active backup policy, associated with any Service Fabric application, service or
        partition, cannot be deleted without first deleting the mapping.

        :param backup_policy_name: The name of the backup policy.
        :type backup_policy_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_delete_backup_policy_request(
            backup_policy_name=backup_policy_name,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_backup_policy_list(
        self,
        *,
        continuation_token_parameter: Optional[str] = None,
        max_results: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets all the backup policies configured.

        Get a list of all the backup policies configured.

        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "AutoRestoreOnDataLoss": bool,  # Required. Specifies whether
                              to trigger restore automatically using the latest available backup in
                              case the partition experiences a data loss event.
                            "MaxIncrementalBackups": 0,  # Required. Defines the maximum
                              number of incremental backups to be taken between two full backups. This
                              is just the upper limit. A full backup may be taken before specified
                              number of incremental backups are completed in one of the following
                              conditions"n"n"n* The replica has never taken a full backup since it has
                              become primary,"n* Some of the log records since the last backup has been
                              truncated, or"n* Replica passed the MaxAccumulatedBackupLogSizeInMB
                              limit.
                            "Name": "str",  # Required. The unique name identifying this
                              backup policy.
                            "RetentionPolicy": {
                                RetentionPolicyType: RetentionPolicyType
                            },
                            "Schedule": {
                                ScheduleKind: ScheduleKind
                            },
                            "Storage": {
                                "FriendlyName": "str",  # Optional. Friendly name for
                                  this backup storage.
                                StorageKind: StorageKind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_backup_policy_list_request(
            api_version=api_version,
            continuation_token_parameter=continuation_token_parameter,
            max_results=max_results,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_backup_policy_by_name(
        self,
        backup_policy_name: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets a particular backup policy by name.

        Gets a particular backup policy identified by {backupPolicyName}.

        :param backup_policy_name: The name of the backup policy.
        :type backup_policy_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "AutoRestoreOnDataLoss": bool,  # Required. Specifies whether to trigger
                      restore automatically using the latest available backup in case the partition
                      experiences a data loss event.
                    "MaxIncrementalBackups": 0,  # Required. Defines the maximum number of
                      incremental backups to be taken between two full backups. This is just the upper
                      limit. A full backup may be taken before specified number of incremental backups
                      are completed in one of the following conditions"n"n"n* The replica has never
                      taken a full backup since it has become primary,"n* Some of the log records since
                      the last backup has been truncated, or"n* Replica passed the
                      MaxAccumulatedBackupLogSizeInMB limit.
                    "Name": "str",  # Required. The unique name identifying this backup policy.
                    "RetentionPolicy": {
                        RetentionPolicyType: RetentionPolicyType
                    },
                    "Schedule": {
                        ScheduleKind: ScheduleKind
                    },
                    "Storage": {
                        "FriendlyName": "str",  # Optional. Friendly name for this backup
                          storage.
                        StorageKind: StorageKind
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_backup_policy_by_name_request(
            backup_policy_name=backup_policy_name,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_all_entities_backed_up_by_policy(
        self,
        backup_policy_name: str,
        *,
        continuation_token_parameter: Optional[str] = None,
        max_results: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the list of backup entities that are associated with this policy.

        Returns a list of Service Fabric application, service or partition which are associated with
        this backup policy.

        :param backup_policy_name: The name of the backup policy.
        :type backup_policy_name: str
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            EntityKind: EntityKind
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_all_entities_backed_up_by_policy_request(
            backup_policy_name=backup_policy_name,
            api_version=api_version,
            continuation_token_parameter=continuation_token_parameter,
            max_results=max_results,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def update_backup_policy(  # pylint: disable=inconsistent-return-statements
        self,
        backup_policy_name: str,
        backup_policy_description: JSON,
        *,
        timeout: Optional[int] = 60,
        validate_connection: Optional[bool] = False,
        **kwargs: Any
    ) -> None:
        """Updates the backup policy.

        Updates the backup policy identified by {backupPolicyName}.

        :param backup_policy_name: The name of the backup policy.
        :type backup_policy_name: str
        :param backup_policy_description: Describes the backup policy.
        :type backup_policy_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword validate_connection: Specifies whether to validate the storage connection and
         credentials before creating or updating the backup policies. Default value is False.
        :paramtype validate_connection: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python


                # JSON input template you can fill out and use as your body input.
                backup_policy_description = {
                    "AutoRestoreOnDataLoss": bool,  # Required. Specifies whether to trigger
                      restore automatically using the latest available backup in case the partition
                      experiences a data loss event.
                    "MaxIncrementalBackups": 0,  # Required. Defines the maximum number of
                      incremental backups to be taken between two full backups. This is just the upper
                      limit. A full backup may be taken before specified number of incremental backups
                      are completed in one of the following conditions"n"n"n* The replica has never
                      taken a full backup since it has become primary,"n* Some of the log records since
                      the last backup has been truncated, or"n* Replica passed the
                      MaxAccumulatedBackupLogSizeInMB limit.
                    "Name": "str",  # Required. The unique name identifying this backup policy.
                    "RetentionPolicy": {
                        RetentionPolicyType: RetentionPolicyType
                    },
                    "Schedule": {
                        ScheduleKind: ScheduleKind
                    },
                    "Storage": {
                        "FriendlyName": "str",  # Optional. Friendly name for this backup
                          storage.
                        StorageKind: StorageKind
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = backup_policy_description

        request = build_update_backup_policy_request(
            backup_policy_name=backup_policy_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            validate_connection=validate_connection,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def enable_application_backup(  # pylint: disable=inconsistent-return-statements
        self,
        application_id: str,
        enable_backup_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Enables periodic backup of stateful partitions under this Service Fabric application.

        Enables periodic backup of stateful partitions which are part of this Service Fabric
        application. Each partition is backed up individually as per the specified backup policy
        description.
        Note only C# based Reliable Actor and Reliable Stateful services are currently supported for
        periodic backup.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param enable_backup_description: Specifies the parameters for enabling backup.
        :type enable_backup_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                enable_backup_description = {
                    "BackupPolicyName": "str"  # Required. Name of the backup policy to be used
                      for enabling periodic backups.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = enable_backup_description

        request = build_enable_application_backup_request(
            application_id=application_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def disable_application_backup(  # pylint: disable=inconsistent-return-statements
        self,
        application_id: str,
        disable_backup_description: Optional[JSON] = None,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Disables periodic backup of Service Fabric application.

        Disables periodic backup of Service Fabric application which was previously enabled.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :param disable_backup_description: Specifies the parameters to disable backup for any backup
         entity. Default value is None.
        :type disable_backup_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                disable_backup_description = {
                    "CleanBackup": bool  # Required. Boolean flag to delete backups. It can be
                      set to true for deleting all the backups which were created for the backup entity
                      that is getting disabled for backup.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        if disable_backup_description is not None:
            _json = disable_backup_description
        else:
            _json = None

        request = build_disable_application_backup_request(
            application_id=application_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_application_backup_configuration_info(
        self,
        application_id: str,
        *,
        continuation_token_parameter: Optional[str] = None,
        max_results: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the Service Fabric application backup configuration information.

        Gets the Service Fabric backup configuration information for the application and the services
        and partitions under this application.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "PolicyInheritedFrom": "str",  # Optional. Specifies the
                              scope at which the backup policy is applied. Known values are: "Invalid",
                              "Partition", "Service", "Application".
                            "PolicyName": "str",  # Optional. The name of the backup
                              policy which is applicable to this Service Fabric application or service
                              or partition.
                            "SuspensionInfo": {
                                "IsSuspended": bool,  # Optional. Indicates whether
                                  periodic backup is suspended at this level or not.
                                "SuspensionInheritedFrom": "str"  # Optional.
                                  Specifies the scope at which the backup suspension was applied. Known
                                  values are: "Invalid", "Partition", "Service", "Application".
                            },
                            Kind: Kind
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_application_backup_configuration_info_request(
            application_id=application_id,
            api_version=api_version,
            continuation_token_parameter=continuation_token_parameter,
            max_results=max_results,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_application_backup_list(
        self,
        application_id: str,
        *,
        timeout: Optional[int] = 60,
        latest: Optional[bool] = False,
        start_date_time_filter: Optional[datetime.datetime] = None,
        end_date_time_filter: Optional[datetime.datetime] = None,
        continuation_token_parameter: Optional[str] = None,
        max_results: Optional[int] = 0,
        **kwargs: Any
    ) -> JSON:
        """Gets the list of backups available for every partition in this application.

        Returns a list of backups available for every partition in this Service Fabric application. The
        server enumerates all the backups available at the backup location configured in the backup
        policy. It also allows filtering of the result based on start and end datetime or just fetching
        the latest available backup for every partition.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword latest: Specifies whether to get only the most recent backup available for a partition
         for the specified time range. Default value is False.
        :paramtype latest: bool
        :keyword start_date_time_filter: Specify the start date time from which to enumerate backups,
         in datetime format. The date time must be specified in ISO8601 format. This is an optional
         parameter. If not specified, all backups from the beginning are enumerated. Default value is
         None.
        :paramtype start_date_time_filter: ~datetime.datetime
        :keyword end_date_time_filter: Specify the end date time till which to enumerate backups, in
         datetime format. The date time must be specified in ISO8601 format. This is an optional
         parameter. If not specified, enumeration is done till the most recent backup. Default value is
         None.
        :paramtype end_date_time_filter: ~datetime.datetime
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "ApplicationName": "str",  # Optional. Name of the Service
                              Fabric application this partition backup belongs to.
                            "BackupChainId": str,  # Optional. Unique backup chain ID.
                              All backups part of the same chain has the same backup chain id. A backup
                              chain is comprised of 1 full backup and multiple incremental backups.
                            "BackupId": str,  # Optional. Unique backup ID .
                            "BackupLocation": "str",  # Optional. Location of the backup,
                              relative to the backup store.
                            "BackupType": "str",  # Optional. Describes the type of
                              backup, whether its full or incremental. Known values are: "Invalid",
                              "Full", "Incremental".
                            "CreationTimeUtc": "2020-02-20 00:00:00",  # Optional. The
                              date time when this backup was taken.
                            "EpochOfLastBackupRecord": {
                                "ConfigurationVersion": "str",  # Optional. The
                                  current configuration number of this Epoch. The configuration number
                                  is an increasing value that is updated whenever the configuration of
                                  this replica set changes.
                                "DataLossVersion": "str"  # Optional. The current
                                  data loss number of this Epoch. The data loss number property is an
                                  increasing value which is updated whenever data loss is suspected, as
                                  when loss of a quorum of replicas in the replica set that includes
                                  the Primary replica.
                            },
                            "FailureError": {
                                "Code": "str",  # Required. Defines the fabric error
                                  codes that be returned as part of the error object in response to
                                  Service Fabric API operations that are not successful. Following are
                                  the error code values that can be returned for a specific HTTP status
                                  code."n"n"n* "n  Possible values of the error code for HTTP status
                                  code 400 (Bad Request)"n"n"n  * "FABRIC_E_INVALID_PARTITION_KEY""n  *
                                  "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR""n  *
                                  "FABRIC_E_INVALID_ADDRESS""n  *
                                  "FABRIC_E_APPLICATION_NOT_UPGRADING""n  *
                                  "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR""n  *
                                  "FABRIC_E_FABRIC_NOT_UPGRADING""n  *
                                  "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR""n  *
                                  "FABRIC_E_INVALID_CONFIGURATION""n  * "FABRIC_E_INVALID_NAME_URI""n
                                  * "FABRIC_E_PATH_TOO_LONG""n  * "FABRIC_E_KEY_TOO_LARGE""n  *
                                  "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED""n  *
                                  "FABRIC_E_INVALID_ATOMIC_GROUP""n  * "FABRIC_E_VALUE_EMPTY""n  *
                                  "FABRIC_E_BACKUP_IS_ENABLED""n  *
                                  "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH""n  *
                                  "FABRIC_E_INVALID_FOR_STATELESS_SERVICES""n  *
                                  "FABRIC_E_INVALID_SERVICE_SCALING_POLICY""n  * "E_INVALIDARG""n"n* "n
                                  Possible values of the error code for HTTP status code 404 (Not
                                  Found)"n"n"n  * "FABRIC_E_NODE_NOT_FOUND""n  *
                                  "FABRIC_E_APPLICATION_TYPE_NOT_FOUND""n  *
                                  "FABRIC_E_APPLICATION_NOT_FOUND""n  *
                                  "FABRIC_E_SERVICE_TYPE_NOT_FOUND""n  *
                                  "FABRIC_E_SERVICE_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND""n  *
                                  "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND""n  *
                                  "FABRIC_E_PARTITION_NOT_FOUND""n  *
                                  "FABRIC_E_REPLICA_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND""n  *
                                  "FABRIC_E_DIRECTORY_NOT_FOUND""n  *
                                  "FABRIC_E_FABRIC_VERSION_NOT_FOUND""n  * "FABRIC_E_FILE_NOT_FOUND""n
                                  * "FABRIC_E_NAME_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_PROPERTY_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_ENUMERATION_COMPLETED""n  *
                                  "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND""n  * "FABRIC_E_KEY_NOT_FOUND""n
                                  * "FABRIC_E_HEALTH_ENTITY_NOT_FOUND""n  *
                                  "FABRIC_E_BACKUP_NOT_ENABLED""n  *
                                  "FABRIC_E_BACKUP_POLICY_NOT_EXISTING""n  *
                                  "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING""n  *
                                  "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR""n"n* "n  Possible
                                  values of the error code for HTTP status code 409 (Conflict)"n"n"n  *
                                  "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS""n  *
                                  "FABRIC_E_APPLICATION_ALREADY_EXISTS""n  *
                                  "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION""n  *
                                  "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS""n  *
                                  "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS""n  *
                                  "FABRIC_E_SERVICE_ALREADY_EXISTS""n  *
                                  "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS""n  *
                                  "FABRIC_E_APPLICATION_TYPE_IN_USE""n  *
                                  "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION""n  *
                                  "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS""n  *
                                  "FABRIC_E_FABRIC_VERSION_IN_USE""n  *
                                  "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS""n  *
                                  "FABRIC_E_NAME_ALREADY_EXISTS""n  * "FABRIC_E_NAME_NOT_EMPTY""n  *
                                  "FABRIC_E_PROPERTY_CHECK_FAILED""n  *
                                  "FABRIC_E_SERVICE_METADATA_MISMATCH""n  *
                                  "FABRIC_E_SERVICE_TYPE_MISMATCH""n  *
                                  "FABRIC_E_HEALTH_STALE_REPORT""n  *
                                  "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED""n  *
                                  "FABRIC_E_NODE_HAS_NOT_STOPPED_YET""n  *
                                  "FABRIC_E_INSTANCE_ID_MISMATCH""n  * "FABRIC_E_BACKUP_IN_PROGRESS""n
                                  * "FABRIC_E_RESTORE_IN_PROGRESS""n  *
                                  "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING""n"n* "n  Possible values of
                                  the error code for HTTP status code 413 (Request Entity Too
                                  Large)"n"n"n  * "FABRIC_E_VALUE_TOO_LARGE""n"n* "n  Possible values
                                  of the error code for HTTP status code 500 (Internal Server
                                  Error)"n"n"n  * "FABRIC_E_NODE_IS_UP""n  * "E_FAIL""n  *
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS""n  *
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND""n  *
                                  "FABRIC_E_VOLUME_ALREADY_EXISTS""n  * "FABRIC_E_VOLUME_NOT_FOUND""n
                                  * "SerializationError""n  * "FABRIC_E_CERTIFICATE_NOT_FOUND""n"n* "n
                                  Possible values of the error code for HTTP status code 503 (Service
                                  Unavailable)"n"n"n  * "FABRIC_E_NO_WRITE_QUORUM""n  *
                                  "FABRIC_E_NOT_PRIMARY""n  * "FABRIC_E_NOT_READY""n  *
                                  "FABRIC_E_RECONFIGURATION_PENDING""n  * "FABRIC_E_SERVICE_OFFLINE""n
                                  * "E_ABORT""n  * "FABRIC_E_VALUE_TOO_LARGE""n"n* "n  Possible values
                                  of the error code for HTTP status code 504 (Gateway Timeout)"n"n"n  *
                                  "FABRIC_E_COMMUNICATION_ERROR""n  *
                                  "FABRIC_E_OPERATION_NOT_COMPLETE""n  * "FABRIC_E_TIMEOUT". Known
                                  values are: "FABRIC_E_INVALID_PARTITION_KEY",
                                  "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR", "FABRIC_E_INVALID_ADDRESS",
                                  "FABRIC_E_APPLICATION_NOT_UPGRADING",
                                  "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR",
                                  "FABRIC_E_FABRIC_NOT_UPGRADING",
                                  "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR",
                                  "FABRIC_E_INVALID_CONFIGURATION", "FABRIC_E_INVALID_NAME_URI",
                                  "FABRIC_E_PATH_TOO_LONG", "FABRIC_E_KEY_TOO_LARGE",
                                  "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED",
                                  "FABRIC_E_INVALID_ATOMIC_GROUP", "FABRIC_E_VALUE_EMPTY",
                                  "FABRIC_E_NODE_NOT_FOUND", "FABRIC_E_APPLICATION_TYPE_NOT_FOUND",
                                  "FABRIC_E_APPLICATION_NOT_FOUND", "FABRIC_E_SERVICE_TYPE_NOT_FOUND",
                                  "FABRIC_E_SERVICE_DOES_NOT_EXIST",
                                  "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND",
                                  "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND",
                                  "FABRIC_E_PARTITION_NOT_FOUND", "FABRIC_E_REPLICA_DOES_NOT_EXIST",
                                  "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST",
                                  "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND",
                                  "FABRIC_E_DIRECTORY_NOT_FOUND", "FABRIC_E_FABRIC_VERSION_NOT_FOUND",
                                  "FABRIC_E_FILE_NOT_FOUND", "FABRIC_E_NAME_DOES_NOT_EXIST",
                                  "FABRIC_E_PROPERTY_DOES_NOT_EXIST", "FABRIC_E_ENUMERATION_COMPLETED",
                                  "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND", "FABRIC_E_KEY_NOT_FOUND",
                                  "FABRIC_E_HEALTH_ENTITY_NOT_FOUND",
                                  "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS",
                                  "FABRIC_E_APPLICATION_ALREADY_EXISTS",
                                  "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION",
                                  "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS",
                                  "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS",
                                  "FABRIC_E_SERVICE_ALREADY_EXISTS",
                                  "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS",
                                  "FABRIC_E_APPLICATION_TYPE_IN_USE",
                                  "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION",
                                  "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS",
                                  "FABRIC_E_FABRIC_VERSION_IN_USE",
                                  "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS",
                                  "FABRIC_E_NAME_ALREADY_EXISTS", "FABRIC_E_NAME_NOT_EMPTY",
                                  "FABRIC_E_PROPERTY_CHECK_FAILED",
                                  "FABRIC_E_SERVICE_METADATA_MISMATCH",
                                  "FABRIC_E_SERVICE_TYPE_MISMATCH", "FABRIC_E_HEALTH_STALE_REPORT",
                                  "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED",
                                  "FABRIC_E_NODE_HAS_NOT_STOPPED_YET", "FABRIC_E_INSTANCE_ID_MISMATCH",
                                  "FABRIC_E_VALUE_TOO_LARGE", "FABRIC_E_NO_WRITE_QUORUM",
                                  "FABRIC_E_NOT_PRIMARY", "FABRIC_E_NOT_READY",
                                  "FABRIC_E_RECONFIGURATION_PENDING", "FABRIC_E_SERVICE_OFFLINE",
                                  "E_ABORT", "FABRIC_E_COMMUNICATION_ERROR",
                                  "FABRIC_E_OPERATION_NOT_COMPLETE", "FABRIC_E_TIMEOUT",
                                  "FABRIC_E_NODE_IS_UP", "E_FAIL", "FABRIC_E_BACKUP_IS_ENABLED",
                                  "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH",
                                  "FABRIC_E_INVALID_FOR_STATELESS_SERVICES",
                                  "FABRIC_E_BACKUP_NOT_ENABLED", "FABRIC_E_BACKUP_POLICY_NOT_EXISTING",
                                  "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING",
                                  "FABRIC_E_BACKUP_IN_PROGRESS", "FABRIC_E_RESTORE_IN_PROGRESS",
                                  "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING",
                                  "FABRIC_E_INVALID_SERVICE_SCALING_POLICY", "E_INVALIDARG",
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS",
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND",
                                  "FABRIC_E_VOLUME_ALREADY_EXISTS", "FABRIC_E_VOLUME_NOT_FOUND",
                                  "SerializationError",
                                  "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR",
                                  "FABRIC_E_CERTIFICATE_NOT_FOUND".
                                "Message": "str"  # Optional. Error message.
                            },
                            "LsnOfLastBackupRecord": "str",  # Optional. LSN of the last
                              record in this backup.
                            "PartitionInformation": {
                                "Id": str,  # Optional. An internal ID used by
                                  Service Fabric to uniquely identify a partition. This is a randomly
                                  generated GUID when the service was created. The partition ID is
                                  unique and does not change for the lifetime of the service. If the
                                  same service was deleted and recreated the IDs of its partitions
                                  would be different.
                                ServicePartitionKind: ServicePartitionKind
                            },
                            "ServiceManifestVersion": "str",  # Optional. Manifest
                              Version of the service this partition backup belongs to.
                            "ServiceName": "str"  # Optional. Name of the Service Fabric
                              service this partition backup belongs to.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_application_backup_list_request(
            application_id=application_id,
            api_version=api_version,
            timeout=timeout,
            latest=latest,
            start_date_time_filter=start_date_time_filter,
            end_date_time_filter=end_date_time_filter,
            continuation_token_parameter=continuation_token_parameter,
            max_results=max_results,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def suspend_application_backup(  # pylint: disable=inconsistent-return-statements
        self,
        application_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Suspends periodic backup for the specified Service Fabric application.

        The application which is configured to take periodic backups, is suspended for taking further
        backups till it is resumed again. This operation applies to the entire application's hierarchy.
        It means all the services and partitions under this application are now suspended for backup.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_suspend_application_backup_request(
            application_id=application_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def resume_application_backup(  # pylint: disable=inconsistent-return-statements
        self,
        application_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Resumes periodic backup of a Service Fabric application which was previously suspended.

        The previously suspended Service Fabric application resumes taking periodic backup as per the
        backup policy currently configured for the same.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_resume_application_backup_request(
            application_id=application_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def enable_service_backup(  # pylint: disable=inconsistent-return-statements
        self,
        service_id: str,
        enable_backup_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Enables periodic backup of stateful partitions under this Service Fabric service.

        Enables periodic backup of stateful partitions which are part of this Service Fabric service.
        Each partition is backed up individually as per the specified backup policy description. In
        case the application, which the service is part of, is already enabled for backup then this
        operation would override the policy being used to take the periodic backup for this service and
        its partitions (unless explicitly overridden at the partition level).
        Note only C# based Reliable Actor and Reliable Stateful services are currently supported for
        periodic backup.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :param enable_backup_description: Specifies the parameters for enabling backup.
        :type enable_backup_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                enable_backup_description = {
                    "BackupPolicyName": "str"  # Required. Name of the backup policy to be used
                      for enabling periodic backups.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = enable_backup_description

        request = build_enable_service_backup_request(
            service_id=service_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def disable_service_backup(  # pylint: disable=inconsistent-return-statements
        self,
        service_id: str,
        disable_backup_description: Optional[JSON] = None,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Disables periodic backup of Service Fabric service which was previously enabled.

        Disables periodic backup of Service Fabric service which was previously enabled. Backup must be
        explicitly enabled before it can be disabled.
        In case the backup is enabled for the Service Fabric application, which this service is part
        of, this service would continue to be periodically backed up as per the policy mapped at the
        application level.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :param disable_backup_description: Specifies the parameters to disable backup for any backup
         entity. Default value is None.
        :type disable_backup_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                disable_backup_description = {
                    "CleanBackup": bool  # Required. Boolean flag to delete backups. It can be
                      set to true for deleting all the backups which were created for the backup entity
                      that is getting disabled for backup.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        if disable_backup_description is not None:
            _json = disable_backup_description
        else:
            _json = None

        request = build_disable_service_backup_request(
            service_id=service_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_service_backup_configuration_info(
        self,
        service_id: str,
        *,
        continuation_token_parameter: Optional[str] = None,
        max_results: Optional[int] = 0,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the Service Fabric service backup configuration information.

        Gets the Service Fabric backup configuration information for the service and the partitions
        under this service.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "PolicyInheritedFrom": "str",  # Optional. Specifies the
                              scope at which the backup policy is applied. Known values are: "Invalid",
                              "Partition", "Service", "Application".
                            "PolicyName": "str",  # Optional. The name of the backup
                              policy which is applicable to this Service Fabric application or service
                              or partition.
                            "SuspensionInfo": {
                                "IsSuspended": bool,  # Optional. Indicates whether
                                  periodic backup is suspended at this level or not.
                                "SuspensionInheritedFrom": "str"  # Optional.
                                  Specifies the scope at which the backup suspension was applied. Known
                                  values are: "Invalid", "Partition", "Service", "Application".
                            },
                            Kind: Kind
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_service_backup_configuration_info_request(
            service_id=service_id,
            api_version=api_version,
            continuation_token_parameter=continuation_token_parameter,
            max_results=max_results,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_service_backup_list(
        self,
        service_id: str,
        *,
        timeout: Optional[int] = 60,
        latest: Optional[bool] = False,
        start_date_time_filter: Optional[datetime.datetime] = None,
        end_date_time_filter: Optional[datetime.datetime] = None,
        continuation_token_parameter: Optional[str] = None,
        max_results: Optional[int] = 0,
        **kwargs: Any
    ) -> JSON:
        """Gets the list of backups available for every partition in this service.

        Returns a list of backups available for every partition in this Service Fabric service. The
        server enumerates all the backups available in the backup store configured in the backup
        policy. It also allows filtering of the result based on start and end datetime or just fetching
        the latest available backup for every partition.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword latest: Specifies whether to get only the most recent backup available for a partition
         for the specified time range. Default value is False.
        :paramtype latest: bool
        :keyword start_date_time_filter: Specify the start date time from which to enumerate backups,
         in datetime format. The date time must be specified in ISO8601 format. This is an optional
         parameter. If not specified, all backups from the beginning are enumerated. Default value is
         None.
        :paramtype start_date_time_filter: ~datetime.datetime
        :keyword end_date_time_filter: Specify the end date time till which to enumerate backups, in
         datetime format. The date time must be specified in ISO8601 format. This is an optional
         parameter. If not specified, enumeration is done till the most recent backup. Default value is
         None.
        :paramtype end_date_time_filter: ~datetime.datetime
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "ApplicationName": "str",  # Optional. Name of the Service
                              Fabric application this partition backup belongs to.
                            "BackupChainId": str,  # Optional. Unique backup chain ID.
                              All backups part of the same chain has the same backup chain id. A backup
                              chain is comprised of 1 full backup and multiple incremental backups.
                            "BackupId": str,  # Optional. Unique backup ID .
                            "BackupLocation": "str",  # Optional. Location of the backup,
                              relative to the backup store.
                            "BackupType": "str",  # Optional. Describes the type of
                              backup, whether its full or incremental. Known values are: "Invalid",
                              "Full", "Incremental".
                            "CreationTimeUtc": "2020-02-20 00:00:00",  # Optional. The
                              date time when this backup was taken.
                            "EpochOfLastBackupRecord": {
                                "ConfigurationVersion": "str",  # Optional. The
                                  current configuration number of this Epoch. The configuration number
                                  is an increasing value that is updated whenever the configuration of
                                  this replica set changes.
                                "DataLossVersion": "str"  # Optional. The current
                                  data loss number of this Epoch. The data loss number property is an
                                  increasing value which is updated whenever data loss is suspected, as
                                  when loss of a quorum of replicas in the replica set that includes
                                  the Primary replica.
                            },
                            "FailureError": {
                                "Code": "str",  # Required. Defines the fabric error
                                  codes that be returned as part of the error object in response to
                                  Service Fabric API operations that are not successful. Following are
                                  the error code values that can be returned for a specific HTTP status
                                  code."n"n"n* "n  Possible values of the error code for HTTP status
                                  code 400 (Bad Request)"n"n"n  * "FABRIC_E_INVALID_PARTITION_KEY""n  *
                                  "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR""n  *
                                  "FABRIC_E_INVALID_ADDRESS""n  *
                                  "FABRIC_E_APPLICATION_NOT_UPGRADING""n  *
                                  "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR""n  *
                                  "FABRIC_E_FABRIC_NOT_UPGRADING""n  *
                                  "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR""n  *
                                  "FABRIC_E_INVALID_CONFIGURATION""n  * "FABRIC_E_INVALID_NAME_URI""n
                                  * "FABRIC_E_PATH_TOO_LONG""n  * "FABRIC_E_KEY_TOO_LARGE""n  *
                                  "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED""n  *
                                  "FABRIC_E_INVALID_ATOMIC_GROUP""n  * "FABRIC_E_VALUE_EMPTY""n  *
                                  "FABRIC_E_BACKUP_IS_ENABLED""n  *
                                  "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH""n  *
                                  "FABRIC_E_INVALID_FOR_STATELESS_SERVICES""n  *
                                  "FABRIC_E_INVALID_SERVICE_SCALING_POLICY""n  * "E_INVALIDARG""n"n* "n
                                  Possible values of the error code for HTTP status code 404 (Not
                                  Found)"n"n"n  * "FABRIC_E_NODE_NOT_FOUND""n  *
                                  "FABRIC_E_APPLICATION_TYPE_NOT_FOUND""n  *
                                  "FABRIC_E_APPLICATION_NOT_FOUND""n  *
                                  "FABRIC_E_SERVICE_TYPE_NOT_FOUND""n  *
                                  "FABRIC_E_SERVICE_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND""n  *
                                  "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND""n  *
                                  "FABRIC_E_PARTITION_NOT_FOUND""n  *
                                  "FABRIC_E_REPLICA_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND""n  *
                                  "FABRIC_E_DIRECTORY_NOT_FOUND""n  *
                                  "FABRIC_E_FABRIC_VERSION_NOT_FOUND""n  * "FABRIC_E_FILE_NOT_FOUND""n
                                  * "FABRIC_E_NAME_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_PROPERTY_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_ENUMERATION_COMPLETED""n  *
                                  "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND""n  * "FABRIC_E_KEY_NOT_FOUND""n
                                  * "FABRIC_E_HEALTH_ENTITY_NOT_FOUND""n  *
                                  "FABRIC_E_BACKUP_NOT_ENABLED""n  *
                                  "FABRIC_E_BACKUP_POLICY_NOT_EXISTING""n  *
                                  "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING""n  *
                                  "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR""n"n* "n  Possible
                                  values of the error code for HTTP status code 409 (Conflict)"n"n"n  *
                                  "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS""n  *
                                  "FABRIC_E_APPLICATION_ALREADY_EXISTS""n  *
                                  "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION""n  *
                                  "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS""n  *
                                  "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS""n  *
                                  "FABRIC_E_SERVICE_ALREADY_EXISTS""n  *
                                  "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS""n  *
                                  "FABRIC_E_APPLICATION_TYPE_IN_USE""n  *
                                  "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION""n  *
                                  "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS""n  *
                                  "FABRIC_E_FABRIC_VERSION_IN_USE""n  *
                                  "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS""n  *
                                  "FABRIC_E_NAME_ALREADY_EXISTS""n  * "FABRIC_E_NAME_NOT_EMPTY""n  *
                                  "FABRIC_E_PROPERTY_CHECK_FAILED""n  *
                                  "FABRIC_E_SERVICE_METADATA_MISMATCH""n  *
                                  "FABRIC_E_SERVICE_TYPE_MISMATCH""n  *
                                  "FABRIC_E_HEALTH_STALE_REPORT""n  *
                                  "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED""n  *
                                  "FABRIC_E_NODE_HAS_NOT_STOPPED_YET""n  *
                                  "FABRIC_E_INSTANCE_ID_MISMATCH""n  * "FABRIC_E_BACKUP_IN_PROGRESS""n
                                  * "FABRIC_E_RESTORE_IN_PROGRESS""n  *
                                  "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING""n"n* "n  Possible values of
                                  the error code for HTTP status code 413 (Request Entity Too
                                  Large)"n"n"n  * "FABRIC_E_VALUE_TOO_LARGE""n"n* "n  Possible values
                                  of the error code for HTTP status code 500 (Internal Server
                                  Error)"n"n"n  * "FABRIC_E_NODE_IS_UP""n  * "E_FAIL""n  *
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS""n  *
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND""n  *
                                  "FABRIC_E_VOLUME_ALREADY_EXISTS""n  * "FABRIC_E_VOLUME_NOT_FOUND""n
                                  * "SerializationError""n  * "FABRIC_E_CERTIFICATE_NOT_FOUND""n"n* "n
                                  Possible values of the error code for HTTP status code 503 (Service
                                  Unavailable)"n"n"n  * "FABRIC_E_NO_WRITE_QUORUM""n  *
                                  "FABRIC_E_NOT_PRIMARY""n  * "FABRIC_E_NOT_READY""n  *
                                  "FABRIC_E_RECONFIGURATION_PENDING""n  * "FABRIC_E_SERVICE_OFFLINE""n
                                  * "E_ABORT""n  * "FABRIC_E_VALUE_TOO_LARGE""n"n* "n  Possible values
                                  of the error code for HTTP status code 504 (Gateway Timeout)"n"n"n  *
                                  "FABRIC_E_COMMUNICATION_ERROR""n  *
                                  "FABRIC_E_OPERATION_NOT_COMPLETE""n  * "FABRIC_E_TIMEOUT". Known
                                  values are: "FABRIC_E_INVALID_PARTITION_KEY",
                                  "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR", "FABRIC_E_INVALID_ADDRESS",
                                  "FABRIC_E_APPLICATION_NOT_UPGRADING",
                                  "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR",
                                  "FABRIC_E_FABRIC_NOT_UPGRADING",
                                  "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR",
                                  "FABRIC_E_INVALID_CONFIGURATION", "FABRIC_E_INVALID_NAME_URI",
                                  "FABRIC_E_PATH_TOO_LONG", "FABRIC_E_KEY_TOO_LARGE",
                                  "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED",
                                  "FABRIC_E_INVALID_ATOMIC_GROUP", "FABRIC_E_VALUE_EMPTY",
                                  "FABRIC_E_NODE_NOT_FOUND", "FABRIC_E_APPLICATION_TYPE_NOT_FOUND",
                                  "FABRIC_E_APPLICATION_NOT_FOUND", "FABRIC_E_SERVICE_TYPE_NOT_FOUND",
                                  "FABRIC_E_SERVICE_DOES_NOT_EXIST",
                                  "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND",
                                  "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND",
                                  "FABRIC_E_PARTITION_NOT_FOUND", "FABRIC_E_REPLICA_DOES_NOT_EXIST",
                                  "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST",
                                  "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND",
                                  "FABRIC_E_DIRECTORY_NOT_FOUND", "FABRIC_E_FABRIC_VERSION_NOT_FOUND",
                                  "FABRIC_E_FILE_NOT_FOUND", "FABRIC_E_NAME_DOES_NOT_EXIST",
                                  "FABRIC_E_PROPERTY_DOES_NOT_EXIST", "FABRIC_E_ENUMERATION_COMPLETED",
                                  "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND", "FABRIC_E_KEY_NOT_FOUND",
                                  "FABRIC_E_HEALTH_ENTITY_NOT_FOUND",
                                  "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS",
                                  "FABRIC_E_APPLICATION_ALREADY_EXISTS",
                                  "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION",
                                  "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS",
                                  "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS",
                                  "FABRIC_E_SERVICE_ALREADY_EXISTS",
                                  "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS",
                                  "FABRIC_E_APPLICATION_TYPE_IN_USE",
                                  "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION",
                                  "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS",
                                  "FABRIC_E_FABRIC_VERSION_IN_USE",
                                  "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS",
                                  "FABRIC_E_NAME_ALREADY_EXISTS", "FABRIC_E_NAME_NOT_EMPTY",
                                  "FABRIC_E_PROPERTY_CHECK_FAILED",
                                  "FABRIC_E_SERVICE_METADATA_MISMATCH",
                                  "FABRIC_E_SERVICE_TYPE_MISMATCH", "FABRIC_E_HEALTH_STALE_REPORT",
                                  "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED",
                                  "FABRIC_E_NODE_HAS_NOT_STOPPED_YET", "FABRIC_E_INSTANCE_ID_MISMATCH",
                                  "FABRIC_E_VALUE_TOO_LARGE", "FABRIC_E_NO_WRITE_QUORUM",
                                  "FABRIC_E_NOT_PRIMARY", "FABRIC_E_NOT_READY",
                                  "FABRIC_E_RECONFIGURATION_PENDING", "FABRIC_E_SERVICE_OFFLINE",
                                  "E_ABORT", "FABRIC_E_COMMUNICATION_ERROR",
                                  "FABRIC_E_OPERATION_NOT_COMPLETE", "FABRIC_E_TIMEOUT",
                                  "FABRIC_E_NODE_IS_UP", "E_FAIL", "FABRIC_E_BACKUP_IS_ENABLED",
                                  "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH",
                                  "FABRIC_E_INVALID_FOR_STATELESS_SERVICES",
                                  "FABRIC_E_BACKUP_NOT_ENABLED", "FABRIC_E_BACKUP_POLICY_NOT_EXISTING",
                                  "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING",
                                  "FABRIC_E_BACKUP_IN_PROGRESS", "FABRIC_E_RESTORE_IN_PROGRESS",
                                  "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING",
                                  "FABRIC_E_INVALID_SERVICE_SCALING_POLICY", "E_INVALIDARG",
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS",
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND",
                                  "FABRIC_E_VOLUME_ALREADY_EXISTS", "FABRIC_E_VOLUME_NOT_FOUND",
                                  "SerializationError",
                                  "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR",
                                  "FABRIC_E_CERTIFICATE_NOT_FOUND".
                                "Message": "str"  # Optional. Error message.
                            },
                            "LsnOfLastBackupRecord": "str",  # Optional. LSN of the last
                              record in this backup.
                            "PartitionInformation": {
                                "Id": str,  # Optional. An internal ID used by
                                  Service Fabric to uniquely identify a partition. This is a randomly
                                  generated GUID when the service was created. The partition ID is
                                  unique and does not change for the lifetime of the service. If the
                                  same service was deleted and recreated the IDs of its partitions
                                  would be different.
                                ServicePartitionKind: ServicePartitionKind
                            },
                            "ServiceManifestVersion": "str",  # Optional. Manifest
                              Version of the service this partition backup belongs to.
                            "ServiceName": "str"  # Optional. Name of the Service Fabric
                              service this partition backup belongs to.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_service_backup_list_request(
            service_id=service_id,
            api_version=api_version,
            timeout=timeout,
            latest=latest,
            start_date_time_filter=start_date_time_filter,
            end_date_time_filter=end_date_time_filter,
            continuation_token_parameter=continuation_token_parameter,
            max_results=max_results,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def suspend_service_backup(  # pylint: disable=inconsistent-return-statements
        self,
        service_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Suspends periodic backup for the specified Service Fabric service.

        The service which is configured to take periodic backups, is suspended for taking further
        backups till it is resumed again. This operation applies to the entire service's hierarchy. It
        means all the partitions under this service are now suspended for backup.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_suspend_service_backup_request(
            service_id=service_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def resume_service_backup(  # pylint: disable=inconsistent-return-statements
        self,
        service_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Resumes periodic backup of a Service Fabric service which was previously suspended.

        The previously suspended Service Fabric service resumes taking periodic backup as per the
        backup policy currently configured for the same.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_resume_service_backup_request(
            service_id=service_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def enable_partition_backup(  # pylint: disable=inconsistent-return-statements
        self,
        partition_id: str,
        enable_backup_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Enables periodic backup of the stateful persisted partition.

        Enables periodic backup of stateful persisted partition. Each partition is backed up as per the
        specified backup policy description. In case the application or service, which is partition is
        part of, is already enabled for backup then this operation would override the policy being used
        to take the periodic backup of this partition.
        Note only C# based Reliable Actor and Reliable Stateful services are currently supported for
        periodic backup.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :param enable_backup_description: Specifies the parameters for enabling backup.
        :type enable_backup_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                enable_backup_description = {
                    "BackupPolicyName": "str"  # Required. Name of the backup policy to be used
                      for enabling periodic backups.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = enable_backup_description

        request = build_enable_partition_backup_request(
            partition_id=partition_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def disable_partition_backup(  # pylint: disable=inconsistent-return-statements
        self,
        partition_id: str,
        disable_backup_description: Optional[JSON] = None,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Disables periodic backup of Service Fabric partition which was previously enabled.

        Disables periodic backup of partition which was previously enabled. Backup must be explicitly
        enabled before it can be disabled.
        In case the backup is enabled for the Service Fabric application or service, which this
        partition is part of, this partition would continue to be periodically backed up as per the
        policy mapped at the higher level entity.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :param disable_backup_description: Specifies the parameters to disable backup for any backup
         entity. Default value is None.
        :type disable_backup_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                disable_backup_description = {
                    "CleanBackup": bool  # Required. Boolean flag to delete backups. It can be
                      set to true for deleting all the backups which were created for the backup entity
                      that is getting disabled for backup.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        if disable_backup_description is not None:
            _json = disable_backup_description
        else:
            _json = None

        request = build_disable_partition_backup_request(
            partition_id=partition_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_partition_backup_configuration_info(
        self,
        partition_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the partition backup configuration information.

        Gets the Service Fabric Backup configuration information for the specified partition.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "PartitionId": str,  # Optional. The partition ID identifying the partition.
                    "PolicyInheritedFrom": "str",  # Optional. Specifies the scope at which the
                      backup policy is applied. Known values are: "Invalid", "Partition", "Service",
                      "Application".
                    "PolicyName": "str",  # Optional. The name of the backup policy which is
                      applicable to this Service Fabric application or service or partition.
                    "ServiceName": "str",  # Optional. The full name of the service with
                      'fabric:' URI scheme.
                    "SuspensionInfo": {
                        "IsSuspended": bool,  # Optional. Indicates whether periodic backup
                          is suspended at this level or not.
                        "SuspensionInheritedFrom": "str"  # Optional. Specifies the scope at
                          which the backup suspension was applied. Known values are: "Invalid",
                          "Partition", "Service", "Application".
                    },
                    Kind: Partition
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_partition_backup_configuration_info_request(
            partition_id=partition_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_partition_backup_list(
        self,
        partition_id: str,
        *,
        timeout: Optional[int] = 60,
        latest: Optional[bool] = False,
        start_date_time_filter: Optional[datetime.datetime] = None,
        end_date_time_filter: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> JSON:
        """Gets the list of backups available for the specified partition.

        Returns a list of backups available for the specified partition. The server enumerates all the
        backups available in the backup store configured in the backup policy. It also allows filtering
        of the result based on start and end datetime or just fetching the latest available backup for
        the partition.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword latest: Specifies whether to get only the most recent backup available for a partition
         for the specified time range. Default value is False.
        :paramtype latest: bool
        :keyword start_date_time_filter: Specify the start date time from which to enumerate backups,
         in datetime format. The date time must be specified in ISO8601 format. This is an optional
         parameter. If not specified, all backups from the beginning are enumerated. Default value is
         None.
        :paramtype start_date_time_filter: ~datetime.datetime
        :keyword end_date_time_filter: Specify the end date time till which to enumerate backups, in
         datetime format. The date time must be specified in ISO8601 format. This is an optional
         parameter. If not specified, enumeration is done till the most recent backup. Default value is
         None.
        :paramtype end_date_time_filter: ~datetime.datetime
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "ApplicationName": "str",  # Optional. Name of the Service
                              Fabric application this partition backup belongs to.
                            "BackupChainId": str,  # Optional. Unique backup chain ID.
                              All backups part of the same chain has the same backup chain id. A backup
                              chain is comprised of 1 full backup and multiple incremental backups.
                            "BackupId": str,  # Optional. Unique backup ID .
                            "BackupLocation": "str",  # Optional. Location of the backup,
                              relative to the backup store.
                            "BackupType": "str",  # Optional. Describes the type of
                              backup, whether its full or incremental. Known values are: "Invalid",
                              "Full", "Incremental".
                            "CreationTimeUtc": "2020-02-20 00:00:00",  # Optional. The
                              date time when this backup was taken.
                            "EpochOfLastBackupRecord": {
                                "ConfigurationVersion": "str",  # Optional. The
                                  current configuration number of this Epoch. The configuration number
                                  is an increasing value that is updated whenever the configuration of
                                  this replica set changes.
                                "DataLossVersion": "str"  # Optional. The current
                                  data loss number of this Epoch. The data loss number property is an
                                  increasing value which is updated whenever data loss is suspected, as
                                  when loss of a quorum of replicas in the replica set that includes
                                  the Primary replica.
                            },
                            "FailureError": {
                                "Code": "str",  # Required. Defines the fabric error
                                  codes that be returned as part of the error object in response to
                                  Service Fabric API operations that are not successful. Following are
                                  the error code values that can be returned for a specific HTTP status
                                  code."n"n"n* "n  Possible values of the error code for HTTP status
                                  code 400 (Bad Request)"n"n"n  * "FABRIC_E_INVALID_PARTITION_KEY""n  *
                                  "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR""n  *
                                  "FABRIC_E_INVALID_ADDRESS""n  *
                                  "FABRIC_E_APPLICATION_NOT_UPGRADING""n  *
                                  "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR""n  *
                                  "FABRIC_E_FABRIC_NOT_UPGRADING""n  *
                                  "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR""n  *
                                  "FABRIC_E_INVALID_CONFIGURATION""n  * "FABRIC_E_INVALID_NAME_URI""n
                                  * "FABRIC_E_PATH_TOO_LONG""n  * "FABRIC_E_KEY_TOO_LARGE""n  *
                                  "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED""n  *
                                  "FABRIC_E_INVALID_ATOMIC_GROUP""n  * "FABRIC_E_VALUE_EMPTY""n  *
                                  "FABRIC_E_BACKUP_IS_ENABLED""n  *
                                  "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH""n  *
                                  "FABRIC_E_INVALID_FOR_STATELESS_SERVICES""n  *
                                  "FABRIC_E_INVALID_SERVICE_SCALING_POLICY""n  * "E_INVALIDARG""n"n* "n
                                  Possible values of the error code for HTTP status code 404 (Not
                                  Found)"n"n"n  * "FABRIC_E_NODE_NOT_FOUND""n  *
                                  "FABRIC_E_APPLICATION_TYPE_NOT_FOUND""n  *
                                  "FABRIC_E_APPLICATION_NOT_FOUND""n  *
                                  "FABRIC_E_SERVICE_TYPE_NOT_FOUND""n  *
                                  "FABRIC_E_SERVICE_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND""n  *
                                  "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND""n  *
                                  "FABRIC_E_PARTITION_NOT_FOUND""n  *
                                  "FABRIC_E_REPLICA_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND""n  *
                                  "FABRIC_E_DIRECTORY_NOT_FOUND""n  *
                                  "FABRIC_E_FABRIC_VERSION_NOT_FOUND""n  * "FABRIC_E_FILE_NOT_FOUND""n
                                  * "FABRIC_E_NAME_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_PROPERTY_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_ENUMERATION_COMPLETED""n  *
                                  "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND""n  * "FABRIC_E_KEY_NOT_FOUND""n
                                  * "FABRIC_E_HEALTH_ENTITY_NOT_FOUND""n  *
                                  "FABRIC_E_BACKUP_NOT_ENABLED""n  *
                                  "FABRIC_E_BACKUP_POLICY_NOT_EXISTING""n  *
                                  "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING""n  *
                                  "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR""n"n* "n  Possible
                                  values of the error code for HTTP status code 409 (Conflict)"n"n"n  *
                                  "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS""n  *
                                  "FABRIC_E_APPLICATION_ALREADY_EXISTS""n  *
                                  "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION""n  *
                                  "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS""n  *
                                  "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS""n  *
                                  "FABRIC_E_SERVICE_ALREADY_EXISTS""n  *
                                  "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS""n  *
                                  "FABRIC_E_APPLICATION_TYPE_IN_USE""n  *
                                  "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION""n  *
                                  "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS""n  *
                                  "FABRIC_E_FABRIC_VERSION_IN_USE""n  *
                                  "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS""n  *
                                  "FABRIC_E_NAME_ALREADY_EXISTS""n  * "FABRIC_E_NAME_NOT_EMPTY""n  *
                                  "FABRIC_E_PROPERTY_CHECK_FAILED""n  *
                                  "FABRIC_E_SERVICE_METADATA_MISMATCH""n  *
                                  "FABRIC_E_SERVICE_TYPE_MISMATCH""n  *
                                  "FABRIC_E_HEALTH_STALE_REPORT""n  *
                                  "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED""n  *
                                  "FABRIC_E_NODE_HAS_NOT_STOPPED_YET""n  *
                                  "FABRIC_E_INSTANCE_ID_MISMATCH""n  * "FABRIC_E_BACKUP_IN_PROGRESS""n
                                  * "FABRIC_E_RESTORE_IN_PROGRESS""n  *
                                  "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING""n"n* "n  Possible values of
                                  the error code for HTTP status code 413 (Request Entity Too
                                  Large)"n"n"n  * "FABRIC_E_VALUE_TOO_LARGE""n"n* "n  Possible values
                                  of the error code for HTTP status code 500 (Internal Server
                                  Error)"n"n"n  * "FABRIC_E_NODE_IS_UP""n  * "E_FAIL""n  *
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS""n  *
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND""n  *
                                  "FABRIC_E_VOLUME_ALREADY_EXISTS""n  * "FABRIC_E_VOLUME_NOT_FOUND""n
                                  * "SerializationError""n  * "FABRIC_E_CERTIFICATE_NOT_FOUND""n"n* "n
                                  Possible values of the error code for HTTP status code 503 (Service
                                  Unavailable)"n"n"n  * "FABRIC_E_NO_WRITE_QUORUM""n  *
                                  "FABRIC_E_NOT_PRIMARY""n  * "FABRIC_E_NOT_READY""n  *
                                  "FABRIC_E_RECONFIGURATION_PENDING""n  * "FABRIC_E_SERVICE_OFFLINE""n
                                  * "E_ABORT""n  * "FABRIC_E_VALUE_TOO_LARGE""n"n* "n  Possible values
                                  of the error code for HTTP status code 504 (Gateway Timeout)"n"n"n  *
                                  "FABRIC_E_COMMUNICATION_ERROR""n  *
                                  "FABRIC_E_OPERATION_NOT_COMPLETE""n  * "FABRIC_E_TIMEOUT". Known
                                  values are: "FABRIC_E_INVALID_PARTITION_KEY",
                                  "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR", "FABRIC_E_INVALID_ADDRESS",
                                  "FABRIC_E_APPLICATION_NOT_UPGRADING",
                                  "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR",
                                  "FABRIC_E_FABRIC_NOT_UPGRADING",
                                  "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR",
                                  "FABRIC_E_INVALID_CONFIGURATION", "FABRIC_E_INVALID_NAME_URI",
                                  "FABRIC_E_PATH_TOO_LONG", "FABRIC_E_KEY_TOO_LARGE",
                                  "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED",
                                  "FABRIC_E_INVALID_ATOMIC_GROUP", "FABRIC_E_VALUE_EMPTY",
                                  "FABRIC_E_NODE_NOT_FOUND", "FABRIC_E_APPLICATION_TYPE_NOT_FOUND",
                                  "FABRIC_E_APPLICATION_NOT_FOUND", "FABRIC_E_SERVICE_TYPE_NOT_FOUND",
                                  "FABRIC_E_SERVICE_DOES_NOT_EXIST",
                                  "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND",
                                  "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND",
                                  "FABRIC_E_PARTITION_NOT_FOUND", "FABRIC_E_REPLICA_DOES_NOT_EXIST",
                                  "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST",
                                  "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND",
                                  "FABRIC_E_DIRECTORY_NOT_FOUND", "FABRIC_E_FABRIC_VERSION_NOT_FOUND",
                                  "FABRIC_E_FILE_NOT_FOUND", "FABRIC_E_NAME_DOES_NOT_EXIST",
                                  "FABRIC_E_PROPERTY_DOES_NOT_EXIST", "FABRIC_E_ENUMERATION_COMPLETED",
                                  "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND", "FABRIC_E_KEY_NOT_FOUND",
                                  "FABRIC_E_HEALTH_ENTITY_NOT_FOUND",
                                  "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS",
                                  "FABRIC_E_APPLICATION_ALREADY_EXISTS",
                                  "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION",
                                  "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS",
                                  "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS",
                                  "FABRIC_E_SERVICE_ALREADY_EXISTS",
                                  "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS",
                                  "FABRIC_E_APPLICATION_TYPE_IN_USE",
                                  "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION",
                                  "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS",
                                  "FABRIC_E_FABRIC_VERSION_IN_USE",
                                  "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS",
                                  "FABRIC_E_NAME_ALREADY_EXISTS", "FABRIC_E_NAME_NOT_EMPTY",
                                  "FABRIC_E_PROPERTY_CHECK_FAILED",
                                  "FABRIC_E_SERVICE_METADATA_MISMATCH",
                                  "FABRIC_E_SERVICE_TYPE_MISMATCH", "FABRIC_E_HEALTH_STALE_REPORT",
                                  "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED",
                                  "FABRIC_E_NODE_HAS_NOT_STOPPED_YET", "FABRIC_E_INSTANCE_ID_MISMATCH",
                                  "FABRIC_E_VALUE_TOO_LARGE", "FABRIC_E_NO_WRITE_QUORUM",
                                  "FABRIC_E_NOT_PRIMARY", "FABRIC_E_NOT_READY",
                                  "FABRIC_E_RECONFIGURATION_PENDING", "FABRIC_E_SERVICE_OFFLINE",
                                  "E_ABORT", "FABRIC_E_COMMUNICATION_ERROR",
                                  "FABRIC_E_OPERATION_NOT_COMPLETE", "FABRIC_E_TIMEOUT",
                                  "FABRIC_E_NODE_IS_UP", "E_FAIL", "FABRIC_E_BACKUP_IS_ENABLED",
                                  "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH",
                                  "FABRIC_E_INVALID_FOR_STATELESS_SERVICES",
                                  "FABRIC_E_BACKUP_NOT_ENABLED", "FABRIC_E_BACKUP_POLICY_NOT_EXISTING",
                                  "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING",
                                  "FABRIC_E_BACKUP_IN_PROGRESS", "FABRIC_E_RESTORE_IN_PROGRESS",
                                  "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING",
                                  "FABRIC_E_INVALID_SERVICE_SCALING_POLICY", "E_INVALIDARG",
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS",
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND",
                                  "FABRIC_E_VOLUME_ALREADY_EXISTS", "FABRIC_E_VOLUME_NOT_FOUND",
                                  "SerializationError",
                                  "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR",
                                  "FABRIC_E_CERTIFICATE_NOT_FOUND".
                                "Message": "str"  # Optional. Error message.
                            },
                            "LsnOfLastBackupRecord": "str",  # Optional. LSN of the last
                              record in this backup.
                            "PartitionInformation": {
                                "Id": str,  # Optional. An internal ID used by
                                  Service Fabric to uniquely identify a partition. This is a randomly
                                  generated GUID when the service was created. The partition ID is
                                  unique and does not change for the lifetime of the service. If the
                                  same service was deleted and recreated the IDs of its partitions
                                  would be different.
                                ServicePartitionKind: ServicePartitionKind
                            },
                            "ServiceManifestVersion": "str",  # Optional. Manifest
                              Version of the service this partition backup belongs to.
                            "ServiceName": "str"  # Optional. Name of the Service Fabric
                              service this partition backup belongs to.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_partition_backup_list_request(
            partition_id=partition_id,
            api_version=api_version,
            timeout=timeout,
            latest=latest,
            start_date_time_filter=start_date_time_filter,
            end_date_time_filter=end_date_time_filter,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def suspend_partition_backup(  # pylint: disable=inconsistent-return-statements
        self,
        partition_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Suspends periodic backup for the specified partition.

        The partition which is configured to take periodic backups, is suspended for taking further
        backups till it is resumed again.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_suspend_partition_backup_request(
            partition_id=partition_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def resume_partition_backup(  # pylint: disable=inconsistent-return-statements
        self,
        partition_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Resumes periodic backup of partition which was previously suspended.

        The previously suspended partition resumes taking periodic backup as per the backup policy
        currently configured for the same.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_resume_partition_backup_request(
            partition_id=partition_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def backup_partition(  # pylint: disable=inconsistent-return-statements
        self,
        partition_id: str,
        backup_partition_description: Optional[JSON] = None,
        *,
        backup_timeout: Optional[int] = 10,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Triggers backup of the partition's state.

        Creates a backup of the stateful persisted partition's state. In case the partition is already
        being periodically backed up, then by default the new backup is created at the same backup
        storage. One can also override the same by specifying the backup storage details as part of the
        request body. Once the backup is initiated, its progress can be tracked using the
        GetBackupProgress operation.
        In case, the operation times out, specify a greater backup timeout value in the query
        parameter.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :param backup_partition_description: Describes the parameters to backup the partition now. If
         not present, backup operation uses default parameters from the backup policy current associated
         with this partition. Default value is None.
        :type backup_partition_description: JSON
        :keyword backup_timeout: Specifies the maximum amount of time, in minutes, to wait for the
         backup operation to complete. Post that, the operation completes with timeout error. However,
         in certain corner cases it could be that though the operation returns back timeout, the backup
         actually goes through. In case of timeout error, its recommended to invoke this operation again
         with a greater timeout value. The default value for the same is 10 minutes. Default value is
         10.
        :paramtype backup_timeout: int
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python


                # JSON input template you can fill out and use as your body input.
                backup_partition_description = {
                    "BackupStorage": {
                        "FriendlyName": "str",  # Optional. Friendly name for this backup
                          storage.
                        StorageKind: StorageKind
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        if backup_partition_description is not None:
            _json = backup_partition_description
        else:
            _json = None

        request = build_backup_partition_request(
            partition_id=partition_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            backup_timeout=backup_timeout,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_partition_backup_progress(
        self,
        partition_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets details for the latest backup triggered for this partition.

        Returns information about the state of the latest backup along with details or failure reason
        in case of completion.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "BackupId": str,  # Optional. Unique ID of the newly created backup.
                    "BackupLocation": "str",  # Optional. Location, relative to the backup store,
                      of the newly created backup.
                    "BackupState": "str",  # Optional. Represents the current state of the
                      partition backup operation. Known values are: "Invalid", "Accepted",
                      "BackupInProgress", "Success", "Failure", "Timeout".
                    "EpochOfLastBackupRecord": {
                        "ConfigurationVersion": "str",  # Optional. The current configuration
                          number of this Epoch. The configuration number is an increasing value that is
                          updated whenever the configuration of this replica set changes.
                        "DataLossVersion": "str"  # Optional. The current data loss number of
                          this Epoch. The data loss number property is an increasing value which is
                          updated whenever data loss is suspected, as when loss of a quorum of replicas
                          in the replica set that includes the Primary replica.
                    },
                    "FailureError": {
                        "Code": "str",  # Required. Defines the fabric error codes that be
                          returned as part of the error object in response to Service Fabric API
                          operations that are not successful. Following are the error code values that
                          can be returned for a specific HTTP status code."n"n"n* "n  Possible values
                          of the error code for HTTP status code 400 (Bad Request)"n"n"n  *
                          "FABRIC_E_INVALID_PARTITION_KEY""n  *
                          "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR""n  * "FABRIC_E_INVALID_ADDRESS""n  *
                          "FABRIC_E_APPLICATION_NOT_UPGRADING""n  *
                          "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR""n  *
                          "FABRIC_E_FABRIC_NOT_UPGRADING""n  *
                          "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR""n  *
                          "FABRIC_E_INVALID_CONFIGURATION""n  * "FABRIC_E_INVALID_NAME_URI""n  *
                          "FABRIC_E_PATH_TOO_LONG""n  * "FABRIC_E_KEY_TOO_LARGE""n  *
                          "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED""n  *
                          "FABRIC_E_INVALID_ATOMIC_GROUP""n  * "FABRIC_E_VALUE_EMPTY""n  *
                          "FABRIC_E_BACKUP_IS_ENABLED""n  *
                          "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH""n  *
                          "FABRIC_E_INVALID_FOR_STATELESS_SERVICES""n  *
                          "FABRIC_E_INVALID_SERVICE_SCALING_POLICY""n  * "E_INVALIDARG""n"n* "n
                          Possible values of the error code for HTTP status code 404 (Not Found)"n"n"n
                          * "FABRIC_E_NODE_NOT_FOUND""n  * "FABRIC_E_APPLICATION_TYPE_NOT_FOUND""n  *
                          "FABRIC_E_APPLICATION_NOT_FOUND""n  * "FABRIC_E_SERVICE_TYPE_NOT_FOUND""n  *
                          "FABRIC_E_SERVICE_DOES_NOT_EXIST""n  *
                          "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND""n  *
                          "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND""n  *
                          "FABRIC_E_PARTITION_NOT_FOUND""n  * "FABRIC_E_REPLICA_DOES_NOT_EXIST""n  *
                          "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST""n  *
                          "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND""n  *
                          "FABRIC_E_DIRECTORY_NOT_FOUND""n  * "FABRIC_E_FABRIC_VERSION_NOT_FOUND""n  *
                          "FABRIC_E_FILE_NOT_FOUND""n  * "FABRIC_E_NAME_DOES_NOT_EXIST""n  *
                          "FABRIC_E_PROPERTY_DOES_NOT_EXIST""n  * "FABRIC_E_ENUMERATION_COMPLETED""n  *
                          "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND""n  * "FABRIC_E_KEY_NOT_FOUND""n  *
                          "FABRIC_E_HEALTH_ENTITY_NOT_FOUND""n  * "FABRIC_E_BACKUP_NOT_ENABLED""n  *
                          "FABRIC_E_BACKUP_POLICY_NOT_EXISTING""n  *
                          "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING""n  *
                          "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR""n"n* "n  Possible values of
                          the error code for HTTP status code 409 (Conflict)"n"n"n  *
                          "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS""n  *
                          "FABRIC_E_APPLICATION_ALREADY_EXISTS""n  *
                          "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION""n  *
                          "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS""n  *
                          "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS""n  *
                          "FABRIC_E_SERVICE_ALREADY_EXISTS""n  *
                          "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS""n  *
                          "FABRIC_E_APPLICATION_TYPE_IN_USE""n  *
                          "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION""n  *
                          "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS""n  *
                          "FABRIC_E_FABRIC_VERSION_IN_USE""n  * "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS""n
                          * "FABRIC_E_NAME_ALREADY_EXISTS""n  * "FABRIC_E_NAME_NOT_EMPTY""n  *
                          "FABRIC_E_PROPERTY_CHECK_FAILED""n  * "FABRIC_E_SERVICE_METADATA_MISMATCH""n
                          * "FABRIC_E_SERVICE_TYPE_MISMATCH""n  * "FABRIC_E_HEALTH_STALE_REPORT""n  *
                          "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED""n  *
                          "FABRIC_E_NODE_HAS_NOT_STOPPED_YET""n  * "FABRIC_E_INSTANCE_ID_MISMATCH""n  *
                          "FABRIC_E_BACKUP_IN_PROGRESS""n  * "FABRIC_E_RESTORE_IN_PROGRESS""n  *
                          "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING""n"n* "n  Possible values of the
                          error code for HTTP status code 413 (Request Entity Too Large)"n"n"n  *
                          "FABRIC_E_VALUE_TOO_LARGE""n"n* "n  Possible values of the error code for
                          HTTP status code 500 (Internal Server Error)"n"n"n  * "FABRIC_E_NODE_IS_UP""n
                          * "E_FAIL""n  * "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS""n  *
                          "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND""n  *
                          "FABRIC_E_VOLUME_ALREADY_EXISTS""n  * "FABRIC_E_VOLUME_NOT_FOUND""n  *
                          "SerializationError""n  * "FABRIC_E_CERTIFICATE_NOT_FOUND""n"n* "n  Possible
                          values of the error code for HTTP status code 503 (Service Unavailable)"n"n"n
                          * "FABRIC_E_NO_WRITE_QUORUM""n  * "FABRIC_E_NOT_PRIMARY""n  *
                          "FABRIC_E_NOT_READY""n  * "FABRIC_E_RECONFIGURATION_PENDING""n  *
                          "FABRIC_E_SERVICE_OFFLINE""n  * "E_ABORT""n  *
                          "FABRIC_E_VALUE_TOO_LARGE""n"n* "n  Possible values of the error code for
                          HTTP status code 504 (Gateway Timeout)"n"n"n  *
                          "FABRIC_E_COMMUNICATION_ERROR""n  * "FABRIC_E_OPERATION_NOT_COMPLETE""n  *
                          "FABRIC_E_TIMEOUT". Known values are: "FABRIC_E_INVALID_PARTITION_KEY",
                          "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR", "FABRIC_E_INVALID_ADDRESS",
                          "FABRIC_E_APPLICATION_NOT_UPGRADING",
                          "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR",
                          "FABRIC_E_FABRIC_NOT_UPGRADING", "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR",
                          "FABRIC_E_INVALID_CONFIGURATION", "FABRIC_E_INVALID_NAME_URI",
                          "FABRIC_E_PATH_TOO_LONG", "FABRIC_E_KEY_TOO_LARGE",
                          "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED",
                          "FABRIC_E_INVALID_ATOMIC_GROUP", "FABRIC_E_VALUE_EMPTY",
                          "FABRIC_E_NODE_NOT_FOUND", "FABRIC_E_APPLICATION_TYPE_NOT_FOUND",
                          "FABRIC_E_APPLICATION_NOT_FOUND", "FABRIC_E_SERVICE_TYPE_NOT_FOUND",
                          "FABRIC_E_SERVICE_DOES_NOT_EXIST",
                          "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND",
                          "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND", "FABRIC_E_PARTITION_NOT_FOUND",
                          "FABRIC_E_REPLICA_DOES_NOT_EXIST", "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST",
                          "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND", "FABRIC_E_DIRECTORY_NOT_FOUND",
                          "FABRIC_E_FABRIC_VERSION_NOT_FOUND", "FABRIC_E_FILE_NOT_FOUND",
                          "FABRIC_E_NAME_DOES_NOT_EXIST", "FABRIC_E_PROPERTY_DOES_NOT_EXIST",
                          "FABRIC_E_ENUMERATION_COMPLETED", "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND",
                          "FABRIC_E_KEY_NOT_FOUND", "FABRIC_E_HEALTH_ENTITY_NOT_FOUND",
                          "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS",
                          "FABRIC_E_APPLICATION_ALREADY_EXISTS",
                          "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION",
                          "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS",
                          "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS",
                          "FABRIC_E_SERVICE_ALREADY_EXISTS", "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS",
                          "FABRIC_E_APPLICATION_TYPE_IN_USE",
                          "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION",
                          "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS", "FABRIC_E_FABRIC_VERSION_IN_USE",
                          "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS", "FABRIC_E_NAME_ALREADY_EXISTS",
                          "FABRIC_E_NAME_NOT_EMPTY", "FABRIC_E_PROPERTY_CHECK_FAILED",
                          "FABRIC_E_SERVICE_METADATA_MISMATCH", "FABRIC_E_SERVICE_TYPE_MISMATCH",
                          "FABRIC_E_HEALTH_STALE_REPORT", "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED",
                          "FABRIC_E_NODE_HAS_NOT_STOPPED_YET", "FABRIC_E_INSTANCE_ID_MISMATCH",
                          "FABRIC_E_VALUE_TOO_LARGE", "FABRIC_E_NO_WRITE_QUORUM",
                          "FABRIC_E_NOT_PRIMARY", "FABRIC_E_NOT_READY",
                          "FABRIC_E_RECONFIGURATION_PENDING", "FABRIC_E_SERVICE_OFFLINE", "E_ABORT",
                          "FABRIC_E_COMMUNICATION_ERROR", "FABRIC_E_OPERATION_NOT_COMPLETE",
                          "FABRIC_E_TIMEOUT", "FABRIC_E_NODE_IS_UP", "E_FAIL",
                          "FABRIC_E_BACKUP_IS_ENABLED",
                          "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH",
                          "FABRIC_E_INVALID_FOR_STATELESS_SERVICES", "FABRIC_E_BACKUP_NOT_ENABLED",
                          "FABRIC_E_BACKUP_POLICY_NOT_EXISTING",
                          "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING",
                          "FABRIC_E_BACKUP_IN_PROGRESS", "FABRIC_E_RESTORE_IN_PROGRESS",
                          "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING",
                          "FABRIC_E_INVALID_SERVICE_SCALING_POLICY", "E_INVALIDARG",
                          "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS",
                          "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND",
                          "FABRIC_E_VOLUME_ALREADY_EXISTS", "FABRIC_E_VOLUME_NOT_FOUND",
                          "SerializationError", "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR",
                          "FABRIC_E_CERTIFICATE_NOT_FOUND".
                        "Message": "str"  # Optional. Error message.
                    },
                    "LsnOfLastBackupRecord": "str",  # Optional. The LSN of last record included
                      in backup.
                    "TimeStampUtc": "2020-02-20 00:00:00"  # Optional. TimeStamp in UTC when
                      operation succeeded or failed.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_partition_backup_progress_request(
            partition_id=partition_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def restore_partition(  # pylint: disable=inconsistent-return-statements
        self,
        partition_id: str,
        restore_partition_description: JSON,
        *,
        restore_timeout: Optional[int] = 10,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Triggers restore of the state of the partition using the specified restore partition
        description.

        Restores the state of a of the stateful persisted partition using the specified backup point.
        In case the partition is already being periodically backed up, then by default the backup point
        is looked for in the storage specified in backup policy. One can also override the same by
        specifying the backup storage details as part of the restore partition description in body.
        Once the restore is initiated, its progress can be tracked using the GetRestoreProgress
        operation.
        In case, the operation times out, specify a greater restore timeout value in the query
        parameter.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :param restore_partition_description: Describes the parameters to restore the partition.
        :type restore_partition_description: JSON
        :keyword restore_timeout: Specifies the maximum amount of time to wait, in minutes, for the
         restore operation to complete. Post that, the operation returns back with timeout error.
         However, in certain corner cases it could be that the restore operation goes through even
         though it completes with timeout. In case of timeout error, its recommended to invoke this
         operation again with a greater timeout value. the default value for the same is 10 minutes.
         Default value is 10.
        :paramtype restore_timeout: int
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python


                # JSON input template you can fill out and use as your body input.
                restore_partition_description = {
                    "BackupId": str,  # Required. Unique backup ID.
                    "BackupLocation": "str",  # Required. Location of the backup relative to the
                      backup storage specified/ configured.
                    "BackupStorage": {
                        "FriendlyName": "str",  # Optional. Friendly name for this backup
                          storage.
                        StorageKind: StorageKind
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = restore_partition_description

        request = build_restore_partition_request(
            partition_id=partition_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            restore_timeout=restore_timeout,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_partition_restore_progress(
        self,
        partition_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets details for the latest restore operation triggered for this partition.

        Returns information about the state of the latest restore operation along with details or
        failure reason in case of completion.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "FailureError": {
                        "Code": "str",  # Required. Defines the fabric error codes that be
                          returned as part of the error object in response to Service Fabric API
                          operations that are not successful. Following are the error code values that
                          can be returned for a specific HTTP status code."n"n"n* "n  Possible values
                          of the error code for HTTP status code 400 (Bad Request)"n"n"n  *
                          "FABRIC_E_INVALID_PARTITION_KEY""n  *
                          "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR""n  * "FABRIC_E_INVALID_ADDRESS""n  *
                          "FABRIC_E_APPLICATION_NOT_UPGRADING""n  *
                          "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR""n  *
                          "FABRIC_E_FABRIC_NOT_UPGRADING""n  *
                          "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR""n  *
                          "FABRIC_E_INVALID_CONFIGURATION""n  * "FABRIC_E_INVALID_NAME_URI""n  *
                          "FABRIC_E_PATH_TOO_LONG""n  * "FABRIC_E_KEY_TOO_LARGE""n  *
                          "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED""n  *
                          "FABRIC_E_INVALID_ATOMIC_GROUP""n  * "FABRIC_E_VALUE_EMPTY""n  *
                          "FABRIC_E_BACKUP_IS_ENABLED""n  *
                          "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH""n  *
                          "FABRIC_E_INVALID_FOR_STATELESS_SERVICES""n  *
                          "FABRIC_E_INVALID_SERVICE_SCALING_POLICY""n  * "E_INVALIDARG""n"n* "n
                          Possible values of the error code for HTTP status code 404 (Not Found)"n"n"n
                          * "FABRIC_E_NODE_NOT_FOUND""n  * "FABRIC_E_APPLICATION_TYPE_NOT_FOUND""n  *
                          "FABRIC_E_APPLICATION_NOT_FOUND""n  * "FABRIC_E_SERVICE_TYPE_NOT_FOUND""n  *
                          "FABRIC_E_SERVICE_DOES_NOT_EXIST""n  *
                          "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND""n  *
                          "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND""n  *
                          "FABRIC_E_PARTITION_NOT_FOUND""n  * "FABRIC_E_REPLICA_DOES_NOT_EXIST""n  *
                          "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST""n  *
                          "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND""n  *
                          "FABRIC_E_DIRECTORY_NOT_FOUND""n  * "FABRIC_E_FABRIC_VERSION_NOT_FOUND""n  *
                          "FABRIC_E_FILE_NOT_FOUND""n  * "FABRIC_E_NAME_DOES_NOT_EXIST""n  *
                          "FABRIC_E_PROPERTY_DOES_NOT_EXIST""n  * "FABRIC_E_ENUMERATION_COMPLETED""n  *
                          "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND""n  * "FABRIC_E_KEY_NOT_FOUND""n  *
                          "FABRIC_E_HEALTH_ENTITY_NOT_FOUND""n  * "FABRIC_E_BACKUP_NOT_ENABLED""n  *
                          "FABRIC_E_BACKUP_POLICY_NOT_EXISTING""n  *
                          "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING""n  *
                          "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR""n"n* "n  Possible values of
                          the error code for HTTP status code 409 (Conflict)"n"n"n  *
                          "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS""n  *
                          "FABRIC_E_APPLICATION_ALREADY_EXISTS""n  *
                          "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION""n  *
                          "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS""n  *
                          "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS""n  *
                          "FABRIC_E_SERVICE_ALREADY_EXISTS""n  *
                          "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS""n  *
                          "FABRIC_E_APPLICATION_TYPE_IN_USE""n  *
                          "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION""n  *
                          "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS""n  *
                          "FABRIC_E_FABRIC_VERSION_IN_USE""n  * "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS""n
                          * "FABRIC_E_NAME_ALREADY_EXISTS""n  * "FABRIC_E_NAME_NOT_EMPTY""n  *
                          "FABRIC_E_PROPERTY_CHECK_FAILED""n  * "FABRIC_E_SERVICE_METADATA_MISMATCH""n
                          * "FABRIC_E_SERVICE_TYPE_MISMATCH""n  * "FABRIC_E_HEALTH_STALE_REPORT""n  *
                          "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED""n  *
                          "FABRIC_E_NODE_HAS_NOT_STOPPED_YET""n  * "FABRIC_E_INSTANCE_ID_MISMATCH""n  *
                          "FABRIC_E_BACKUP_IN_PROGRESS""n  * "FABRIC_E_RESTORE_IN_PROGRESS""n  *
                          "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING""n"n* "n  Possible values of the
                          error code for HTTP status code 413 (Request Entity Too Large)"n"n"n  *
                          "FABRIC_E_VALUE_TOO_LARGE""n"n* "n  Possible values of the error code for
                          HTTP status code 500 (Internal Server Error)"n"n"n  * "FABRIC_E_NODE_IS_UP""n
                          * "E_FAIL""n  * "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS""n  *
                          "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND""n  *
                          "FABRIC_E_VOLUME_ALREADY_EXISTS""n  * "FABRIC_E_VOLUME_NOT_FOUND""n  *
                          "SerializationError""n  * "FABRIC_E_CERTIFICATE_NOT_FOUND""n"n* "n  Possible
                          values of the error code for HTTP status code 503 (Service Unavailable)"n"n"n
                          * "FABRIC_E_NO_WRITE_QUORUM""n  * "FABRIC_E_NOT_PRIMARY""n  *
                          "FABRIC_E_NOT_READY""n  * "FABRIC_E_RECONFIGURATION_PENDING""n  *
                          "FABRIC_E_SERVICE_OFFLINE""n  * "E_ABORT""n  *
                          "FABRIC_E_VALUE_TOO_LARGE""n"n* "n  Possible values of the error code for
                          HTTP status code 504 (Gateway Timeout)"n"n"n  *
                          "FABRIC_E_COMMUNICATION_ERROR""n  * "FABRIC_E_OPERATION_NOT_COMPLETE""n  *
                          "FABRIC_E_TIMEOUT". Known values are: "FABRIC_E_INVALID_PARTITION_KEY",
                          "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR", "FABRIC_E_INVALID_ADDRESS",
                          "FABRIC_E_APPLICATION_NOT_UPGRADING",
                          "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR",
                          "FABRIC_E_FABRIC_NOT_UPGRADING", "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR",
                          "FABRIC_E_INVALID_CONFIGURATION", "FABRIC_E_INVALID_NAME_URI",
                          "FABRIC_E_PATH_TOO_LONG", "FABRIC_E_KEY_TOO_LARGE",
                          "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED",
                          "FABRIC_E_INVALID_ATOMIC_GROUP", "FABRIC_E_VALUE_EMPTY",
                          "FABRIC_E_NODE_NOT_FOUND", "FABRIC_E_APPLICATION_TYPE_NOT_FOUND",
                          "FABRIC_E_APPLICATION_NOT_FOUND", "FABRIC_E_SERVICE_TYPE_NOT_FOUND",
                          "FABRIC_E_SERVICE_DOES_NOT_EXIST",
                          "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND",
                          "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND", "FABRIC_E_PARTITION_NOT_FOUND",
                          "FABRIC_E_REPLICA_DOES_NOT_EXIST", "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST",
                          "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND", "FABRIC_E_DIRECTORY_NOT_FOUND",
                          "FABRIC_E_FABRIC_VERSION_NOT_FOUND", "FABRIC_E_FILE_NOT_FOUND",
                          "FABRIC_E_NAME_DOES_NOT_EXIST", "FABRIC_E_PROPERTY_DOES_NOT_EXIST",
                          "FABRIC_E_ENUMERATION_COMPLETED", "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND",
                          "FABRIC_E_KEY_NOT_FOUND", "FABRIC_E_HEALTH_ENTITY_NOT_FOUND",
                          "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS",
                          "FABRIC_E_APPLICATION_ALREADY_EXISTS",
                          "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION",
                          "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS",
                          "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS",
                          "FABRIC_E_SERVICE_ALREADY_EXISTS", "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS",
                          "FABRIC_E_APPLICATION_TYPE_IN_USE",
                          "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION",
                          "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS", "FABRIC_E_FABRIC_VERSION_IN_USE",
                          "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS", "FABRIC_E_NAME_ALREADY_EXISTS",
                          "FABRIC_E_NAME_NOT_EMPTY", "FABRIC_E_PROPERTY_CHECK_FAILED",
                          "FABRIC_E_SERVICE_METADATA_MISMATCH", "FABRIC_E_SERVICE_TYPE_MISMATCH",
                          "FABRIC_E_HEALTH_STALE_REPORT", "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED",
                          "FABRIC_E_NODE_HAS_NOT_STOPPED_YET", "FABRIC_E_INSTANCE_ID_MISMATCH",
                          "FABRIC_E_VALUE_TOO_LARGE", "FABRIC_E_NO_WRITE_QUORUM",
                          "FABRIC_E_NOT_PRIMARY", "FABRIC_E_NOT_READY",
                          "FABRIC_E_RECONFIGURATION_PENDING", "FABRIC_E_SERVICE_OFFLINE", "E_ABORT",
                          "FABRIC_E_COMMUNICATION_ERROR", "FABRIC_E_OPERATION_NOT_COMPLETE",
                          "FABRIC_E_TIMEOUT", "FABRIC_E_NODE_IS_UP", "E_FAIL",
                          "FABRIC_E_BACKUP_IS_ENABLED",
                          "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH",
                          "FABRIC_E_INVALID_FOR_STATELESS_SERVICES", "FABRIC_E_BACKUP_NOT_ENABLED",
                          "FABRIC_E_BACKUP_POLICY_NOT_EXISTING",
                          "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING",
                          "FABRIC_E_BACKUP_IN_PROGRESS", "FABRIC_E_RESTORE_IN_PROGRESS",
                          "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING",
                          "FABRIC_E_INVALID_SERVICE_SCALING_POLICY", "E_INVALIDARG",
                          "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS",
                          "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND",
                          "FABRIC_E_VOLUME_ALREADY_EXISTS", "FABRIC_E_VOLUME_NOT_FOUND",
                          "SerializationError", "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR",
                          "FABRIC_E_CERTIFICATE_NOT_FOUND".
                        "Message": "str"  # Optional. Error message.
                    },
                    "RestoreState": "str",  # Optional. Represents the current state of the
                      partition restore operation. Known values are: "Invalid", "Accepted",
                      "RestoreInProgress", "Success", "Failure", "Timeout".
                    "RestoredEpoch": {
                        "ConfigurationVersion": "str",  # Optional. The current configuration
                          number of this Epoch. The configuration number is an increasing value that is
                          updated whenever the configuration of this replica set changes.
                        "DataLossVersion": "str"  # Optional. The current data loss number of
                          this Epoch. The data loss number property is an increasing value which is
                          updated whenever data loss is suspected, as when loss of a quorum of replicas
                          in the replica set that includes the Primary replica.
                    },
                    "RestoredLsn": "str",  # Optional. Restored LSN.
                    "TimeStampUtc": "2020-02-20 00:00:00"  # Optional. Timestamp when operation
                      succeeded or failed.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_partition_restore_progress_request(
            partition_id=partition_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_backups_from_backup_location(
        self,
        get_backup_by_storage_query_description: JSON,
        *,
        timeout: Optional[int] = 60,
        continuation_token_parameter: Optional[str] = None,
        max_results: Optional[int] = 0,
        **kwargs: Any
    ) -> JSON:
        """Gets the list of backups available for the specified backed up entity at the specified backup
        location.

        Gets the list of backups available for the specified backed up entity (Application, Service or
        Partition) at the specified backup location (FileShare or Azure Blob Storage).

        :param get_backup_by_storage_query_description: Describes the filters and backup storage
         details to be used for enumerating backups.
        :type get_backup_by_storage_query_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword max_results: The maximum number of results to be returned as part of the paged
         queries. This parameter defines the upper bound on the number of results returned. The results
         returned can be less than the specified maximum results if they do not fit in the message as
         per the max message size restrictions defined in the configuration. If this parameter is zero
         or not specified, the paged query includes as many results as possible that fit in the return
         message. Default value is 0.
        :paramtype max_results: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python


                # JSON input template you can fill out and use as your body input.
                get_backup_by_storage_query_description = {
                    "BackupEntity": {
                        EntityKind: EntityKind
                    },
                    "EndDateTimeFilter": "2020-02-20 00:00:00",  # Optional. Specifies the end
                      date time in ISO8601 till which to enumerate backups. If not specified, backups
                      are enumerated till the end.
                    "Latest": bool,  # Optional. If specified as true, gets the most recent
                      backup (within the specified time range) for every partition under the specified
                      backup entity.
                    "StartDateTimeFilter": "2020-02-20 00:00:00",  # Optional. Specifies the
                      start date time in ISO8601 from which to enumerate backups. If not specified,
                      backups are enumerated from the beginning.
                    "Storage": {
                        "FriendlyName": "str",  # Optional. Friendly name for this backup
                          storage.
                        StorageKind: StorageKind
                    }
                }

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "ApplicationName": "str",  # Optional. Name of the Service
                              Fabric application this partition backup belongs to.
                            "BackupChainId": str,  # Optional. Unique backup chain ID.
                              All backups part of the same chain has the same backup chain id. A backup
                              chain is comprised of 1 full backup and multiple incremental backups.
                            "BackupId": str,  # Optional. Unique backup ID .
                            "BackupLocation": "str",  # Optional. Location of the backup,
                              relative to the backup store.
                            "BackupType": "str",  # Optional. Describes the type of
                              backup, whether its full or incremental. Known values are: "Invalid",
                              "Full", "Incremental".
                            "CreationTimeUtc": "2020-02-20 00:00:00",  # Optional. The
                              date time when this backup was taken.
                            "EpochOfLastBackupRecord": {
                                "ConfigurationVersion": "str",  # Optional. The
                                  current configuration number of this Epoch. The configuration number
                                  is an increasing value that is updated whenever the configuration of
                                  this replica set changes.
                                "DataLossVersion": "str"  # Optional. The current
                                  data loss number of this Epoch. The data loss number property is an
                                  increasing value which is updated whenever data loss is suspected, as
                                  when loss of a quorum of replicas in the replica set that includes
                                  the Primary replica.
                            },
                            "FailureError": {
                                "Code": "str",  # Required. Defines the fabric error
                                  codes that be returned as part of the error object in response to
                                  Service Fabric API operations that are not successful. Following are
                                  the error code values that can be returned for a specific HTTP status
                                  code."n"n"n* "n  Possible values of the error code for HTTP status
                                  code 400 (Bad Request)"n"n"n  * "FABRIC_E_INVALID_PARTITION_KEY""n  *
                                  "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR""n  *
                                  "FABRIC_E_INVALID_ADDRESS""n  *
                                  "FABRIC_E_APPLICATION_NOT_UPGRADING""n  *
                                  "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR""n  *
                                  "FABRIC_E_FABRIC_NOT_UPGRADING""n  *
                                  "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR""n  *
                                  "FABRIC_E_INVALID_CONFIGURATION""n  * "FABRIC_E_INVALID_NAME_URI""n
                                  * "FABRIC_E_PATH_TOO_LONG""n  * "FABRIC_E_KEY_TOO_LARGE""n  *
                                  "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED""n  *
                                  "FABRIC_E_INVALID_ATOMIC_GROUP""n  * "FABRIC_E_VALUE_EMPTY""n  *
                                  "FABRIC_E_BACKUP_IS_ENABLED""n  *
                                  "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH""n  *
                                  "FABRIC_E_INVALID_FOR_STATELESS_SERVICES""n  *
                                  "FABRIC_E_INVALID_SERVICE_SCALING_POLICY""n  * "E_INVALIDARG""n"n* "n
                                  Possible values of the error code for HTTP status code 404 (Not
                                  Found)"n"n"n  * "FABRIC_E_NODE_NOT_FOUND""n  *
                                  "FABRIC_E_APPLICATION_TYPE_NOT_FOUND""n  *
                                  "FABRIC_E_APPLICATION_NOT_FOUND""n  *
                                  "FABRIC_E_SERVICE_TYPE_NOT_FOUND""n  *
                                  "FABRIC_E_SERVICE_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND""n  *
                                  "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND""n  *
                                  "FABRIC_E_PARTITION_NOT_FOUND""n  *
                                  "FABRIC_E_REPLICA_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND""n  *
                                  "FABRIC_E_DIRECTORY_NOT_FOUND""n  *
                                  "FABRIC_E_FABRIC_VERSION_NOT_FOUND""n  * "FABRIC_E_FILE_NOT_FOUND""n
                                  * "FABRIC_E_NAME_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_PROPERTY_DOES_NOT_EXIST""n  *
                                  "FABRIC_E_ENUMERATION_COMPLETED""n  *
                                  "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND""n  * "FABRIC_E_KEY_NOT_FOUND""n
                                  * "FABRIC_E_HEALTH_ENTITY_NOT_FOUND""n  *
                                  "FABRIC_E_BACKUP_NOT_ENABLED""n  *
                                  "FABRIC_E_BACKUP_POLICY_NOT_EXISTING""n  *
                                  "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING""n  *
                                  "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR""n"n* "n  Possible
                                  values of the error code for HTTP status code 409 (Conflict)"n"n"n  *
                                  "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS""n  *
                                  "FABRIC_E_APPLICATION_ALREADY_EXISTS""n  *
                                  "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION""n  *
                                  "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS""n  *
                                  "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS""n  *
                                  "FABRIC_E_SERVICE_ALREADY_EXISTS""n  *
                                  "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS""n  *
                                  "FABRIC_E_APPLICATION_TYPE_IN_USE""n  *
                                  "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION""n  *
                                  "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS""n  *
                                  "FABRIC_E_FABRIC_VERSION_IN_USE""n  *
                                  "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS""n  *
                                  "FABRIC_E_NAME_ALREADY_EXISTS""n  * "FABRIC_E_NAME_NOT_EMPTY""n  *
                                  "FABRIC_E_PROPERTY_CHECK_FAILED""n  *
                                  "FABRIC_E_SERVICE_METADATA_MISMATCH""n  *
                                  "FABRIC_E_SERVICE_TYPE_MISMATCH""n  *
                                  "FABRIC_E_HEALTH_STALE_REPORT""n  *
                                  "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED""n  *
                                  "FABRIC_E_NODE_HAS_NOT_STOPPED_YET""n  *
                                  "FABRIC_E_INSTANCE_ID_MISMATCH""n  * "FABRIC_E_BACKUP_IN_PROGRESS""n
                                  * "FABRIC_E_RESTORE_IN_PROGRESS""n  *
                                  "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING""n"n* "n  Possible values of
                                  the error code for HTTP status code 413 (Request Entity Too
                                  Large)"n"n"n  * "FABRIC_E_VALUE_TOO_LARGE""n"n* "n  Possible values
                                  of the error code for HTTP status code 500 (Internal Server
                                  Error)"n"n"n  * "FABRIC_E_NODE_IS_UP""n  * "E_FAIL""n  *
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS""n  *
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND""n  *
                                  "FABRIC_E_VOLUME_ALREADY_EXISTS""n  * "FABRIC_E_VOLUME_NOT_FOUND""n
                                  * "SerializationError""n  * "FABRIC_E_CERTIFICATE_NOT_FOUND""n"n* "n
                                  Possible values of the error code for HTTP status code 503 (Service
                                  Unavailable)"n"n"n  * "FABRIC_E_NO_WRITE_QUORUM""n  *
                                  "FABRIC_E_NOT_PRIMARY""n  * "FABRIC_E_NOT_READY""n  *
                                  "FABRIC_E_RECONFIGURATION_PENDING""n  * "FABRIC_E_SERVICE_OFFLINE""n
                                  * "E_ABORT""n  * "FABRIC_E_VALUE_TOO_LARGE""n"n* "n  Possible values
                                  of the error code for HTTP status code 504 (Gateway Timeout)"n"n"n  *
                                  "FABRIC_E_COMMUNICATION_ERROR""n  *
                                  "FABRIC_E_OPERATION_NOT_COMPLETE""n  * "FABRIC_E_TIMEOUT". Known
                                  values are: "FABRIC_E_INVALID_PARTITION_KEY",
                                  "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR", "FABRIC_E_INVALID_ADDRESS",
                                  "FABRIC_E_APPLICATION_NOT_UPGRADING",
                                  "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR",
                                  "FABRIC_E_FABRIC_NOT_UPGRADING",
                                  "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR",
                                  "FABRIC_E_INVALID_CONFIGURATION", "FABRIC_E_INVALID_NAME_URI",
                                  "FABRIC_E_PATH_TOO_LONG", "FABRIC_E_KEY_TOO_LARGE",
                                  "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED",
                                  "FABRIC_E_INVALID_ATOMIC_GROUP", "FABRIC_E_VALUE_EMPTY",
                                  "FABRIC_E_NODE_NOT_FOUND", "FABRIC_E_APPLICATION_TYPE_NOT_FOUND",
                                  "FABRIC_E_APPLICATION_NOT_FOUND", "FABRIC_E_SERVICE_TYPE_NOT_FOUND",
                                  "FABRIC_E_SERVICE_DOES_NOT_EXIST",
                                  "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND",
                                  "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND",
                                  "FABRIC_E_PARTITION_NOT_FOUND", "FABRIC_E_REPLICA_DOES_NOT_EXIST",
                                  "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST",
                                  "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND",
                                  "FABRIC_E_DIRECTORY_NOT_FOUND", "FABRIC_E_FABRIC_VERSION_NOT_FOUND",
                                  "FABRIC_E_FILE_NOT_FOUND", "FABRIC_E_NAME_DOES_NOT_EXIST",
                                  "FABRIC_E_PROPERTY_DOES_NOT_EXIST", "FABRIC_E_ENUMERATION_COMPLETED",
                                  "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND", "FABRIC_E_KEY_NOT_FOUND",
                                  "FABRIC_E_HEALTH_ENTITY_NOT_FOUND",
                                  "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS",
                                  "FABRIC_E_APPLICATION_ALREADY_EXISTS",
                                  "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION",
                                  "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS",
                                  "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS",
                                  "FABRIC_E_SERVICE_ALREADY_EXISTS",
                                  "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS",
                                  "FABRIC_E_APPLICATION_TYPE_IN_USE",
                                  "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION",
                                  "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS",
                                  "FABRIC_E_FABRIC_VERSION_IN_USE",
                                  "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS",
                                  "FABRIC_E_NAME_ALREADY_EXISTS", "FABRIC_E_NAME_NOT_EMPTY",
                                  "FABRIC_E_PROPERTY_CHECK_FAILED",
                                  "FABRIC_E_SERVICE_METADATA_MISMATCH",
                                  "FABRIC_E_SERVICE_TYPE_MISMATCH", "FABRIC_E_HEALTH_STALE_REPORT",
                                  "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED",
                                  "FABRIC_E_NODE_HAS_NOT_STOPPED_YET", "FABRIC_E_INSTANCE_ID_MISMATCH",
                                  "FABRIC_E_VALUE_TOO_LARGE", "FABRIC_E_NO_WRITE_QUORUM",
                                  "FABRIC_E_NOT_PRIMARY", "FABRIC_E_NOT_READY",
                                  "FABRIC_E_RECONFIGURATION_PENDING", "FABRIC_E_SERVICE_OFFLINE",
                                  "E_ABORT", "FABRIC_E_COMMUNICATION_ERROR",
                                  "FABRIC_E_OPERATION_NOT_COMPLETE", "FABRIC_E_TIMEOUT",
                                  "FABRIC_E_NODE_IS_UP", "E_FAIL", "FABRIC_E_BACKUP_IS_ENABLED",
                                  "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH",
                                  "FABRIC_E_INVALID_FOR_STATELESS_SERVICES",
                                  "FABRIC_E_BACKUP_NOT_ENABLED", "FABRIC_E_BACKUP_POLICY_NOT_EXISTING",
                                  "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING",
                                  "FABRIC_E_BACKUP_IN_PROGRESS", "FABRIC_E_RESTORE_IN_PROGRESS",
                                  "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING",
                                  "FABRIC_E_INVALID_SERVICE_SCALING_POLICY", "E_INVALIDARG",
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS",
                                  "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND",
                                  "FABRIC_E_VOLUME_ALREADY_EXISTS", "FABRIC_E_VOLUME_NOT_FOUND",
                                  "SerializationError",
                                  "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR",
                                  "FABRIC_E_CERTIFICATE_NOT_FOUND".
                                "Message": "str"  # Optional. Error message.
                            },
                            "LsnOfLastBackupRecord": "str",  # Optional. LSN of the last
                              record in this backup.
                            "PartitionInformation": {
                                "Id": str,  # Optional. An internal ID used by
                                  Service Fabric to uniquely identify a partition. This is a randomly
                                  generated GUID when the service was created. The partition ID is
                                  unique and does not change for the lifetime of the service. If the
                                  same service was deleted and recreated the IDs of its partitions
                                  would be different.
                                ServicePartitionKind: ServicePartitionKind
                            },
                            "ServiceManifestVersion": "str",  # Optional. Manifest
                              Version of the service this partition backup belongs to.
                            "ServiceName": "str"  # Optional. Name of the Service Fabric
                              service this partition backup belongs to.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = get_backup_by_storage_query_description

        request = build_get_backups_from_backup_location_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            continuation_token_parameter=continuation_token_parameter,
            max_results=max_results,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def create_name(  # pylint: disable=inconsistent-return-statements
        self,
        name_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Creates a Service Fabric name.

        Creates the specified Service Fabric name.

        :param name_description: Describes the Service Fabric name to be created.
        :type name_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                name_description = {
                    "Name": "str"  # Required. The Service Fabric name, including the 'fabric:'
                      URI scheme.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = name_description

        request = build_create_name_request(
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_name_exists_info(  # pylint: disable=inconsistent-return-statements
        self,
        name_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Returns whether the Service Fabric name exists.

        Returns whether the specified Service Fabric name exists.

        :param name_id: The Service Fabric name, without the 'fabric:' URI scheme.
        :type name_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_get_name_exists_info_request(
            name_id=name_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def delete_name(  # pylint: disable=inconsistent-return-statements
        self,
        name_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Deletes a Service Fabric name.

        Deletes the specified Service Fabric name. A name must be created before it can be deleted.
        Deleting a name with child properties will fail.

        :param name_id: The Service Fabric name, without the 'fabric:' URI scheme.
        :type name_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_delete_name_request(
            name_id=name_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_sub_name_info_list(
        self,
        name_id: str,
        *,
        recursive: Optional[bool] = False,
        continuation_token_parameter: Optional[str] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Enumerates all the Service Fabric names under a given name.

        Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a
        page, one page of results is returned as well as a continuation token, which can be used to get
        the next page. Querying a name that doesn't exist will fail.

        :param name_id: The Service Fabric name, without the 'fabric:' URI scheme.
        :type name_id: str
        :keyword recursive: Allows specifying that the search performed should be recursive. Default
         value is False.
        :paramtype recursive: bool
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "IsConsistent": bool,  # Optional. Indicates whether any name under the given
                      name has been modified during the enumeration. If there was a modification, this
                      property value is false.
                    "SubNames": [
                        "str"  # Optional. List of the child names.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_sub_name_info_list_request(
            name_id=name_id,
            api_version=api_version,
            recursive=recursive,
            continuation_token_parameter=continuation_token_parameter,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_property_info_list(
        self,
        name_id: str,
        *,
        include_values: Optional[bool] = False,
        continuation_token_parameter: Optional[str] = None,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets information on all Service Fabric properties under a given name.

        A Service Fabric name can have one or more named properties that store custom information. This
        operation gets the information about these properties in a paged list. The information includes
        name, value, and metadata about each of the properties.

        :param name_id: The Service Fabric name, without the 'fabric:' URI scheme.
        :type name_id: str
        :keyword include_values: Allows specifying whether to include the values of the properties
         returned. True if values should be returned with the metadata; False to return only property
         metadata. Default value is False.
        :paramtype include_values: bool
        :keyword continuation_token_parameter: The continuation token parameter is used to obtain next
         set of results. A continuation token with a non-empty value is included in the response of the
         API when the results from the system do not fit in a single response. When this value is passed
         to the next API call, the API returns next set of results. If there are no further results,
         then the continuation token does not contain a value. The value of this parameter should not be
         URL encoded. Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "IsConsistent": bool,  # Optional. Indicates whether any property under the
                      given name has been modified during the enumeration. If there was a modification,
                      this property value is false.
                    "Properties": [
                        {
                            "Metadata": {
                                "CustomTypeId": "str",  # Optional. The property's
                                  custom type ID.
                                "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                                  Optional. Represents when the Property was last modified. Only write
                                  operations will cause this field to be updated.
                                "Parent": "str",  # Optional. The name of the parent
                                  Service Fabric Name for the property. It could be thought of as the
                                  name-space/table under which the property exists.
                                "SequenceNumber": "str",  # Optional. The version of
                                  the property. Every time a property is modified, its sequence number
                                  is increased.
                                "SizeInBytes": 0,  # Optional. The length of the
                                  serialized property value.
                                "TypeId": "str"  # Optional. The kind of property,
                                  determined by the type of data. Following are the possible values.
                                  Known values are: "Invalid", "Binary", "Int64", "Double", "String",
                                  "Guid".
                            },
                            "Name": "str",  # Required. The name of the Service Fabric
                              property.
                            "Value": {
                                Kind: Kind
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_property_info_list_request(
            name_id=name_id,
            api_version=api_version,
            include_values=include_values,
            continuation_token_parameter=continuation_token_parameter,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def put_property(  # pylint: disable=inconsistent-return-statements
        self,
        name_id: str,
        property_description: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Creates or updates a Service Fabric property.

        Creates or updates the specified Service Fabric property under a given name.

        :param name_id: The Service Fabric name, without the 'fabric:' URI scheme.
        :type name_id: str
        :param property_description: Describes the Service Fabric property to be created.
        :type property_description: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python


                # JSON input template you can fill out and use as your body input.
                property_description = {
                    "CustomTypeId": "str",  # Optional. The property's custom type ID. Using this
                      property, the user is able to tag the type of the value of the property.
                    "PropertyName": "str",  # Required. The name of the Service Fabric property.
                    "Value": {
                        Kind: Kind
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _json = property_description

        request = build_put_property_request(
            name_id=name_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def get_property_info(
        self,
        name_id: str,
        *,
        property_name: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Gets the specified Service Fabric property.

        Gets the specified Service Fabric property under a given name. This will always return both
        value and metadata.

        :param name_id: The Service Fabric name, without the 'fabric:' URI scheme.
        :type name_id: str
        :keyword property_name: Specifies the name of the property to get.
        :paramtype property_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Metadata": {
                        "CustomTypeId": "str",  # Optional. The property's custom type ID.
                        "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  # Optional.
                          Represents when the Property was last modified. Only write operations will
                          cause this field to be updated.
                        "Parent": "str",  # Optional. The name of the parent Service Fabric
                          Name for the property. It could be thought of as the name-space/table under
                          which the property exists.
                        "SequenceNumber": "str",  # Optional. The version of the property.
                          Every time a property is modified, its sequence number is increased.
                        "SizeInBytes": 0,  # Optional. The length of the serialized property
                          value.
                        "TypeId": "str"  # Optional. The kind of property, determined by the
                          type of data. Following are the possible values. Known values are: "Invalid",
                          "Binary", "Int64", "Double", "String", "Guid".
                    },
                    "Name": "str",  # Required. The name of the Service Fabric property.
                    "Value": {
                        Kind: Kind
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_property_info_request(
            name_id=name_id,
            api_version=api_version,
            property_name=property_name,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def delete_property(  # pylint: disable=inconsistent-return-statements
        self,
        name_id: str,
        *,
        property_name: str,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> None:
        """Deletes the specified Service Fabric property.

        Deletes the specified Service Fabric property under a given name. A property must be created
        before it can be deleted.

        :param name_id: The Service Fabric name, without the 'fabric:' URI scheme.
        :type name_id: str
        :keyword property_name: Specifies the name of the property to get.
        :paramtype property_name: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_delete_property_request(
            name_id=name_id,
            api_version=api_version,
            property_name=property_name,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def submit_property_batch(
        self,
        name_id: str,
        property_batch_description_list: JSON,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> JSON:
        """Submits a property batch.

        Submits a batch of property operations. Either all or none of the operations will be committed.

        :param name_id: The Service Fabric name, without the 'fabric:' URI scheme.
        :type name_id: str
        :param property_batch_description_list: Describes the property batch operations to be
         submitted.
        :type property_batch_description_list: JSON
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This is the latest supported version of the API. If a lower API version is passed, the returned
         response may be different from the one documented in this specification.

         Additionally the runtime accept any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0, but if the
         runtime is 6.1, in order to make it easier to write the clients, the runtime will accept
         version 6.1 for that API. However the behavior of the API will be as per the documented 6.0
         version. Default value is "6.0". Note that overriding this default value may result in
         unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                property_batch_description_list = {
                    "Operations": [
                        {
                            "PropertyName": "str",  # Required. The name of the Service
                              Fabric property.
                            Kind: Kind
                        }
                    ]
                }

                # response body for status code(s): 200
                response.json() == {
                    "Properties": {
                        "str": {
                            "Metadata": {
                                "CustomTypeId": "str",  # Optional. The property's
                                  custom type ID.
                                "LastModifiedUtcTimestamp": "2020-02-20 00:00:00",  #
                                  Optional. Represents when the Property was last modified. Only write
                                  operations will cause this field to be updated.
                                "Parent": "str",  # Optional. The name of the parent
                                  Service Fabric Name for the property. It could be thought of as the
                                  name-space/table under which the property exists.
                                "SequenceNumber": "str",  # Optional. The version of
                                  the property. Every time a property is modified, its sequence number
                                  is increased.
                                "SizeInBytes": 0,  # Optional. The length of the
                                  serialized property value.
                                "TypeId": "str"  # Optional. The kind of property,
                                  determined by the type of data. Following are the possible values.
                                  Known values are: "Invalid", "Binary", "Int64", "Double", "String",
                                  "Guid".
                            },
                            "Name": "str",  # Required. The name of the Service Fabric
                              property.
                            "Value": {
                                Kind: Kind
                            }
                        }
                    },
                    Kind: Successful
                }
                # response body for status code(s): 409
                response.json() == {
                    "ErrorMessage": "str",  # Optional. The error message of the failed
                      operation. Describes the exception thrown due to the first unsuccessful operation
                      in the property batch.
                    "OperationIndex": 0,  # Optional. The index of the unsuccessful operation in
                      the property batch.
                    Kind: Failed
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _json = property_batch_description_list

        request = build_submit_property_batch_request(
            name_id=name_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 409:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_cluster_event_list(
        self,
        *,
        start_time_utc: str,
        end_time_utc: str,
        timeout: Optional[int] = 60,
        events_types_filter: Optional[str] = None,
        exclude_analysis_events: Optional[bool] = None,
        skip_correlation_lookup: Optional[bool] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets all Cluster-related events.

        The response is list of ClusterEvent objects.

        :keyword start_time_utc: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype start_time_utc: str
        :keyword end_time_utc: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype end_time_utc: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword events_types_filter: This is a comma separated string specifying the types of
         FabricEvents that should only be included in the response. Default value is None.
        :paramtype events_types_filter: str
        :keyword exclude_analysis_events: This param disables the retrieval of AnalysisEvents if true
         is passed. Default value is None.
        :paramtype exclude_analysis_events: bool
        :keyword skip_correlation_lookup: This param disables the search of CorrelatedEvents
         information if true is passed. otherwise the CorrelationEvents get processed and
         HasCorrelatedEvents field in every FabricEvent gets populated. Default value is None.
        :paramtype skip_correlation_lookup: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "Category": "str",  # Optional. The category of event.
                        "EventInstanceId": str,  # Required. The identifier for the
                          FabricEvent instance.
                        "HasCorrelatedEvents": bool,  # Optional. Shows there is existing
                          related events available.
                        "TimeStamp": "2020-02-20 00:00:00",  # Required. The time event was
                          logged.
                        Kind: ClusterEvent
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_cluster_event_list_request(
            api_version=api_version,
            start_time_utc=start_time_utc,
            end_time_utc=end_time_utc,
            timeout=timeout,
            events_types_filter=events_types_filter,
            exclude_analysis_events=exclude_analysis_events,
            skip_correlation_lookup=skip_correlation_lookup,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_containers_event_list(
        self,
        *,
        start_time_utc: str,
        end_time_utc: str,
        timeout: Optional[int] = 60,
        events_types_filter: Optional[str] = None,
        exclude_analysis_events: Optional[bool] = None,
        skip_correlation_lookup: Optional[bool] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets all Containers-related events.

        The response is list of ContainerInstanceEvent objects.

        :keyword start_time_utc: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype start_time_utc: str
        :keyword end_time_utc: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype end_time_utc: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword events_types_filter: This is a comma separated string specifying the types of
         FabricEvents that should only be included in the response. Default value is None.
        :paramtype events_types_filter: str
        :keyword exclude_analysis_events: This param disables the retrieval of AnalysisEvents if true
         is passed. Default value is None.
        :paramtype exclude_analysis_events: bool
        :keyword skip_correlation_lookup: This param disables the search of CorrelatedEvents
         information if true is passed. otherwise the CorrelationEvents get processed and
         HasCorrelatedEvents field in every FabricEvent gets populated. Default value is None.
        :paramtype skip_correlation_lookup: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.2-preview'. Default value is "6.2-preview". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "Category": "str",  # Optional. The category of event.
                        "EventInstanceId": str,  # Required. The identifier for the
                          FabricEvent instance.
                        "HasCorrelatedEvents": bool,  # Optional. Shows there is existing
                          related events available.
                        "TimeStamp": "2020-02-20 00:00:00",  # Required. The time event was
                          logged.
                        Kind: ContainerInstanceEvent
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.2-preview"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_containers_event_list_request(
            api_version=api_version,
            start_time_utc=start_time_utc,
            end_time_utc=end_time_utc,
            timeout=timeout,
            events_types_filter=events_types_filter,
            exclude_analysis_events=exclude_analysis_events,
            skip_correlation_lookup=skip_correlation_lookup,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_node_event_list(
        self,
        node_name: str,
        *,
        start_time_utc: str,
        end_time_utc: str,
        timeout: Optional[int] = 60,
        events_types_filter: Optional[str] = None,
        exclude_analysis_events: Optional[bool] = None,
        skip_correlation_lookup: Optional[bool] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets a Node-related events.

        The response is list of NodeEvent objects.

        :param node_name: The name of the node.
        :type node_name: str
        :keyword start_time_utc: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype start_time_utc: str
        :keyword end_time_utc: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype end_time_utc: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword events_types_filter: This is a comma separated string specifying the types of
         FabricEvents that should only be included in the response. Default value is None.
        :paramtype events_types_filter: str
        :keyword exclude_analysis_events: This param disables the retrieval of AnalysisEvents if true
         is passed. Default value is None.
        :paramtype exclude_analysis_events: bool
        :keyword skip_correlation_lookup: This param disables the search of CorrelatedEvents
         information if true is passed. otherwise the CorrelationEvents get processed and
         HasCorrelatedEvents field in every FabricEvent gets populated. Default value is None.
        :paramtype skip_correlation_lookup: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "Category": "str",  # Optional. The category of event.
                        "EventInstanceId": str,  # Required. The identifier for the
                          FabricEvent instance.
                        "HasCorrelatedEvents": bool,  # Optional. Shows there is existing
                          related events available.
                        "NodeName": "str",  # Required. The name of a Service Fabric node.
                        "TimeStamp": "2020-02-20 00:00:00",  # Required. The time event was
                          logged.
                        Kind: NodeEvent
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_node_event_list_request(
            node_name=node_name,
            api_version=api_version,
            start_time_utc=start_time_utc,
            end_time_utc=end_time_utc,
            timeout=timeout,
            events_types_filter=events_types_filter,
            exclude_analysis_events=exclude_analysis_events,
            skip_correlation_lookup=skip_correlation_lookup,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_nodes_event_list(
        self,
        *,
        start_time_utc: str,
        end_time_utc: str,
        timeout: Optional[int] = 60,
        events_types_filter: Optional[str] = None,
        exclude_analysis_events: Optional[bool] = None,
        skip_correlation_lookup: Optional[bool] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets all Nodes-related Events.

        The response is list of NodeEvent objects.

        :keyword start_time_utc: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype start_time_utc: str
        :keyword end_time_utc: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype end_time_utc: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword events_types_filter: This is a comma separated string specifying the types of
         FabricEvents that should only be included in the response. Default value is None.
        :paramtype events_types_filter: str
        :keyword exclude_analysis_events: This param disables the retrieval of AnalysisEvents if true
         is passed. Default value is None.
        :paramtype exclude_analysis_events: bool
        :keyword skip_correlation_lookup: This param disables the search of CorrelatedEvents
         information if true is passed. otherwise the CorrelationEvents get processed and
         HasCorrelatedEvents field in every FabricEvent gets populated. Default value is None.
        :paramtype skip_correlation_lookup: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "Category": "str",  # Optional. The category of event.
                        "EventInstanceId": str,  # Required. The identifier for the
                          FabricEvent instance.
                        "HasCorrelatedEvents": bool,  # Optional. Shows there is existing
                          related events available.
                        "NodeName": "str",  # Required. The name of a Service Fabric node.
                        "TimeStamp": "2020-02-20 00:00:00",  # Required. The time event was
                          logged.
                        Kind: NodeEvent
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_nodes_event_list_request(
            api_version=api_version,
            start_time_utc=start_time_utc,
            end_time_utc=end_time_utc,
            timeout=timeout,
            events_types_filter=events_types_filter,
            exclude_analysis_events=exclude_analysis_events,
            skip_correlation_lookup=skip_correlation_lookup,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_application_event_list(
        self,
        application_id: str,
        *,
        start_time_utc: str,
        end_time_utc: str,
        timeout: Optional[int] = 60,
        events_types_filter: Optional[str] = None,
        exclude_analysis_events: Optional[bool] = None,
        skip_correlation_lookup: Optional[bool] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets an Application-related events.

        The response is list of ApplicationEvent objects.

        :param application_id: The identity of the application. This is typically the full name of the
         application without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the application name is "fabric:/myapp/app1", the application identity would
         be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
        :type application_id: str
        :keyword start_time_utc: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype start_time_utc: str
        :keyword end_time_utc: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype end_time_utc: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword events_types_filter: This is a comma separated string specifying the types of
         FabricEvents that should only be included in the response. Default value is None.
        :paramtype events_types_filter: str
        :keyword exclude_analysis_events: This param disables the retrieval of AnalysisEvents if true
         is passed. Default value is None.
        :paramtype exclude_analysis_events: bool
        :keyword skip_correlation_lookup: This param disables the search of CorrelatedEvents
         information if true is passed. otherwise the CorrelationEvents get processed and
         HasCorrelatedEvents field in every FabricEvent gets populated. Default value is None.
        :paramtype skip_correlation_lookup: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "ApplicationId": "str",  # Required. The identity of the application.
                          This is an encoded representation of the application name. This is used in
                          the REST APIs to identify the application resource."nStarting in version 6.0,
                          hierarchical names are delimited with the "~" character. For example, if the
                          application name is "fabric:/myapp/app1","nthe application identity would be
                          "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
                        "Category": "str",  # Optional. The category of event.
                        "EventInstanceId": str,  # Required. The identifier for the
                          FabricEvent instance.
                        "HasCorrelatedEvents": bool,  # Optional. Shows there is existing
                          related events available.
                        "TimeStamp": "2020-02-20 00:00:00",  # Required. The time event was
                          logged.
                        Kind: ApplicationEvent
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_application_event_list_request(
            application_id=application_id,
            api_version=api_version,
            start_time_utc=start_time_utc,
            end_time_utc=end_time_utc,
            timeout=timeout,
            events_types_filter=events_types_filter,
            exclude_analysis_events=exclude_analysis_events,
            skip_correlation_lookup=skip_correlation_lookup,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_applications_event_list(
        self,
        *,
        start_time_utc: str,
        end_time_utc: str,
        timeout: Optional[int] = 60,
        events_types_filter: Optional[str] = None,
        exclude_analysis_events: Optional[bool] = None,
        skip_correlation_lookup: Optional[bool] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets all Applications-related events.

        The response is list of ApplicationEvent objects.

        :keyword start_time_utc: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype start_time_utc: str
        :keyword end_time_utc: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype end_time_utc: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword events_types_filter: This is a comma separated string specifying the types of
         FabricEvents that should only be included in the response. Default value is None.
        :paramtype events_types_filter: str
        :keyword exclude_analysis_events: This param disables the retrieval of AnalysisEvents if true
         is passed. Default value is None.
        :paramtype exclude_analysis_events: bool
        :keyword skip_correlation_lookup: This param disables the search of CorrelatedEvents
         information if true is passed. otherwise the CorrelationEvents get processed and
         HasCorrelatedEvents field in every FabricEvent gets populated. Default value is None.
        :paramtype skip_correlation_lookup: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "ApplicationId": "str",  # Required. The identity of the application.
                          This is an encoded representation of the application name. This is used in
                          the REST APIs to identify the application resource."nStarting in version 6.0,
                          hierarchical names are delimited with the "~" character. For example, if the
                          application name is "fabric:/myapp/app1","nthe application identity would be
                          "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
                        "Category": "str",  # Optional. The category of event.
                        "EventInstanceId": str,  # Required. The identifier for the
                          FabricEvent instance.
                        "HasCorrelatedEvents": bool,  # Optional. Shows there is existing
                          related events available.
                        "TimeStamp": "2020-02-20 00:00:00",  # Required. The time event was
                          logged.
                        Kind: ApplicationEvent
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_applications_event_list_request(
            api_version=api_version,
            start_time_utc=start_time_utc,
            end_time_utc=end_time_utc,
            timeout=timeout,
            events_types_filter=events_types_filter,
            exclude_analysis_events=exclude_analysis_events,
            skip_correlation_lookup=skip_correlation_lookup,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_service_event_list(
        self,
        service_id: str,
        *,
        start_time_utc: str,
        end_time_utc: str,
        timeout: Optional[int] = 60,
        events_types_filter: Optional[str] = None,
        exclude_analysis_events: Optional[bool] = None,
        skip_correlation_lookup: Optional[bool] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets a Service-related events.

        The response is list of ServiceEvent objects.

        :param service_id: The identity of the service. This ID is typically the full name of the
         service without the 'fabric:' URI scheme.
         Starting from version 6.0, hierarchical names are delimited with the "~" character.
         For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
         "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
        :type service_id: str
        :keyword start_time_utc: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype start_time_utc: str
        :keyword end_time_utc: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype end_time_utc: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword events_types_filter: This is a comma separated string specifying the types of
         FabricEvents that should only be included in the response. Default value is None.
        :paramtype events_types_filter: str
        :keyword exclude_analysis_events: This param disables the retrieval of AnalysisEvents if true
         is passed. Default value is None.
        :paramtype exclude_analysis_events: bool
        :keyword skip_correlation_lookup: This param disables the search of CorrelatedEvents
         information if true is passed. otherwise the CorrelationEvents get processed and
         HasCorrelatedEvents field in every FabricEvent gets populated. Default value is None.
        :paramtype skip_correlation_lookup: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "Category": "str",  # Optional. The category of event.
                        "EventInstanceId": str,  # Required. The identifier for the
                          FabricEvent instance.
                        "HasCorrelatedEvents": bool,  # Optional. Shows there is existing
                          related events available.
                        "ServiceId": "str",  # Required. The identity of the service. This ID
                          is an encoded representation of the service name. This is used in the REST
                          APIs to identify the service resource."nStarting in version 6.0, hierarchical
                          names are delimited with the "~" character. For example, if the service name
                          is "fabric:/myapp/app1/svc1","nthe service identity would be
                          "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
                        "TimeStamp": "2020-02-20 00:00:00",  # Required. The time event was
                          logged.
                        Kind: ServiceEvent
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_service_event_list_request(
            service_id=service_id,
            api_version=api_version,
            start_time_utc=start_time_utc,
            end_time_utc=end_time_utc,
            timeout=timeout,
            events_types_filter=events_types_filter,
            exclude_analysis_events=exclude_analysis_events,
            skip_correlation_lookup=skip_correlation_lookup,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_services_event_list(
        self,
        *,
        start_time_utc: str,
        end_time_utc: str,
        timeout: Optional[int] = 60,
        events_types_filter: Optional[str] = None,
        exclude_analysis_events: Optional[bool] = None,
        skip_correlation_lookup: Optional[bool] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets all Services-related events.

        The response is list of ServiceEvent objects.

        :keyword start_time_utc: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype start_time_utc: str
        :keyword end_time_utc: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype end_time_utc: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword events_types_filter: This is a comma separated string specifying the types of
         FabricEvents that should only be included in the response. Default value is None.
        :paramtype events_types_filter: str
        :keyword exclude_analysis_events: This param disables the retrieval of AnalysisEvents if true
         is passed. Default value is None.
        :paramtype exclude_analysis_events: bool
        :keyword skip_correlation_lookup: This param disables the search of CorrelatedEvents
         information if true is passed. otherwise the CorrelationEvents get processed and
         HasCorrelatedEvents field in every FabricEvent gets populated. Default value is None.
        :paramtype skip_correlation_lookup: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "Category": "str",  # Optional. The category of event.
                        "EventInstanceId": str,  # Required. The identifier for the
                          FabricEvent instance.
                        "HasCorrelatedEvents": bool,  # Optional. Shows there is existing
                          related events available.
                        "ServiceId": "str",  # Required. The identity of the service. This ID
                          is an encoded representation of the service name. This is used in the REST
                          APIs to identify the service resource."nStarting in version 6.0, hierarchical
                          names are delimited with the "~" character. For example, if the service name
                          is "fabric:/myapp/app1/svc1","nthe service identity would be
                          "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
                        "TimeStamp": "2020-02-20 00:00:00",  # Required. The time event was
                          logged.
                        Kind: ServiceEvent
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_services_event_list_request(
            api_version=api_version,
            start_time_utc=start_time_utc,
            end_time_utc=end_time_utc,
            timeout=timeout,
            events_types_filter=events_types_filter,
            exclude_analysis_events=exclude_analysis_events,
            skip_correlation_lookup=skip_correlation_lookup,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_partition_event_list(
        self,
        partition_id: str,
        *,
        start_time_utc: str,
        end_time_utc: str,
        timeout: Optional[int] = 60,
        events_types_filter: Optional[str] = None,
        exclude_analysis_events: Optional[bool] = None,
        skip_correlation_lookup: Optional[bool] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets a Partition-related events.

        The response is list of PartitionEvent objects.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword start_time_utc: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype start_time_utc: str
        :keyword end_time_utc: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype end_time_utc: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword events_types_filter: This is a comma separated string specifying the types of
         FabricEvents that should only be included in the response. Default value is None.
        :paramtype events_types_filter: str
        :keyword exclude_analysis_events: This param disables the retrieval of AnalysisEvents if true
         is passed. Default value is None.
        :paramtype exclude_analysis_events: bool
        :keyword skip_correlation_lookup: This param disables the search of CorrelatedEvents
         information if true is passed. otherwise the CorrelationEvents get processed and
         HasCorrelatedEvents field in every FabricEvent gets populated. Default value is None.
        :paramtype skip_correlation_lookup: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "Category": "str",  # Optional. The category of event.
                        "EventInstanceId": str,  # Required. The identifier for the
                          FabricEvent instance.
                        "HasCorrelatedEvents": bool,  # Optional. Shows there is existing
                          related events available.
                        "PartitionId": str,  # Required. An internal ID used by Service
                          Fabric to uniquely identify a partition. This is a randomly generated GUID
                          when the service was created. The partition ID is unique and does not change
                          for the lifetime of the service. If the same service was deleted and
                          recreated the IDs of its partitions would be different.
                        "TimeStamp": "2020-02-20 00:00:00",  # Required. The time event was
                          logged.
                        Kind: PartitionEvent
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_partition_event_list_request(
            partition_id=partition_id,
            api_version=api_version,
            start_time_utc=start_time_utc,
            end_time_utc=end_time_utc,
            timeout=timeout,
            events_types_filter=events_types_filter,
            exclude_analysis_events=exclude_analysis_events,
            skip_correlation_lookup=skip_correlation_lookup,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_partitions_event_list(
        self,
        *,
        start_time_utc: str,
        end_time_utc: str,
        timeout: Optional[int] = 60,
        events_types_filter: Optional[str] = None,
        exclude_analysis_events: Optional[bool] = None,
        skip_correlation_lookup: Optional[bool] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets all Partitions-related events.

        The response is list of PartitionEvent objects.

        :keyword start_time_utc: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype start_time_utc: str
        :keyword end_time_utc: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype end_time_utc: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword events_types_filter: This is a comma separated string specifying the types of
         FabricEvents that should only be included in the response. Default value is None.
        :paramtype events_types_filter: str
        :keyword exclude_analysis_events: This param disables the retrieval of AnalysisEvents if true
         is passed. Default value is None.
        :paramtype exclude_analysis_events: bool
        :keyword skip_correlation_lookup: This param disables the search of CorrelatedEvents
         information if true is passed. otherwise the CorrelationEvents get processed and
         HasCorrelatedEvents field in every FabricEvent gets populated. Default value is None.
        :paramtype skip_correlation_lookup: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "Category": "str",  # Optional. The category of event.
                        "EventInstanceId": str,  # Required. The identifier for the
                          FabricEvent instance.
                        "HasCorrelatedEvents": bool,  # Optional. Shows there is existing
                          related events available.
                        "PartitionId": str,  # Required. An internal ID used by Service
                          Fabric to uniquely identify a partition. This is a randomly generated GUID
                          when the service was created. The partition ID is unique and does not change
                          for the lifetime of the service. If the same service was deleted and
                          recreated the IDs of its partitions would be different.
                        "TimeStamp": "2020-02-20 00:00:00",  # Required. The time event was
                          logged.
                        Kind: PartitionEvent
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_partitions_event_list_request(
            api_version=api_version,
            start_time_utc=start_time_utc,
            end_time_utc=end_time_utc,
            timeout=timeout,
            events_types_filter=events_types_filter,
            exclude_analysis_events=exclude_analysis_events,
            skip_correlation_lookup=skip_correlation_lookup,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_partition_replica_event_list(
        self,
        partition_id: str,
        replica_id: str,
        *,
        start_time_utc: str,
        end_time_utc: str,
        timeout: Optional[int] = 60,
        events_types_filter: Optional[str] = None,
        exclude_analysis_events: Optional[bool] = None,
        skip_correlation_lookup: Optional[bool] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets a Partition Replica-related events.

        The response is list of ReplicaEvent objects.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :param replica_id: The identifier of the replica.
        :type replica_id: str
        :keyword start_time_utc: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype start_time_utc: str
        :keyword end_time_utc: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype end_time_utc: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword events_types_filter: This is a comma separated string specifying the types of
         FabricEvents that should only be included in the response. Default value is None.
        :paramtype events_types_filter: str
        :keyword exclude_analysis_events: This param disables the retrieval of AnalysisEvents if true
         is passed. Default value is None.
        :paramtype exclude_analysis_events: bool
        :keyword skip_correlation_lookup: This param disables the search of CorrelatedEvents
         information if true is passed. otherwise the CorrelationEvents get processed and
         HasCorrelatedEvents field in every FabricEvent gets populated. Default value is None.
        :paramtype skip_correlation_lookup: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "Category": "str",  # Optional. The category of event.
                        "EventInstanceId": str,  # Required. The identifier for the
                          FabricEvent instance.
                        "HasCorrelatedEvents": bool,  # Optional. Shows there is existing
                          related events available.
                        "PartitionId": str,  # Required. An internal ID used by Service
                          Fabric to uniquely identify a partition. This is a randomly generated GUID
                          when the service was created. The partition ID is unique and does not change
                          for the lifetime of the service. If the same service was deleted and
                          recreated the IDs of its partitions would be different.
                        "ReplicaId": 0.0,  # Required. Id of a stateful service replica.
                          ReplicaId is used by Service Fabric to uniquely identify a replica of a
                          partition. It is unique within a partition and does not change for the
                          lifetime of the replica. If a replica gets dropped and another replica gets
                          created on the same node for the same partition, it will get a different
                          value for the id. Sometimes the id of a stateless service instance is also
                          referred as a replica id.
                        "TimeStamp": "2020-02-20 00:00:00",  # Required. The time event was
                          logged.
                        Kind: ReplicaEvent
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_partition_replica_event_list_request(
            partition_id=partition_id,
            replica_id=replica_id,
            api_version=api_version,
            start_time_utc=start_time_utc,
            end_time_utc=end_time_utc,
            timeout=timeout,
            events_types_filter=events_types_filter,
            exclude_analysis_events=exclude_analysis_events,
            skip_correlation_lookup=skip_correlation_lookup,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_partition_replicas_event_list(
        self,
        partition_id: str,
        *,
        start_time_utc: str,
        end_time_utc: str,
        timeout: Optional[int] = 60,
        events_types_filter: Optional[str] = None,
        exclude_analysis_events: Optional[bool] = None,
        skip_correlation_lookup: Optional[bool] = None,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets all Replicas-related events for a Partition.

        The response is list of ReplicaEvent objects.

        :param partition_id: The identity of the partition.
        :type partition_id: str
        :keyword start_time_utc: The start time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype start_time_utc: str
        :keyword end_time_utc: The end time of a lookup query in ISO UTC yyyy-MM-ddTHH:mm:ssZ.
        :paramtype end_time_utc: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword events_types_filter: This is a comma separated string specifying the types of
         FabricEvents that should only be included in the response. Default value is None.
        :paramtype events_types_filter: str
        :keyword exclude_analysis_events: This param disables the retrieval of AnalysisEvents if true
         is passed. Default value is None.
        :paramtype exclude_analysis_events: bool
        :keyword skip_correlation_lookup: This param disables the search of CorrelatedEvents
         information if true is passed. otherwise the CorrelationEvents get processed and
         HasCorrelatedEvents field in every FabricEvent gets populated. Default value is None.
        :paramtype skip_correlation_lookup: bool
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "Category": "str",  # Optional. The category of event.
                        "EventInstanceId": str,  # Required. The identifier for the
                          FabricEvent instance.
                        "HasCorrelatedEvents": bool,  # Optional. Shows there is existing
                          related events available.
                        "PartitionId": str,  # Required. An internal ID used by Service
                          Fabric to uniquely identify a partition. This is a randomly generated GUID
                          when the service was created. The partition ID is unique and does not change
                          for the lifetime of the service. If the same service was deleted and
                          recreated the IDs of its partitions would be different.
                        "ReplicaId": 0.0,  # Required. Id of a stateful service replica.
                          ReplicaId is used by Service Fabric to uniquely identify a replica of a
                          partition. It is unique within a partition and does not change for the
                          lifetime of the replica. If a replica gets dropped and another replica gets
                          created on the same node for the same partition, it will get a different
                          value for the id. Sometimes the id of a stateless service instance is also
                          referred as a replica id.
                        "TimeStamp": "2020-02-20 00:00:00",  # Required. The time event was
                          logged.
                        Kind: ReplicaEvent
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_partition_replicas_event_list_request(
            partition_id=partition_id,
            api_version=api_version,
            start_time_utc=start_time_utc,
            end_time_utc=end_time_utc,
            timeout=timeout,
            events_types_filter=events_types_filter,
            exclude_analysis_events=exclude_analysis_events,
            skip_correlation_lookup=skip_correlation_lookup,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)



    @distributed_trace_async
    async def get_correlated_event_list(
        self,
        event_instance_id: str,
        *,
        timeout: Optional[int] = 60,
        **kwargs: Any
    ) -> List[JSON]:
        """Gets all correlated events for a given event.

        The response is list of FabricEvents.

        :param event_instance_id: The EventInstanceId.
        :type event_instance_id: str
        :keyword timeout: The server timeout for performing the operation in seconds. This timeout
         specifies the time duration that the client is willing to wait for the requested operation to
         complete. The default value for this parameter is 60 seconds. Default value is 60.
        :paramtype timeout: long
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '6.4'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "6.4". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == [
                    {
                        "Category": "str",  # Optional. The category of event.
                        "EventInstanceId": str,  # Required. The identifier for the
                          FabricEvent instance.
                        "HasCorrelatedEvents": bool,  # Optional. Shows there is existing
                          related events available.
                        "TimeStamp": "2020-02-20 00:00:00",  # Required. The time event was
                          logged.
                        Kind: Kind
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "6.4"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[List[JSON]]

        
        request = build_get_correlated_event_list_request(
            event_instance_id=event_instance_id,
            api_version=api_version,
            timeout=timeout,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})

        return cast(List[JSON], deserialized)


class MeshSecretOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.servicefabric.aio.ServiceFabricClientAPIs`'s
        :attr:`mesh_secret` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def create_or_update(
        self,
        secret_resource_name: str,
        secret_resource_description: JSON,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Creates or updates a Secret resource.

        Creates a Secret resource with the specified name, description and properties. If Secret
        resource with the same name exists, then it is updated with the specified description and
        properties. Once created, the kind and contentType of a secret resource cannot be updated.

        :param secret_resource_name: The name of the secret resource.
        :type secret_resource_name: str
        :param secret_resource_description: Description for creating a secret resource.
        :type secret_resource_description: JSON
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python


                # JSON input template you can fill out and use as your body input.
                secret_resource_description = {
                    "name": "str",  # Required. Name of the Secret resource.
                    "properties": {
                        "contentType": "str",  # Optional. The type of the content stored in
                          the secret value. The value of this property is opaque to Service Fabric.
                          Once set, the value of this property cannot be changed.
                        "description": "str",  # Optional. User readable description of the
                          secret.
                        "status": "str",  # Optional. Status of the resource. Known values
                          are: "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str",  # Optional. Gives additional information
                          about the current status of the secret.
                        kind: SecretResourceProperties
                    }
                }

                # response body for status code(s): 200, 201
                response.json() == {
                    "name": "str",  # Required. Name of the Secret resource.
                    "properties": {
                        "contentType": "str",  # Optional. The type of the content stored in
                          the secret value. The value of this property is opaque to Service Fabric.
                          Once set, the value of this property cannot be changed.
                        "description": "str",  # Optional. User readable description of the
                          secret.
                        "status": "str",  # Optional. Status of the resource. Known values
                          are: "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str",  # Optional. Gives additional information
                          about the current status of the secret.
                        kind: SecretResourceProperties
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        _json = secret_resource_description

        request = build_mesh_secret_create_or_update_request(
            secret_resource_name=secret_resource_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get(
        self,
        secret_resource_name: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the Secret resource with the given name.

        Gets the information about the Secret resource with the given name. The information include the
        description and other properties of the Secret.

        :param secret_resource_name: The name of the secret resource.
        :type secret_resource_name: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "name": "str",  # Required. Name of the Secret resource.
                    "properties": {
                        "contentType": "str",  # Optional. The type of the content stored in
                          the secret value. The value of this property is opaque to Service Fabric.
                          Once set, the value of this property cannot be changed.
                        "description": "str",  # Optional. User readable description of the
                          secret.
                        "status": "str",  # Optional. Status of the resource. Known values
                          are: "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str",  # Optional. Gives additional information
                          about the current status of the secret.
                        kind: SecretResourceProperties
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_secret_get_request(
            secret_resource_name=secret_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        secret_resource_name: str,
        **kwargs: Any
    ) -> None:
        """Deletes the Secret resource.

        Deletes the specified Secret resource and all of its named values.

        :param secret_resource_name: The name of the secret resource.
        :type secret_resource_name: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_mesh_secret_delete_request(
            secret_resource_name=secret_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def list(
        self,
        **kwargs: Any
    ) -> JSON:
        """Lists all the secret resources.

        Gets the information about all secret resources in a given resource group. The information
        include the description and other properties of the Secret.

        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "name": "str",  # Required. Name of the Secret resource.
                            "properties": {
                                "contentType": "str",  # Optional. The type of the
                                  content stored in the secret value. The value of this property is
                                  opaque to Service Fabric. Once set, the value of this property cannot
                                  be changed.
                                "description": "str",  # Optional. User readable
                                  description of the secret.
                                "status": "str",  # Optional. Status of the resource.
                                  Known values are: "Unknown", "Ready", "Upgrading", "Creating",
                                  "Deleting", "Failed".
                                "statusDetails": "str",  # Optional. Gives additional
                                  information about the current status of the secret.
                                kind: SecretResourceProperties
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_secret_list_request(
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class MeshSecretValueOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.servicefabric.aio.ServiceFabricClientAPIs`'s
        :attr:`mesh_secret_value` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def add_value(
        self,
        secret_resource_name: str,
        secret_value_resource_name: str,
        secret_value_resource_description: JSON,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Adds the specified value as a new version of the specified secret resource.

        Creates a new value of the specified secret resource. The name of the value is typically the
        version identifier. Once created the value cannot be changed.

        :param secret_resource_name: The name of the secret resource.
        :type secret_resource_name: str
        :param secret_value_resource_name: The name of the secret resource value which is typically the
         version identifier for the value.
        :type secret_value_resource_name: str
        :param secret_value_resource_description: Description for creating a value of a secret
         resource.
        :type secret_value_resource_description: JSON
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                secret_value_resource_description = {
                    "name": "str",  # Required. Version identifier of the secret value.
                    "properties": {
                        "value": "str"  # Optional. The actual value of the secret.
                    }
                }

                # response body for status code(s): 200, 201
                response.json() == {
                    "name": "str",  # Required. Version identifier of the secret value.
                    "properties": {
                        "value": "str"  # Optional. The actual value of the secret.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        _json = secret_value_resource_description

        request = build_mesh_secret_value_add_value_request(
            secret_resource_name=secret_resource_name,
            secret_value_resource_name=secret_value_resource_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get(
        self,
        secret_resource_name: str,
        secret_value_resource_name: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the specified secret value resource.

        Get the information about the specified named secret value resources. The information does not
        include the actual value of the secret.

        :param secret_resource_name: The name of the secret resource.
        :type secret_resource_name: str
        :param secret_value_resource_name: The name of the secret resource value which is typically the
         version identifier for the value.
        :type secret_value_resource_name: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "name": "str",  # Required. Version identifier of the secret value.
                    "properties": {
                        "value": "str"  # Optional. The actual value of the secret.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_secret_value_get_request(
            secret_resource_name=secret_resource_name,
            secret_value_resource_name=secret_value_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        secret_resource_name: str,
        secret_value_resource_name: str,
        **kwargs: Any
    ) -> None:
        """Deletes the specified  value of the named secret resource.

        Deletes the secret value resource identified by the name. The name of the resource is typically
        the version associated with that value. Deletion will fail if the specified value is in use.

        :param secret_resource_name: The name of the secret resource.
        :type secret_resource_name: str
        :param secret_value_resource_name: The name of the secret resource value which is typically the
         version identifier for the value.
        :type secret_value_resource_name: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_mesh_secret_value_delete_request(
            secret_resource_name=secret_resource_name,
            secret_value_resource_name=secret_value_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def list(
        self,
        secret_resource_name: str,
        **kwargs: Any
    ) -> JSON:
        """List names of all values of the specified secret resource.

        Gets information about all secret value resources of the specified secret resource. The
        information includes the names of the secret value resources, but not the actual values.

        :param secret_resource_name: The name of the secret resource.
        :type secret_resource_name: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "name": "str",  # Required. Version identifier of the secret
                              value.
                            "properties": {
                                "value": "str"  # Optional. The actual value of the
                                  secret.
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_secret_value_list_request(
            secret_resource_name=secret_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def show(
        self,
        secret_resource_name: str,
        secret_value_resource_name: str,
        **kwargs: Any
    ) -> JSON:
        """Lists the specified value of the secret resource.

        Lists the decrypted value of the specified named value of the secret resource. This is a
        privileged operation.

        :param secret_resource_name: The name of the secret resource.
        :type secret_resource_name: str
        :param secret_value_resource_name: The name of the secret resource value which is typically the
         version identifier for the value.
        :type secret_value_resource_name: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "value": "str"  # Optional. The actual value of the secret.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_secret_value_show_request(
            secret_resource_name=secret_resource_name,
            secret_value_resource_name=secret_value_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class MeshVolumeOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.servicefabric.aio.ServiceFabricClientAPIs`'s
        :attr:`mesh_volume` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def create_or_update(
        self,
        volume_resource_name: str,
        volume_resource_description: JSON,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Creates or updates a Volume resource.

        Creates a Volume resource with the specified name, description and properties. If Volume
        resource with the same name exists, then it is updated with the specified description and
        properties.

        :param volume_resource_name: The identity of the volume.
        :type volume_resource_name: str
        :param volume_resource_description: Description for creating a Volume resource.
        :type volume_resource_description: JSON
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                volume_resource_description = {
                    "name": "str",  # Required. Name of the Volume resource.
                    "properties": {
                        "azureFileParameters": {
                            "accountKey": "str",  # Optional. Access key of the Azure
                              storage account for the File Share.
                            "accountName": "str",  # Required. Name of the Azure storage
                              account for the File Share.
                            "shareName": "str"  # Required. Name of the Azure Files file
                              share that provides storage for the volume.
                        },
                        "description": "str",  # Optional. User readable description of the
                          volume.
                        "provider": "SFAzureFile",  # Default value is "SFAzureFile".
                          Required. Provider of the volume. Known values are: "SFAzureFile".
                        "status": "str",  # Optional. Status of the volume. Known values are:
                          "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str"  # Optional. Gives additional information
                          about the current status of the volume.
                    }
                }

                # response body for status code(s): 200, 201
                response.json() == {
                    "name": "str",  # Required. Name of the Volume resource.
                    "properties": {
                        "azureFileParameters": {
                            "accountKey": "str",  # Optional. Access key of the Azure
                              storage account for the File Share.
                            "accountName": "str",  # Required. Name of the Azure storage
                              account for the File Share.
                            "shareName": "str"  # Required. Name of the Azure Files file
                              share that provides storage for the volume.
                        },
                        "description": "str",  # Optional. User readable description of the
                          volume.
                        "provider": "SFAzureFile",  # Default value is "SFAzureFile".
                          Required. Provider of the volume. Known values are: "SFAzureFile".
                        "status": "str",  # Optional. Status of the volume. Known values are:
                          "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str"  # Optional. Gives additional information
                          about the current status of the volume.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        _json = volume_resource_description

        request = build_mesh_volume_create_or_update_request(
            volume_resource_name=volume_resource_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get(
        self,
        volume_resource_name: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the Volume resource with the given name.

        Gets the information about the Volume resource with the given name. The information include the
        description and other properties of the Volume.

        :param volume_resource_name: The identity of the volume.
        :type volume_resource_name: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "name": "str",  # Required. Name of the Volume resource.
                    "properties": {
                        "azureFileParameters": {
                            "accountKey": "str",  # Optional. Access key of the Azure
                              storage account for the File Share.
                            "accountName": "str",  # Required. Name of the Azure storage
                              account for the File Share.
                            "shareName": "str"  # Required. Name of the Azure Files file
                              share that provides storage for the volume.
                        },
                        "description": "str",  # Optional. User readable description of the
                          volume.
                        "provider": "SFAzureFile",  # Default value is "SFAzureFile".
                          Required. Provider of the volume. Known values are: "SFAzureFile".
                        "status": "str",  # Optional. Status of the volume. Known values are:
                          "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str"  # Optional. Gives additional information
                          about the current status of the volume.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_volume_get_request(
            volume_resource_name=volume_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        volume_resource_name: str,
        **kwargs: Any
    ) -> None:
        """Deletes the Volume resource.

        Deletes the Volume resource identified by the name.

        :param volume_resource_name: The identity of the volume.
        :type volume_resource_name: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_mesh_volume_delete_request(
            volume_resource_name=volume_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def list(
        self,
        **kwargs: Any
    ) -> JSON:
        """Lists all the volume resources.

        Gets the information about all volume resources in a given resource group. The information
        include the description and other properties of the Volume.

        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "name": "str",  # Required. Name of the Volume resource.
                            "properties": {
                                "azureFileParameters": {
                                    "accountKey": "str",  # Optional. Access key
                                      of the Azure storage account for the File Share.
                                    "accountName": "str",  # Required. Name of
                                      the Azure storage account for the File Share.
                                    "shareName": "str"  # Required. Name of the
                                      Azure Files file share that provides storage for the volume.
                                },
                                "description": "str",  # Optional. User readable
                                  description of the volume.
                                "provider": "SFAzureFile",  # Default value is
                                  "SFAzureFile". Required. Provider of the volume. Known values are:
                                  "SFAzureFile".
                                "status": "str",  # Optional. Status of the volume.
                                  Known values are: "Unknown", "Ready", "Upgrading", "Creating",
                                  "Deleting", "Failed".
                                "statusDetails": "str"  # Optional. Gives additional
                                  information about the current status of the volume.
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_volume_list_request(
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class MeshNetworkOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.servicefabric.aio.ServiceFabricClientAPIs`'s
        :attr:`mesh_network` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def create_or_update(
        self,
        network_resource_name: str,
        network_resource_description: JSON,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Creates or updates a Network resource.

        Creates a Network resource with the specified name, description and properties. If Network
        resource with the same name exists, then it is updated with the specified description and
        properties. Network resource provides connectivity between application services.

        :param network_resource_name: The identity of the network.
        :type network_resource_name: str
        :param network_resource_description: Description for creating a Network resource.
        :type network_resource_description: JSON
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python


                # JSON input template you can fill out and use as your body input.
                network_resource_description = {
                    "name": "str",  # Required. Name of the Network resource.
                    "properties": {
                        "description": "str",  # Optional. User readable description of the
                          network.
                        "status": "str",  # Optional. Status of the network. Known values
                          are: "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str",  # Optional. Gives additional information
                          about the current status of the network.
                        kind: NetworkResourceProperties
                    }
                }

                # response body for status code(s): 200, 201
                response.json() == {
                    "name": "str",  # Required. Name of the Network resource.
                    "properties": {
                        "description": "str",  # Optional. User readable description of the
                          network.
                        "status": "str",  # Optional. Status of the network. Known values
                          are: "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str",  # Optional. Gives additional information
                          about the current status of the network.
                        kind: NetworkResourceProperties
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        _json = network_resource_description

        request = build_mesh_network_create_or_update_request(
            network_resource_name=network_resource_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get(
        self,
        network_resource_name: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the Network resource with the given name.

        Gets the information about the Network resource with the given name. The information include
        the description and other properties of the Network.

        :param network_resource_name: The identity of the network.
        :type network_resource_name: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "name": "str",  # Required. Name of the Network resource.
                    "properties": {
                        "description": "str",  # Optional. User readable description of the
                          network.
                        "status": "str",  # Optional. Status of the network. Known values
                          are: "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str",  # Optional. Gives additional information
                          about the current status of the network.
                        kind: NetworkResourceProperties
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_network_get_request(
            network_resource_name=network_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        network_resource_name: str,
        **kwargs: Any
    ) -> None:
        """Deletes the Network resource.

        Deletes the Network resource identified by the name.

        :param network_resource_name: The identity of the network.
        :type network_resource_name: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_mesh_network_delete_request(
            network_resource_name=network_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def list(
        self,
        **kwargs: Any
    ) -> JSON:
        """Lists all the network resources.

        Gets the information about all network resources in a given resource group. The information
        include the description and other properties of the Network.

        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "name": "str",  # Required. Name of the Network resource.
                            "properties": {
                                "description": "str",  # Optional. User readable
                                  description of the network.
                                "status": "str",  # Optional. Status of the network.
                                  Known values are: "Unknown", "Ready", "Upgrading", "Creating",
                                  "Deleting", "Failed".
                                "statusDetails": "str",  # Optional. Gives additional
                                  information about the current status of the network.
                                kind: NetworkResourceProperties
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_network_list_request(
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class MeshApplicationOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.servicefabric.aio.ServiceFabricClientAPIs`'s
        :attr:`mesh_application` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def create_or_update(
        self,
        application_resource_name: str,
        application_resource_description: JSON,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Creates or updates a Application resource.

        Creates a Application resource with the specified name, description and properties. If
        Application resource with the same name exists, then it is updated with the specified
        description and properties.

        :param application_resource_name: The identity of the application.
        :type application_resource_name: str
        :param application_resource_description: Description for creating a Application resource.
        :type application_resource_description: JSON
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                application_resource_description = {
                    "identity": {
                        "principalId": "str",  # Optional. the object identifier of the
                          Service Principal of the identity associated with this resource.
                        "tenantId": "str",  # Optional. the identifier of the tenant
                          containing the application's identity.
                        "tokenServiceEndpoint": "str",  # Optional. the endpoint for the
                          token service managing this identity.
                        "type": "str",  # Required. the types of identities associated with
                          this resource; currently restricted to 'SystemAssigned and UserAssigned'.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. the client identifier
                                  of the Service Principal which this identity represents.
                                "principalId": "str"  # Optional. the object
                                  identifier of the Service Principal which this identity represents.
                            }
                        }
                    },
                    "name": "str",  # Required. Name of the Application resource.
                    "properties": {
                        "debugParams": "str",  # Optional. Internal - used by Visual Studio
                          to setup the debugging session on the local development environment.
                        "description": "str",  # Optional. User readable description of the
                          application.
                        "diagnostics": {
                            "defaultSinkRefs": [
                                "str"  # Optional. The sinks to be used if
                                  diagnostics is enabled. Sink choices can be overridden at the service
                                  and code package level.
                            ],
                            "enabled": bool,  # Optional. Status of whether or not sinks
                              are enabled.
                            "sinks": [
                                {
                                    "description": "str",  # Optional. A
                                      description of the sink.
                                    "name": "str",  # Optional. Name of the sink.
                                      This value is referenced by DiagnosticsReferenceDescription.
                                    kind: kind
                                }
                            ]
                        },
                        "healthState": "str",  # Optional. Describes the health state of an
                          application resource. Known values are: "Invalid", "Ok", "Warning", "Error",
                          "Unknown".
                        "serviceNames": [
                            "str"  # Optional. Names of the services in the application.
                        ],
                        "services": [
                            {
                                "name": "str",  # Required. Name of the Service
                                  resource.
                                "properties": {
                                    "autoScalingPolicies": [
                                        {
                                            "mechanism": {
                                                kind: kind
                                            },
                                            "name": "str",  # Required.
                                              The name of the auto scaling policy.
                                            "trigger": {
                                                kind: kind
                                            }
                                        }
                                    ],
                                    "codePackages": [
                                        {
                                            "commands": [
                                                "str"  # Optional.
                                                  Command array to execute within the container in exec
                                                  form.
                                            ],
                                            "diagnostics": {
                                                "enabled": bool,  #
                                                  Optional. Status of whether or not sinks are enabled.
                                                "sinkRefs": [
                                                    "str"  #
                                                      Optional. List of sinks to be used if enabled.
                                                      References the list of sinks in
                                                      DiagnosticsDescription.
                                                ]
                                            },
                                            "endpoints": [
                                                {
                                                    "name":
                                                      "str",  # Required. The name of the endpoint.
                                                    "port": 0  #
                                                      Optional. Port used by the container.
                                                }
                                            ],
                                            "entryPoint": "str",  #
                                              Optional. Override for the default entry point in the
                                              container.
                                            "environmentVariables": [
                                                {
                                                    "name":
                                                      "str",  # Optional. The name of the environment
                                                      variable.
                                                    "type":
                                                      "ClearText",  # Optional. Default value is
                                                      "ClearText". The type of the environment variable
                                                      being given in value. Known values are:
                                                      "ClearText", "KeyVaultReference",
                                                      "SecretValueReference". Default value:
                                                      "ClearText".
                                                    "value":
                                                      "str"  # Optional. The value of the environment
                                                      variable, will be processed based on the type
                                                      provided.
                                                }
                                            ],
                                            "image": "str",  # Required.
                                              The Container image to use.
                                            "imageRegistryCredential": {
                                                "password": "str",  #
                                                  Optional. The password for the private registry. The
                                                  password is required for create or update operations,
                                                  however it is not returned in the get or list
                                                  operations. Will be processed based on the type
                                                  provided.
                                                "passwordType":
                                                  "ClearText",  # Optional. Default value is
                                                  "ClearText". The type of the image registry password
                                                  being given in password. Known values are:
                                                  "ClearText", "KeyVaultReference",
                                                  "SecretValueReference". Default value: "ClearText".
                                                "server": "str",  #
                                                  Required. Docker image registry server, without
                                                  protocol such as ``http`` and ``https``.
                                                "username": "str"  #
                                                  Required. The username for the private registry.
                                            },
                                            "instanceView": {
                                                "currentState": {
                "detailStatus": "str",  # Optional.
                                                      Human-readable status of this state.
                                                    "exitCode":
                                                      "str",  # Optional. The container exit code.
                                                    "finishTime":
                                                      "2020-02-20 00:00:00",  # Optional. Date/time
                                                      when the container state finished.
                                                    "startTime":
                                                      "2020-02-20 00:00:00",  # Optional. Date/time
                                                      when the container state started.
                                                    "state":
                                                      "str"  # Optional. The state of this container.
                                                },
                                                "events": [
                                                    {
                "count": 0,  # Optional. The count of the
                                                          event.
                "firstTimestamp": "str",  # Optional.
                                                          Date/time of the first event.
                "lastTimestamp": "str",  # Optional.
                                                          Date/time of the last event.
                "message": "str",  # Optional. The event
                                                          message.
                "name": "str",  # Optional. The name of the
                                                          container event.
                "type": "str"  # Optional. The event type.
                                                    }
                                                ],
                                                "previousState": {
                "detailStatus": "str",  # Optional.
                                                      Human-readable status of this state.
                                                    "exitCode":
                                                      "str",  # Optional. The container exit code.
                                                    "finishTime":
                                                      "2020-02-20 00:00:00",  # Optional. Date/time
                                                      when the container state finished.
                                                    "startTime":
                                                      "2020-02-20 00:00:00",  # Optional. Date/time
                                                      when the container state started.
                                                    "state":
                                                      "str"  # Optional. The state of this container.
                                                },
                                                "restartCount": 0  #
                                                  Optional. The number of times the container has been
                                                  restarted.
                                            },
                                            "labels": [
                                                {
                                                    "name":
                                                      "str",  # Required. The name of the container
                                                      label.
                                                    "value":
                                                      "str"  # Required. The value of the container
                                                      label.
                                                }
                                            ],
                                            "livenessProbe": [
                                                {
                                                    "exec": {
                "command": "str"  # Required. Comma separated
                                                          command to run inside the container for
                                                          example "sh, -c, echo hello world".
                                                    },
                "failureThreshold": 3,  # Optional. Default value
                                                      is 3. The count of failures after which probe is
                                                      considered failed.
                                                    "httpGet": {
                "host": "str",  # Optional. Host IP to
                                                          connect to.
                "httpHeaders": [
                {
                "name": "str",  # Required. The name
                                                                  of the header.
                "value": "str"  # Required. The value
                                                                  of the header.
                }
                                                        ],
                "path": "str",  # Optional. Path to access on
                                                          the HTTP request.
                "port": 0,  # Required. Port to access for
                                                          probe.
                "scheme": "str"  # Optional. Scheme for the
                                                          http probe. Can be Http or Https. Known
                                                          values are: "http", "https".
                                                    },
                "initialDelaySeconds": 0,  # Optional. The
                                                      initial delay in seconds to start executing probe
                                                      once codepackage has started.
                "periodSeconds": 10,  # Optional. Default value
                                                      is 10. Periodic seconds to execute probe.
                "successThreshold": 1,  # Optional. Default value
                                                      is 1. The count of successful probe executions
                                                      after which probe is considered success.
                                                    "tcpSocket":
                                                      {
                "port": 0  # Required. Port to access for
                                                          probe.
                                                    },
                "timeoutSeconds": 1  # Optional. Default value is
                                                      1. Period after which probe is considered as
                                                      failed if it hasn't completed successfully.
                                                }
                                            ],
                                            "name": "str",  # Required.
                                              The name of the code package.
                                            "readinessProbe": [
                                                {
                                                    "exec": {
                "command": "str"  # Required. Comma separated
                                                          command to run inside the container for
                                                          example "sh, -c, echo hello world".
                                                    },
                "failureThreshold": 3,  # Optional. Default value
                                                      is 3. The count of failures after which probe is
                                                      considered failed.
                                                    "httpGet": {
                "host": "str",  # Optional. Host IP to
                                                          connect to.
                "httpHeaders": [
                {
                "name": "str",  # Required. The name
                                                                  of the header.
                "value": "str"  # Required. The value
                                                                  of the header.
                }
                                                        ],
                "path": "str",  # Optional. Path to access on
                                                          the HTTP request.
                "port": 0,  # Required. Port to access for
                                                          probe.
                "scheme": "str"  # Optional. Scheme for the
                                                          http probe. Can be Http or Https. Known
                                                          values are: "http", "https".
                                                    },
                "initialDelaySeconds": 0,  # Optional. The
                                                      initial delay in seconds to start executing probe
                                                      once codepackage has started.
                "periodSeconds": 10,  # Optional. Default value
                                                      is 10. Periodic seconds to execute probe.
                "successThreshold": 1,  # Optional. Default value
                                                      is 1. The count of successful probe executions
                                                      after which probe is considered success.
                                                    "tcpSocket":
                                                      {
                "port": 0  # Required. Port to access for
                                                          probe.
                                                    },
                "timeoutSeconds": 1  # Optional. Default value is
                                                      1. Period after which probe is considered as
                                                      failed if it hasn't completed successfully.
                                                }
                                            ],
                                            "reliableCollectionsRefs": [
                                                {
                "doNotPersistState": bool,  # Optional. False
                                                      (the default) if ReliableCollections state is
                                                      persisted to disk as usual. True if you do not
                                                      want to persist state, in which case replication
                                                      is still enabled and you can use
                                                      ReliableCollections as distributed cache.
                                                    "name": "str"
                                                      # Required. Name of ReliableCollection resource.
                                                      Right now it's not used and you can use any
                                                      string.
                                                }
                                            ],
                                            "resources": {
                                                "limits": {
                                                    "cpu": 0.0,
                                                      # Optional. CPU limits in cores. At present, only
                                                      full cores are supported.
                                                    "memoryInGB":
                                                      0.0  # Optional. The memory limit in GB.
                                                },
                                                "requests": {
                                                    "cpu": 0.0,
                                                      # Required. Requested number of CPU cores. At
                                                      present, only full cores are supported.
                                                    "memoryInGB":
                                                      0.0  # Required. The memory request in GB for
                                                      this container.
                                                }
                                            },
                                            "settings": [
                                                {
                                                    "name":
                                                      "str",  # Optional. The name of the setting.
                                                    "type":
                                                      "ClearText",  # Optional. Default value is
                                                      "ClearText". The type of the setting being given
                                                      in value. Known values are: "ClearText",
                                                      "KeyVaultReference", "SecretValueReference".
                                                      Default value: "ClearText".
                                                    "value":
                                                      "str"  # Optional. The value of the setting, will
                                                      be processed based on the type provided.
                                                }
                                            ],
                                            "volumeRefs": [
                                                {
                "destinationPath": "str",  # Required. The path
                                                      within the container at which the volume should
                                                      be mounted. Only valid path characters are
                                                      allowed.
                                                    "name":
                                                      "str",  # Required. Name of the volume being
                                                      referenced.
                                                    "readOnly":
                                                      bool  # Optional. The flag indicating whether the
                                                      volume is read only. Default is 'false'.
                                                }
                                            ],
                                            "volumes": [
                                                {
                "creationParameters": {
                "description": "str",  # Optional. User
                                                          readable description of the volume.
                                                        kind:
                                                          kind
                                                    },
                "destinationPath": "str",  # Required. The path
                                                      within the container at which the volume should
                                                      be mounted. Only valid path characters are
                                                      allowed.
                                                    "name":
                                                      "str",  # Required. Name of the volume being
                                                      referenced.
                                                    "readOnly":
                                                      bool  # Optional. The flag indicating whether the
                                                      volume is read only. Default is 'false'.
                                                }
                                            ]
                                        }
                                    ],
                                    "description": "str",  # Optional. User
                                      readable description of the service.
                                    "diagnostics": {
                                        "enabled": bool,  # Optional. Status
                                          of whether or not sinks are enabled.
                                        "sinkRefs": [
                                            "str"  # Optional. List of
                                              sinks to be used if enabled. References the list of sinks
                                              in DiagnosticsDescription.
                                        ]
                                    },
                                    "dnsName": "str",  # Optional. Dns name of
                                      the service.
                                    "executionPolicy": {
                                        type: type
                                    },
                                    "healthState": "str",  # Optional. Describes
                                      the health state of an application resource. Known values are:
                                      "Invalid", "Ok", "Warning", "Error", "Unknown".
                                    "identityRefs": [
                                        {
                                            "identityRef": "str",  #
                                              Optional. The application identity name.
                                            "name": "str"  # Optional.
                                              The identity friendly name.
                                        }
                                    ],
                                    "networkRefs": [
                                        {
                                            "endpointRefs": [
                                                {
                                                    "name": "str"
                                                      # Optional. Name of the endpoint.
                                                }
                                            ],
                                            "name": "str"  # Optional.
                                              Name of the network.
                                        }
                                    ],
                                    "osType": "str",  # Required. The operation
                                      system required by the code in service. Known values are:
                                      "Linux", "Windows".
                                    "replicaCount": 0,  # Optional. The number of
                                      replicas of the service to create. Defaults to 1 if not
                                      specified.
                                    "status": "str",  # Optional. Status of the
                                      service. Known values are: "Unknown", "Ready", "Upgrading",
                                      "Creating", "Deleting", "Failed".
                                    "statusDetails": "str",  # Optional. Gives
                                      additional information about the current status of the service.
                                    "unhealthyEvaluation": "str"  # Optional.
                                      When the service's health state is not 'Ok', this additional
                                      details from service fabric Health Manager for the user to know
                                      why the service is marked unhealthy.
                                }
                            }
                        ],
                        "status": "str",  # Optional. Status of the application. Known values
                          are: "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str",  # Optional. Gives additional information
                          about the current status of the application.
                        "unhealthyEvaluation": "str"  # Optional. When the application's
                          health state is not 'Ok', this additional details from service fabric Health
                          Manager for the user to know why the application is marked unhealthy.
                    }
                }

                # response body for status code(s): 200, 201
                response.json() == {
                    "identity": {
                        "principalId": "str",  # Optional. the object identifier of the
                          Service Principal of the identity associated with this resource.
                        "tenantId": "str",  # Optional. the identifier of the tenant
                          containing the application's identity.
                        "tokenServiceEndpoint": "str",  # Optional. the endpoint for the
                          token service managing this identity.
                        "type": "str",  # Required. the types of identities associated with
                          this resource; currently restricted to 'SystemAssigned and UserAssigned'.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. the client identifier
                                  of the Service Principal which this identity represents.
                                "principalId": "str"  # Optional. the object
                                  identifier of the Service Principal which this identity represents.
                            }
                        }
                    },
                    "name": "str",  # Required. Name of the Application resource.
                    "properties": {
                        "debugParams": "str",  # Optional. Internal - used by Visual Studio
                          to setup the debugging session on the local development environment.
                        "description": "str",  # Optional. User readable description of the
                          application.
                        "diagnostics": {
                            "defaultSinkRefs": [
                                "str"  # Optional. The sinks to be used if
                                  diagnostics is enabled. Sink choices can be overridden at the service
                                  and code package level.
                            ],
                            "enabled": bool,  # Optional. Status of whether or not sinks
                              are enabled.
                            "sinks": [
                                {
                                    "description": "str",  # Optional. A
                                      description of the sink.
                                    "name": "str",  # Optional. Name of the sink.
                                      This value is referenced by DiagnosticsReferenceDescription.
                                    kind: kind
                                }
                            ]
                        },
                        "healthState": "str",  # Optional. Describes the health state of an
                          application resource. Known values are: "Invalid", "Ok", "Warning", "Error",
                          "Unknown".
                        "serviceNames": [
                            "str"  # Optional. Names of the services in the application.
                        ],
                        "services": [
                            {
                                "name": "str",  # Required. Name of the Service
                                  resource.
                                "properties": {
                                    "autoScalingPolicies": [
                                        {
                                            "mechanism": {
                                                kind: kind
                                            },
                                            "name": "str",  # Required.
                                              The name of the auto scaling policy.
                                            "trigger": {
                                                kind: kind
                                            }
                                        }
                                    ],
                                    "codePackages": [
                                        {
                                            "commands": [
                                                "str"  # Optional.
                                                  Command array to execute within the container in exec
                                                  form.
                                            ],
                                            "diagnostics": {
                                                "enabled": bool,  #
                                                  Optional. Status of whether or not sinks are enabled.
                                                "sinkRefs": [
                                                    "str"  #
                                                      Optional. List of sinks to be used if enabled.
                                                      References the list of sinks in
                                                      DiagnosticsDescription.
                                                ]
                                            },
                                            "endpoints": [
                                                {
                                                    "name":
                                                      "str",  # Required. The name of the endpoint.
                                                    "port": 0  #
                                                      Optional. Port used by the container.
                                                }
                                            ],
                                            "entryPoint": "str",  #
                                              Optional. Override for the default entry point in the
                                              container.
                                            "environmentVariables": [
                                                {
                                                    "name":
                                                      "str",  # Optional. The name of the environment
                                                      variable.
                                                    "type":
                                                      "ClearText",  # Optional. Default value is
                                                      "ClearText". The type of the environment variable
                                                      being given in value. Known values are:
                                                      "ClearText", "KeyVaultReference",
                                                      "SecretValueReference". Default value:
                                                      "ClearText".
                                                    "value":
                                                      "str"  # Optional. The value of the environment
                                                      variable, will be processed based on the type
                                                      provided.
                                                }
                                            ],
                                            "image": "str",  # Required.
                                              The Container image to use.
                                            "imageRegistryCredential": {
                                                "password": "str",  #
                                                  Optional. The password for the private registry. The
                                                  password is required for create or update operations,
                                                  however it is not returned in the get or list
                                                  operations. Will be processed based on the type
                                                  provided.
                                                "passwordType":
                                                  "ClearText",  # Optional. Default value is
                                                  "ClearText". The type of the image registry password
                                                  being given in password. Known values are:
                                                  "ClearText", "KeyVaultReference",
                                                  "SecretValueReference". Default value: "ClearText".
                                                "server": "str",  #
                                                  Required. Docker image registry server, without
                                                  protocol such as ``http`` and ``https``.
                                                "username": "str"  #
                                                  Required. The username for the private registry.
                                            },
                                            "instanceView": {
                                                "currentState": {
                "detailStatus": "str",  # Optional.
                                                      Human-readable status of this state.
                                                    "exitCode":
                                                      "str",  # Optional. The container exit code.
                                                    "finishTime":
                                                      "2020-02-20 00:00:00",  # Optional. Date/time
                                                      when the container state finished.
                                                    "startTime":
                                                      "2020-02-20 00:00:00",  # Optional. Date/time
                                                      when the container state started.
                                                    "state":
                                                      "str"  # Optional. The state of this container.
                                                },
                                                "events": [
                                                    {
                "count": 0,  # Optional. The count of the
                                                          event.
                "firstTimestamp": "str",  # Optional.
                                                          Date/time of the first event.
                "lastTimestamp": "str",  # Optional.
                                                          Date/time of the last event.
                "message": "str",  # Optional. The event
                                                          message.
                "name": "str",  # Optional. The name of the
                                                          container event.
                "type": "str"  # Optional. The event type.
                                                    }
                                                ],
                                                "previousState": {
                "detailStatus": "str",  # Optional.
                                                      Human-readable status of this state.
                                                    "exitCode":
                                                      "str",  # Optional. The container exit code.
                                                    "finishTime":
                                                      "2020-02-20 00:00:00",  # Optional. Date/time
                                                      when the container state finished.
                                                    "startTime":
                                                      "2020-02-20 00:00:00",  # Optional. Date/time
                                                      when the container state started.
                                                    "state":
                                                      "str"  # Optional. The state of this container.
                                                },
                                                "restartCount": 0  #
                                                  Optional. The number of times the container has been
                                                  restarted.
                                            },
                                            "labels": [
                                                {
                                                    "name":
                                                      "str",  # Required. The name of the container
                                                      label.
                                                    "value":
                                                      "str"  # Required. The value of the container
                                                      label.
                                                }
                                            ],
                                            "livenessProbe": [
                                                {
                                                    "exec": {
                "command": "str"  # Required. Comma separated
                                                          command to run inside the container for
                                                          example "sh, -c, echo hello world".
                                                    },
                "failureThreshold": 3,  # Optional. Default value
                                                      is 3. The count of failures after which probe is
                                                      considered failed.
                                                    "httpGet": {
                "host": "str",  # Optional. Host IP to
                                                          connect to.
                "httpHeaders": [
                {
                "name": "str",  # Required. The name
                                                                  of the header.
                "value": "str"  # Required. The value
                                                                  of the header.
                }
                                                        ],
                "path": "str",  # Optional. Path to access on
                                                          the HTTP request.
                "port": 0,  # Required. Port to access for
                                                          probe.
                "scheme": "str"  # Optional. Scheme for the
                                                          http probe. Can be Http or Https. Known
                                                          values are: "http", "https".
                                                    },
                "initialDelaySeconds": 0,  # Optional. The
                                                      initial delay in seconds to start executing probe
                                                      once codepackage has started.
                "periodSeconds": 10,  # Optional. Default value
                                                      is 10. Periodic seconds to execute probe.
                "successThreshold": 1,  # Optional. Default value
                                                      is 1. The count of successful probe executions
                                                      after which probe is considered success.
                                                    "tcpSocket":
                                                      {
                "port": 0  # Required. Port to access for
                                                          probe.
                                                    },
                "timeoutSeconds": 1  # Optional. Default value is
                                                      1. Period after which probe is considered as
                                                      failed if it hasn't completed successfully.
                                                }
                                            ],
                                            "name": "str",  # Required.
                                              The name of the code package.
                                            "readinessProbe": [
                                                {
                                                    "exec": {
                "command": "str"  # Required. Comma separated
                                                          command to run inside the container for
                                                          example "sh, -c, echo hello world".
                                                    },
                "failureThreshold": 3,  # Optional. Default value
                                                      is 3. The count of failures after which probe is
                                                      considered failed.
                                                    "httpGet": {
                "host": "str",  # Optional. Host IP to
                                                          connect to.
                "httpHeaders": [
                {
                "name": "str",  # Required. The name
                                                                  of the header.
                "value": "str"  # Required. The value
                                                                  of the header.
                }
                                                        ],
                "path": "str",  # Optional. Path to access on
                                                          the HTTP request.
                "port": 0,  # Required. Port to access for
                                                          probe.
                "scheme": "str"  # Optional. Scheme for the
                                                          http probe. Can be Http or Https. Known
                                                          values are: "http", "https".
                                                    },
                "initialDelaySeconds": 0,  # Optional. The
                                                      initial delay in seconds to start executing probe
                                                      once codepackage has started.
                "periodSeconds": 10,  # Optional. Default value
                                                      is 10. Periodic seconds to execute probe.
                "successThreshold": 1,  # Optional. Default value
                                                      is 1. The count of successful probe executions
                                                      after which probe is considered success.
                                                    "tcpSocket":
                                                      {
                "port": 0  # Required. Port to access for
                                                          probe.
                                                    },
                "timeoutSeconds": 1  # Optional. Default value is
                                                      1. Period after which probe is considered as
                                                      failed if it hasn't completed successfully.
                                                }
                                            ],
                                            "reliableCollectionsRefs": [
                                                {
                "doNotPersistState": bool,  # Optional. False
                                                      (the default) if ReliableCollections state is
                                                      persisted to disk as usual. True if you do not
                                                      want to persist state, in which case replication
                                                      is still enabled and you can use
                                                      ReliableCollections as distributed cache.
                                                    "name": "str"
                                                      # Required. Name of ReliableCollection resource.
                                                      Right now it's not used and you can use any
                                                      string.
                                                }
                                            ],
                                            "resources": {
                                                "limits": {
                                                    "cpu": 0.0,
                                                      # Optional. CPU limits in cores. At present, only
                                                      full cores are supported.
                                                    "memoryInGB":
                                                      0.0  # Optional. The memory limit in GB.
                                                },
                                                "requests": {
                                                    "cpu": 0.0,
                                                      # Required. Requested number of CPU cores. At
                                                      present, only full cores are supported.
                                                    "memoryInGB":
                                                      0.0  # Required. The memory request in GB for
                                                      this container.
                                                }
                                            },
                                            "settings": [
                                                {
                                                    "name":
                                                      "str",  # Optional. The name of the setting.
                                                    "type":
                                                      "ClearText",  # Optional. Default value is
                                                      "ClearText". The type of the setting being given
                                                      in value. Known values are: "ClearText",
                                                      "KeyVaultReference", "SecretValueReference".
                                                      Default value: "ClearText".
                                                    "value":
                                                      "str"  # Optional. The value of the setting, will
                                                      be processed based on the type provided.
                                                }
                                            ],
                                            "volumeRefs": [
                                                {
                "destinationPath": "str",  # Required. The path
                                                      within the container at which the volume should
                                                      be mounted. Only valid path characters are
                                                      allowed.
                                                    "name":
                                                      "str",  # Required. Name of the volume being
                                                      referenced.
                                                    "readOnly":
                                                      bool  # Optional. The flag indicating whether the
                                                      volume is read only. Default is 'false'.
                                                }
                                            ],
                                            "volumes": [
                                                {
                "creationParameters": {
                "description": "str",  # Optional. User
                                                          readable description of the volume.
                                                        kind:
                                                          kind
                                                    },
                "destinationPath": "str",  # Required. The path
                                                      within the container at which the volume should
                                                      be mounted. Only valid path characters are
                                                      allowed.
                                                    "name":
                                                      "str",  # Required. Name of the volume being
                                                      referenced.
                                                    "readOnly":
                                                      bool  # Optional. The flag indicating whether the
                                                      volume is read only. Default is 'false'.
                                                }
                                            ]
                                        }
                                    ],
                                    "description": "str",  # Optional. User
                                      readable description of the service.
                                    "diagnostics": {
                                        "enabled": bool,  # Optional. Status
                                          of whether or not sinks are enabled.
                                        "sinkRefs": [
                                            "str"  # Optional. List of
                                              sinks to be used if enabled. References the list of sinks
                                              in DiagnosticsDescription.
                                        ]
                                    },
                                    "dnsName": "str",  # Optional. Dns name of
                                      the service.
                                    "executionPolicy": {
                                        type: type
                                    },
                                    "healthState": "str",  # Optional. Describes
                                      the health state of an application resource. Known values are:
                                      "Invalid", "Ok", "Warning", "Error", "Unknown".
                                    "identityRefs": [
                                        {
                                            "identityRef": "str",  #
                                              Optional. The application identity name.
                                            "name": "str"  # Optional.
                                              The identity friendly name.
                                        }
                                    ],
                                    "networkRefs": [
                                        {
                                            "endpointRefs": [
                                                {
                                                    "name": "str"
                                                      # Optional. Name of the endpoint.
                                                }
                                            ],
                                            "name": "str"  # Optional.
                                              Name of the network.
                                        }
                                    ],
                                    "osType": "str",  # Required. The operation
                                      system required by the code in service. Known values are:
                                      "Linux", "Windows".
                                    "replicaCount": 0,  # Optional. The number of
                                      replicas of the service to create. Defaults to 1 if not
                                      specified.
                                    "status": "str",  # Optional. Status of the
                                      service. Known values are: "Unknown", "Ready", "Upgrading",
                                      "Creating", "Deleting", "Failed".
                                    "statusDetails": "str",  # Optional. Gives
                                      additional information about the current status of the service.
                                    "unhealthyEvaluation": "str"  # Optional.
                                      When the service's health state is not 'Ok', this additional
                                      details from service fabric Health Manager for the user to know
                                      why the service is marked unhealthy.
                                }
                            }
                        ],
                        "status": "str",  # Optional. Status of the application. Known values
                          are: "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str",  # Optional. Gives additional information
                          about the current status of the application.
                        "unhealthyEvaluation": "str"  # Optional. When the application's
                          health state is not 'Ok', this additional details from service fabric Health
                          Manager for the user to know why the application is marked unhealthy.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        _json = application_resource_description

        request = build_mesh_application_create_or_update_request(
            application_resource_name=application_resource_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get(
        self,
        application_resource_name: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the Application resource with the given name.

        Gets the information about the Application resource with the given name. The information
        include the description and other properties of the Application.

        :param application_resource_name: The identity of the application.
        :type application_resource_name: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "identity": {
                        "principalId": "str",  # Optional. the object identifier of the
                          Service Principal of the identity associated with this resource.
                        "tenantId": "str",  # Optional. the identifier of the tenant
                          containing the application's identity.
                        "tokenServiceEndpoint": "str",  # Optional. the endpoint for the
                          token service managing this identity.
                        "type": "str",  # Required. the types of identities associated with
                          this resource; currently restricted to 'SystemAssigned and UserAssigned'.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. the client identifier
                                  of the Service Principal which this identity represents.
                                "principalId": "str"  # Optional. the object
                                  identifier of the Service Principal which this identity represents.
                            }
                        }
                    },
                    "name": "str",  # Required. Name of the Application resource.
                    "properties": {
                        "debugParams": "str",  # Optional. Internal - used by Visual Studio
                          to setup the debugging session on the local development environment.
                        "description": "str",  # Optional. User readable description of the
                          application.
                        "diagnostics": {
                            "defaultSinkRefs": [
                                "str"  # Optional. The sinks to be used if
                                  diagnostics is enabled. Sink choices can be overridden at the service
                                  and code package level.
                            ],
                            "enabled": bool,  # Optional. Status of whether or not sinks
                              are enabled.
                            "sinks": [
                                {
                                    "description": "str",  # Optional. A
                                      description of the sink.
                                    "name": "str",  # Optional. Name of the sink.
                                      This value is referenced by DiagnosticsReferenceDescription.
                                    kind: kind
                                }
                            ]
                        },
                        "healthState": "str",  # Optional. Describes the health state of an
                          application resource. Known values are: "Invalid", "Ok", "Warning", "Error",
                          "Unknown".
                        "serviceNames": [
                            "str"  # Optional. Names of the services in the application.
                        ],
                        "services": [
                            {
                                "name": "str",  # Required. Name of the Service
                                  resource.
                                "properties": {
                                    "autoScalingPolicies": [
                                        {
                                            "mechanism": {
                                                kind: kind
                                            },
                                            "name": "str",  # Required.
                                              The name of the auto scaling policy.
                                            "trigger": {
                                                kind: kind
                                            }
                                        }
                                    ],
                                    "codePackages": [
                                        {
                                            "commands": [
                                                "str"  # Optional.
                                                  Command array to execute within the container in exec
                                                  form.
                                            ],
                                            "diagnostics": {
                                                "enabled": bool,  #
                                                  Optional. Status of whether or not sinks are enabled.
                                                "sinkRefs": [
                                                    "str"  #
                                                      Optional. List of sinks to be used if enabled.
                                                      References the list of sinks in
                                                      DiagnosticsDescription.
                                                ]
                                            },
                                            "endpoints": [
                                                {
                                                    "name":
                                                      "str",  # Required. The name of the endpoint.
                                                    "port": 0  #
                                                      Optional. Port used by the container.
                                                }
                                            ],
                                            "entryPoint": "str",  #
                                              Optional. Override for the default entry point in the
                                              container.
                                            "environmentVariables": [
                                                {
                                                    "name":
                                                      "str",  # Optional. The name of the environment
                                                      variable.
                                                    "type":
                                                      "ClearText",  # Optional. Default value is
                                                      "ClearText". The type of the environment variable
                                                      being given in value. Known values are:
                                                      "ClearText", "KeyVaultReference",
                                                      "SecretValueReference". Default value:
                                                      "ClearText".
                                                    "value":
                                                      "str"  # Optional. The value of the environment
                                                      variable, will be processed based on the type
                                                      provided.
                                                }
                                            ],
                                            "image": "str",  # Required.
                                              The Container image to use.
                                            "imageRegistryCredential": {
                                                "password": "str",  #
                                                  Optional. The password for the private registry. The
                                                  password is required for create or update operations,
                                                  however it is not returned in the get or list
                                                  operations. Will be processed based on the type
                                                  provided.
                                                "passwordType":
                                                  "ClearText",  # Optional. Default value is
                                                  "ClearText". The type of the image registry password
                                                  being given in password. Known values are:
                                                  "ClearText", "KeyVaultReference",
                                                  "SecretValueReference". Default value: "ClearText".
                                                "server": "str",  #
                                                  Required. Docker image registry server, without
                                                  protocol such as ``http`` and ``https``.
                                                "username": "str"  #
                                                  Required. The username for the private registry.
                                            },
                                            "instanceView": {
                                                "currentState": {
                "detailStatus": "str",  # Optional.
                                                      Human-readable status of this state.
                                                    "exitCode":
                                                      "str",  # Optional. The container exit code.
                                                    "finishTime":
                                                      "2020-02-20 00:00:00",  # Optional. Date/time
                                                      when the container state finished.
                                                    "startTime":
                                                      "2020-02-20 00:00:00",  # Optional. Date/time
                                                      when the container state started.
                                                    "state":
                                                      "str"  # Optional. The state of this container.
                                                },
                                                "events": [
                                                    {
                "count": 0,  # Optional. The count of the
                                                          event.
                "firstTimestamp": "str",  # Optional.
                                                          Date/time of the first event.
                "lastTimestamp": "str",  # Optional.
                                                          Date/time of the last event.
                "message": "str",  # Optional. The event
                                                          message.
                "name": "str",  # Optional. The name of the
                                                          container event.
                "type": "str"  # Optional. The event type.
                                                    }
                                                ],
                                                "previousState": {
                "detailStatus": "str",  # Optional.
                                                      Human-readable status of this state.
                                                    "exitCode":
                                                      "str",  # Optional. The container exit code.
                                                    "finishTime":
                                                      "2020-02-20 00:00:00",  # Optional. Date/time
                                                      when the container state finished.
                                                    "startTime":
                                                      "2020-02-20 00:00:00",  # Optional. Date/time
                                                      when the container state started.
                                                    "state":
                                                      "str"  # Optional. The state of this container.
                                                },
                                                "restartCount": 0  #
                                                  Optional. The number of times the container has been
                                                  restarted.
                                            },
                                            "labels": [
                                                {
                                                    "name":
                                                      "str",  # Required. The name of the container
                                                      label.
                                                    "value":
                                                      "str"  # Required. The value of the container
                                                      label.
                                                }
                                            ],
                                            "livenessProbe": [
                                                {
                                                    "exec": {
                "command": "str"  # Required. Comma separated
                                                          command to run inside the container for
                                                          example "sh, -c, echo hello world".
                                                    },
                "failureThreshold": 3,  # Optional. Default value
                                                      is 3. The count of failures after which probe is
                                                      considered failed.
                                                    "httpGet": {
                "host": "str",  # Optional. Host IP to
                                                          connect to.
                "httpHeaders": [
                {
                "name": "str",  # Required. The name
                                                                  of the header.
                "value": "str"  # Required. The value
                                                                  of the header.
                }
                                                        ],
                "path": "str",  # Optional. Path to access on
                                                          the HTTP request.
                "port": 0,  # Required. Port to access for
                                                          probe.
                "scheme": "str"  # Optional. Scheme for the
                                                          http probe. Can be Http or Https. Known
                                                          values are: "http", "https".
                                                    },
                "initialDelaySeconds": 0,  # Optional. The
                                                      initial delay in seconds to start executing probe
                                                      once codepackage has started.
                "periodSeconds": 10,  # Optional. Default value
                                                      is 10. Periodic seconds to execute probe.
                "successThreshold": 1,  # Optional. Default value
                                                      is 1. The count of successful probe executions
                                                      after which probe is considered success.
                                                    "tcpSocket":
                                                      {
                "port": 0  # Required. Port to access for
                                                          probe.
                                                    },
                "timeoutSeconds": 1  # Optional. Default value is
                                                      1. Period after which probe is considered as
                                                      failed if it hasn't completed successfully.
                                                }
                                            ],
                                            "name": "str",  # Required.
                                              The name of the code package.
                                            "readinessProbe": [
                                                {
                                                    "exec": {
                "command": "str"  # Required. Comma separated
                                                          command to run inside the container for
                                                          example "sh, -c, echo hello world".
                                                    },
                "failureThreshold": 3,  # Optional. Default value
                                                      is 3. The count of failures after which probe is
                                                      considered failed.
                                                    "httpGet": {
                "host": "str",  # Optional. Host IP to
                                                          connect to.
                "httpHeaders": [
                {
                "name": "str",  # Required. The name
                                                                  of the header.
                "value": "str"  # Required. The value
                                                                  of the header.
                }
                                                        ],
                "path": "str",  # Optional. Path to access on
                                                          the HTTP request.
                "port": 0,  # Required. Port to access for
                                                          probe.
                "scheme": "str"  # Optional. Scheme for the
                                                          http probe. Can be Http or Https. Known
                                                          values are: "http", "https".
                                                    },
                "initialDelaySeconds": 0,  # Optional. The
                                                      initial delay in seconds to start executing probe
                                                      once codepackage has started.
                "periodSeconds": 10,  # Optional. Default value
                                                      is 10. Periodic seconds to execute probe.
                "successThreshold": 1,  # Optional. Default value
                                                      is 1. The count of successful probe executions
                                                      after which probe is considered success.
                                                    "tcpSocket":
                                                      {
                "port": 0  # Required. Port to access for
                                                          probe.
                                                    },
                "timeoutSeconds": 1  # Optional. Default value is
                                                      1. Period after which probe is considered as
                                                      failed if it hasn't completed successfully.
                                                }
                                            ],
                                            "reliableCollectionsRefs": [
                                                {
                "doNotPersistState": bool,  # Optional. False
                                                      (the default) if ReliableCollections state is
                                                      persisted to disk as usual. True if you do not
                                                      want to persist state, in which case replication
                                                      is still enabled and you can use
                                                      ReliableCollections as distributed cache.
                                                    "name": "str"
                                                      # Required. Name of ReliableCollection resource.
                                                      Right now it's not used and you can use any
                                                      string.
                                                }
                                            ],
                                            "resources": {
                                                "limits": {
                                                    "cpu": 0.0,
                                                      # Optional. CPU limits in cores. At present, only
                                                      full cores are supported.
                                                    "memoryInGB":
                                                      0.0  # Optional. The memory limit in GB.
                                                },
                                                "requests": {
                                                    "cpu": 0.0,
                                                      # Required. Requested number of CPU cores. At
                                                      present, only full cores are supported.
                                                    "memoryInGB":
                                                      0.0  # Required. The memory request in GB for
                                                      this container.
                                                }
                                            },
                                            "settings": [
                                                {
                                                    "name":
                                                      "str",  # Optional. The name of the setting.
                                                    "type":
                                                      "ClearText",  # Optional. Default value is
                                                      "ClearText". The type of the setting being given
                                                      in value. Known values are: "ClearText",
                                                      "KeyVaultReference", "SecretValueReference".
                                                      Default value: "ClearText".
                                                    "value":
                                                      "str"  # Optional. The value of the setting, will
                                                      be processed based on the type provided.
                                                }
                                            ],
                                            "volumeRefs": [
                                                {
                "destinationPath": "str",  # Required. The path
                                                      within the container at which the volume should
                                                      be mounted. Only valid path characters are
                                                      allowed.
                                                    "name":
                                                      "str",  # Required. Name of the volume being
                                                      referenced.
                                                    "readOnly":
                                                      bool  # Optional. The flag indicating whether the
                                                      volume is read only. Default is 'false'.
                                                }
                                            ],
                                            "volumes": [
                                                {
                "creationParameters": {
                "description": "str",  # Optional. User
                                                          readable description of the volume.
                                                        kind:
                                                          kind
                                                    },
                "destinationPath": "str",  # Required. The path
                                                      within the container at which the volume should
                                                      be mounted. Only valid path characters are
                                                      allowed.
                                                    "name":
                                                      "str",  # Required. Name of the volume being
                                                      referenced.
                                                    "readOnly":
                                                      bool  # Optional. The flag indicating whether the
                                                      volume is read only. Default is 'false'.
                                                }
                                            ]
                                        }
                                    ],
                                    "description": "str",  # Optional. User
                                      readable description of the service.
                                    "diagnostics": {
                                        "enabled": bool,  # Optional. Status
                                          of whether or not sinks are enabled.
                                        "sinkRefs": [
                                            "str"  # Optional. List of
                                              sinks to be used if enabled. References the list of sinks
                                              in DiagnosticsDescription.
                                        ]
                                    },
                                    "dnsName": "str",  # Optional. Dns name of
                                      the service.
                                    "executionPolicy": {
                                        type: type
                                    },
                                    "healthState": "str",  # Optional. Describes
                                      the health state of an application resource. Known values are:
                                      "Invalid", "Ok", "Warning", "Error", "Unknown".
                                    "identityRefs": [
                                        {
                                            "identityRef": "str",  #
                                              Optional. The application identity name.
                                            "name": "str"  # Optional.
                                              The identity friendly name.
                                        }
                                    ],
                                    "networkRefs": [
                                        {
                                            "endpointRefs": [
                                                {
                                                    "name": "str"
                                                      # Optional. Name of the endpoint.
                                                }
                                            ],
                                            "name": "str"  # Optional.
                                              Name of the network.
                                        }
                                    ],
                                    "osType": "str",  # Required. The operation
                                      system required by the code in service. Known values are:
                                      "Linux", "Windows".
                                    "replicaCount": 0,  # Optional. The number of
                                      replicas of the service to create. Defaults to 1 if not
                                      specified.
                                    "status": "str",  # Optional. Status of the
                                      service. Known values are: "Unknown", "Ready", "Upgrading",
                                      "Creating", "Deleting", "Failed".
                                    "statusDetails": "str",  # Optional. Gives
                                      additional information about the current status of the service.
                                    "unhealthyEvaluation": "str"  # Optional.
                                      When the service's health state is not 'Ok', this additional
                                      details from service fabric Health Manager for the user to know
                                      why the service is marked unhealthy.
                                }
                            }
                        ],
                        "status": "str",  # Optional. Status of the application. Known values
                          are: "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str",  # Optional. Gives additional information
                          about the current status of the application.
                        "unhealthyEvaluation": "str"  # Optional. When the application's
                          health state is not 'Ok', this additional details from service fabric Health
                          Manager for the user to know why the application is marked unhealthy.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_application_get_request(
            application_resource_name=application_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        application_resource_name: str,
        **kwargs: Any
    ) -> None:
        """Deletes the Application resource.

        Deletes the Application resource identified by the name.

        :param application_resource_name: The identity of the application.
        :type application_resource_name: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_mesh_application_delete_request(
            application_resource_name=application_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def list(
        self,
        **kwargs: Any
    ) -> JSON:
        """Lists all the application resources.

        Gets the information about all application resources in a given resource group. The information
        include the description and other properties of the Application.

        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "identity": {
                                "principalId": "str",  # Optional. the object
                                  identifier of the Service Principal of the identity associated with
                                  this resource.
                                "tenantId": "str",  # Optional. the identifier of the
                                  tenant containing the application's identity.
                                "tokenServiceEndpoint": "str",  # Optional. the
                                  endpoint for the token service managing this identity.
                                "type": "str",  # Required. the types of identities
                                  associated with this resource; currently restricted to
                                  'SystemAssigned and UserAssigned'.
                                "userAssignedIdentities": {
                                    "str": {
                                        "clientId": "str",  # Optional. the
                                          client identifier of the Service Principal which this
                                          identity represents.
                                        "principalId": "str"  # Optional. the
                                          object identifier of the Service Principal which this
                                          identity represents.
                                    }
                                }
                            },
                            "name": "str",  # Required. Name of the Application resource.
                            "properties": {
                                "debugParams": "str",  # Optional. Internal - used by
                                  Visual Studio to setup the debugging session on the local development
                                  environment.
                                "description": "str",  # Optional. User readable
                                  description of the application.
                                "diagnostics": {
                                    "defaultSinkRefs": [
                                        "str"  # Optional. The sinks to be
                                          used if diagnostics is enabled. Sink choices can be
                                          overridden at the service and code package level.
                                    ],
                                    "enabled": bool,  # Optional. Status of
                                      whether or not sinks are enabled.
                                    "sinks": [
                                        {
                                            "description": "str",  #
                                              Optional. A description of the sink.
                                            "name": "str",  # Optional.
                                              Name of the sink. This value is referenced by
                                              DiagnosticsReferenceDescription.
                                            kind: kind
                                        }
                                    ]
                                },
                                "healthState": "str",  # Optional. Describes the
                                  health state of an application resource. Known values are: "Invalid",
                                  "Ok", "Warning", "Error", "Unknown".
                                "serviceNames": [
                                    "str"  # Optional. Names of the services in
                                      the application.
                                ],
                                "services": [
                                    {
                                        "name": "str",  # Required. Name of
                                          the Service resource.
                                        "properties": {
                                            "autoScalingPolicies": [
                                                {
                                                    "mechanism":
                                                      {
                                                        kind:
                                                          kind
                                                    },
                                                    "name":
                                                      "str",  # Required. The name of the auto scaling
                                                      policy.
                                                    "trigger": {
                                                        kind:
                                                          kind
                                                    }
                                                }
                                            ],
                                            "codePackages": [
                                                {
                                                    "commands": [
                                                        "str"
                                                          # Optional. Command array to execute within
                                                          the container in exec form.
                                                    ],
                "diagnostics": {
                "enabled": bool,  # Optional. Status of
                                                          whether or not sinks are enabled.
                "sinkRefs": [
                "str"  # Optional. List of sinks to be
                                                              used if enabled. References the list of
                                                              sinks in DiagnosticsDescription.
                                                        ]
                                                    },
                                                    "endpoints":
                                                      [
                                                        {
                "name": "str",  # Required. The name of
                                                              the endpoint.
                "port": 0  # Optional. Port used by the
                                                              container.
                                                        }
                                                    ],
                                                    "entryPoint":
                                                      "str",  # Optional. Override for the default
                                                      entry point in the container.
                "environmentVariables": [
                                                        {
                "name": "str",  # Optional. The name of
                                                              the environment variable.
                "type": "ClearText",  # Optional. Default
                                                              value is "ClearText". The type of the
                                                              environment variable being given in
                                                              value. Known values are: "ClearText",
                                                              "KeyVaultReference",
                                                              "SecretValueReference". Default value:
                                                              "ClearText".
                "value": "str"  # Optional. The value of
                                                              the environment variable, will be
                                                              processed based on the type provided.
                                                        }
                                                    ],
                                                    "image":
                                                      "str",  # Required. The Container image to use.
                "imageRegistryCredential": {
                "password": "str",  # Optional. The password
                                                          for the private registry. The password is
                                                          required for create or update operations,
                                                          however it is not returned in the get or list
                                                          operations. Will be processed based on the
                                                          type provided.
                "passwordType": "ClearText",  # Optional.
                                                          Default value is "ClearText". The type of the
                                                          image registry password being given in
                                                          password. Known values are: "ClearText",
                                                          "KeyVaultReference", "SecretValueReference".
                                                          Default value: "ClearText".
                "server": "str",  # Required. Docker image
                                                          registry server, without protocol such as
                                                          ``http`` and ``https``.
                "username": "str"  # Required. The username
                                                          for the private registry.
                                                    },
                "instanceView": {
                "currentState": {
                "detailStatus": "str",  # Optional.
                                                              Human-readable status of this state.
                "exitCode": "str",  # Optional. The
                                                              container exit code.
                "finishTime": "2020-02-20 00:00:00",  #
                                                              Optional. Date/time when the container
                                                              state finished.
                "startTime": "2020-02-20 00:00:00",  #
                                                              Optional. Date/time when the container
                                                              state started.
                "state": "str"  # Optional. The state of
                                                              this container.
                                                        },
                "events": [
                {
                "count": 0,  # Optional. The count of
                                                                  the event.
                "firstTimestamp": "str",  # Optional.
                                                                  Date/time of the first event.
                "lastTimestamp": "str",  # Optional.
                                                                  Date/time of the last event.
                "message": "str",  # Optional. The
                                                                  event message.
                "name": "str",  # Optional. The name
                                                                  of the container event.
                "type": "str"  # Optional. The event
                                                                  type.
                }
                                                        ],
                "previousState": {
                "detailStatus": "str",  # Optional.
                                                              Human-readable status of this state.
                "exitCode": "str",  # Optional. The
                                                              container exit code.
                "finishTime": "2020-02-20 00:00:00",  #
                                                              Optional. Date/time when the container
                                                              state finished.
                "startTime": "2020-02-20 00:00:00",  #
                                                              Optional. Date/time when the container
                                                              state started.
                "state": "str"  # Optional. The state of
                                                              this container.
                                                        },
                "restartCount": 0  # Optional. The number of
                                                          times the container has been restarted.
                                                    },
                                                    "labels": [
                                                        {
                "name": "str",  # Required. The name of
                                                              the container label.
                "value": "str"  # Required. The value of
                                                              the container label.
                                                        }
                                                    ],
                "livenessProbe": [
                                                        {
                "exec": {
                "command": "str"  # Required. Comma
                                                                  separated command to run inside the
                                                                  container for example "sh, -c, echo
                                                                  hello world".
                },
                "failureThreshold": 3,  # Optional.
                                                              Default value is 3. The count of failures
                                                              after which probe is considered failed.
                "httpGet": {
                "host": "str",  # Optional. Host IP
                                                                  to connect to.
                "httpHeaders": [
                {
                "name": "str",  # Required.
                                                                          The name of the header.
                "value": "str"  # Required.
                                                                          The value of the header.
                }
                ],
                "path": "str",  # Optional. Path to
                                                                  access on the HTTP request.
                "port": 0,  # Required. Port to
                                                                  access for probe.
                "scheme": "str"  # Optional. Scheme
                                                                  for the http probe. Can be Http or
                                                                  Https. Known values are: "http",
                                                                  "https".
                },
                "initialDelaySeconds": 0,  # Optional.
                                                              The initial delay in seconds to start
                                                              executing probe once codepackage has
                                                              started.
                "periodSeconds": 10,  # Optional. Default
                                                              value is 10. Periodic seconds to execute
                                                              probe.
                "successThreshold": 1,  # Optional.
                                                              Default value is 1. The count of
                                                              successful probe executions after which
                                                              probe is considered success.
                "tcpSocket": {
                "port": 0  # Required. Port to access
                                                                  for probe.
                },
                "timeoutSeconds": 1  # Optional. Default
                                                              value is 1. Period after which probe is
                                                              considered as failed if it hasn't
                                                              completed successfully.
                                                        }
                                                    ],
                                                    "name":
                                                      "str",  # Required. The name of the code package.
                "readinessProbe": [
                                                        {
                "exec": {
                "command": "str"  # Required. Comma
                                                                  separated command to run inside the
                                                                  container for example "sh, -c, echo
                                                                  hello world".
                },
                "failureThreshold": 3,  # Optional.
                                                              Default value is 3. The count of failures
                                                              after which probe is considered failed.
                "httpGet": {
                "host": "str",  # Optional. Host IP
                                                                  to connect to.
                "httpHeaders": [
                {
                "name": "str",  # Required.
                                                                          The name of the header.
                "value": "str"  # Required.
                                                                          The value of the header.
                }
                ],
                "path": "str",  # Optional. Path to
                                                                  access on the HTTP request.
                "port": 0,  # Required. Port to
                                                                  access for probe.
                "scheme": "str"  # Optional. Scheme
                                                                  for the http probe. Can be Http or
                                                                  Https. Known values are: "http",
                                                                  "https".
                },
                "initialDelaySeconds": 0,  # Optional.
                                                              The initial delay in seconds to start
                                                              executing probe once codepackage has
                                                              started.
                "periodSeconds": 10,  # Optional. Default
                                                              value is 10. Periodic seconds to execute
                                                              probe.
                "successThreshold": 1,  # Optional.
                                                              Default value is 1. The count of
                                                              successful probe executions after which
                                                              probe is considered success.
                "tcpSocket": {
                "port": 0  # Required. Port to access
                                                                  for probe.
                },
                "timeoutSeconds": 1  # Optional. Default
                                                              value is 1. Period after which probe is
                                                              considered as failed if it hasn't
                                                              completed successfully.
                                                        }
                                                    ],
                "reliableCollectionsRefs": [
                                                        {
                "doNotPersistState": bool,  # Optional.
                                                              False (the default) if
                                                              ReliableCollections state is persisted to
                                                              disk as usual. True if you do not want to
                                                              persist state, in which case replication
                                                              is still enabled and you can use
                                                              ReliableCollections as distributed cache.
                "name": "str"  # Required. Name of
                                                              ReliableCollection resource. Right now
                                                              it's not used and you can use any string.
                                                        }
                                                    ],
                                                    "resources":
                                                      {
                "limits": {
                "cpu": 0.0,  # Optional. CPU limits in
                                                              cores. At present, only full cores are
                                                              supported.
                "memoryInGB": 0.0  # Optional. The memory
                                                              limit in GB.
                                                        },
                "requests": {
                "cpu": 0.0,  # Required. Requested number
                                                              of CPU cores. At present, only full cores
                                                              are supported.
                "memoryInGB": 0.0  # Required. The memory
                                                              request in GB for this container.
                                                        }
                                                    },
                                                    "settings": [
                                                        {
                "name": "str",  # Optional. The name of
                                                              the setting.
                "type": "ClearText",  # Optional. Default
                                                              value is "ClearText". The type of the
                                                              setting being given in value. Known
                                                              values are: "ClearText",
                                                              "KeyVaultReference",
                                                              "SecretValueReference". Default value:
                                                              "ClearText".
                "value": "str"  # Optional. The value of
                                                              the setting, will be processed based on
                                                              the type provided.
                                                        }
                                                    ],
                                                    "volumeRefs":
                                                      [
                                                        {
                "destinationPath": "str",  # Required.
                                                              The path within the container at which
                                                              the volume should be mounted. Only valid
                                                              path characters are allowed.
                "name": "str",  # Required. Name of the
                                                              volume being referenced.
                "readOnly": bool  # Optional. The flag
                                                              indicating whether the volume is read
                                                              only. Default is 'false'.
                                                        }
                                                    ],
                                                    "volumes": [
                                                        {
                "creationParameters": {
                "description": "str",  # Optional.
                                                                  User readable description of the
                                                                  volume.
                kind: kind
                },
                "destinationPath": "str",  # Required.
                                                              The path within the container at which
                                                              the volume should be mounted. Only valid
                                                              path characters are allowed.
                "name": "str",  # Required. Name of the
                                                              volume being referenced.
                "readOnly": bool  # Optional. The flag
                                                              indicating whether the volume is read
                                                              only. Default is 'false'.
                                                        }
                                                    ]
                                                }
                                            ],
                                            "description": "str",  #
                                              Optional. User readable description of the service.
                                            "diagnostics": {
                                                "enabled": bool,  #
                                                  Optional. Status of whether or not sinks are enabled.
                                                "sinkRefs": [
                                                    "str"  #
                                                      Optional. List of sinks to be used if enabled.
                                                      References the list of sinks in
                                                      DiagnosticsDescription.
                                                ]
                                            },
                                            "dnsName": "str",  #
                                              Optional. Dns name of the service.
                                            "executionPolicy": {
                                                type: type
                                            },
                                            "healthState": "str",  #
                                              Optional. Describes the health state of an application
                                              resource. Known values are: "Invalid", "Ok", "Warning",
                                              "Error", "Unknown".
                                            "identityRefs": [
                                                {
                "identityRef": "str",  # Optional. The
                                                      application identity name.
                                                    "name": "str"
                                                      # Optional. The identity friendly name.
                                                }
                                            ],
                                            "networkRefs": [
                                                {
                "endpointRefs": [
                                                        {
                "name": "str"  # Optional. Name of the
                                                              endpoint.
                                                        }
                                                    ],
                                                    "name": "str"
                                                      # Optional. Name of the network.
                                                }
                                            ],
                                            "osType": "str",  # Required.
                                              The operation system required by the code in service.
                                              Known values are: "Linux", "Windows".
                                            "replicaCount": 0,  #
                                              Optional. The number of replicas of the service to
                                              create. Defaults to 1 if not specified.
                                            "status": "str",  # Optional.
                                              Status of the service. Known values are: "Unknown",
                                              "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                                            "statusDetails": "str",  #
                                              Optional. Gives additional information about the current
                                              status of the service.
                                            "unhealthyEvaluation": "str"
                                              # Optional. When the service's health state is not 'Ok',
                                              this additional details from service fabric Health
                                              Manager for the user to know why the service is marked
                                              unhealthy.
                                        }
                                    }
                                ],
                                "status": "str",  # Optional. Status of the
                                  application. Known values are: "Unknown", "Ready", "Upgrading",
                                  "Creating", "Deleting", "Failed".
                                "statusDetails": "str",  # Optional. Gives additional
                                  information about the current status of the application.
                                "unhealthyEvaluation": "str"  # Optional. When the
                                  application's health state is not 'Ok', this additional details from
                                  service fabric Health Manager for the user to know why the
                                  application is marked unhealthy.
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_application_list_request(
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_upgrade_progress(
        self,
        application_resource_name: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the progress of the latest upgrade performed on this application resource.

        Gets the upgrade progress information about the Application resource with the given name. The
        information include percentage of completion and other upgrade state information of the
        Application resource.

        :param application_resource_name: The identity of the application.
        :type application_resource_name: str
        :keyword api_version: The version of the API. This parameter is required and its value must be
         '7.0'.

         Service Fabric REST API version is based on the runtime version in which the API was
         introduced or was changed. Service Fabric runtime supports more than one version of the API.
         This version is the latest supported version of the API. If a lower API version is passed, the
         returned response may be different from the one documented in this specification.

         Additionally the runtime accepts any version that is higher than the latest supported version
         up to the current version of the runtime. So if the latest API version is 6.0 and the runtime
         is 6.1, the runtime will accept version 6.1 for that API. However the behavior of the API will
         be as per the documented 6.0 version. Default value is "7.0". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ApplicationUpgradeStatusDetails": "str",  # Optional. Additional detailed
                      information about the status of the pending upgrade.
                    "FailureTimestampUtc": "str",  # Optional. The estimated UTC datetime when
                      the upgrade failed and FailureAction was executed.
                    "Name": "str",  # Optional. Name of the Application resource.
                    "PercentCompleted": "str",  # Optional. The estimated percent of replicas are
                      completed in the upgrade.
                    "RollingUpgradeMode": "Monitored",  # Optional. Default value is "Monitored".
                      The mode used to monitor health during a rolling upgrade. The values are
                      UnmonitoredAuto, UnmonitoredManual, and Monitored. Known values are: "Invalid",
                      "UnmonitoredAuto", "UnmonitoredManual", "Monitored". Default value: "Monitored".
                    "ServiceUpgradeProgress": [
                        {
                            "CompletedReplicaCount": "str",  # Optional. The number of
                              replicas that completes the upgrade in the service.
                            "PendingReplicaCount": "str",  # Optional. The number of
                              replicas that are waiting to be upgraded in the service.
                            "ServiceName": "str"  # Optional. Name of the Service
                              resource.
                        }
                    ],
                    "StartTimestampUtc": "str",  # Optional. The estimated UTC datetime when the
                      upgrade started.
                    "TargetApplicationTypeVersion": "str",  # Optional. The target application
                      version for the application upgrade.
                    "UpgradeDuration": "PT0H2M0S",  # Optional. Default value is "PT0H2M0S". The
                      estimated amount of time that the overall upgrade elapsed. It is first
                      interpreted as a string representing an ISO 8601 duration. If that fails, then it
                      is interpreted as a number representing the total number of milliseconds.
                    "UpgradeReplicaSetCheckTimeoutInSeconds": 42949672925,  # Optional. Default
                      value is 42949672925. The maximum amount of time to block processing of an
                      upgrade domain and prevent loss of availability when there are unexpected issues.
                      When this timeout expires, processing of the upgrade domain will proceed
                      regardless of availability loss issues. The timeout is reset at the start of each
                      upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned
                      32-bit integer).
                    "UpgradeState": "str"  # Optional. The state of the application resource
                      upgrade. Known values are: "Invalid", "ProvisioningTarget", "RollingForward",
                      "UnprovisioningCurrent", "CompletedRollforward", "RollingBack",
                      "UnprovisioningTarget", "CompletedRollback", "Failed".
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "7.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_application_get_upgrade_progress_request(
            application_resource_name=application_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class MeshServiceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.servicefabric.aio.ServiceFabricClientAPIs`'s
        :attr:`mesh_service` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def get(
        self,
        application_resource_name: str,
        service_resource_name: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the Service resource with the given name.

        Gets the information about the Service resource with the given name. The information include
        the description and other properties of the Service.

        :param application_resource_name: The identity of the application.
        :type application_resource_name: str
        :param service_resource_name: The identity of the service.
        :type service_resource_name: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "name": "str",  # Required. Name of the Service resource.
                    "properties": {
                        "autoScalingPolicies": [
                            {
                                "mechanism": {
                                    kind: kind
                                },
                                "name": "str",  # Required. The name of the auto
                                  scaling policy.
                                "trigger": {
                                    kind: kind
                                }
                            }
                        ],
                        "codePackages": [
                            {
                                "commands": [
                                    "str"  # Optional. Command array to execute
                                      within the container in exec form.
                                ],
                                "diagnostics": {
                                    "enabled": bool,  # Optional. Status of
                                      whether or not sinks are enabled.
                                    "sinkRefs": [
                                        "str"  # Optional. List of sinks to
                                          be used if enabled. References the list of sinks in
                                          DiagnosticsDescription.
                                    ]
                                },
                                "endpoints": [
                                    {
                                        "name": "str",  # Required. The name
                                          of the endpoint.
                                        "port": 0  # Optional. Port used by
                                          the container.
                                    }
                                ],
                                "entryPoint": "str",  # Optional. Override for the
                                  default entry point in the container.
                                "environmentVariables": [
                                    {
                                        "name": "str",  # Optional. The name
                                          of the environment variable.
                                        "type": "ClearText",  # Optional.
                                          Default value is "ClearText". The type of the environment
                                          variable being given in value. Known values are: "ClearText",
                                          "KeyVaultReference", "SecretValueReference". Default value:
                                          "ClearText".
                                        "value": "str"  # Optional. The value
                                          of the environment variable, will be processed based on the
                                          type provided.
                                    }
                                ],
                                "image": "str",  # Required. The Container image to
                                  use.
                                "imageRegistryCredential": {
                                    "password": "str",  # Optional. The password
                                      for the private registry. The password is required for create or
                                      update operations, however it is not returned in the get or list
                                      operations. Will be processed based on the type provided.
                                    "passwordType": "ClearText",  # Optional.
                                      Default value is "ClearText". The type of the image registry
                                      password being given in password. Known values are: "ClearText",
                                      "KeyVaultReference", "SecretValueReference". Default value:
                                      "ClearText".
                                    "server": "str",  # Required. Docker image
                                      registry server, without protocol such as ``http`` and ``https``.
                                    "username": "str"  # Required. The username
                                      for the private registry.
                                },
                                "instanceView": {
                                    "currentState": {
                                        "detailStatus": "str",  # Optional.
                                          Human-readable status of this state.
                                        "exitCode": "str",  # Optional. The
                                          container exit code.
                                        "finishTime": "2020-02-20 00:00:00",
                                          # Optional. Date/time when the container state finished.
                                        "startTime": "2020-02-20 00:00:00",
                                          # Optional. Date/time when the container state started.
                                        "state": "str"  # Optional. The state
                                          of this container.
                                    },
                                    "events": [
                                        {
                                            "count": 0,  # Optional. The
                                              count of the event.
                                            "firstTimestamp": "str",  #
                                              Optional. Date/time of the first event.
                                            "lastTimestamp": "str",  #
                                              Optional. Date/time of the last event.
                                            "message": "str",  #
                                              Optional. The event message.
                                            "name": "str",  # Optional.
                                              The name of the container event.
                                            "type": "str"  # Optional.
                                              The event type.
                                        }
                                    ],
                                    "previousState": {
                                        "detailStatus": "str",  # Optional.
                                          Human-readable status of this state.
                                        "exitCode": "str",  # Optional. The
                                          container exit code.
                                        "finishTime": "2020-02-20 00:00:00",
                                          # Optional. Date/time when the container state finished.
                                        "startTime": "2020-02-20 00:00:00",
                                          # Optional. Date/time when the container state started.
                                        "state": "str"  # Optional. The state
                                          of this container.
                                    },
                                    "restartCount": 0  # Optional. The number of
                                      times the container has been restarted.
                                },
                                "labels": [
                                    {
                                        "name": "str",  # Required. The name
                                          of the container label.
                                        "value": "str"  # Required. The value
                                          of the container label.
                                    }
                                ],
                                "livenessProbe": [
                                    {
                                        "exec": {
                                            "command": "str"  # Required.
                                              Comma separated command to run inside the container for
                                              example "sh, -c, echo hello world".
                                        },
                                        "failureThreshold": 3,  # Optional.
                                          Default value is 3. The count of failures after which probe
                                          is considered failed.
                                        "httpGet": {
                                            "host": "str",  # Optional.
                                              Host IP to connect to.
                                            "httpHeaders": [
                                                {
                                                    "name":
                                                      "str",  # Required. The name of the header.
                                                    "value":
                                                      "str"  # Required. The value of the header.
                                                }
                                            ],
                                            "path": "str",  # Optional.
                                              Path to access on the HTTP request.
                                            "port": 0,  # Required. Port
                                              to access for probe.
                                            "scheme": "str"  # Optional.
                                              Scheme for the http probe. Can be Http or Https. Known
                                              values are: "http", "https".
                                        },
                                        "initialDelaySeconds": 0,  #
                                          Optional. The initial delay in seconds to start executing
                                          probe once codepackage has started.
                                        "periodSeconds": 10,  # Optional.
                                          Default value is 10. Periodic seconds to execute probe.
                                        "successThreshold": 1,  # Optional.
                                          Default value is 1. The count of successful probe executions
                                          after which probe is considered success.
                                        "tcpSocket": {
                                            "port": 0  # Required. Port
                                              to access for probe.
                                        },
                                        "timeoutSeconds": 1  # Optional.
                                          Default value is 1. Period after which probe is considered as
                                          failed if it hasn't completed successfully.
                                    }
                                ],
                                "name": "str",  # Required. The name of the code
                                  package.
                                "readinessProbe": [
                                    {
                                        "exec": {
                                            "command": "str"  # Required.
                                              Comma separated command to run inside the container for
                                              example "sh, -c, echo hello world".
                                        },
                                        "failureThreshold": 3,  # Optional.
                                          Default value is 3. The count of failures after which probe
                                          is considered failed.
                                        "httpGet": {
                                            "host": "str",  # Optional.
                                              Host IP to connect to.
                                            "httpHeaders": [
                                                {
                                                    "name":
                                                      "str",  # Required. The name of the header.
                                                    "value":
                                                      "str"  # Required. The value of the header.
                                                }
                                            ],
                                            "path": "str",  # Optional.
                                              Path to access on the HTTP request.
                                            "port": 0,  # Required. Port
                                              to access for probe.
                                            "scheme": "str"  # Optional.
                                              Scheme for the http probe. Can be Http or Https. Known
                                              values are: "http", "https".
                                        },
                                        "initialDelaySeconds": 0,  #
                                          Optional. The initial delay in seconds to start executing
                                          probe once codepackage has started.
                                        "periodSeconds": 10,  # Optional.
                                          Default value is 10. Periodic seconds to execute probe.
                                        "successThreshold": 1,  # Optional.
                                          Default value is 1. The count of successful probe executions
                                          after which probe is considered success.
                                        "tcpSocket": {
                                            "port": 0  # Required. Port
                                              to access for probe.
                                        },
                                        "timeoutSeconds": 1  # Optional.
                                          Default value is 1. Period after which probe is considered as
                                          failed if it hasn't completed successfully.
                                    }
                                ],
                                "reliableCollectionsRefs": [
                                    {
                                        "doNotPersistState": bool,  #
                                          Optional. False (the default) if ReliableCollections state is
                                          persisted to disk as usual. True if you do not want to
                                          persist state, in which case replication is still enabled and
                                          you can use ReliableCollections as distributed cache.
                                        "name": "str"  # Required. Name of
                                          ReliableCollection resource. Right now it's not used and you
                                          can use any string.
                                    }
                                ],
                                "resources": {
                                    "limits": {
                                        "cpu": 0.0,  # Optional. CPU limits
                                          in cores. At present, only full cores are supported.
                                        "memoryInGB": 0.0  # Optional. The
                                          memory limit in GB.
                                    },
                                    "requests": {
                                        "cpu": 0.0,  # Required. Requested
                                          number of CPU cores. At present, only full cores are
                                          supported.
                                        "memoryInGB": 0.0  # Required. The
                                          memory request in GB for this container.
                                    }
                                },
                                "settings": [
                                    {
                                        "name": "str",  # Optional. The name
                                          of the setting.
                                        "type": "ClearText",  # Optional.
                                          Default value is "ClearText". The type of the setting being
                                          given in value. Known values are: "ClearText",
                                          "KeyVaultReference", "SecretValueReference". Default value:
                                          "ClearText".
                                        "value": "str"  # Optional. The value
                                          of the setting, will be processed based on the type provided.
                                    }
                                ],
                                "volumeRefs": [
                                    {
                                        "destinationPath": "str",  #
                                          Required. The path within the container at which the volume
                                          should be mounted. Only valid path characters are allowed.
                                        "name": "str",  # Required. Name of
                                          the volume being referenced.
                                        "readOnly": bool  # Optional. The
                                          flag indicating whether the volume is read only. Default is
                                          'false'.
                                    }
                                ],
                                "volumes": [
                                    {
                                        "creationParameters": {
                                            "description": "str",  #
                                              Optional. User readable description of the volume.
                                            kind: kind
                                        },
                                        "destinationPath": "str",  #
                                          Required. The path within the container at which the volume
                                          should be mounted. Only valid path characters are allowed.
                                        "name": "str",  # Required. Name of
                                          the volume being referenced.
                                        "readOnly": bool  # Optional. The
                                          flag indicating whether the volume is read only. Default is
                                          'false'.
                                    }
                                ]
                            }
                        ],
                        "description": "str",  # Optional. User readable description of the
                          service.
                        "diagnostics": {
                            "enabled": bool,  # Optional. Status of whether or not sinks
                              are enabled.
                            "sinkRefs": [
                                "str"  # Optional. List of sinks to be used if
                                  enabled. References the list of sinks in DiagnosticsDescription.
                            ]
                        },
                        "dnsName": "str",  # Optional. Dns name of the service.
                        "executionPolicy": {
                            type: type
                        },
                        "healthState": "str",  # Optional. Describes the health state of an
                          application resource. Known values are: "Invalid", "Ok", "Warning", "Error",
                          "Unknown".
                        "identityRefs": [
                            {
                                "identityRef": "str",  # Optional. The application
                                  identity name.
                                "name": "str"  # Optional. The identity friendly
                                  name.
                            }
                        ],
                        "networkRefs": [
                            {
                                "endpointRefs": [
                                    {
                                        "name": "str"  # Optional. Name of
                                          the endpoint.
                                    }
                                ],
                                "name": "str"  # Optional. Name of the network.
                            }
                        ],
                        "osType": "str",  # Required. The operation system required by the
                          code in service. Known values are: "Linux", "Windows".
                        "replicaCount": 0,  # Optional. The number of replicas of the service
                          to create. Defaults to 1 if not specified.
                        "status": "str",  # Optional. Status of the service. Known values
                          are: "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str",  # Optional. Gives additional information
                          about the current status of the service.
                        "unhealthyEvaluation": "str"  # Optional. When the service's health
                          state is not 'Ok', this additional details from service fabric Health Manager
                          for the user to know why the service is marked unhealthy.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_service_get_request(
            application_resource_name=application_resource_name,
            service_resource_name=service_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def list(
        self,
        application_resource_name: str,
        **kwargs: Any
    ) -> JSON:
        """Lists all the service resources.

        Gets the information about all services of an application resource. The information include the
        description and other properties of the Service.

        :param application_resource_name: The identity of the application.
        :type application_resource_name: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "name": "str",  # Required. Name of the Service resource.
                            "properties": {
                                "autoScalingPolicies": [
                                    {
                                        "mechanism": {
                                            kind: kind
                                        },
                                        "name": "str",  # Required. The name
                                          of the auto scaling policy.
                                        "trigger": {
                                            kind: kind
                                        }
                                    }
                                ],
                                "codePackages": [
                                    {
                                        "commands": [
                                            "str"  # Optional. Command
                                              array to execute within the container in exec form.
                                        ],
                                        "diagnostics": {
                                            "enabled": bool,  # Optional.
                                              Status of whether or not sinks are enabled.
                                            "sinkRefs": [
                                                "str"  # Optional.
                                                  List of sinks to be used if enabled. References the
                                                  list of sinks in DiagnosticsDescription.
                                            ]
                                        },
                                        "endpoints": [
                                            {
                                                "name": "str",  #
                                                  Required. The name of the endpoint.
                                                "port": 0  #
                                                  Optional. Port used by the container.
                                            }
                                        ],
                                        "entryPoint": "str",  # Optional.
                                          Override for the default entry point in the container.
                                        "environmentVariables": [
                                            {
                                                "name": "str",  #
                                                  Optional. The name of the environment variable.
                                                "type": "ClearText",
                                                  # Optional. Default value is "ClearText". The type of
                                                  the environment variable being given in value. Known
                                                  values are: "ClearText", "KeyVaultReference",
                                                  "SecretValueReference". Default value: "ClearText".
                                                "value": "str"  #
                                                  Optional. The value of the environment variable, will
                                                  be processed based on the type provided.
                                            }
                                        ],
                                        "image": "str",  # Required. The
                                          Container image to use.
                                        "imageRegistryCredential": {
                                            "password": "str",  #
                                              Optional. The password for the private registry. The
                                              password is required for create or update operations,
                                              however it is not returned in the get or list operations.
                                              Will be processed based on the type provided.
                                            "passwordType": "ClearText",
                                              # Optional. Default value is "ClearText". The type of the
                                              image registry password being given in password. Known
                                              values are: "ClearText", "KeyVaultReference",
                                              "SecretValueReference". Default value: "ClearText".
                                            "server": "str",  # Required.
                                              Docker image registry server, without protocol such as
                                              ``http`` and ``https``.
                                            "username": "str"  #
                                              Required. The username for the private registry.
                                        },
                                        "instanceView": {
                                            "currentState": {
                                                "detailStatus":
                                                  "str",  # Optional. Human-readable status of this
                                                  state.
                                                "exitCode": "str",  #
                                                  Optional. The container exit code.
                                                "finishTime":
                                                  "2020-02-20 00:00:00",  # Optional. Date/time when
                                                  the container state finished.
                                                "startTime":
                                                  "2020-02-20 00:00:00",  # Optional. Date/time when
                                                  the container state started.
                                                "state": "str"  #
                                                  Optional. The state of this container.
                                            },
                                            "events": [
                                                {
                                                    "count": 0,
                                                      # Optional. The count of the event.
                "firstTimestamp": "str",  # Optional. Date/time
                                                      of the first event.
                "lastTimestamp": "str",  # Optional. Date/time of
                                                      the last event.
                                                    "message":
                                                      "str",  # Optional. The event message.
                                                    "name":
                                                      "str",  # Optional. The name of the container
                                                      event.
                                                    "type": "str"
                                                      # Optional. The event type.
                                                }
                                            ],
                                            "previousState": {
                                                "detailStatus":
                                                  "str",  # Optional. Human-readable status of this
                                                  state.
                                                "exitCode": "str",  #
                                                  Optional. The container exit code.
                                                "finishTime":
                                                  "2020-02-20 00:00:00",  # Optional. Date/time when
                                                  the container state finished.
                                                "startTime":
                                                  "2020-02-20 00:00:00",  # Optional. Date/time when
                                                  the container state started.
                                                "state": "str"  #
                                                  Optional. The state of this container.
                                            },
                                            "restartCount": 0  #
                                              Optional. The number of times the container has been
                                              restarted.
                                        },
                                        "labels": [
                                            {
                                                "name": "str",  #
                                                  Required. The name of the container label.
                                                "value": "str"  #
                                                  Required. The value of the container label.
                                            }
                                        ],
                                        "livenessProbe": [
                                            {
                                                "exec": {
                                                    "command":
                                                      "str"  # Required. Comma separated command to run
                                                      inside the container for example "sh, -c, echo
                                                      hello world".
                                                },
                                                "failureThreshold":
                                                  3,  # Optional. Default value is 3. The count of
                                                  failures after which probe is considered failed.
                                                "httpGet": {
                                                    "host":
                                                      "str",  # Optional. Host IP to connect to.
                "httpHeaders": [
                                                        {
                "name": "str",  # Required. The name of
                                                              the header.
                "value": "str"  # Required. The value of
                                                              the header.
                                                        }
                                                    ],
                                                    "path":
                                                      "str",  # Optional. Path to access on the HTTP
                                                      request.
                                                    "port": 0,  #
                                                      Required. Port to access for probe.
                                                    "scheme":
                                                      "str"  # Optional. Scheme for the http probe. Can
                                                      be Http or Https. Known values are: "http",
                                                      "https".
                                                },
                "initialDelaySeconds": 0,  # Optional. The initial
                                                  delay in seconds to start executing probe once
                                                  codepackage has started.
                                                "periodSeconds": 10,
                                                  # Optional. Default value is 10. Periodic seconds to
                                                  execute probe.
                                                "successThreshold":
                                                  1,  # Optional. Default value is 1. The count of
                                                  successful probe executions after which probe is
                                                  considered success.
                                                "tcpSocket": {
                                                    "port": 0  #
                                                      Required. Port to access for probe.
                                                },
                                                "timeoutSeconds": 1
                                                  # Optional. Default value is 1. Period after which
                                                  probe is considered as failed if it hasn't completed
                                                  successfully.
                                            }
                                        ],
                                        "name": "str",  # Required. The name
                                          of the code package.
                                        "readinessProbe": [
                                            {
                                                "exec": {
                                                    "command":
                                                      "str"  # Required. Comma separated command to run
                                                      inside the container for example "sh, -c, echo
                                                      hello world".
                                                },
                                                "failureThreshold":
                                                  3,  # Optional. Default value is 3. The count of
                                                  failures after which probe is considered failed.
                                                "httpGet": {
                                                    "host":
                                                      "str",  # Optional. Host IP to connect to.
                "httpHeaders": [
                                                        {
                "name": "str",  # Required. The name of
                                                              the header.
                "value": "str"  # Required. The value of
                                                              the header.
                                                        }
                                                    ],
                                                    "path":
                                                      "str",  # Optional. Path to access on the HTTP
                                                      request.
                                                    "port": 0,  #
                                                      Required. Port to access for probe.
                                                    "scheme":
                                                      "str"  # Optional. Scheme for the http probe. Can
                                                      be Http or Https. Known values are: "http",
                                                      "https".
                                                },
                "initialDelaySeconds": 0,  # Optional. The initial
                                                  delay in seconds to start executing probe once
                                                  codepackage has started.
                                                "periodSeconds": 10,
                                                  # Optional. Default value is 10. Periodic seconds to
                                                  execute probe.
                                                "successThreshold":
                                                  1,  # Optional. Default value is 1. The count of
                                                  successful probe executions after which probe is
                                                  considered success.
                                                "tcpSocket": {
                                                    "port": 0  #
                                                      Required. Port to access for probe.
                                                },
                                                "timeoutSeconds": 1
                                                  # Optional. Default value is 1. Period after which
                                                  probe is considered as failed if it hasn't completed
                                                  successfully.
                                            }
                                        ],
                                        "reliableCollectionsRefs": [
                                            {
                                                "doNotPersistState":
                                                  bool,  # Optional. False (the default) if
                                                  ReliableCollections state is persisted to disk as
                                                  usual. True if you do not want to persist state, in
                                                  which case replication is still enabled and you can
                                                  use ReliableCollections as distributed cache.
                                                "name": "str"  #
                                                  Required. Name of ReliableCollection resource. Right
                                                  now it's not used and you can use any string.
                                            }
                                        ],
                                        "resources": {
                                            "limits": {
                                                "cpu": 0.0,  #
                                                  Optional. CPU limits in cores. At present, only full
                                                  cores are supported.
                                                "memoryInGB": 0.0  #
                                                  Optional. The memory limit in GB.
                                            },
                                            "requests": {
                                                "cpu": 0.0,  #
                                                  Required. Requested number of CPU cores. At present,
                                                  only full cores are supported.
                                                "memoryInGB": 0.0  #
                                                  Required. The memory request in GB for this
                                                  container.
                                            }
                                        },
                                        "settings": [
                                            {
                                                "name": "str",  #
                                                  Optional. The name of the setting.
                                                "type": "ClearText",
                                                  # Optional. Default value is "ClearText". The type of
                                                  the setting being given in value. Known values are:
                                                  "ClearText", "KeyVaultReference",
                                                  "SecretValueReference". Default value: "ClearText".
                                                "value": "str"  #
                                                  Optional. The value of the setting, will be processed
                                                  based on the type provided.
                                            }
                                        ],
                                        "volumeRefs": [
                                            {
                                                "destinationPath":
                                                  "str",  # Required. The path within the container at
                                                  which the volume should be mounted. Only valid path
                                                  characters are allowed.
                                                "name": "str",  #
                                                  Required. Name of the volume being referenced.
                                                "readOnly": bool  #
                                                  Optional. The flag indicating whether the volume is
                                                  read only. Default is 'false'.
                                            }
                                        ],
                                        "volumes": [
                                            {
                                                "creationParameters":
                                                  {
                "description": "str",  # Optional. User readable
                                                      description of the volume.
                                                    kind: kind
                                                },
                                                "destinationPath":
                                                  "str",  # Required. The path within the container at
                                                  which the volume should be mounted. Only valid path
                                                  characters are allowed.
                                                "name": "str",  #
                                                  Required. Name of the volume being referenced.
                                                "readOnly": bool  #
                                                  Optional. The flag indicating whether the volume is
                                                  read only. Default is 'false'.
                                            }
                                        ]
                                    }
                                ],
                                "description": "str",  # Optional. User readable
                                  description of the service.
                                "diagnostics": {
                                    "enabled": bool,  # Optional. Status of
                                      whether or not sinks are enabled.
                                    "sinkRefs": [
                                        "str"  # Optional. List of sinks to
                                          be used if enabled. References the list of sinks in
                                          DiagnosticsDescription.
                                    ]
                                },
                                "dnsName": "str",  # Optional. Dns name of the
                                  service.
                                "executionPolicy": {
                                    type: type
                                },
                                "healthState": "str",  # Optional. Describes the
                                  health state of an application resource. Known values are: "Invalid",
                                  "Ok", "Warning", "Error", "Unknown".
                                "identityRefs": [
                                    {
                                        "identityRef": "str",  # Optional.
                                          The application identity name.
                                        "name": "str"  # Optional. The
                                          identity friendly name.
                                    }
                                ],
                                "networkRefs": [
                                    {
                                        "endpointRefs": [
                                            {
                                                "name": "str"  #
                                                  Optional. Name of the endpoint.
                                            }
                                        ],
                                        "name": "str"  # Optional. Name of
                                          the network.
                                    }
                                ],
                                "osType": "str",  # Required. The operation system
                                  required by the code in service. Known values are: "Linux",
                                  "Windows".
                                "replicaCount": 0,  # Optional. The number of
                                  replicas of the service to create. Defaults to 1 if not specified.
                                "status": "str",  # Optional. Status of the service.
                                  Known values are: "Unknown", "Ready", "Upgrading", "Creating",
                                  "Deleting", "Failed".
                                "statusDetails": "str",  # Optional. Gives additional
                                  information about the current status of the service.
                                "unhealthyEvaluation": "str"  # Optional. When the
                                  service's health state is not 'Ok', this additional details from
                                  service fabric Health Manager for the user to know why the service is
                                  marked unhealthy.
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_service_list_request(
            application_resource_name=application_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class MeshCodePackageOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.servicefabric.aio.ServiceFabricClientAPIs`'s
        :attr:`mesh_code_package` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def get_container_logs(
        self,
        application_resource_name: str,
        service_resource_name: str,
        replica_name: str,
        code_package_name: str,
        *,
        tail: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Gets the logs from the container.

        Gets the logs for the container of the specified code package of the service replica.

        :param application_resource_name: The identity of the application.
        :type application_resource_name: str
        :param service_resource_name: The identity of the service.
        :type service_resource_name: str
        :param replica_name: Service Fabric replica name.
        :type replica_name: str
        :param code_package_name: The name of code package of the service.
        :type code_package_name: str
        :keyword tail: Number of lines to show from the end of the logs. Default is 100. 'all' to show
         the complete logs.
        :paramtype tail: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "Content": "str"  # Optional. Container logs.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_code_package_get_container_logs_request(
            application_resource_name=application_resource_name,
            service_resource_name=service_resource_name,
            replica_name=replica_name,
            code_package_name=code_package_name,
            api_version=api_version,
            tail=tail,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class MeshServiceReplicaOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.servicefabric.aio.ServiceFabricClientAPIs`'s
        :attr:`mesh_service_replica` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def get(
        self,
        application_resource_name: str,
        service_resource_name: str,
        replica_name: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the given replica of the service of an application.

        Gets the information about the service replica with the given name. The information include the
        description and other properties of the service replica.

        :param application_resource_name: The identity of the application.
        :type application_resource_name: str
        :param service_resource_name: The identity of the service.
        :type service_resource_name: str
        :param replica_name: Service Fabric replica name.
        :type replica_name: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "codePackages": [
                        {
                            "commands": [
                                "str"  # Optional. Command array to execute within
                                  the container in exec form.
                            ],
                            "diagnostics": {
                                "enabled": bool,  # Optional. Status of whether or
                                  not sinks are enabled.
                                "sinkRefs": [
                                    "str"  # Optional. List of sinks to be used
                                      if enabled. References the list of sinks in
                                      DiagnosticsDescription.
                                ]
                            },
                            "endpoints": [
                                {
                                    "name": "str",  # Required. The name of the
                                      endpoint.
                                    "port": 0  # Optional. Port used by the
                                      container.
                                }
                            ],
                            "entryPoint": "str",  # Optional. Override for the default
                              entry point in the container.
                            "environmentVariables": [
                                {
                                    "name": "str",  # Optional. The name of the
                                      environment variable.
                                    "type": "ClearText",  # Optional. Default
                                      value is "ClearText". The type of the environment variable being
                                      given in value. Known values are: "ClearText",
                                      "KeyVaultReference", "SecretValueReference". Default value:
                                      "ClearText".
                                    "value": "str"  # Optional. The value of the
                                      environment variable, will be processed based on the type
                                      provided.
                                }
                            ],
                            "image": "str",  # Required. The Container image to use.
                            "imageRegistryCredential": {
                                "password": "str",  # Optional. The password for the
                                  private registry. The password is required for create or update
                                  operations, however it is not returned in the get or list operations.
                                  Will be processed based on the type provided.
                                "passwordType": "ClearText",  # Optional. Default
                                  value is "ClearText". The type of the image registry password being
                                  given in password. Known values are: "ClearText",
                                  "KeyVaultReference", "SecretValueReference". Default value:
                                  "ClearText".
                                "server": "str",  # Required. Docker image registry
                                  server, without protocol such as ``http`` and ``https``.
                                "username": "str"  # Required. The username for the
                                  private registry.
                            },
                            "instanceView": {
                                "currentState": {
                                    "detailStatus": "str",  # Optional.
                                      Human-readable status of this state.
                                    "exitCode": "str",  # Optional. The container
                                      exit code.
                                    "finishTime": "2020-02-20 00:00:00",  #
                                      Optional. Date/time when the container state finished.
                                    "startTime": "2020-02-20 00:00:00",  #
                                      Optional. Date/time when the container state started.
                                    "state": "str"  # Optional. The state of this
                                      container.
                                },
                                "events": [
                                    {
                                        "count": 0,  # Optional. The count of
                                          the event.
                                        "firstTimestamp": "str",  # Optional.
                                          Date/time of the first event.
                                        "lastTimestamp": "str",  # Optional.
                                          Date/time of the last event.
                                        "message": "str",  # Optional. The
                                          event message.
                                        "name": "str",  # Optional. The name
                                          of the container event.
                                        "type": "str"  # Optional. The event
                                          type.
                                    }
                                ],
                                "previousState": {
                                    "detailStatus": "str",  # Optional.
                                      Human-readable status of this state.
                                    "exitCode": "str",  # Optional. The container
                                      exit code.
                                    "finishTime": "2020-02-20 00:00:00",  #
                                      Optional. Date/time when the container state finished.
                                    "startTime": "2020-02-20 00:00:00",  #
                                      Optional. Date/time when the container state started.
                                    "state": "str"  # Optional. The state of this
                                      container.
                                },
                                "restartCount": 0  # Optional. The number of times
                                  the container has been restarted.
                            },
                            "labels": [
                                {
                                    "name": "str",  # Required. The name of the
                                      container label.
                                    "value": "str"  # Required. The value of the
                                      container label.
                                }
                            ],
                            "livenessProbe": [
                                {
                                    "exec": {
                                        "command": "str"  # Required. Comma
                                          separated command to run inside the container for example
                                          "sh, -c, echo hello world".
                                    },
                                    "failureThreshold": 3,  # Optional. Default
                                      value is 3. The count of failures after which probe is considered
                                      failed.
                                    "httpGet": {
                                        "host": "str",  # Optional. Host IP
                                          to connect to.
                                        "httpHeaders": [
                                            {
                                                "name": "str",  #
                                                  Required. The name of the header.
                                                "value": "str"  #
                                                  Required. The value of the header.
                                            }
                                        ],
                                        "path": "str",  # Optional. Path to
                                          access on the HTTP request.
                                        "port": 0,  # Required. Port to
                                          access for probe.
                                        "scheme": "str"  # Optional. Scheme
                                          for the http probe. Can be Http or Https. Known values are:
                                          "http", "https".
                                    },
                                    "initialDelaySeconds": 0,  # Optional. The
                                      initial delay in seconds to start executing probe once
                                      codepackage has started.
                                    "periodSeconds": 10,  # Optional. Default
                                      value is 10. Periodic seconds to execute probe.
                                    "successThreshold": 1,  # Optional. Default
                                      value is 1. The count of successful probe executions after which
                                      probe is considered success.
                                    "tcpSocket": {
                                        "port": 0  # Required. Port to access
                                          for probe.
                                    },
                                    "timeoutSeconds": 1  # Optional. Default
                                      value is 1. Period after which probe is considered as failed if
                                      it hasn't completed successfully.
                                }
                            ],
                            "name": "str",  # Required. The name of the code package.
                            "readinessProbe": [
                                {
                                    "exec": {
                                        "command": "str"  # Required. Comma
                                          separated command to run inside the container for example
                                          "sh, -c, echo hello world".
                                    },
                                    "failureThreshold": 3,  # Optional. Default
                                      value is 3. The count of failures after which probe is considered
                                      failed.
                                    "httpGet": {
                                        "host": "str",  # Optional. Host IP
                                          to connect to.
                                        "httpHeaders": [
                                            {
                                                "name": "str",  #
                                                  Required. The name of the header.
                                                "value": "str"  #
                                                  Required. The value of the header.
                                            }
                                        ],
                                        "path": "str",  # Optional. Path to
                                          access on the HTTP request.
                                        "port": 0,  # Required. Port to
                                          access for probe.
                                        "scheme": "str"  # Optional. Scheme
                                          for the http probe. Can be Http or Https. Known values are:
                                          "http", "https".
                                    },
                                    "initialDelaySeconds": 0,  # Optional. The
                                      initial delay in seconds to start executing probe once
                                      codepackage has started.
                                    "periodSeconds": 10,  # Optional. Default
                                      value is 10. Periodic seconds to execute probe.
                                    "successThreshold": 1,  # Optional. Default
                                      value is 1. The count of successful probe executions after which
                                      probe is considered success.
                                    "tcpSocket": {
                                        "port": 0  # Required. Port to access
                                          for probe.
                                    },
                                    "timeoutSeconds": 1  # Optional. Default
                                      value is 1. Period after which probe is considered as failed if
                                      it hasn't completed successfully.
                                }
                            ],
                            "reliableCollectionsRefs": [
                                {
                                    "doNotPersistState": bool,  # Optional. False
                                      (the default) if ReliableCollections state is persisted to disk
                                      as usual. True if you do not want to persist state, in which case
                                      replication is still enabled and you can use ReliableCollections
                                      as distributed cache.
                                    "name": "str"  # Required. Name of
                                      ReliableCollection resource. Right now it's not used and you can
                                      use any string.
                                }
                            ],
                            "resources": {
                                "limits": {
                                    "cpu": 0.0,  # Optional. CPU limits in cores.
                                      At present, only full cores are supported.
                                    "memoryInGB": 0.0  # Optional. The memory
                                      limit in GB.
                                },
                                "requests": {
                                    "cpu": 0.0,  # Required. Requested number of
                                      CPU cores. At present, only full cores are supported.
                                    "memoryInGB": 0.0  # Required. The memory
                                      request in GB for this container.
                                }
                            },
                            "settings": [
                                {
                                    "name": "str",  # Optional. The name of the
                                      setting.
                                    "type": "ClearText",  # Optional. Default
                                      value is "ClearText". The type of the setting being given in
                                      value. Known values are: "ClearText", "KeyVaultReference",
                                      "SecretValueReference". Default value: "ClearText".
                                    "value": "str"  # Optional. The value of the
                                      setting, will be processed based on the type provided.
                                }
                            ],
                            "volumeRefs": [
                                {
                                    "destinationPath": "str",  # Required. The
                                      path within the container at which the volume should be mounted.
                                      Only valid path characters are allowed.
                                    "name": "str",  # Required. Name of the
                                      volume being referenced.
                                    "readOnly": bool  # Optional. The flag
                                      indicating whether the volume is read only. Default is 'false'.
                                }
                            ],
                            "volumes": [
                                {
                                    "creationParameters": {
                                        "description": "str",  # Optional.
                                          User readable description of the volume.
                                        kind: kind
                                    },
                                    "destinationPath": "str",  # Required. The
                                      path within the container at which the volume should be mounted.
                                      Only valid path characters are allowed.
                                    "name": "str",  # Required. Name of the
                                      volume being referenced.
                                    "readOnly": bool  # Optional. The flag
                                      indicating whether the volume is read only. Default is 'false'.
                                }
                            ]
                        }
                    ],
                    "diagnostics": {
                        "enabled": bool,  # Optional. Status of whether or not sinks are
                          enabled.
                        "sinkRefs": [
                            "str"  # Optional. List of sinks to be used if enabled.
                              References the list of sinks in DiagnosticsDescription.
                        ]
                    },
                    "networkRefs": [
                        {
                            "endpointRefs": [
                                {
                                    "name": "str"  # Optional. Name of the
                                      endpoint.
                                }
                            ],
                            "name": "str"  # Optional. Name of the network.
                        }
                    ],
                    "osType": "str",  # Required. The operation system required by the code in
                      service. Known values are: "Linux", "Windows".
                    "replicaName": "str"  # Required. Name of the replica.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_service_replica_get_request(
            application_resource_name=application_resource_name,
            service_resource_name=service_resource_name,
            replica_name=replica_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def list(
        self,
        application_resource_name: str,
        service_resource_name: str,
        **kwargs: Any
    ) -> JSON:
        """Lists all the replicas of a service.

        Gets the information about all replicas of a service. The information include the description
        and other properties of the service replica.

        :param application_resource_name: The identity of the application.
        :type application_resource_name: str
        :param service_resource_name: The identity of the service.
        :type service_resource_name: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "codePackages": [
                                {
                                    "commands": [
                                        "str"  # Optional. Command array to
                                          execute within the container in exec form.
                                    ],
                                    "diagnostics": {
                                        "enabled": bool,  # Optional. Status
                                          of whether or not sinks are enabled.
                                        "sinkRefs": [
                                            "str"  # Optional. List of
                                              sinks to be used if enabled. References the list of sinks
                                              in DiagnosticsDescription.
                                        ]
                                    },
                                    "endpoints": [
                                        {
                                            "name": "str",  # Required.
                                              The name of the endpoint.
                                            "port": 0  # Optional. Port
                                              used by the container.
                                        }
                                    ],
                                    "entryPoint": "str",  # Optional. Override
                                      for the default entry point in the container.
                                    "environmentVariables": [
                                        {
                                            "name": "str",  # Optional.
                                              The name of the environment variable.
                                            "type": "ClearText",  #
                                              Optional. Default value is "ClearText". The type of the
                                              environment variable being given in value. Known values
                                              are: "ClearText", "KeyVaultReference",
                                              "SecretValueReference". Default value: "ClearText".
                                            "value": "str"  # Optional.
                                              The value of the environment variable, will be processed
                                              based on the type provided.
                                        }
                                    ],
                                    "image": "str",  # Required. The Container
                                      image to use.
                                    "imageRegistryCredential": {
                                        "password": "str",  # Optional. The
                                          password for the private registry. The password is required
                                          for create or update operations, however it is not returned
                                          in the get or list operations. Will be processed based on the
                                          type provided.
                                        "passwordType": "ClearText",  #
                                          Optional. Default value is "ClearText". The type of the image
                                          registry password being given in password. Known values are:
                                          "ClearText", "KeyVaultReference", "SecretValueReference".
                                          Default value: "ClearText".
                                        "server": "str",  # Required. Docker
                                          image registry server, without protocol such as ``http`` and
                                          ``https``.
                                        "username": "str"  # Required. The
                                          username for the private registry.
                                    },
                                    "instanceView": {
                                        "currentState": {
                                            "detailStatus": "str",  #
                                              Optional. Human-readable status of this state.
                                            "exitCode": "str",  #
                                              Optional. The container exit code.
                                            "finishTime": "2020-02-20
                                              00:00:00",  # Optional. Date/time when the container
                                              state finished.
                                            "startTime": "2020-02-20
                                              00:00:00",  # Optional. Date/time when the container
                                              state started.
                                            "state": "str"  # Optional.
                                              The state of this container.
                                        },
                                        "events": [
                                            {
                                                "count": 0,  #
                                                  Optional. The count of the event.
                                                "firstTimestamp":
                                                  "str",  # Optional. Date/time of the first event.
                                                "lastTimestamp":
                                                  "str",  # Optional. Date/time of the last event.
                                                "message": "str",  #
                                                  Optional. The event message.
                                                "name": "str",  #
                                                  Optional. The name of the container event.
                                                "type": "str"  #
                                                  Optional. The event type.
                                            }
                                        ],
                                        "previousState": {
                                            "detailStatus": "str",  #
                                              Optional. Human-readable status of this state.
                                            "exitCode": "str",  #
                                              Optional. The container exit code.
                                            "finishTime": "2020-02-20
                                              00:00:00",  # Optional. Date/time when the container
                                              state finished.
                                            "startTime": "2020-02-20
                                              00:00:00",  # Optional. Date/time when the container
                                              state started.
                                            "state": "str"  # Optional.
                                              The state of this container.
                                        },
                                        "restartCount": 0  # Optional. The
                                          number of times the container has been restarted.
                                    },
                                    "labels": [
                                        {
                                            "name": "str",  # Required.
                                              The name of the container label.
                                            "value": "str"  # Required.
                                              The value of the container label.
                                        }
                                    ],
                                    "livenessProbe": [
                                        {
                                            "exec": {
                                                "command": "str"  #
                                                  Required. Comma separated command to run inside the
                                                  container for example "sh, -c, echo hello world".
                                            },
                                            "failureThreshold": 3,  #
                                              Optional. Default value is 3. The count of failures after
                                              which probe is considered failed.
                                            "httpGet": {
                                                "host": "str",  #
                                                  Optional. Host IP to connect to.
                                                "httpHeaders": [
                                                    {
                "name": "str",  # Required. The name of the
                                                          header.
                "value": "str"  # Required. The value of the
                                                          header.
                                                    }
                                                ],
                                                "path": "str",  #
                                                  Optional. Path to access on the HTTP request.
                                                "port": 0,  #
                                                  Required. Port to access for probe.
                                                "scheme": "str"  #
                                                  Optional. Scheme for the http probe. Can be Http or
                                                  Https. Known values are: "http", "https".
                                            },
                                            "initialDelaySeconds": 0,  #
                                              Optional. The initial delay in seconds to start executing
                                              probe once codepackage has started.
                                            "periodSeconds": 10,  #
                                              Optional. Default value is 10. Periodic seconds to
                                              execute probe.
                                            "successThreshold": 1,  #
                                              Optional. Default value is 1. The count of successful
                                              probe executions after which probe is considered success.
                                            "tcpSocket": {
                                                "port": 0  #
                                                  Required. Port to access for probe.
                                            },
                                            "timeoutSeconds": 1  #
                                              Optional. Default value is 1. Period after which probe is
                                              considered as failed if it hasn't completed successfully.
                                        }
                                    ],
                                    "name": "str",  # Required. The name of the
                                      code package.
                                    "readinessProbe": [
                                        {
                                            "exec": {
                                                "command": "str"  #
                                                  Required. Comma separated command to run inside the
                                                  container for example "sh, -c, echo hello world".
                                            },
                                            "failureThreshold": 3,  #
                                              Optional. Default value is 3. The count of failures after
                                              which probe is considered failed.
                                            "httpGet": {
                                                "host": "str",  #
                                                  Optional. Host IP to connect to.
                                                "httpHeaders": [
                                                    {
                "name": "str",  # Required. The name of the
                                                          header.
                "value": "str"  # Required. The value of the
                                                          header.
                                                    }
                                                ],
                                                "path": "str",  #
                                                  Optional. Path to access on the HTTP request.
                                                "port": 0,  #
                                                  Required. Port to access for probe.
                                                "scheme": "str"  #
                                                  Optional. Scheme for the http probe. Can be Http or
                                                  Https. Known values are: "http", "https".
                                            },
                                            "initialDelaySeconds": 0,  #
                                              Optional. The initial delay in seconds to start executing
                                              probe once codepackage has started.
                                            "periodSeconds": 10,  #
                                              Optional. Default value is 10. Periodic seconds to
                                              execute probe.
                                            "successThreshold": 1,  #
                                              Optional. Default value is 1. The count of successful
                                              probe executions after which probe is considered success.
                                            "tcpSocket": {
                                                "port": 0  #
                                                  Required. Port to access for probe.
                                            },
                                            "timeoutSeconds": 1  #
                                              Optional. Default value is 1. Period after which probe is
                                              considered as failed if it hasn't completed successfully.
                                        }
                                    ],
                                    "reliableCollectionsRefs": [
                                        {
                                            "doNotPersistState": bool,  #
                                              Optional. False (the default) if ReliableCollections
                                              state is persisted to disk as usual. True if you do not
                                              want to persist state, in which case replication is still
                                              enabled and you can use ReliableCollections as
                                              distributed cache.
                                            "name": "str"  # Required.
                                              Name of ReliableCollection resource. Right now it's not
                                              used and you can use any string.
                                        }
                                    ],
                                    "resources": {
                                        "limits": {
                                            "cpu": 0.0,  # Optional. CPU
                                              limits in cores. At present, only full cores are
                                              supported.
                                            "memoryInGB": 0.0  #
                                              Optional. The memory limit in GB.
                                        },
                                        "requests": {
                                            "cpu": 0.0,  # Required.
                                              Requested number of CPU cores. At present, only full
                                              cores are supported.
                                            "memoryInGB": 0.0  #
                                              Required. The memory request in GB for this container.
                                        }
                                    },
                                    "settings": [
                                        {
                                            "name": "str",  # Optional.
                                              The name of the setting.
                                            "type": "ClearText",  #
                                              Optional. Default value is "ClearText". The type of the
                                              setting being given in value. Known values are:
                                              "ClearText", "KeyVaultReference", "SecretValueReference".
                                              Default value: "ClearText".
                                            "value": "str"  # Optional.
                                              The value of the setting, will be processed based on the
                                              type provided.
                                        }
                                    ],
                                    "volumeRefs": [
                                        {
                                            "destinationPath": "str",  #
                                              Required. The path within the container at which the
                                              volume should be mounted. Only valid path characters are
                                              allowed.
                                            "name": "str",  # Required.
                                              Name of the volume being referenced.
                                            "readOnly": bool  # Optional.
                                              The flag indicating whether the volume is read only.
                                              Default is 'false'.
                                        }
                                    ],
                                    "volumes": [
                                        {
                                            "creationParameters": {
                                                "description": "str",
                                                  # Optional. User readable description of the volume.
                                                kind: kind
                                            },
                                            "destinationPath": "str",  #
                                              Required. The path within the container at which the
                                              volume should be mounted. Only valid path characters are
                                              allowed.
                                            "name": "str",  # Required.
                                              Name of the volume being referenced.
                                            "readOnly": bool  # Optional.
                                              The flag indicating whether the volume is read only.
                                              Default is 'false'.
                                        }
                                    ]
                                }
                            ],
                            "diagnostics": {
                                "enabled": bool,  # Optional. Status of whether or
                                  not sinks are enabled.
                                "sinkRefs": [
                                    "str"  # Optional. List of sinks to be used
                                      if enabled. References the list of sinks in
                                      DiagnosticsDescription.
                                ]
                            },
                            "networkRefs": [
                                {
                                    "endpointRefs": [
                                        {
                                            "name": "str"  # Optional.
                                              Name of the endpoint.
                                        }
                                    ],
                                    "name": "str"  # Optional. Name of the
                                      network.
                                }
                            ],
                            "osType": "str",  # Required. The operation system required
                              by the code in service. Known values are: "Linux", "Windows".
                            "replicaName": "str"  # Required. Name of the replica.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_service_replica_list_request(
            application_resource_name=application_resource_name,
            service_resource_name=service_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class MeshGatewayOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.servicefabric.aio.ServiceFabricClientAPIs`'s
        :attr:`mesh_gateway` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def create_or_update(
        self,
        gateway_resource_name: str,
        gateway_resource_description: JSON,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Creates or updates a Gateway resource.

        Creates a Gateway resource with the specified name, description and properties. If Gateway
        resource with the same name exists, then it is updated with the specified description and
        properties. Use Gateway resource to provide public connectivity to application services.

        :param gateway_resource_name: The identity of the gateway.
        :type gateway_resource_name: str
        :param gateway_resource_description: Description for creating a Gateway resource.
        :type gateway_resource_description: JSON
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                gateway_resource_description = {
                    "name": "str",  # Required. Name of the Gateway resource.
                    "properties": {
                        "description": "str",  # Optional. User readable description of the
                          gateway.
                        "destinationNetwork": {
                            "endpointRefs": [
                                {
                                    "name": "str"  # Optional. Name of the
                                      endpoint.
                                }
                            ],
                            "name": "str"  # Optional. Name of the network.
                        },
                        "http": [
                            {
                                "hosts": [
                                    {
                                        "name": "str",  # Required. http
                                          hostname config name.
                                        "routes": [
                                            {
                                                "destination": {
                "applicationName": "str",  # Required. Name of
                                                      the service fabric Mesh application.
                "endpointName": "str",  # Required. name of the
                                                      endpoint in the service.
                "serviceName": "str"  # Required. service that
                                                      contains the endpoint.
                                                },
                                                "match": {
                                                    "headers": [
                                                        {
                "name": "str",  # Required. Name of
                                                              header to match in request.
                "type": "exact",  # Optional. Default
                                                              value is "exact". how to match header
                                                              value. Known values are: "exact".
                "value": "str"  # Optional. Value of
                                                              header to match in request.
                                                        }
                                                    ],
                                                    "path": {
                "rewrite": "str",  # Optional. replacement
                                                          string for matched part of the Uri.
                "type": "prefix",  # Default value is
                                                          "prefix". Required. how to match value in the
                                                          Uri. Known values are: "prefix".
                "value": "str"  # Required. Uri path to match
                                                          for request.
                                                    }
                                                },
                                                "name": "str"  #
                                                  Required. http route name.
                                            }
                                        ]
                                    }
                                ],
                                "name": "str",  # Required. http gateway config name.
                                "port": 0  # Required. Specifies the port at which
                                  the service endpoint below needs to be exposed.
                            }
                        ],
                        "ipAddress": "str",  # Optional. IP address of the gateway. This is
                          populated in the response and is ignored for incoming requests.
                        "sourceNetwork": {
                            "endpointRefs": [
                                {
                                    "name": "str"  # Optional. Name of the
                                      endpoint.
                                }
                            ],
                            "name": "str"  # Optional. Name of the network.
                        },
                        "status": "str",  # Optional. Status of the resource. Known values
                          are: "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str",  # Optional. Gives additional information
                          about the current status of the gateway.
                        "tcp": [
                            {
                                "destination": {
                                    "applicationName": "str",  # Required. Name
                                      of the service fabric Mesh application.
                                    "endpointName": "str",  # Required. name of
                                      the endpoint in the service.
                                    "serviceName": "str"  # Required. service
                                      that contains the endpoint.
                                },
                                "name": "str",  # Required. tcp gateway config name.
                                "port": 0  # Required. Specifies the port at which
                                  the service endpoint below needs to be exposed.
                            }
                        ]
                    }
                }

                # response body for status code(s): 200, 201
                response.json() == {
                    "name": "str",  # Required. Name of the Gateway resource.
                    "properties": {
                        "description": "str",  # Optional. User readable description of the
                          gateway.
                        "destinationNetwork": {
                            "endpointRefs": [
                                {
                                    "name": "str"  # Optional. Name of the
                                      endpoint.
                                }
                            ],
                            "name": "str"  # Optional. Name of the network.
                        },
                        "http": [
                            {
                                "hosts": [
                                    {
                                        "name": "str",  # Required. http
                                          hostname config name.
                                        "routes": [
                                            {
                                                "destination": {
                "applicationName": "str",  # Required. Name of
                                                      the service fabric Mesh application.
                "endpointName": "str",  # Required. name of the
                                                      endpoint in the service.
                "serviceName": "str"  # Required. service that
                                                      contains the endpoint.
                                                },
                                                "match": {
                                                    "headers": [
                                                        {
                "name": "str",  # Required. Name of
                                                              header to match in request.
                "type": "exact",  # Optional. Default
                                                              value is "exact". how to match header
                                                              value. Known values are: "exact".
                "value": "str"  # Optional. Value of
                                                              header to match in request.
                                                        }
                                                    ],
                                                    "path": {
                "rewrite": "str",  # Optional. replacement
                                                          string for matched part of the Uri.
                "type": "prefix",  # Default value is
                                                          "prefix". Required. how to match value in the
                                                          Uri. Known values are: "prefix".
                "value": "str"  # Required. Uri path to match
                                                          for request.
                                                    }
                                                },
                                                "name": "str"  #
                                                  Required. http route name.
                                            }
                                        ]
                                    }
                                ],
                                "name": "str",  # Required. http gateway config name.
                                "port": 0  # Required. Specifies the port at which
                                  the service endpoint below needs to be exposed.
                            }
                        ],
                        "ipAddress": "str",  # Optional. IP address of the gateway. This is
                          populated in the response and is ignored for incoming requests.
                        "sourceNetwork": {
                            "endpointRefs": [
                                {
                                    "name": "str"  # Optional. Name of the
                                      endpoint.
                                }
                            ],
                            "name": "str"  # Optional. Name of the network.
                        },
                        "status": "str",  # Optional. Status of the resource. Known values
                          are: "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str",  # Optional. Gives additional information
                          about the current status of the gateway.
                        "tcp": [
                            {
                                "destination": {
                                    "applicationName": "str",  # Required. Name
                                      of the service fabric Mesh application.
                                    "endpointName": "str",  # Required. name of
                                      the endpoint in the service.
                                    "serviceName": "str"  # Required. service
                                      that contains the endpoint.
                                },
                                "name": "str",  # Required. tcp gateway config name.
                                "port": 0  # Required. Specifies the port at which
                                  the service endpoint below needs to be exposed.
                            }
                        ]
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        _json = gateway_resource_description

        request = build_mesh_gateway_create_or_update_request(
            gateway_resource_name=gateway_resource_name,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def get(
        self,
        gateway_resource_name: str,
        **kwargs: Any
    ) -> JSON:
        """Gets the Gateway resource with the given name.

        Gets the information about the Gateway resource with the given name. The information include
        the description and other properties of the Gateway.

        :param gateway_resource_name: The identity of the gateway.
        :type gateway_resource_name: str
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "name": "str",  # Required. Name of the Gateway resource.
                    "properties": {
                        "description": "str",  # Optional. User readable description of the
                          gateway.
                        "destinationNetwork": {
                            "endpointRefs": [
                                {
                                    "name": "str"  # Optional. Name of the
                                      endpoint.
                                }
                            ],
                            "name": "str"  # Optional. Name of the network.
                        },
                        "http": [
                            {
                                "hosts": [
                                    {
                                        "name": "str",  # Required. http
                                          hostname config name.
                                        "routes": [
                                            {
                                                "destination": {
                "applicationName": "str",  # Required. Name of
                                                      the service fabric Mesh application.
                "endpointName": "str",  # Required. name of the
                                                      endpoint in the service.
                "serviceName": "str"  # Required. service that
                                                      contains the endpoint.
                                                },
                                                "match": {
                                                    "headers": [
                                                        {
                "name": "str",  # Required. Name of
                                                              header to match in request.
                "type": "exact",  # Optional. Default
                                                              value is "exact". how to match header
                                                              value. Known values are: "exact".
                "value": "str"  # Optional. Value of
                                                              header to match in request.
                                                        }
                                                    ],
                                                    "path": {
                "rewrite": "str",  # Optional. replacement
                                                          string for matched part of the Uri.
                "type": "prefix",  # Default value is
                                                          "prefix". Required. how to match value in the
                                                          Uri. Known values are: "prefix".
                "value": "str"  # Required. Uri path to match
                                                          for request.
                                                    }
                                                },
                                                "name": "str"  #
                                                  Required. http route name.
                                            }
                                        ]
                                    }
                                ],
                                "name": "str",  # Required. http gateway config name.
                                "port": 0  # Required. Specifies the port at which
                                  the service endpoint below needs to be exposed.
                            }
                        ],
                        "ipAddress": "str",  # Optional. IP address of the gateway. This is
                          populated in the response and is ignored for incoming requests.
                        "sourceNetwork": {
                            "endpointRefs": [
                                {
                                    "name": "str"  # Optional. Name of the
                                      endpoint.
                                }
                            ],
                            "name": "str"  # Optional. Name of the network.
                        },
                        "status": "str",  # Optional. Status of the resource. Known values
                          are: "Unknown", "Ready", "Upgrading", "Creating", "Deleting", "Failed".
                        "statusDetails": "str",  # Optional. Gives additional information
                          about the current status of the gateway.
                        "tcp": [
                            {
                                "destination": {
                                    "applicationName": "str",  # Required. Name
                                      of the service fabric Mesh application.
                                    "endpointName": "str",  # Required. name of
                                      the endpoint in the service.
                                    "serviceName": "str"  # Required. service
                                      that contains the endpoint.
                                },
                                "name": "str",  # Required. tcp gateway config name.
                                "port": 0  # Required. Specifies the port at which
                                  the service endpoint below needs to be exposed.
                            }
                        ]
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_gateway_get_request(
            gateway_resource_name=gateway_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        gateway_resource_name: str,
        **kwargs: Any
    ) -> None:
        """Deletes the Gateway resource.

        Deletes the Gateway resource identified by the name.

        :param gateway_resource_name: The identity of the gateway.
        :type gateway_resource_name: str
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_mesh_gateway_delete_request(
            gateway_resource_name=gateway_resource_name,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})



    @distributed_trace_async
    async def list(
        self,
        **kwargs: Any
    ) -> JSON:
        """Lists all the gateway resources.

        Gets the information about all gateway resources in a given resource group. The information
        include the description and other properties of the Gateway.

        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "ContinuationToken": "str",  # Optional. The continuation token parameter is
                      used to obtain next set of results. The continuation token is included in the
                      response of the API when the results from the system do not fit in a single
                      response. When this value is passed to the next API call, the API returns next
                      set of results. If there are no further results, then the continuation token is
                      not included in the response.
                    "Items": [
                        {
                            "name": "str",  # Required. Name of the Gateway resource.
                            "properties": {
                                "description": "str",  # Optional. User readable
                                  description of the gateway.
                                "destinationNetwork": {
                                    "endpointRefs": [
                                        {
                                            "name": "str"  # Optional.
                                              Name of the endpoint.
                                        }
                                    ],
                                    "name": "str"  # Optional. Name of the
                                      network.
                                },
                                "http": [
                                    {
                                        "hosts": [
                                            {
                                                "name": "str",  #
                                                  Required. http hostname config name.
                                                "routes": [
                                                    {
                "destination": {
                "applicationName": "str",  # Required.
                                                              Name of the service fabric Mesh
                                                              application.
                "endpointName": "str",  # Required. name
                                                              of the endpoint in the service.
                "serviceName": "str"  # Required. service
                                                              that contains the endpoint.
                                                        },
                "match": {
                "headers": [
                {
                "name": "str",  # Required. Name
                                                                      of header to match in request.
                "type": "exact",  # Optional.
                                                                      Default value is "exact". how to
                                                                      match header value. Known values
                                                                      are: "exact".
                "value": "str"  # Optional. Value
                                                                      of header to match in request.
                }
                ],
                "path": {
                "rewrite": "str",  # Optional.
                                                                  replacement string for matched part
                                                                  of the Uri.
                "type": "prefix",  # Default value is
                                                                  "prefix". Required. how to match
                                                                  value in the Uri. Known values are:
                                                                  "prefix".
                "value": "str"  # Required. Uri path
                                                                  to match for request.
                }
                                                        },
                "name": "str"  # Required. http route name.
                                                    }
                                                ]
                                            }
                                        ],
                                        "name": "str",  # Required. http
                                          gateway config name.
                                        "port": 0  # Required. Specifies the
                                          port at which the service endpoint below needs to be exposed.
                                    }
                                ],
                                "ipAddress": "str",  # Optional. IP address of the
                                  gateway. This is populated in the response and is ignored for
                                  incoming requests.
                                "sourceNetwork": {
                                    "endpointRefs": [
                                        {
                                            "name": "str"  # Optional.
                                              Name of the endpoint.
                                        }
                                    ],
                                    "name": "str"  # Optional. Name of the
                                      network.
                                },
                                "status": "str",  # Optional. Status of the resource.
                                  Known values are: "Unknown", "Ready", "Upgrading", "Creating",
                                  "Deleting", "Failed".
                                "statusDetails": "str",  # Optional. Gives additional
                                  information about the current status of the gateway.
                                "tcp": [
                                    {
                                        "destination": {
                                            "applicationName": "str",  #
                                              Required. Name of the service fabric Mesh application.
                                            "endpointName": "str",  #
                                              Required. name of the endpoint in the service.
                                            "serviceName": "str"  #
                                              Required. service that contains the endpoint.
                                        },
                                        "name": "str",  # Required. tcp
                                          gateway config name.
                                        "port": 0  # Required. Specifies the
                                          port at which the service endpoint below needs to be exposed.
                                    }
                                ]
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "9.0.0.46"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_mesh_gateway_list_request(
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


